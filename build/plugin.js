/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 355);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var root_1 = __webpack_require__(7);
var toSubscriber_1 = __webpack_require__(352);
var observable_1 = __webpack_require__(21);
/**
 * A representation of any set of values over any amount of time. This the most basic building block
 * of RxJS.
 *
 * @class Observable<T>
 */
var Observable = (function () {
    /**
     * @constructor
     * @param {Function} subscribe the function that is  called when the Observable is
     * initially subscribed to. This function is given a Subscriber, to which new values
     * can be `next`ed, or an `error` method can be called to raise an error, or
     * `complete` can be called to notify of a successful completion.
     */
    function Observable(subscribe) {
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    /**
     * Creates a new Observable, with this Observable as the source, and the passed
     * operator defined as the new observable's operator.
     * @method lift
     * @param {Operator} operator the operator defining the operation to take on the observable
     * @return {Observable} a new observable with the Operator applied
     */
    Observable.prototype.lift = function (operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
        if (operator) {
            operator.call(sink, this.source);
        }
        else {
            sink.add(this._trySubscribe(sink));
        }
        if (sink.syncErrorThrowable) {
            sink.syncErrorThrowable = false;
            if (sink.syncErrorThrown) {
                throw sink.syncErrorValue;
            }
        }
        return sink;
    };
    Observable.prototype._trySubscribe = function (sink) {
        try {
            return this._subscribe(sink);
        }
        catch (err) {
            sink.syncErrorThrown = true;
            sink.syncErrorValue = err;
            sink.error(err);
        }
    };
    /**
     * @method forEach
     * @param {Function} next a handler for each value emitted by the observable
     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
     * @return {Promise} a promise that either resolves on observable completion or
     *  rejects with the handled error
     */
    Observable.prototype.forEach = function (next, PromiseCtor) {
        var _this = this;
        if (!PromiseCtor) {
            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
                PromiseCtor = root_1.root.Rx.config.Promise;
            }
            else if (root_1.root.Promise) {
                PromiseCtor = root_1.root.Promise;
            }
        }
        if (!PromiseCtor) {
            throw new Error('no Promise impl found');
        }
        return new PromiseCtor(function (resolve, reject) {
            var subscription = _this.subscribe(function (value) {
                if (subscription) {
                    // if there is a subscription, then we can surmise
                    // the next handling is asynchronous. Any errors thrown
                    // need to be rejected explicitly and unsubscribe must be
                    // called manually
                    try {
                        next(value);
                    }
                    catch (err) {
                        reject(err);
                        subscription.unsubscribe();
                    }
                }
                else {
                    // if there is NO subscription, then we're getting a nexted
                    // value synchronously during subscription. We can just call it.
                    // If it errors, Observable's `subscribe` will ensure the
                    // unsubscription logic is called, then synchronously rethrow the error.
                    // After that, Promise will trap the error and send it
                    // down the rejection path.
                    next(value);
                }
            }, reject, resolve);
        });
    };
    Observable.prototype._subscribe = function (subscriber) {
        return this.source.subscribe(subscriber);
    };
    /**
     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
     * @method Symbol.observable
     * @return {Observable} this instance of the observable
     */
    Observable.prototype[observable_1.$$observable] = function () {
        return this;
    };
    // HACK: Since TypeScript inherits static properties too, we have to
    // fight against TypeScript here so Subject can have a different static create signature
    /**
     * Creates a new cold Observable by calling the Observable constructor
     * @static true
     * @owner Observable
     * @method create
     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
     * @return {Observable} a new cold observable
     */
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}());
exports.Observable = Observable;
//# sourceMappingURL=Observable.js.map

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isFunction_1 = __webpack_require__(27);
var Subscription_1 = __webpack_require__(4);
var Observer_1 = __webpack_require__(39);
var rxSubscriber_1 = __webpack_require__(22);
/**
 * Implements the {@link Observer} interface and extends the
 * {@link Subscription} class. While the {@link Observer} is the public API for
 * consuming the values of an {@link Observable}, all Observers get converted to
 * a Subscriber, in order to provide Subscription-like capabilities such as
 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
 * implementing operators, but it is rarely used as a public API.
 *
 * @class Subscriber<T>
 */
var Subscriber = (function (_super) {
    __extends(Subscriber, _super);
    /**
     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
     * defined Observer or a `next` callback function.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     */
    function Subscriber(destinationOrNext, error, complete) {
        _super.call(this);
        this.syncErrorValue = null;
        this.syncErrorThrown = false;
        this.syncErrorThrowable = false;
        this.isStopped = false;
        switch (arguments.length) {
            case 0:
                this.destination = Observer_1.empty;
                break;
            case 1:
                if (!destinationOrNext) {
                    this.destination = Observer_1.empty;
                    break;
                }
                if (typeof destinationOrNext === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                        this.destination = destinationOrNext;
                        this.destination.add(this);
                    }
                    else {
                        this.syncErrorThrowable = true;
                        this.destination = new SafeSubscriber(this, destinationOrNext);
                    }
                    break;
                }
            default:
                this.syncErrorThrowable = true;
                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
                break;
        }
    }
    Subscriber.prototype[rxSubscriber_1.$$rxSubscriber] = function () { return this; };
    /**
     * A static factory for a Subscriber, given a (potentially partial) definition
     * of an Observer.
     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
     * Observer represented by the given arguments.
     */
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    /**
     * The {@link Observer} callback to receive notifications of type `next` from
     * the Observable, with a value. The Observable may call this method 0 or more
     * times.
     * @param {T} [value] The `next` value.
     * @return {void}
     */
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    /**
     * The {@link Observer} callback to receive notifications of type `error` from
     * the Observable, with an attached {@link Error}. Notifies the Observer that
     * the Observable has experienced an error condition.
     * @param {any} [err] The `error` exception.
     * @return {void}
     */
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    /**
     * The {@link Observer} callback to receive a valueless notification of type
     * `complete` from the Observable. Notifies the Observer that the Observable
     * has finished sending push-based notifications.
     * @return {void}
     */
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    Subscriber.prototype._unsubscribeAndRecycle = function () {
        var _a = this, _parent = _a._parent, _parents = _a._parents;
        this._parent = null;
        this._parents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parent = _parent;
        this._parents = _parents;
        return this;
    };
    return Subscriber;
}(Subscription_1.Subscription));
exports.Subscriber = Subscriber;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SafeSubscriber = (function (_super) {
    __extends(SafeSubscriber, _super);
    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
        _super.call(this);
        this._parentSubscriber = _parentSubscriber;
        var next;
        var context = this;
        if (isFunction_1.isFunction(observerOrNext)) {
            next = observerOrNext;
        }
        else if (observerOrNext) {
            context = observerOrNext;
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (isFunction_1.isFunction(context.unsubscribe)) {
                this.add(context.unsubscribe.bind(context));
            }
            context.unsubscribe = this.unsubscribe.bind(this);
        }
        this._context = context;
        this._next = next;
        this._error = error;
        this._complete = complete;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parentSubscriber = this._parentSubscriber;
            if (!_parentSubscriber.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            }
            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._error) {
                if (!_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);
                    this.unsubscribe();
                }
            }
            else if (!_parentSubscriber.syncErrorThrowable) {
                this.unsubscribe();
                throw err;
            }
            else {
                _parentSubscriber.syncErrorValue = err;
                _parentSubscriber.syncErrorThrown = true;
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._complete) {
                if (!_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._complete);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, this._complete);
                    this.unsubscribe();
                }
            }
            else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            this.unsubscribe();
            throw err;
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            parent.syncErrorValue = err;
            parent.syncErrorThrown = true;
            return true;
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber));
//# sourceMappingURL=Subscriber.js.map

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(1);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var OuterSubscriber = (function (_super) {
    __extends(OuterSubscriber, _super);
    function OuterSubscriber() {
        _super.apply(this, arguments);
    }
    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
        this.destination.error(error);
    };
    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
        this.destination.complete();
    };
    return OuterSubscriber;
}(Subscriber_1.Subscriber));
exports.OuterSubscriber = OuterSubscriber;
//# sourceMappingURL=OuterSubscriber.js.map

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var root_1 = __webpack_require__(7);
var isArrayLike_1 = __webpack_require__(63);
var isPromise_1 = __webpack_require__(65);
var isObject_1 = __webpack_require__(64);
var Observable_1 = __webpack_require__(0);
var iterator_1 = __webpack_require__(18);
var InnerSubscriber_1 = __webpack_require__(78);
var observable_1 = __webpack_require__(21);
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {
    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);
    if (destination.closed) {
        return null;
    }
    if (result instanceof Observable_1.Observable) {
        if (result._isScalar) {
            destination.next(result.value);
            destination.complete();
            return null;
        }
        else {
            return result.subscribe(destination);
        }
    }
    else if (isArrayLike_1.isArrayLike(result)) {
        for (var i = 0, len = result.length; i < len && !destination.closed; i++) {
            destination.next(result[i]);
        }
        if (!destination.closed) {
            destination.complete();
        }
    }
    else if (isPromise_1.isPromise(result)) {
        result.then(function (value) {
            if (!destination.closed) {
                destination.next(value);
                destination.complete();
            }
        }, function (err) { return destination.error(err); })
            .then(null, function (err) {
            // Escaping the Promise trap: globally throw unhandled errors
            root_1.root.setTimeout(function () { throw err; });
        });
        return destination;
    }
    else if (result && typeof result[iterator_1.$$iterator] === 'function') {
        var iterator = result[iterator_1.$$iterator]();
        do {
            var item = iterator.next();
            if (item.done) {
                destination.complete();
                break;
            }
            destination.next(item.value);
            if (destination.closed) {
                break;
            }
        } while (true);
    }
    else if (result && typeof result[observable_1.$$observable] === 'function') {
        var obs = result[observable_1.$$observable]();
        if (typeof obs.subscribe !== 'function') {
            destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));
        }
        else {
            return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));
        }
    }
    else {
        var value = isObject_1.isObject(result) ? 'an invalid object' : "'" + result + "'";
        var msg = ("You provided " + value + " where a stream was expected.")
            + ' You can provide an Observable, Promise, Array, or Iterable.';
        destination.error(new TypeError(msg));
    }
    return null;
}
exports.subscribeToResult = subscribeToResult;
//# sourceMappingURL=subscribeToResult.js.map

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isArray_1 = __webpack_require__(11);
var isObject_1 = __webpack_require__(64);
var isFunction_1 = __webpack_require__(27);
var tryCatch_1 = __webpack_require__(8);
var errorObject_1 = __webpack_require__(6);
var UnsubscriptionError_1 = __webpack_require__(61);
/**
 * Represents a disposable resource, such as the execution of an Observable. A
 * Subscription has one important method, `unsubscribe`, that takes no argument
 * and just disposes the resource held by the subscription.
 *
 * Additionally, subscriptions may be grouped together through the `add()`
 * method, which will attach a child Subscription to the current Subscription.
 * When a Subscription is unsubscribed, all its children (and its grandchildren)
 * will be unsubscribed as well.
 *
 * @class Subscription
 */
var Subscription = (function () {
    /**
     * @param {function(): void} [unsubscribe] A function describing how to
     * perform the disposal of resources when the `unsubscribe` method is called.
     */
    function Subscription(unsubscribe) {
        /**
         * A flag to indicate whether this Subscription has already been unsubscribed.
         * @type {boolean}
         */
        this.closed = false;
        this._parent = null;
        this._parents = null;
        this._subscriptions = null;
        if (unsubscribe) {
            this._unsubscribe = unsubscribe;
        }
    }
    /**
     * Disposes the resources held by the subscription. May, for instance, cancel
     * an ongoing Observable execution or cancel any other type of work that
     * started when the Subscription was created.
     * @return {void}
     */
    Subscription.prototype.unsubscribe = function () {
        var hasErrors = false;
        var errors;
        if (this.closed) {
            return;
        }
        var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parent = null;
        this._parents = null;
        // null out _subscriptions first so any child subscriptions that attempt
        // to remove themselves from this subscription will noop
        this._subscriptions = null;
        var index = -1;
        var len = _parents ? _parents.length : 0;
        // if this._parent is null, then so is this._parents, and we
        // don't have to remove ourselves from any parent subscriptions.
        while (_parent) {
            _parent.remove(this);
            // if this._parents is null or index >= len,
            // then _parent is set to null, and the loop exits
            _parent = ++index < len && _parents[index] || null;
        }
        if (isFunction_1.isFunction(_unsubscribe)) {
            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
            if (trial === errorObject_1.errorObject) {
                hasErrors = true;
                errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ?
                    flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);
            }
        }
        if (isArray_1.isArray(_subscriptions)) {
            index = -1;
            len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject_1.isObject(sub)) {
                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
                    if (trial === errorObject_1.errorObject) {
                        hasErrors = true;
                        errors = errors || [];
                        var err = errorObject_1.errorObject.e;
                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
                        }
                        else {
                            errors.push(err);
                        }
                    }
                }
            }
        }
        if (hasErrors) {
            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
        }
    };
    /**
     * Adds a tear down to be called during the unsubscribe() of this
     * Subscription.
     *
     * If the tear down being added is a subscription that is already
     * unsubscribed, is the same reference `add` is being called on, or is
     * `Subscription.EMPTY`, it will not be added.
     *
     * If this subscription is already in an `closed` state, the passed
     * tear down logic will be executed immediately.
     *
     * @param {TeardownLogic} teardown The additional logic to execute on
     * teardown.
     * @return {Subscription} Returns the Subscription used or created to be
     * added to the inner subscriptions list. This Subscription can be used with
     * `remove()` to remove the passed teardown logic from the inner subscriptions
     * list.
     */
    Subscription.prototype.add = function (teardown) {
        if (!teardown || (teardown === Subscription.EMPTY)) {
            return Subscription.EMPTY;
        }
        if (teardown === this) {
            return this;
        }
        var subscription = teardown;
        switch (typeof teardown) {
            case 'function':
                subscription = new Subscription(teardown);
            case 'object':
                if (subscription.closed || typeof subscription.unsubscribe !== 'function') {
                    return subscription;
                }
                else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                }
                else if (typeof subscription._addParent !== 'function' /* quack quack */) {
                    var tmp = subscription;
                    subscription = new Subscription();
                    subscription._subscriptions = [tmp];
                }
                break;
            default:
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
        }
        var subscriptions = this._subscriptions || (this._subscriptions = []);
        subscriptions.push(subscription);
        subscription._addParent(this);
        return subscription;
    };
    /**
     * Removes a Subscription from the internal list of subscriptions that will
     * unsubscribe during the unsubscribe process of this Subscription.
     * @param {Subscription} subscription The subscription to remove.
     * @return {void}
     */
    Subscription.prototype.remove = function (subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.prototype._addParent = function (parent) {
        var _a = this, _parent = _a._parent, _parents = _a._parents;
        if (!_parent || _parent === parent) {
            // If we don't have a parent, or the new parent is the same as the
            // current parent, then set this._parent to the new parent.
            this._parent = parent;
        }
        else if (!_parents) {
            // If there's already one parent, but not multiple, allocate an Array to
            // store the rest of the parent Subscriptions.
            this._parents = [parent];
        }
        else if (_parents.indexOf(parent) === -1) {
            // Only add the new parent to the _parents list if it's not already there.
            _parents.push(parent);
        }
    };
    Subscription.EMPTY = (function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription()));
    return Subscription;
}());
exports.Subscription = Subscription;
function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError_1.UnsubscriptionError) ? err.errors : err); }, []);
}
//# sourceMappingURL=Subscription.js.map

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(0);
var Subscriber_1 = __webpack_require__(1);
var Subscription_1 = __webpack_require__(4);
var ObjectUnsubscribedError_1 = __webpack_require__(25);
var SubjectSubscription_1 = __webpack_require__(40);
var rxSubscriber_1 = __webpack_require__(22);
/**
 * @class SubjectSubscriber<T>
 */
var SubjectSubscriber = (function (_super) {
    __extends(SubjectSubscriber, _super);
    function SubjectSubscriber(destination) {
        _super.call(this, destination);
        this.destination = destination;
    }
    return SubjectSubscriber;
}(Subscriber_1.Subscriber));
exports.SubjectSubscriber = SubjectSubscriber;
/**
 * @class Subject<T>
 */
var Subject = (function (_super) {
    __extends(Subject, _super);
    function Subject() {
        _super.call(this);
        this.observers = [];
        this.closed = false;
        this.isStopped = false;
        this.hasError = false;
        this.thrownError = null;
    }
    Subject.prototype[rxSubscriber_1.$$rxSubscriber] = function () {
        return new SubjectSubscriber(this);
    };
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype.next = function (value) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].next(value);
            }
        }
    };
    Subject.prototype.error = function (err) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].error(err);
        }
        this.observers.length = 0;
    };
    Subject.prototype.complete = function () {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].complete();
        }
        this.observers.length = 0;
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
    };
    Subject.prototype._trySubscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else {
            return _super.prototype._trySubscribe.call(this, subscriber);
        }
    };
    Subject.prototype._subscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1.Subscription.EMPTY;
        }
        else if (this.isStopped) {
            subscriber.complete();
            return Subscription_1.Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new Observable_1.Observable();
        observable.source = this;
        return observable;
    };
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(Observable_1.Observable));
exports.Subject = Subject;
/**
 * @class AnonymousSubject<T>
 */
var AnonymousSubject = (function (_super) {
    __extends(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        _super.call(this);
        this.destination = destination;
        this.source = source;
    }
    AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;
        if (destination && destination.next) {
            destination.next(value);
        }
    };
    AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;
        if (destination && destination.error) {
            this.destination.error(err);
        }
    };
    AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;
        if (destination && destination.complete) {
            this.destination.complete();
        }
    };
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;
        if (source) {
            return this.source.subscribe(subscriber);
        }
        else {
            return Subscription_1.Subscription.EMPTY;
        }
    };
    return AnonymousSubject;
}(Subject));
exports.AnonymousSubject = AnonymousSubject;
//# sourceMappingURL=Subject.js.map

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// typeof any so that it we don't have to cast when comparing a result to the error object
exports.errorObject = { e: {} };
//# sourceMappingURL=errorObject.js.map

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
/**
 * window: browser in DOM main thread
 * self: browser in WebWorker
 * global: Node.js/other
 */
exports.root = (typeof window == 'object' && window.window === window && window
    || typeof self == 'object' && self.self === self && self
    || typeof global == 'object' && global.global === global && global);
if (!exports.root) {
    throw new Error('RxJS could not find any global context (window, self, global)');
}
//# sourceMappingURL=root.js.map
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(68)))

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var errorObject_1 = __webpack_require__(6);
var tryCatchTarget;
function tryCatcher() {
    try {
        return tryCatchTarget.apply(this, arguments);
    }
    catch (e) {
        errorObject_1.errorObject.e = e;
        return errorObject_1.errorObject;
    }
}
function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}
exports.tryCatch = tryCatch;
;
//# sourceMappingURL=tryCatch.js.map

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var AsyncAction_1 = __webpack_require__(16);
var AsyncScheduler_1 = __webpack_require__(17);
/**
 *
 * Async Scheduler
 *
 * <span class="informal">Schedule task as if you used setTimeout(task, duration)</span>
 *
 * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript
 * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating
 * in intervals.
 *
 * If you just want to "defer" task, that is to perform it right after currently
 * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),
 * better choice will be the {@link asap} scheduler.
 *
 * @example <caption>Use async scheduler to delay task</caption>
 * const task = () => console.log('it works!');
 *
 * Rx.Scheduler.async.schedule(task, 2000);
 *
 * // After 2 seconds logs:
 * // "it works!"
 *
 *
 * @example <caption>Use async scheduler to repeat task in intervals</caption>
 * function task(state) {
 *   console.log(state);
 *   this.schedule(state + 1, 1000); // `this` references currently executing Action,
 *                                   // which we reschedule with new state and delay
 * }
 *
 * Rx.Scheduler.async.schedule(task, 3000, 0);
 *
 * // Logs:
 * // 0 after 3s
 * // 1 after 4s
 * // 2 after 5s
 * // 3 after 6s
 *
 * @static true
 * @name async
 * @owner Scheduler
 */
exports.async = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);
//# sourceMappingURL=async.js.map

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(0);
var ScalarObservable_1 = __webpack_require__(30);
var EmptyObservable_1 = __webpack_require__(13);
var isScheduler_1 = __webpack_require__(12);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ArrayObservable = (function (_super) {
    __extends(ArrayObservable, _super);
    function ArrayObservable(array, scheduler) {
        _super.call(this);
        this.array = array;
        this.scheduler = scheduler;
        if (!scheduler && array.length === 1) {
            this._isScalar = true;
            this.value = array[0];
        }
    }
    ArrayObservable.create = function (array, scheduler) {
        return new ArrayObservable(array, scheduler);
    };
    /**
     * Creates an Observable that emits some values you specify as arguments,
     * immediately one after the other, and then emits a complete notification.
     *
     * <span class="informal">Emits the arguments you provide, then completes.
     * </span>
     *
     * <img src="./img/of.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the arguments given, and the complete notification thereafter. It can
     * be used for composing with other Observables, such as with {@link concat}.
     * By default, it uses a `null` IScheduler, which means the `next`
     * notifications are sent synchronously, although with a different IScheduler
     * it is possible to determine when those notifications will be delivered.
     *
     * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>
     * var numbers = Rx.Observable.of(10, 20, 30);
     * var letters = Rx.Observable.of('a', 'b', 'c');
     * var interval = Rx.Observable.interval(1000);
     * var result = numbers.concat(letters).concat(interval);
     * result.subscribe(x => console.log(x));
     *
     * @see {@link create}
     * @see {@link empty}
     * @see {@link never}
     * @see {@link throw}
     *
     * @param {...T} values Arguments that represent `next` values to be emitted.
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emissions of the `next` notifications.
     * @return {Observable<T>} An Observable that emits each given input value.
     * @static true
     * @name of
     * @owner Observable
     */
    ArrayObservable.of = function () {
        var array = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            array[_i - 0] = arguments[_i];
        }
        var scheduler = array[array.length - 1];
        if (isScheduler_1.isScheduler(scheduler)) {
            array.pop();
        }
        else {
            scheduler = null;
        }
        var len = array.length;
        if (len > 1) {
            return new ArrayObservable(array, scheduler);
        }
        else if (len === 1) {
            return new ScalarObservable_1.ScalarObservable(array[0], scheduler);
        }
        else {
            return new EmptyObservable_1.EmptyObservable(scheduler);
        }
    };
    ArrayObservable.dispatch = function (state) {
        var array = state.array, index = state.index, count = state.count, subscriber = state.subscriber;
        if (index >= count) {
            subscriber.complete();
            return;
        }
        subscriber.next(array[index]);
        if (subscriber.closed) {
            return;
        }
        state.index = index + 1;
        this.schedule(state);
    };
    ArrayObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var array = this.array;
        var count = array.length;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(ArrayObservable.dispatch, 0, {
                array: array, index: index, count: count, subscriber: subscriber
            });
        }
        else {
            for (var i = 0; i < count && !subscriber.closed; i++) {
                subscriber.next(array[i]);
            }
            subscriber.complete();
        }
    };
    return ArrayObservable;
}(Observable_1.Observable));
exports.ArrayObservable = ArrayObservable;
//# sourceMappingURL=ArrayObservable.js.map

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });
//# sourceMappingURL=isArray.js.map

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function isScheduler(value) {
    return value && typeof value.schedule === 'function';
}
exports.isScheduler = isScheduler;
//# sourceMappingURL=isScheduler.js.map

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(0);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var EmptyObservable = (function (_super) {
    __extends(EmptyObservable, _super);
    function EmptyObservable(scheduler) {
        _super.call(this);
        this.scheduler = scheduler;
    }
    /**
     * Creates an Observable that emits no items to the Observer and immediately
     * emits a complete notification.
     *
     * <span class="informal">Just emits 'complete', and nothing else.
     * </span>
     *
     * <img src="./img/empty.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the complete notification. It can be used for composing with other
     * Observables, such as in a {@link mergeMap}.
     *
     * @example <caption>Emit the number 7, then complete.</caption>
     * var result = Rx.Observable.empty().startWith(7);
     * result.subscribe(x => console.log(x));
     *
     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>
     * var interval = Rx.Observable.interval(1000);
     * var result = interval.mergeMap(x =>
     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()
     * );
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following to the console:
     * // x is equal to the count on the interval eg(0,1,2,3,...)
     * // x will occur every 1000ms
     * // if x % 2 is equal to 1 print abc
     * // if x % 2 is not equal to 1 nothing will be output
     *
     * @see {@link create}
     * @see {@link never}
     * @see {@link of}
     * @see {@link throw}
     *
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emission of the complete notification.
     * @return {Observable} An "empty" Observable: emits only the complete
     * notification.
     * @static true
     * @name empty
     * @owner Observable
     */
    EmptyObservable.create = function (scheduler) {
        return new EmptyObservable(scheduler);
    };
    EmptyObservable.dispatch = function (arg) {
        var subscriber = arg.subscriber;
        subscriber.complete();
    };
    EmptyObservable.prototype._subscribe = function (subscriber) {
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });
        }
        else {
            subscriber.complete();
        }
    };
    return EmptyObservable;
}(Observable_1.Observable));
exports.EmptyObservable = EmptyObservable;
//# sourceMappingURL=EmptyObservable.js.map

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ConnectableObservable_1 = __webpack_require__(41);
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits the results of invoking a specified selector on items
 * emitted by a ConnectableObservable that shares a single subscription to the underlying stream.
 *
 * <img src="./img/multicast.png" width="100%">
 *
 * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate subject through
 * which the source sequence's elements will be multicast to the selector function
 * or Subject to push source elements into.
 * @param {Function} [selector] - Optional selector function that can use the multicasted source stream
 * as many times as needed, without causing multiple subscriptions to the source stream.
 * Subscribers to the given source will receive all notifications of the source from the
 * time of the subscription forward.
 * @return {Observable} An Observable that emits the results of invoking the selector
 * on the items emitted by a `ConnectableObservable` that shares a single subscription to
 * the underlying stream.
 * @method multicast
 * @owner Observable
 */
function multicast(subjectOrSubjectFactory, selector) {
    var subjectFactory;
    if (typeof subjectOrSubjectFactory === 'function') {
        subjectFactory = subjectOrSubjectFactory;
    }
    else {
        subjectFactory = function subjectFactory() {
            return subjectOrSubjectFactory;
        };
    }
    if (typeof selector === 'function') {
        return this.lift(new MulticastOperator(subjectFactory, selector));
    }
    var connectable = Object.create(this, ConnectableObservable_1.connectableObservableDescriptor);
    connectable.source = this;
    connectable.subjectFactory = subjectFactory;
    return connectable;
}
exports.multicast = multicast;
var MulticastOperator = (function () {
    function MulticastOperator(subjectFactory, selector) {
        this.subjectFactory = subjectFactory;
        this.selector = selector;
    }
    MulticastOperator.prototype.call = function (subscriber, source) {
        var selector = this.selector;
        var subject = this.subjectFactory();
        var subscription = selector(subject).subscribe(subscriber);
        subscription.add(source.subscribe(subject));
        return subscription;
    };
    return MulticastOperator;
}());
exports.MulticastOperator = MulticastOperator;
//# sourceMappingURL=multicast.js.map

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
/**
 * Represents a push-based event or value that an {@link Observable} can emit.
 * This class is particularly useful for operators that manage notifications,
 * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and
 * others. Besides wrapping the actual delivered value, it also annotates it
 * with metadata of, for instance, what type of push message it is (`next`,
 * `error`, or `complete`).
 *
 * @see {@link materialize}
 * @see {@link dematerialize}
 * @see {@link observeOn}
 *
 * @class Notification<T>
 */
var Notification = (function () {
    function Notification(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === 'N';
    }
    /**
     * Delivers to the given `observer` the value wrapped by this Notification.
     * @param {Observer} observer
     * @return
     */
    Notification.prototype.observe = function (observer) {
        switch (this.kind) {
            case 'N':
                return observer.next && observer.next(this.value);
            case 'E':
                return observer.error && observer.error(this.error);
            case 'C':
                return observer.complete && observer.complete();
        }
    };
    /**
     * Given some {@link Observer} callbacks, deliver the value represented by the
     * current Notification to the correctly corresponding callback.
     * @param {function(value: T): void} next An Observer `next` callback.
     * @param {function(err: any): void} [error] An Observer `error` callback.
     * @param {function(): void} [complete] An Observer `complete` callback.
     * @return {any}
     */
    Notification.prototype.do = function (next, error, complete) {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return next && next(this.value);
            case 'E':
                return error && error(this.error);
            case 'C':
                return complete && complete();
        }
    };
    /**
     * Takes an Observer or its individual callback functions, and calls `observe`
     * or `do` methods accordingly.
     * @param {Observer|function(value: T): void} nextOrObserver An Observer or
     * the `next` callback.
     * @param {function(err: any): void} [error] An Observer `error` callback.
     * @param {function(): void} [complete] An Observer `complete` callback.
     * @return {any}
     */
    Notification.prototype.accept = function (nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
            return this.observe(nextOrObserver);
        }
        else {
            return this.do(nextOrObserver, error, complete);
        }
    };
    /**
     * Returns a simple Observable that just delivers the notification represented
     * by this Notification instance.
     * @return {any}
     */
    Notification.prototype.toObservable = function () {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return Observable_1.Observable.of(this.value);
            case 'E':
                return Observable_1.Observable.throw(this.error);
            case 'C':
                return Observable_1.Observable.empty();
        }
        throw new Error('unexpected notification kind value');
    };
    /**
     * A shortcut to create a Notification instance of the type `next` from a
     * given value.
     * @param {T} value The `next` value.
     * @return {Notification<T>} The "next" Notification representing the
     * argument.
     */
    Notification.createNext = function (value) {
        if (typeof value !== 'undefined') {
            return new Notification('N', value);
        }
        return this.undefinedValueNotification;
    };
    /**
     * A shortcut to create a Notification instance of the type `error` from a
     * given error.
     * @param {any} [err] The `error` error.
     * @return {Notification<T>} The "error" Notification representing the
     * argument.
     */
    Notification.createError = function (err) {
        return new Notification('E', undefined, err);
    };
    /**
     * A shortcut to create a Notification instance of the type `complete`.
     * @return {Notification<any>} The valueless "complete" Notification.
     */
    Notification.createComplete = function () {
        return this.completeNotification;
    };
    Notification.completeNotification = new Notification('C');
    Notification.undefinedValueNotification = new Notification('N', undefined);
    return Notification;
}());
exports.Notification = Notification;
//# sourceMappingURL=Notification.js.map

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var root_1 = __webpack_require__(7);
var Action_1 = __webpack_require__(333);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AsyncAction = (function (_super) {
    __extends(AsyncAction, _super);
    function AsyncAction(scheduler, work) {
        _super.call(this, scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
        this.pending = false;
    }
    AsyncAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        if (this.closed) {
            return this;
        }
        // Always replace the current state with the new state.
        this.state = state;
        // Set the pending flag indicating that this action has been scheduled, or
        // has recursively rescheduled itself.
        this.pending = true;
        var id = this.id;
        var scheduler = this.scheduler;
        //
        // Important implementation note:
        //
        // Actions only execute once by default, unless rescheduled from within the
        // scheduled callback. This allows us to implement single and repeat
        // actions via the same code path, without adding API surface area, as well
        // as mimic traditional recursion but across asynchronous boundaries.
        //
        // However, JS runtimes and timers distinguish between intervals achieved by
        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of
        // serial `setTimeout` calls can be individually delayed, which delays
        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to
        // guarantee the interval callback will be invoked more precisely to the
        // interval period, regardless of load.
        //
        // Therefore, we use `setInterval` to schedule single and repeat actions.
        // If the action reschedules itself with the same delay, the interval is not
        // canceled. If the action doesn't reschedule, or reschedules with a
        // different delay, the interval will be canceled after scheduled callback
        // execution.
        //
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.delay = delay;
        // If this action has already an async Id, don't request a new one.
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
        return this;
    };
    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        return root_1.root.setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        // If this action is rescheduled with the same delay time, don't clear the interval id.
        if (delay !== null && this.delay === delay) {
            return id;
        }
        // Otherwise, if the action's delay time is different from the current delay,
        // clear the interval id
        return root_1.root.clearInterval(id) && undefined || undefined;
    };
    /**
     * Immediately executes this action and the `work` it contains.
     * @return {any}
     */
    AsyncAction.prototype.execute = function (state, delay) {
        if (this.closed) {
            return new Error('executing a cancelled action');
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
            return error;
        }
        else if (this.pending === false && this.id != null) {
            // Dequeue if the action didn't reschedule itself. Don't call
            // unsubscribe(), because the action could reschedule later.
            // For example:
            // ```
            // scheduler.schedule(function doWork(counter) {
            //   /* ... I'm a busy worker bee ... */
            //   var originalAction = this;
            //   /* wait 100ms before rescheduling the action */
            //   setTimeout(function () {
            //     originalAction.schedule(counter + 1);
            //   }, 100);
            // }, 1000);
            // ```
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
    };
    AsyncAction.prototype._execute = function (state, delay) {
        var errored = false;
        var errorValue = undefined;
        try {
            this.work(state);
        }
        catch (e) {
            errored = true;
            errorValue = !!e && e || new Error(e);
        }
        if (errored) {
            this.unsubscribe();
            return errorValue;
        }
    };
    AsyncAction.prototype._unsubscribe = function () {
        var id = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.delay = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;
        if (index !== -1) {
            actions.splice(index, 1);
        }
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
        }
    };
    return AsyncAction;
}(Action_1.Action));
exports.AsyncAction = AsyncAction;
//# sourceMappingURL=AsyncAction.js.map

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Scheduler_1 = __webpack_require__(80);
var AsyncScheduler = (function (_super) {
    __extends(AsyncScheduler, _super);
    function AsyncScheduler() {
        _super.apply(this, arguments);
        this.actions = [];
        /**
         * A flag to indicate whether the Scheduler is currently executing a batch of
         * queued actions.
         * @type {boolean}
         */
        this.active = false;
        /**
         * An internal ID used to track the latest asynchronous task such as those
         * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and
         * others.
         * @type {any}
         */
        this.scheduled = undefined;
    }
    AsyncScheduler.prototype.flush = function (action) {
        var actions = this.actions;
        if (this.active) {
            actions.push(action);
            return;
        }
        var error;
        this.active = true;
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (action = actions.shift()); // exhaust the scheduler queue
        this.active = false;
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsyncScheduler;
}(Scheduler_1.Scheduler));
exports.AsyncScheduler = AsyncScheduler;
//# sourceMappingURL=AsyncScheduler.js.map

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var root_1 = __webpack_require__(7);
function symbolIteratorPonyfill(root) {
    var Symbol = root.Symbol;
    if (typeof Symbol === 'function') {
        if (!Symbol.iterator) {
            Symbol.iterator = Symbol('iterator polyfill');
        }
        return Symbol.iterator;
    }
    else {
        // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)
        var Set_1 = root.Set;
        if (Set_1 && typeof new Set_1()['@@iterator'] === 'function') {
            return '@@iterator';
        }
        var Map_1 = root.Map;
        // required for compatability with es6-shim
        if (Map_1) {
            var keys = Object.getOwnPropertyNames(Map_1.prototype);
            for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.
                if (key !== 'entries' && key !== 'size' && Map_1.prototype[key] === Map_1.prototype['entries']) {
                    return key;
                }
            }
        }
        return '@@iterator';
    }
}
exports.symbolIteratorPonyfill = symbolIteratorPonyfill;
exports.$$iterator = symbolIteratorPonyfill(root_1.root);
//# sourceMappingURL=iterator.js.map

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = __webpack_require__(5);
var Subscription_1 = __webpack_require__(4);
/**
 * @class AsyncSubject<T>
 */
var AsyncSubject = (function (_super) {
    __extends(AsyncSubject, _super);
    function AsyncSubject() {
        _super.apply(this, arguments);
        this.value = null;
        this.hasNext = false;
        this.hasCompleted = false;
    }
    AsyncSubject.prototype._subscribe = function (subscriber) {
        if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1.Subscription.EMPTY;
        }
        else if (this.hasCompleted && this.hasNext) {
            subscriber.next(this.value);
            subscriber.complete();
            return Subscription_1.Subscription.EMPTY;
        }
        return _super.prototype._subscribe.call(this, subscriber);
    };
    AsyncSubject.prototype.next = function (value) {
        if (!this.hasCompleted) {
            this.value = value;
            this.hasNext = true;
        }
    };
    AsyncSubject.prototype.error = function (error) {
        if (!this.hasCompleted) {
            _super.prototype.error.call(this, error);
        }
    };
    AsyncSubject.prototype.complete = function () {
        this.hasCompleted = true;
        if (this.hasNext) {
            _super.prototype.next.call(this, this.value);
        }
        _super.prototype.complete.call(this);
    };
    return AsyncSubject;
}(Subject_1.Subject));
exports.AsyncSubject = AsyncSubject;
//# sourceMappingURL=AsyncSubject.js.map

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(2);
var subscribeToResult_1 = __webpack_require__(3);
/**
 * Converts a higher-order Observable into a first-order Observable which
 * concurrently delivers all values that are emitted on the inner Observables.
 *
 * <span class="informal">Flattens an Observable-of-Observables.</span>
 *
 * <img src="./img/mergeAll.png" width="100%">
 *
 * `mergeAll` subscribes to an Observable that emits Observables, also known as
 * a higher-order Observable. Each time it observes one of these emitted inner
 * Observables, it subscribes to that and delivers all the values from the
 * inner Observable on the output Observable. The output Observable only
 * completes once all inner Observables have completed. Any error delivered by
 * a inner Observable will be immediately emitted on the output Observable.
 *
 * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
 * var firstOrder = higherOrder.mergeAll();
 * firstOrder.subscribe(x => console.log(x));
 *
 * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));
 * var firstOrder = higherOrder.mergeAll(2);
 * firstOrder.subscribe(x => console.log(x));
 *
 * @see {@link combineAll}
 * @see {@link concatAll}
 * @see {@link exhaust}
 * @see {@link merge}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 * @see {@link switch}
 * @see {@link zipAll}
 *
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits values coming from all the
 * inner Observables emitted by the source Observable.
 * @method mergeAll
 * @owner Observable
 */
function mergeAll(concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    return this.lift(new MergeAllOperator(concurrent));
}
exports.mergeAll = mergeAll;
var MergeAllOperator = (function () {
    function MergeAllOperator(concurrent) {
        this.concurrent = concurrent;
    }
    MergeAllOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeAllSubscriber(observer, this.concurrent));
    };
    return MergeAllOperator;
}());
exports.MergeAllOperator = MergeAllOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MergeAllSubscriber = (function (_super) {
    __extends(MergeAllSubscriber, _super);
    function MergeAllSubscriber(destination, concurrent) {
        _super.call(this, destination);
        this.concurrent = concurrent;
        this.hasCompleted = false;
        this.buffer = [];
        this.active = 0;
    }
    MergeAllSubscriber.prototype._next = function (observable) {
        if (this.active < this.concurrent) {
            this.active++;
            this.add(subscribeToResult_1.subscribeToResult(this, observable));
        }
        else {
            this.buffer.push(observable);
        }
    };
    MergeAllSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
    };
    MergeAllSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeAllSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.MergeAllSubscriber = MergeAllSubscriber;
//# sourceMappingURL=mergeAll.js.map

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var root_1 = __webpack_require__(7);
function getSymbolObservable(context) {
    var $$observable;
    var Symbol = context.Symbol;
    if (typeof Symbol === 'function') {
        if (Symbol.observable) {
            $$observable = Symbol.observable;
        }
        else {
            $$observable = Symbol('observable');
            Symbol.observable = $$observable;
        }
    }
    else {
        $$observable = '@@observable';
    }
    return $$observable;
}
exports.getSymbolObservable = getSymbolObservable;
exports.$$observable = getSymbolObservable(root_1.root);
//# sourceMappingURL=observable.js.map

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var root_1 = __webpack_require__(7);
var Symbol = root_1.root.Symbol;
exports.$$rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?
    Symbol.for('rxSubscriber') : '@@rxSubscriber';
//# sourceMappingURL=rxSubscriber.js.map

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when an element was queried at a certain index of an
 * Observable, but no such index or position exists in that sequence.
 *
 * @see {@link elementAt}
 * @see {@link take}
 * @see {@link takeLast}
 *
 * @class ArgumentOutOfRangeError
 */
var ArgumentOutOfRangeError = (function (_super) {
    __extends(ArgumentOutOfRangeError, _super);
    function ArgumentOutOfRangeError() {
        var err = _super.call(this, 'argument out of range');
        this.name = err.name = 'ArgumentOutOfRangeError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return ArgumentOutOfRangeError;
}(Error));
exports.ArgumentOutOfRangeError = ArgumentOutOfRangeError;
//# sourceMappingURL=ArgumentOutOfRangeError.js.map

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when an Observable or a sequence was queried but has no
 * elements.
 *
 * @see {@link first}
 * @see {@link last}
 * @see {@link single}
 *
 * @class EmptyError
 */
var EmptyError = (function (_super) {
    __extends(EmptyError, _super);
    function EmptyError() {
        var err = _super.call(this, 'no elements in sequence');
        this.name = err.name = 'EmptyError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return EmptyError;
}(Error));
exports.EmptyError = EmptyError;
//# sourceMappingURL=EmptyError.js.map

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when an action is invalid because the object has been
 * unsubscribed.
 *
 * @see {@link Subject}
 * @see {@link BehaviorSubject}
 *
 * @class ObjectUnsubscribedError
 */
var ObjectUnsubscribedError = (function (_super) {
    __extends(ObjectUnsubscribedError, _super);
    function ObjectUnsubscribedError() {
        var err = _super.call(this, 'object unsubscribed');
        this.name = err.name = 'ObjectUnsubscribedError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return ObjectUnsubscribedError;
}(Error));
exports.ObjectUnsubscribedError = ObjectUnsubscribedError;
//# sourceMappingURL=ObjectUnsubscribedError.js.map

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function isDate(value) {
    return value instanceof Date && !isNaN(+value);
}
exports.isDate = isDate;
//# sourceMappingURL=isDate.js.map

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function isFunction(x) {
    return typeof x === 'function';
}
exports.isFunction = isFunction;
//# sourceMappingURL=isFunction.js.map

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isArray_1 = __webpack_require__(11);
function isNumeric(val) {
    // parseFloat NaNs numeric-cast false positives (null|true|false|"")
    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
    // subtraction forces infinities to NaN
    // adding 1 corrects loss of precision from parseFloat (#15100)
    return !isArray_1.isArray(val) && (val - parseFloat(val) + 1) >= 0;
}
exports.isNumeric = isNumeric;
;
//# sourceMappingURL=isNumeric.js.map

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = __webpack_require__(5);
var queue_1 = __webpack_require__(57);
var Subscription_1 = __webpack_require__(4);
var observeOn_1 = __webpack_require__(34);
var ObjectUnsubscribedError_1 = __webpack_require__(25);
var SubjectSubscription_1 = __webpack_require__(40);
/**
 * @class ReplaySubject<T>
 */
var ReplaySubject = (function (_super) {
    __extends(ReplaySubject, _super);
    function ReplaySubject(bufferSize, windowTime, scheduler) {
        if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }
        if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }
        _super.call(this);
        this.scheduler = scheduler;
        this._events = [];
        this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
        this._windowTime = windowTime < 1 ? 1 : windowTime;
    }
    ReplaySubject.prototype.next = function (value) {
        var now = this._getNow();
        this._events.push(new ReplayEvent(now, value));
        this._trimBufferThenGetEvents();
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype._subscribe = function (subscriber) {
        var _events = this._trimBufferThenGetEvents();
        var scheduler = this.scheduler;
        var subscription;
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else if (this.hasError) {
            subscription = Subscription_1.Subscription.EMPTY;
        }
        else if (this.isStopped) {
            subscription = Subscription_1.Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            subscription = new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
        if (scheduler) {
            subscriber.add(subscriber = new observeOn_1.ObserveOnSubscriber(subscriber, scheduler));
        }
        var len = _events.length;
        for (var i = 0; i < len && !subscriber.closed; i++) {
            subscriber.next(_events[i].value);
        }
        if (this.hasError) {
            subscriber.error(this.thrownError);
        }
        else if (this.isStopped) {
            subscriber.complete();
        }
        return subscription;
    };
    ReplaySubject.prototype._getNow = function () {
        return (this.scheduler || queue_1.queue).now();
    };
    ReplaySubject.prototype._trimBufferThenGetEvents = function () {
        var now = this._getNow();
        var _bufferSize = this._bufferSize;
        var _windowTime = this._windowTime;
        var _events = this._events;
        var eventsCount = _events.length;
        var spliceCount = 0;
        // Trim events that fall out of the time window.
        // Start at the front of the list. Break early once
        // we encounter an event that falls within the window.
        while (spliceCount < eventsCount) {
            if ((now - _events[spliceCount].time) < _windowTime) {
                break;
            }
            spliceCount++;
        }
        if (eventsCount > _bufferSize) {
            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
        }
        if (spliceCount > 0) {
            _events.splice(0, spliceCount);
        }
        return _events;
    };
    return ReplaySubject;
}(Subject_1.Subject));
exports.ReplaySubject = ReplaySubject;
var ReplayEvent = (function () {
    function ReplayEvent(time, value) {
        this.time = time;
        this.value = value;
    }
    return ReplayEvent;
}());
//# sourceMappingURL=ReplaySubject.js.map

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(0);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ScalarObservable = (function (_super) {
    __extends(ScalarObservable, _super);
    function ScalarObservable(value, scheduler) {
        _super.call(this);
        this.value = value;
        this.scheduler = scheduler;
        this._isScalar = true;
        if (scheduler) {
            this._isScalar = false;
        }
    }
    ScalarObservable.create = function (value, scheduler) {
        return new ScalarObservable(value, scheduler);
    };
    ScalarObservable.dispatch = function (state) {
        var done = state.done, value = state.value, subscriber = state.subscriber;
        if (done) {
            subscriber.complete();
            return;
        }
        subscriber.next(value);
        if (subscriber.closed) {
            return;
        }
        state.done = true;
        this.schedule(state);
    };
    ScalarObservable.prototype._subscribe = function (subscriber) {
        var value = this.value;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(ScalarObservable.dispatch, 0, {
                done: false, value: value, subscriber: subscriber
            });
        }
        else {
            subscriber.next(value);
            if (!subscriber.closed) {
                subscriber.complete();
            }
        }
    };
    return ScalarObservable;
}(Observable_1.Observable));
exports.ScalarObservable = ScalarObservable;
//# sourceMappingURL=ScalarObservable.js.map

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ArrayObservable_1 = __webpack_require__(10);
var isArray_1 = __webpack_require__(11);
var OuterSubscriber_1 = __webpack_require__(2);
var subscribeToResult_1 = __webpack_require__(3);
var none = {};
/* tslint:enable:max-line-length */
/**
 * Combines multiple Observables to create an Observable whose values are
 * calculated from the latest values of each of its input Observables.
 *
 * <span class="informal">Whenever any input Observable emits a value, it
 * computes a formula using the latest values from all the inputs, then emits
 * the output of that formula.</span>
 *
 * <img src="./img/combineLatest.png" width="100%">
 *
 * `combineLatest` combines the values from this Observable with values from
 * Observables passed as arguments. This is done by subscribing to each
 * Observable, in order, and collecting an array of each of the most recent
 * values any time any of the input Observables emits, then either taking that
 * array and passing it as arguments to an optional `project` function and
 * emitting the return value of that, or just emitting the array of recent
 * values directly if there is no `project` function.
 *
 * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>
 * var weight = Rx.Observable.of(70, 72, 76, 79, 75);
 * var height = Rx.Observable.of(1.76, 1.77, 1.78);
 * var bmi = weight.combineLatest(height, (w, h) => w / (h * h));
 * bmi.subscribe(x => console.log('BMI is ' + x));
 *
 * // With output to console:
 * // BMI is 24.212293388429753
 * // BMI is 23.93948099205209
 * // BMI is 23.671253629592222
 *
 * @see {@link combineAll}
 * @see {@link merge}
 * @see {@link withLatestFrom}
 *
 * @param {ObservableInput} other An input Observable to combine with the source
 * Observable. More than one input Observables may be given as argument.
 * @param {function} [project] An optional function to project the values from
 * the combined latest values into a new value on the output Observable.
 * @return {Observable} An Observable of projected values from the most recent
 * values from each input Observable, or an array of the most recent values from
 * each input Observable.
 * @method combineLatest
 * @owner Observable
 */
function combineLatest() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var project = null;
    if (typeof observables[observables.length - 1] === 'function') {
        project = observables.pop();
    }
    // if the first and only other argument besides the resultSelector is an array
    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`
    if (observables.length === 1 && isArray_1.isArray(observables[0])) {
        observables = observables[0].slice();
    }
    observables.unshift(this);
    return this.lift.call(new ArrayObservable_1.ArrayObservable(observables), new CombineLatestOperator(project));
}
exports.combineLatest = combineLatest;
var CombineLatestOperator = (function () {
    function CombineLatestOperator(project) {
        this.project = project;
    }
    CombineLatestOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CombineLatestSubscriber(subscriber, this.project));
    };
    return CombineLatestOperator;
}());
exports.CombineLatestOperator = CombineLatestOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var CombineLatestSubscriber = (function (_super) {
    __extends(CombineLatestSubscriber, _super);
    function CombineLatestSubscriber(destination, project) {
        _super.call(this, destination);
        this.project = project;
        this.active = 0;
        this.values = [];
        this.observables = [];
    }
    CombineLatestSubscriber.prototype._next = function (observable) {
        this.values.push(none);
        this.observables.push(observable);
    };
    CombineLatestSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            this.active = len;
            this.toRespond = len;
            for (var i = 0; i < len; i++) {
                var observable = observables[i];
                this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));
            }
        }
    };
    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
        if ((this.active -= 1) === 0) {
            this.destination.complete();
        }
    };
    CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var values = this.values;
        var oldVal = values[outerIndex];
        var toRespond = !this.toRespond
            ? 0
            : oldVal === none ? --this.toRespond : this.toRespond;
        values[outerIndex] = innerValue;
        if (toRespond === 0) {
            if (this.project) {
                this._tryProject(values);
            }
            else {
                this.destination.next(values.slice());
            }
        }
    };
    CombineLatestSubscriber.prototype._tryProject = function (values) {
        var result;
        try {
            result = this.project.apply(this, values);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return CombineLatestSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.CombineLatestSubscriber = CombineLatestSubscriber;
//# sourceMappingURL=combineLatest.js.map

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var isScheduler_1 = __webpack_require__(12);
var ArrayObservable_1 = __webpack_require__(10);
var mergeAll_1 = __webpack_require__(20);
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which sequentially emits all values from every
 * given input Observable after the current Observable.
 *
 * <span class="informal">Concatenates multiple Observables together by
 * sequentially emitting their values, one Observable after the other.</span>
 *
 * <img src="./img/concat.png" width="100%">
 *
 * Joins this Observable with multiple other Observables by subscribing to them
 * one at a time, starting with the source, and merging their results into the
 * output Observable. Will wait for each Observable to complete before moving
 * on to the next.
 *
 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
 * var timer = Rx.Observable.interval(1000).take(4);
 * var sequence = Rx.Observable.range(1, 10);
 * var result = timer.concat(sequence);
 * result.subscribe(x => console.log(x));
 *
 * // results in:
 * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10
 *
 * @example <caption>Concatenate 3 Observables</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var result = timer1.concat(timer2, timer3);
 * result.subscribe(x => console.log(x));
 *
 * // results in the following:
 * // (Prints to console sequentially)
 * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9
 * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5
 * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9
 *
 * @see {@link concatAll}
 * @see {@link concatMap}
 * @see {@link concatMapTo}
 *
 * @param {ObservableInput} other An input Observable to concatenate after the source
 * Observable. More than one input Observables may be given as argument.
 * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each
 * Observable subscription on.
 * @return {Observable} All values of each passed Observable merged into a
 * single Observable, in order, in serial fashion.
 * @method concat
 * @owner Observable
 */
function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return this.lift.call(concatStatic.apply(void 0, [this].concat(observables)));
}
exports.concat = concat;
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which sequentially emits all values from given
 * Observable and then moves on to the next.
 *
 * <span class="informal">Concatenates multiple Observables together by
 * sequentially emitting their values, one Observable after the other.</span>
 *
 * <img src="./img/concat.png" width="100%">
 *
 * `concat` joins multiple Observables together, by subscribing to them one at a time and
 * merging their results into the output Observable. You can pass either an array of
 * Observables, or put them directly as arguments. Passing an empty array will result
 * in Observable that completes immediately.
 *
 * `concat` will subscribe to first input Observable and emit all its values, without
 * changing or affecting them in any way. When that Observable completes, it will
 * subscribe to then next Observable passed and, again, emit its values. This will be
 * repeated, until the operator runs out of Observables. When last input Observable completes,
 * `concat` will complete as well. At any given moment only one Observable passed to operator
 * emits values. If you would like to emit values from passed Observables concurrently, check out
 * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,
 * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.
 *
 * Note that if some input Observable never completes, `concat` will also never complete
 * and Observables following the one that did not complete will never be subscribed. On the other
 * hand, if some Observable simply completes immediately after it is subscribed, it will be
 * invisible for `concat`, which will just move on to the next Observable.
 *
 * If any Observable in chain errors, instead of passing control to the next Observable,
 * `concat` will error immediately as well. Observables that would be subscribed after
 * the one that emitted error, never will.
 *
 * If you pass to `concat` the same Observable many times, its stream of values
 * will be "replayed" on every subscription, which means you can repeat given Observable
 * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,
 * you can always use {@link repeat}.
 *
 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
 * var timer = Rx.Observable.interval(1000).take(4);
 * var sequence = Rx.Observable.range(1, 10);
 * var result = Rx.Observable.concat(timer, sequence);
 * result.subscribe(x => console.log(x));
 *
 * // results in:
 * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10
 *
 *
 * @example <caption>Concatenate an array of 3 Observables</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var result = Rx.Observable.concat([timer1, timer2, timer3]); // note that array is passed
 * result.subscribe(x => console.log(x));
 *
 * // results in the following:
 * // (Prints to console sequentially)
 * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9
 * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5
 * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9
 *
 *
 * @example <caption>Concatenate the same Observable to repeat it</caption>
 * const timer = Rx.Observable.interval(1000).take(2);
 *
 * Rx.Observable.concat(timer, timer) // concating the same Observable!
 * .subscribe(
 *   value => console.log(value),
 *   err => {},
 *   () => console.log('...and it is done!')
 * );
 *
 * // Logs:
 * // 0 after 1s
 * // 1 after 2s
 * // 0 after 3s
 * // 1 after 4s
 * // "...and it is done!" also after 4s
 *
 * @see {@link concatAll}
 * @see {@link concatMap}
 * @see {@link concatMapTo}
 *
 * @param {ObservableInput} input1 An input Observable to concatenate with others.
 * @param {ObservableInput} input2 An input Observable to concatenate with others.
 * More than one input Observables may be given as argument.
 * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each
 * Observable subscription on.
 * @return {Observable} All values of each passed Observable merged into a
 * single Observable, in order, in serial fashion.
 * @static true
 * @name concat
 * @owner Observable
 */
function concatStatic() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var scheduler = null;
    var args = observables;
    if (isScheduler_1.isScheduler(args[observables.length - 1])) {
        scheduler = args.pop();
    }
    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable_1.Observable) {
        return observables[0];
    }
    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(1));
}
exports.concatStatic = concatStatic;
//# sourceMappingURL=concat.js.map

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(1);
/**
 * Applies a given `project` function to each value emitted by the source
 * Observable, and emits the resulting values as an Observable.
 *
 * <span class="informal">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),
 * it passes each source value through a transformation function to get
 * corresponding output values.</span>
 *
 * <img src="./img/map.png" width="100%">
 *
 * Similar to the well known `Array.prototype.map` function, this operator
 * applies a projection to each value and emits that projection in the output
 * Observable.
 *
 * @example <caption>Map every every click to the clientX position of that click</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks.map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link mapTo}
 * @see {@link pluck}
 *
 * @param {function(value: T, index: number): R} project The function to apply
 * to each `value` emitted by the source Observable. The `index` parameter is
 * the number `i` for the i-th emission that has happened since the
 * subscription, starting from the number `0`.
 * @param {any} [thisArg] An optional argument to define what `this` is in the
 * `project` function.
 * @return {Observable<R>} An Observable that emits the values from the source
 * Observable transformed by the given `project` function.
 * @method map
 * @owner Observable
 */
function map(project, thisArg) {
    if (typeof project !== 'function') {
        throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
    }
    return this.lift(new MapOperator(project, thisArg));
}
exports.map = map;
var MapOperator = (function () {
    function MapOperator(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
    }
    MapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator;
}());
exports.MapOperator = MapOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MapSubscriber = (function (_super) {
    __extends(MapSubscriber, _super);
    function MapSubscriber(destination, project, thisArg) {
        _super.call(this, destination);
        this.project = project;
        this.count = 0;
        this.thisArg = thisArg || this;
    }
    // NOTE: This looks unoptimized, but it's actually purposefully NOT
    // using try/catch optimizations.
    MapSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.project.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return MapSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=map.js.map

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(1);
var Notification_1 = __webpack_require__(15);
/**
 * @see {@link Notification}
 *
 * @param scheduler
 * @param delay
 * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
 * @method observeOn
 * @owner Observable
 */
function observeOn(scheduler, delay) {
    if (delay === void 0) { delay = 0; }
    return this.lift(new ObserveOnOperator(scheduler, delay));
}
exports.observeOn = observeOn;
var ObserveOnOperator = (function () {
    function ObserveOnOperator(scheduler, delay) {
        if (delay === void 0) { delay = 0; }
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
    };
    return ObserveOnOperator;
}());
exports.ObserveOnOperator = ObserveOnOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ObserveOnSubscriber = (function (_super) {
    __extends(ObserveOnSubscriber, _super);
    function ObserveOnSubscriber(destination, scheduler, delay) {
        if (delay === void 0) { delay = 0; }
        _super.call(this, destination);
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnSubscriber.dispatch = function (arg) {
        var notification = arg.notification, destination = arg.destination;
        notification.observe(destination);
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
    };
    ObserveOnSubscriber.prototype._next = function (value) {
        this.scheduleMessage(Notification_1.Notification.createNext(value));
    };
    ObserveOnSubscriber.prototype._error = function (err) {
        this.scheduleMessage(Notification_1.Notification.createError(err));
    };
    ObserveOnSubscriber.prototype._complete = function () {
        this.scheduleMessage(Notification_1.Notification.createComplete());
    };
    return ObserveOnSubscriber;
}(Subscriber_1.Subscriber));
exports.ObserveOnSubscriber = ObserveOnSubscriber;
var ObserveOnMessage = (function () {
    function ObserveOnMessage(notification, destination) {
        this.notification = notification;
        this.destination = destination;
    }
    return ObserveOnMessage;
}());
exports.ObserveOnMessage = ObserveOnMessage;
//# sourceMappingURL=observeOn.js.map

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(1);
/* tslint:enable:max-line-length */
/**
 * Applies an accumulator function over the source Observable, and returns the
 * accumulated result when the source completes, given an optional seed value.
 *
 * <span class="informal">Combines together all values emitted on the source,
 * using an accumulator function that knows how to join a new source value into
 * the accumulation from the past.</span>
 *
 * <img src="./img/reduce.png" width="100%">
 *
 * Like
 * [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce),
 * `reduce` applies an `accumulator` function against an accumulation and each
 * value of the source Observable (from the past) to reduce it to a single
 * value, emitted on the output Observable. Note that `reduce` will only emit
 * one value, only when the source Observable completes. It is equivalent to
 * applying operator {@link scan} followed by operator {@link last}.
 *
 * Returns an Observable that applies a specified `accumulator` function to each
 * item emitted by the source Observable. If a `seed` value is specified, then
 * that value will be used as the initial value for the accumulator. If no seed
 * value is specified, the first item of the source is used as the seed.
 *
 * @example <caption>Count the number of click events that happened in 5 seconds</caption>
 * var clicksInFiveSeconds = Rx.Observable.fromEvent(document, 'click')
 *   .takeUntil(Rx.Observable.interval(5000));
 * var ones = clicksInFiveSeconds.mapTo(1);
 * var seed = 0;
 * var count = ones.reduce((acc, one) => acc + one, seed);
 * count.subscribe(x => console.log(x));
 *
 * @see {@link count}
 * @see {@link expand}
 * @see {@link mergeScan}
 * @see {@link scan}
 *
 * @param {function(acc: R, value: T, index: number): R} accumulator The accumulator function
 * called on each source value.
 * @param {R} [seed] The initial accumulation value.
 * @return {Observable<R>} An Observable that emits a single value that is the
 * result of accumulating the values emitted by the source Observable.
 * @method reduce
 * @owner Observable
 */
function reduce(accumulator, seed) {
    var hasSeed = false;
    // providing a seed of `undefined` *should* be valid and trigger
    // hasSeed! so don't use `seed !== undefined` checks!
    // For this reason, we have to check it here at the original call site
    // otherwise inside Operator/Subscriber we won't know if `undefined`
    // means they didn't provide anything or if they literally provided `undefined`
    if (arguments.length >= 2) {
        hasSeed = true;
    }
    return this.lift(new ReduceOperator(accumulator, seed, hasSeed));
}
exports.reduce = reduce;
var ReduceOperator = (function () {
    function ReduceOperator(accumulator, seed, hasSeed) {
        if (hasSeed === void 0) { hasSeed = false; }
        this.accumulator = accumulator;
        this.seed = seed;
        this.hasSeed = hasSeed;
    }
    ReduceOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ReduceSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
    };
    return ReduceOperator;
}());
exports.ReduceOperator = ReduceOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ReduceSubscriber = (function (_super) {
    __extends(ReduceSubscriber, _super);
    function ReduceSubscriber(destination, accumulator, seed, hasSeed) {
        _super.call(this, destination);
        this.accumulator = accumulator;
        this.hasSeed = hasSeed;
        this.index = 0;
        this.hasValue = false;
        this.acc = seed;
        if (!this.hasSeed) {
            this.index++;
        }
    }
    ReduceSubscriber.prototype._next = function (value) {
        if (this.hasValue || (this.hasValue = this.hasSeed)) {
            this._tryReduce(value);
        }
        else {
            this.acc = value;
            this.hasValue = true;
        }
    };
    ReduceSubscriber.prototype._tryReduce = function (value) {
        var result;
        try {
            result = this.accumulator(this.acc, value, this.index++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.acc = result;
    };
    ReduceSubscriber.prototype._complete = function () {
        if (this.hasValue || this.hasSeed) {
            this.destination.next(this.acc);
        }
        this.destination.complete();
    };
    return ReduceSubscriber;
}(Subscriber_1.Subscriber));
exports.ReduceSubscriber = ReduceSubscriber;
//# sourceMappingURL=reduce.js.map

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ArrayObservable_1 = __webpack_require__(10);
var isArray_1 = __webpack_require__(11);
var Subscriber_1 = __webpack_require__(1);
var OuterSubscriber_1 = __webpack_require__(2);
var subscribeToResult_1 = __webpack_require__(3);
var iterator_1 = __webpack_require__(18);
/* tslint:enable:max-line-length */
/**
 * @param observables
 * @return {Observable<R>}
 * @method zip
 * @owner Observable
 */
function zipProto() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return this.lift.call(zipStatic.apply(void 0, [this].concat(observables)));
}
exports.zipProto = zipProto;
/* tslint:enable:max-line-length */
/**
 * Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each
 * of its input Observables.
 *
 * If the latest parameter is a function, this function is used to compute the created value from the input values.
 * Otherwise, an array of the input values is returned.
 *
 * @example <caption>Combine age and name from different sources</caption>
 *
 * let age$ = Observable.of<number>(27, 25, 29);
 * let name$ = Observable.of<string>('Foo', 'Bar', 'Beer');
 * let isDev$ = Observable.of<boolean>(true, true, false);
 *
 * Observable
 *     .zip(age$,
 *          name$,
 *          isDev$,
 *          (age: number, name: string, isDev: boolean) => ({ age, name, isDev }))
 *     .subscribe(x => console.log(x));
 *
 * // outputs
 * // { age: 27, name: 'Foo', isDev: true }
 * // { age: 25, name: 'Bar', isDev: true }
 * // { age: 29, name: 'Beer', isDev: false }
 *
 * @param observables
 * @return {Observable<R>}
 * @static true
 * @name zip
 * @owner Observable
 */
function zipStatic() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var project = observables[observables.length - 1];
    if (typeof project === 'function') {
        observables.pop();
    }
    return new ArrayObservable_1.ArrayObservable(observables).lift(new ZipOperator(project));
}
exports.zipStatic = zipStatic;
var ZipOperator = (function () {
    function ZipOperator(project) {
        this.project = project;
    }
    ZipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ZipSubscriber(subscriber, this.project));
    };
    return ZipOperator;
}());
exports.ZipOperator = ZipOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ZipSubscriber = (function (_super) {
    __extends(ZipSubscriber, _super);
    function ZipSubscriber(destination, project, values) {
        if (values === void 0) { values = Object.create(null); }
        _super.call(this, destination);
        this.iterators = [];
        this.active = 0;
        this.project = (typeof project === 'function') ? project : null;
        this.values = values;
    }
    ZipSubscriber.prototype._next = function (value) {
        var iterators = this.iterators;
        if (isArray_1.isArray(value)) {
            iterators.push(new StaticArrayIterator(value));
        }
        else if (typeof value[iterator_1.$$iterator] === 'function') {
            iterators.push(new StaticIterator(value[iterator_1.$$iterator]()));
        }
        else {
            iterators.push(new ZipBufferIterator(this.destination, this, value));
        }
    };
    ZipSubscriber.prototype._complete = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        this.active = len;
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            if (iterator.stillUnsubscribed) {
                this.add(iterator.subscribe(iterator, i));
            }
            else {
                this.active--; // not an observable
            }
        }
    };
    ZipSubscriber.prototype.notifyInactive = function () {
        this.active--;
        if (this.active === 0) {
            this.destination.complete();
        }
    };
    ZipSubscriber.prototype.checkIterators = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        var destination = this.destination;
        // abort if not all of them have values
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {
                return;
            }
        }
        var shouldComplete = false;
        var args = [];
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            var result = iterator.next();
            // check to see if it's completed now that you've gotten
            // the next value.
            if (iterator.hasCompleted()) {
                shouldComplete = true;
            }
            if (result.done) {
                destination.complete();
                return;
            }
            args.push(result.value);
        }
        if (this.project) {
            this._tryProject(args);
        }
        else {
            destination.next(args);
        }
        if (shouldComplete) {
            destination.complete();
        }
    };
    ZipSubscriber.prototype._tryProject = function (args) {
        var result;
        try {
            result = this.project.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return ZipSubscriber;
}(Subscriber_1.Subscriber));
exports.ZipSubscriber = ZipSubscriber;
var StaticIterator = (function () {
    function StaticIterator(iterator) {
        this.iterator = iterator;
        this.nextResult = iterator.next();
    }
    StaticIterator.prototype.hasValue = function () {
        return true;
    };
    StaticIterator.prototype.next = function () {
        var result = this.nextResult;
        this.nextResult = this.iterator.next();
        return result;
    };
    StaticIterator.prototype.hasCompleted = function () {
        var nextResult = this.nextResult;
        return nextResult && nextResult.done;
    };
    return StaticIterator;
}());
var StaticArrayIterator = (function () {
    function StaticArrayIterator(array) {
        this.array = array;
        this.index = 0;
        this.length = 0;
        this.length = array.length;
    }
    StaticArrayIterator.prototype[iterator_1.$$iterator] = function () {
        return this;
    };
    StaticArrayIterator.prototype.next = function (value) {
        var i = this.index++;
        var array = this.array;
        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };
    };
    StaticArrayIterator.prototype.hasValue = function () {
        return this.array.length > this.index;
    };
    StaticArrayIterator.prototype.hasCompleted = function () {
        return this.array.length === this.index;
    };
    return StaticArrayIterator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ZipBufferIterator = (function (_super) {
    __extends(ZipBufferIterator, _super);
    function ZipBufferIterator(destination, parent, observable) {
        _super.call(this, destination);
        this.parent = parent;
        this.observable = observable;
        this.stillUnsubscribed = true;
        this.buffer = [];
        this.isComplete = false;
    }
    ZipBufferIterator.prototype[iterator_1.$$iterator] = function () {
        return this;
    };
    // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next
    //    this is legit because `next()` will never be called by a subscription in this case.
    ZipBufferIterator.prototype.next = function () {
        var buffer = this.buffer;
        if (buffer.length === 0 && this.isComplete) {
            return { value: null, done: true };
        }
        else {
            return { value: buffer.shift(), done: false };
        }
    };
    ZipBufferIterator.prototype.hasValue = function () {
        return this.buffer.length > 0;
    };
    ZipBufferIterator.prototype.hasCompleted = function () {
        return this.buffer.length === 0 && this.isComplete;
    };
    ZipBufferIterator.prototype.notifyComplete = function () {
        if (this.buffer.length > 0) {
            this.isComplete = true;
            this.parent.notifyInactive();
        }
        else {
            this.destination.complete();
        }
    };
    ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.buffer.push(innerValue);
        this.parent.checkIterators();
    };
    ZipBufferIterator.prototype.subscribe = function (value, index) {
        return subscribeToResult_1.subscribeToResult(this, this.observable, this, index);
    };
    return ZipBufferIterator;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=zip.js.map

/***/ }),
/* 37 */
/***/ (function(module, exports) {

exports.agent = 'pendo-designer-agent';
exports.background = 'pendo-designer-background';
exports.contentScript = 'pendo-designer-content-script';
exports.designer = 'pendo-designer';
exports.plugin = 'pendo-designer-plugin';

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = __webpack_require__(5);
var ObjectUnsubscribedError_1 = __webpack_require__(25);
/**
 * @class BehaviorSubject<T>
 */
var BehaviorSubject = (function (_super) {
    __extends(BehaviorSubject, _super);
    function BehaviorSubject(_value) {
        _super.call(this);
        this._value = _value;
    }
    Object.defineProperty(BehaviorSubject.prototype, "value", {
        get: function () {
            return this.getValue();
        },
        enumerable: true,
        configurable: true
    });
    BehaviorSubject.prototype._subscribe = function (subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        if (subscription && !subscription.closed) {
            subscriber.next(this._value);
        }
        return subscription;
    };
    BehaviorSubject.prototype.getValue = function () {
        if (this.hasError) {
            throw this.thrownError;
        }
        else if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else {
            return this._value;
        }
    };
    BehaviorSubject.prototype.next = function (value) {
        _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject;
}(Subject_1.Subject));
exports.BehaviorSubject = BehaviorSubject;
//# sourceMappingURL=BehaviorSubject.js.map

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.empty = {
    closed: true,
    next: function (value) { },
    error: function (err) { throw err; },
    complete: function () { }
};
//# sourceMappingURL=Observer.js.map

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1 = __webpack_require__(4);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SubjectSubscription = (function (_super) {
    __extends(SubjectSubscription, _super);
    function SubjectSubscription(subject, subscriber) {
        _super.call(this);
        this.subject = subject;
        this.subscriber = subscriber;
        this.closed = false;
    }
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    return SubjectSubscription;
}(Subscription_1.Subscription));
exports.SubjectSubscription = SubjectSubscription;
//# sourceMappingURL=SubjectSubscription.js.map

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = __webpack_require__(5);
var Observable_1 = __webpack_require__(0);
var Subscriber_1 = __webpack_require__(1);
var Subscription_1 = __webpack_require__(4);
/**
 * @class ConnectableObservable<T>
 */
var ConnectableObservable = (function (_super) {
    __extends(ConnectableObservable, _super);
    function ConnectableObservable(source, subjectFactory) {
        _super.call(this);
        this.source = source;
        this.subjectFactory = subjectFactory;
        this._refCount = 0;
    }
    ConnectableObservable.prototype._subscribe = function (subscriber) {
        return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable.prototype.getSubject = function () {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
            this._subject = this.subjectFactory();
        }
        return this._subject;
    };
    ConnectableObservable.prototype.connect = function () {
        var connection = this._connection;
        if (!connection) {
            connection = this._connection = new Subscription_1.Subscription();
            connection.add(this.source
                .subscribe(new ConnectableSubscriber(this.getSubject(), this)));
            if (connection.closed) {
                this._connection = null;
                connection = Subscription_1.Subscription.EMPTY;
            }
            else {
                this._connection = connection;
            }
        }
        return connection;
    };
    ConnectableObservable.prototype.refCount = function () {
        return this.lift(new RefCountOperator(this));
    };
    return ConnectableObservable;
}(Observable_1.Observable));
exports.ConnectableObservable = ConnectableObservable;
exports.connectableObservableDescriptor = {
    operator: { value: null },
    _refCount: { value: 0, writable: true },
    _subscribe: { value: ConnectableObservable.prototype._subscribe },
    getSubject: { value: ConnectableObservable.prototype.getSubject },
    connect: { value: ConnectableObservable.prototype.connect },
    refCount: { value: ConnectableObservable.prototype.refCount }
};
var ConnectableSubscriber = (function (_super) {
    __extends(ConnectableSubscriber, _super);
    function ConnectableSubscriber(destination, connectable) {
        _super.call(this, destination);
        this.connectable = connectable;
    }
    ConnectableSubscriber.prototype._error = function (err) {
        this._unsubscribe();
        _super.prototype._error.call(this, err);
    };
    ConnectableSubscriber.prototype._complete = function () {
        this._unsubscribe();
        _super.prototype._complete.call(this);
    };
    ConnectableSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (connectable) {
            this.connectable = null;
            var connection = connectable._connection;
            connectable._refCount = 0;
            connectable._subject = null;
            connectable._connection = null;
            if (connection) {
                connection.unsubscribe();
            }
        }
    };
    return ConnectableSubscriber;
}(Subject_1.SubjectSubscriber));
var RefCountOperator = (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var RefCountSubscriber = (function (_super) {
    __extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        _super.call(this, destination);
        this.connectable = connectable;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        ///
        // Compare the local RefCountSubscriber's connection Subscription to the
        // connection Subscription on the shared ConnectableObservable. In cases
        // where the ConnectableObservable source synchronously emits values, and
        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,
        // execution continues to here before the RefCountOperator has a chance to
        // supply the RefCountSubscriber with the shared connection Subscription.
        // For example:
        // ```
        // Observable.range(0, 10)
        //   .publish()
        //   .refCount()
        //   .take(5)
        //   .subscribe();
        // ```
        // In order to account for this case, RefCountSubscriber should only dispose
        // the ConnectableObservable's shared connection Subscription if the
        // connection Subscription exists, *and* either:
        //   a. RefCountSubscriber doesn't have a reference to the shared connection
        //      Subscription yet, or,
        //   b. RefCountSubscriber's connection Subscription reference is identical
        //      to the shared connection Subscription
        ///
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=ConnectableObservable.js.map

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isArray_1 = __webpack_require__(11);
var isArrayLike_1 = __webpack_require__(63);
var isPromise_1 = __webpack_require__(65);
var PromiseObservable_1 = __webpack_require__(43);
var IteratorObservable_1 = __webpack_require__(219);
var ArrayObservable_1 = __webpack_require__(10);
var ArrayLikeObservable_1 = __webpack_require__(208);
var iterator_1 = __webpack_require__(18);
var Observable_1 = __webpack_require__(0);
var observeOn_1 = __webpack_require__(34);
var observable_1 = __webpack_require__(21);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var FromObservable = (function (_super) {
    __extends(FromObservable, _super);
    function FromObservable(ish, scheduler) {
        _super.call(this, null);
        this.ish = ish;
        this.scheduler = scheduler;
    }
    /**
     * Creates an Observable from an Array, an array-like object, a Promise, an
     * iterable object, or an Observable-like object.
     *
     * <span class="informal">Converts almost anything to an Observable.</span>
     *
     * <img src="./img/from.png" width="100%">
     *
     * Convert various other objects and data types into Observables. `from`
     * converts a Promise or an array-like or an
     * [iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)
     * object into an Observable that emits the items in that promise or array or
     * iterable. A String, in this context, is treated as an array of characters.
     * Observable-like objects (contains a function named with the ES2015 Symbol
     * for Observable) can also be converted through this operator.
     *
     * @example <caption>Converts an array to an Observable</caption>
     * var array = [10, 20, 30];
     * var result = Rx.Observable.from(array);
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following:
     * // 10 20 30
     *
     * @example <caption>Convert an infinite iterable (from a generator) to an Observable</caption>
     * function* generateDoubles(seed) {
     *   var i = seed;
     *   while (true) {
     *     yield i;
     *     i = 2 * i; // double it
     *   }
     * }
     *
     * var iterator = generateDoubles(3);
     * var result = Rx.Observable.from(iterator).take(10);
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following:
     * // 3 6 12 24 48 96 192 384 768 1536
     *
     * @see {@link create}
     * @see {@link fromEvent}
     * @see {@link fromEventPattern}
     * @see {@link fromPromise}
     *
     * @param {ObservableInput<T>} ish A subscribable object, a Promise, an
     * Observable-like, an Array, an iterable or an array-like object to be
     * converted.
     * @param {Scheduler} [scheduler] The scheduler on which to schedule the
     * emissions of values.
     * @return {Observable<T>} The Observable whose values are originally from the
     * input object that was converted.
     * @static true
     * @name from
     * @owner Observable
     */
    FromObservable.create = function (ish, scheduler) {
        if (ish != null) {
            if (typeof ish[observable_1.$$observable] === 'function') {
                if (ish instanceof Observable_1.Observable && !scheduler) {
                    return ish;
                }
                return new FromObservable(ish, scheduler);
            }
            else if (isArray_1.isArray(ish)) {
                return new ArrayObservable_1.ArrayObservable(ish, scheduler);
            }
            else if (isPromise_1.isPromise(ish)) {
                return new PromiseObservable_1.PromiseObservable(ish, scheduler);
            }
            else if (typeof ish[iterator_1.$$iterator] === 'function' || typeof ish === 'string') {
                return new IteratorObservable_1.IteratorObservable(ish, scheduler);
            }
            else if (isArrayLike_1.isArrayLike(ish)) {
                return new ArrayLikeObservable_1.ArrayLikeObservable(ish, scheduler);
            }
        }
        throw new TypeError((ish !== null && typeof ish || ish) + ' is not observable');
    };
    FromObservable.prototype._subscribe = function (subscriber) {
        var ish = this.ish;
        var scheduler = this.scheduler;
        if (scheduler == null) {
            return ish[observable_1.$$observable]().subscribe(subscriber);
        }
        else {
            return ish[observable_1.$$observable]().subscribe(new observeOn_1.ObserveOnSubscriber(subscriber, scheduler, 0));
        }
    };
    return FromObservable;
}(Observable_1.Observable));
exports.FromObservable = FromObservable;
//# sourceMappingURL=FromObservable.js.map

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var root_1 = __webpack_require__(7);
var Observable_1 = __webpack_require__(0);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var PromiseObservable = (function (_super) {
    __extends(PromiseObservable, _super);
    function PromiseObservable(promise, scheduler) {
        _super.call(this);
        this.promise = promise;
        this.scheduler = scheduler;
    }
    /**
     * Converts a Promise to an Observable.
     *
     * <span class="informal">Returns an Observable that just emits the Promise's
     * resolved value, then completes.</span>
     *
     * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an
     * Observable. If the Promise resolves with a value, the output Observable
     * emits that resolved value as a `next`, and then completes. If the Promise
     * is rejected, then the output Observable emits the corresponding Error.
     *
     * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>
     * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     * @see {@link bindCallback}
     * @see {@link from}
     *
     * @param {Promise<T>} promise The promise to be converted.
     * @param {Scheduler} [scheduler] An optional IScheduler to use for scheduling
     * the delivery of the resolved value (or the rejection).
     * @return {Observable<T>} An Observable which wraps the Promise.
     * @static true
     * @name fromPromise
     * @owner Observable
     */
    PromiseObservable.create = function (promise, scheduler) {
        return new PromiseObservable(promise, scheduler);
    };
    PromiseObservable.prototype._subscribe = function (subscriber) {
        var _this = this;
        var promise = this.promise;
        var scheduler = this.scheduler;
        if (scheduler == null) {
            if (this._isScalar) {
                if (!subscriber.closed) {
                    subscriber.next(this.value);
                    subscriber.complete();
                }
            }
            else {
                promise.then(function (value) {
                    _this.value = value;
                    _this._isScalar = true;
                    if (!subscriber.closed) {
                        subscriber.next(value);
                        subscriber.complete();
                    }
                }, function (err) {
                    if (!subscriber.closed) {
                        subscriber.error(err);
                    }
                })
                    .then(null, function (err) {
                    // escape the promise trap, throw unhandled errors
                    root_1.root.setTimeout(function () { throw err; });
                });
            }
        }
        else {
            if (this._isScalar) {
                if (!subscriber.closed) {
                    return scheduler.schedule(dispatchNext, 0, { value: this.value, subscriber: subscriber });
                }
            }
            else {
                promise.then(function (value) {
                    _this.value = value;
                    _this._isScalar = true;
                    if (!subscriber.closed) {
                        subscriber.add(scheduler.schedule(dispatchNext, 0, { value: value, subscriber: subscriber }));
                    }
                }, function (err) {
                    if (!subscriber.closed) {
                        subscriber.add(scheduler.schedule(dispatchError, 0, { err: err, subscriber: subscriber }));
                    }
                })
                    .then(null, function (err) {
                    // escape the promise trap, throw unhandled errors
                    root_1.root.setTimeout(function () { throw err; });
                });
            }
        }
    };
    return PromiseObservable;
}(Observable_1.Observable));
exports.PromiseObservable = PromiseObservable;
function dispatchNext(arg) {
    var value = arg.value, subscriber = arg.subscriber;
    if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
    }
}
function dispatchError(arg) {
    var err = arg.err, subscriber = arg.subscriber;
    if (!subscriber.closed) {
        subscriber.error(err);
    }
}
//# sourceMappingURL=PromiseObservable.js.map

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var root_1 = __webpack_require__(7);
var tryCatch_1 = __webpack_require__(8);
var errorObject_1 = __webpack_require__(6);
var Observable_1 = __webpack_require__(0);
var Subscriber_1 = __webpack_require__(1);
var map_1 = __webpack_require__(33);
function getCORSRequest() {
    if (root_1.root.XMLHttpRequest) {
        return new root_1.root.XMLHttpRequest();
    }
    else if (!!root_1.root.XDomainRequest) {
        return new root_1.root.XDomainRequest();
    }
    else {
        throw new Error('CORS is not supported by your browser');
    }
}
function getXMLHttpRequest() {
    if (root_1.root.XMLHttpRequest) {
        return new root_1.root.XMLHttpRequest();
    }
    else {
        var progId = void 0;
        try {
            var progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'];
            for (var i = 0; i < 3; i++) {
                try {
                    progId = progIds[i];
                    if (new root_1.root.ActiveXObject(progId)) {
                        break;
                    }
                }
                catch (e) {
                }
            }
            return new root_1.root.ActiveXObject(progId);
        }
        catch (e) {
            throw new Error('XMLHttpRequest is not supported by your browser');
        }
    }
}
function ajaxGet(url, headers) {
    if (headers === void 0) { headers = null; }
    return new AjaxObservable({ method: 'GET', url: url, headers: headers });
}
exports.ajaxGet = ajaxGet;
;
function ajaxPost(url, body, headers) {
    return new AjaxObservable({ method: 'POST', url: url, body: body, headers: headers });
}
exports.ajaxPost = ajaxPost;
;
function ajaxDelete(url, headers) {
    return new AjaxObservable({ method: 'DELETE', url: url, headers: headers });
}
exports.ajaxDelete = ajaxDelete;
;
function ajaxPut(url, body, headers) {
    return new AjaxObservable({ method: 'PUT', url: url, body: body, headers: headers });
}
exports.ajaxPut = ajaxPut;
;
function ajaxPatch(url, body, headers) {
    return new AjaxObservable({ method: 'PATCH', url: url, body: body, headers: headers });
}
exports.ajaxPatch = ajaxPatch;
;
function ajaxGetJSON(url, headers) {
    return new AjaxObservable({ method: 'GET', url: url, responseType: 'json', headers: headers })
        .lift(new map_1.MapOperator(function (x, index) { return x.response; }, null));
}
exports.ajaxGetJSON = ajaxGetJSON;
;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var AjaxObservable = (function (_super) {
    __extends(AjaxObservable, _super);
    function AjaxObservable(urlOrRequest) {
        _super.call(this);
        var request = {
            async: true,
            createXHR: function () {
                return this.crossDomain ? getCORSRequest.call(this) : getXMLHttpRequest();
            },
            crossDomain: false,
            withCredentials: false,
            headers: {},
            method: 'GET',
            responseType: 'json',
            timeout: 0
        };
        if (typeof urlOrRequest === 'string') {
            request.url = urlOrRequest;
        }
        else {
            for (var prop in urlOrRequest) {
                if (urlOrRequest.hasOwnProperty(prop)) {
                    request[prop] = urlOrRequest[prop];
                }
            }
        }
        this.request = request;
    }
    AjaxObservable.prototype._subscribe = function (subscriber) {
        return new AjaxSubscriber(subscriber, this.request);
    };
    /**
     * Creates an observable for an Ajax request with either a request object with
     * url, headers, etc or a string for a URL.
     *
     * @example
     * source = Rx.Observable.ajax('/products');
     * source = Rx.Observable.ajax({ url: 'products', method: 'GET' });
     *
     * @param {string|Object} request Can be one of the following:
     *   A string of the URL to make the Ajax call.
     *   An object with the following properties
     *   - url: URL of the request
     *   - body: The body of the request
     *   - method: Method of the request, such as GET, POST, PUT, PATCH, DELETE
     *   - async: Whether the request is async
     *   - headers: Optional headers
     *   - crossDomain: true if a cross domain request, else false
     *   - createXHR: a function to override if you need to use an alternate
     *   XMLHttpRequest implementation.
     *   - resultSelector: a function to use to alter the output value type of
     *   the Observable. Gets {@link AjaxResponse} as an argument.
     * @return {Observable} An observable sequence containing the XMLHttpRequest.
     * @static true
     * @name ajax
     * @owner Observable
    */
    AjaxObservable.create = (function () {
        var create = function (urlOrRequest) {
            return new AjaxObservable(urlOrRequest);
        };
        create.get = ajaxGet;
        create.post = ajaxPost;
        create.delete = ajaxDelete;
        create.put = ajaxPut;
        create.patch = ajaxPatch;
        create.getJSON = ajaxGetJSON;
        return create;
    })();
    return AjaxObservable;
}(Observable_1.Observable));
exports.AjaxObservable = AjaxObservable;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AjaxSubscriber = (function (_super) {
    __extends(AjaxSubscriber, _super);
    function AjaxSubscriber(destination, request) {
        _super.call(this, destination);
        this.request = request;
        this.done = false;
        var headers = request.headers = request.headers || {};
        // force CORS if requested
        if (!request.crossDomain && !headers['X-Requested-With']) {
            headers['X-Requested-With'] = 'XMLHttpRequest';
        }
        // ensure content type is set
        if (!('Content-Type' in headers) && !(root_1.root.FormData && request.body instanceof root_1.root.FormData) && typeof request.body !== 'undefined') {
            headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';
        }
        // properly serialize body
        request.body = this.serializeBody(request.body, request.headers['Content-Type']);
        this.send();
    }
    AjaxSubscriber.prototype.next = function (e) {
        this.done = true;
        var _a = this, xhr = _a.xhr, request = _a.request, destination = _a.destination;
        var response = new AjaxResponse(e, xhr, request);
        destination.next(response);
    };
    AjaxSubscriber.prototype.send = function () {
        var _a = this, request = _a.request, _b = _a.request, user = _b.user, method = _b.method, url = _b.url, async = _b.async, password = _b.password, headers = _b.headers, body = _b.body;
        var createXHR = request.createXHR;
        var xhr = tryCatch_1.tryCatch(createXHR).call(request);
        if (xhr === errorObject_1.errorObject) {
            this.error(errorObject_1.errorObject.e);
        }
        else {
            this.xhr = xhr;
            // set up the events before open XHR
            // https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest
            // You need to add the event listeners before calling open() on the request.
            // Otherwise the progress events will not fire.
            this.setupEvents(xhr, request);
            // open XHR
            var result = void 0;
            if (user) {
                result = tryCatch_1.tryCatch(xhr.open).call(xhr, method, url, async, user, password);
            }
            else {
                result = tryCatch_1.tryCatch(xhr.open).call(xhr, method, url, async);
            }
            if (result === errorObject_1.errorObject) {
                this.error(errorObject_1.errorObject.e);
                return null;
            }
            // timeout, responseType and withCredentials can be set once the XHR is open
            xhr.timeout = request.timeout;
            xhr.responseType = request.responseType;
            if ('withCredentials' in xhr) {
                xhr.withCredentials = !!request.withCredentials;
            }
            // set headers
            this.setHeaders(xhr, headers);
            // finally send the request
            result = body ? tryCatch_1.tryCatch(xhr.send).call(xhr, body) : tryCatch_1.tryCatch(xhr.send).call(xhr);
            if (result === errorObject_1.errorObject) {
                this.error(errorObject_1.errorObject.e);
                return null;
            }
        }
        return xhr;
    };
    AjaxSubscriber.prototype.serializeBody = function (body, contentType) {
        if (!body || typeof body === 'string') {
            return body;
        }
        else if (root_1.root.FormData && body instanceof root_1.root.FormData) {
            return body;
        }
        if (contentType) {
            var splitIndex = contentType.indexOf(';');
            if (splitIndex !== -1) {
                contentType = contentType.substring(0, splitIndex);
            }
        }
        switch (contentType) {
            case 'application/x-www-form-urlencoded':
                return Object.keys(body).map(function (key) { return (encodeURI(key) + "=" + encodeURI(body[key])); }).join('&');
            case 'application/json':
                return JSON.stringify(body);
            default:
                return body;
        }
    };
    AjaxSubscriber.prototype.setHeaders = function (xhr, headers) {
        for (var key in headers) {
            if (headers.hasOwnProperty(key)) {
                xhr.setRequestHeader(key, headers[key]);
            }
        }
    };
    AjaxSubscriber.prototype.setupEvents = function (xhr, request) {
        var progressSubscriber = request.progressSubscriber;
        function xhrTimeout(e) {
            var _a = xhrTimeout, subscriber = _a.subscriber, progressSubscriber = _a.progressSubscriber, request = _a.request;
            if (progressSubscriber) {
                progressSubscriber.error(e);
            }
            subscriber.error(new AjaxTimeoutError(this, request)); //TODO: Make betterer.
        }
        ;
        xhr.ontimeout = xhrTimeout;
        xhrTimeout.request = request;
        xhrTimeout.subscriber = this;
        xhrTimeout.progressSubscriber = progressSubscriber;
        if (xhr.upload && 'withCredentials' in xhr) {
            if (progressSubscriber) {
                var xhrProgress_1;
                xhrProgress_1 = function (e) {
                    var progressSubscriber = xhrProgress_1.progressSubscriber;
                    progressSubscriber.next(e);
                };
                if (root_1.root.XDomainRequest) {
                    xhr.onprogress = xhrProgress_1;
                }
                else {
                    xhr.upload.onprogress = xhrProgress_1;
                }
                xhrProgress_1.progressSubscriber = progressSubscriber;
            }
            var xhrError_1;
            xhrError_1 = function (e) {
                var _a = xhrError_1, progressSubscriber = _a.progressSubscriber, subscriber = _a.subscriber, request = _a.request;
                if (progressSubscriber) {
                    progressSubscriber.error(e);
                }
                subscriber.error(new AjaxError('ajax error', this, request));
            };
            xhr.onerror = xhrError_1;
            xhrError_1.request = request;
            xhrError_1.subscriber = this;
            xhrError_1.progressSubscriber = progressSubscriber;
        }
        function xhrReadyStateChange(e) {
            var _a = xhrReadyStateChange, subscriber = _a.subscriber, progressSubscriber = _a.progressSubscriber, request = _a.request;
            if (this.readyState === 4) {
                // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)
                var status_1 = this.status === 1223 ? 204 : this.status;
                var response = (this.responseType === 'text' ? (this.response || this.responseText) : this.response);
                // fix status code when it is 0 (0 status is undocumented).
                // Occurs when accessing file resources or on Android 4.1 stock browser
                // while retrieving files from application cache.
                if (status_1 === 0) {
                    status_1 = response ? 200 : 0;
                }
                if (200 <= status_1 && status_1 < 300) {
                    if (progressSubscriber) {
                        progressSubscriber.complete();
                    }
                    subscriber.next(e);
                    subscriber.complete();
                }
                else {
                    if (progressSubscriber) {
                        progressSubscriber.error(e);
                    }
                    subscriber.error(new AjaxError('ajax error ' + status_1, this, request));
                }
            }
        }
        ;
        xhr.onreadystatechange = xhrReadyStateChange;
        xhrReadyStateChange.subscriber = this;
        xhrReadyStateChange.progressSubscriber = progressSubscriber;
        xhrReadyStateChange.request = request;
    };
    AjaxSubscriber.prototype.unsubscribe = function () {
        var _a = this, done = _a.done, xhr = _a.xhr;
        if (!done && xhr && xhr.readyState !== 4 && typeof xhr.abort === 'function') {
            xhr.abort();
        }
        _super.prototype.unsubscribe.call(this);
    };
    return AjaxSubscriber;
}(Subscriber_1.Subscriber));
exports.AjaxSubscriber = AjaxSubscriber;
/**
 * A normalized AJAX response.
 *
 * @see {@link ajax}
 *
 * @class AjaxResponse
 */
var AjaxResponse = (function () {
    function AjaxResponse(originalEvent, xhr, request) {
        this.originalEvent = originalEvent;
        this.xhr = xhr;
        this.request = request;
        this.status = xhr.status;
        this.responseType = xhr.responseType || request.responseType;
        switch (this.responseType) {
            case 'json':
                if ('response' in xhr) {
                    //IE does not support json as responseType, parse it internally
                    this.response = xhr.responseType ? xhr.response : JSON.parse(xhr.response || xhr.responseText || 'null');
                }
                else {
                    this.response = JSON.parse(xhr.responseText || 'null');
                }
                break;
            case 'xml':
                this.response = xhr.responseXML;
                break;
            case 'text':
            default:
                this.response = ('response' in xhr) ? xhr.response : xhr.responseText;
                break;
        }
    }
    return AjaxResponse;
}());
exports.AjaxResponse = AjaxResponse;
/**
 * A normalized AJAX error.
 *
 * @see {@link ajax}
 *
 * @class AjaxError
 */
var AjaxError = (function (_super) {
    __extends(AjaxError, _super);
    function AjaxError(message, xhr, request) {
        _super.call(this, message);
        this.message = message;
        this.xhr = xhr;
        this.request = request;
        this.status = xhr.status;
    }
    return AjaxError;
}(Error));
exports.AjaxError = AjaxError;
/**
 * @see {@link ajax}
 *
 * @class AjaxTimeoutError
 */
var AjaxTimeoutError = (function (_super) {
    __extends(AjaxTimeoutError, _super);
    function AjaxTimeoutError(xhr, request) {
        _super.call(this, 'ajax timeout', xhr, request);
    }
    return AjaxTimeoutError;
}(AjaxError));
exports.AjaxTimeoutError = AjaxTimeoutError;
//# sourceMappingURL=AjaxObservable.js.map

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(1);
var tryCatch_1 = __webpack_require__(8);
var errorObject_1 = __webpack_require__(6);
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.
 *
 * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
 *
 * If a comparator function is not provided, an equality check is used by default.
 *
 * @example <caption>A simple example with numbers</caption>
 * Observable.of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4)
 *   .distinctUntilChanged()
 *   .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4
 *
 * @example <caption>An example using a compare function</caption>
 * interface Person {
 *    age: number,
 *    name: string
 * }
 *
 * Observable.of<Person>(
 *     { age: 4, name: 'Foo'},
 *     { age: 7, name: 'Bar'},
 *     { age: 5, name: 'Foo'})
 *     { age: 6, name: 'Foo'})
 *     .distinctUntilChanged((p: Person, q: Person) => p.name === q.name)
 *     .subscribe(x => console.log(x));
 *
 * // displays:
 * // { age: 4, name: 'Foo' }
 * // { age: 7, name: 'Bar' }
 * // { age: 5, name: 'Foo' }
 *
 * @see {@link distinct}
 * @see {@link distinctUntilKeyChanged}
 *
 * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.
 * @return {Observable} An Observable that emits items from the source Observable with distinct values.
 * @method distinctUntilChanged
 * @owner Observable
 */
function distinctUntilChanged(compare, keySelector) {
    return this.lift(new DistinctUntilChangedOperator(compare, keySelector));
}
exports.distinctUntilChanged = distinctUntilChanged;
var DistinctUntilChangedOperator = (function () {
    function DistinctUntilChangedOperator(compare, keySelector) {
        this.compare = compare;
        this.keySelector = keySelector;
    }
    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
    };
    return DistinctUntilChangedOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DistinctUntilChangedSubscriber = (function (_super) {
    __extends(DistinctUntilChangedSubscriber, _super);
    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
        _super.call(this, destination);
        this.keySelector = keySelector;
        this.hasKey = false;
        if (typeof compare === 'function') {
            this.compare = compare;
        }
    }
    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
        return x === y;
    };
    DistinctUntilChangedSubscriber.prototype._next = function (value) {
        var keySelector = this.keySelector;
        var key = value;
        if (keySelector) {
            key = tryCatch_1.tryCatch(this.keySelector)(value);
            if (key === errorObject_1.errorObject) {
                return this.destination.error(errorObject_1.errorObject.e);
            }
        }
        var result = false;
        if (this.hasKey) {
            result = tryCatch_1.tryCatch(this.compare)(this.key, key);
            if (result === errorObject_1.errorObject) {
                return this.destination.error(errorObject_1.errorObject.e);
            }
        }
        else {
            this.hasKey = true;
        }
        if (Boolean(result) === false) {
            this.key = key;
            this.destination.next(value);
        }
    };
    return DistinctUntilChangedSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=distinctUntilChanged.js.map

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(1);
/* tslint:enable:max-line-length */
/**
 * Filter items emitted by the source Observable by only emitting those that
 * satisfy a specified predicate.
 *
 * <span class="informal">Like
 * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),
 * it only emits a value from the source if it passes a criterion function.</span>
 *
 * <img src="./img/filter.png" width="100%">
 *
 * Similar to the well-known `Array.prototype.filter` method, this operator
 * takes values from the source Observable, passes them through a `predicate`
 * function and only emits those values that yielded `true`.
 *
 * @example <caption>Emit only click events whose target was a DIV element</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');
 * clicksOnDivs.subscribe(x => console.log(x));
 *
 * @see {@link distinct}
 * @see {@link distinctUntilChanged}
 * @see {@link distinctUntilKeyChanged}
 * @see {@link ignoreElements}
 * @see {@link partition}
 * @see {@link skip}
 *
 * @param {function(value: T, index: number): boolean} predicate A function that
 * evaluates each value emitted by the source Observable. If it returns `true`,
 * the value is emitted, if `false` the value is not passed to the output
 * Observable. The `index` parameter is the number `i` for the i-th source
 * emission that has happened since the subscription, starting from the number
 * `0`.
 * @param {any} [thisArg] An optional argument to determine the value of `this`
 * in the `predicate` function.
 * @return {Observable} An Observable of values from the source that were
 * allowed by the `predicate` function.
 * @method filter
 * @owner Observable
 */
function filter(predicate, thisArg) {
    return this.lift(new FilterOperator(predicate, thisArg));
}
exports.filter = filter;
var FilterOperator = (function () {
    function FilterOperator(predicate, thisArg) {
        this.predicate = predicate;
        this.thisArg = thisArg;
    }
    FilterOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
    };
    return FilterOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FilterSubscriber = (function (_super) {
    __extends(FilterSubscriber, _super);
    function FilterSubscriber(destination, predicate, thisArg) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.count = 0;
        this.predicate = predicate;
    }
    // the try catch block below is left specifically for
    // optimization and perf reasons. a tryCatcher is not necessary here.
    FilterSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.predicate.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.destination.next(value);
        }
    };
    return FilterSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=filter.js.map

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(1);
/* tslint:enable:max-line-length */
/**
 * Emits only the first value emitted by the source Observable that meets some
 * condition.
 *
 * <span class="informal">Finds the first value that passes some test and emits
 * that.</span>
 *
 * <img src="./img/find.png" width="100%">
 *
 * `find` searches for the first item in the source Observable that matches the
 * specified condition embodied by the `predicate`, and returns the first
 * occurrence in the source. Unlike {@link first}, the `predicate` is required
 * in `find`, and does not emit an error if a valid value is not found.
 *
 * @example <caption>Find and emit the first click that happens on a DIV element</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.find(ev => ev.target.tagName === 'DIV');
 * result.subscribe(x => console.log(x));
 *
 * @see {@link filter}
 * @see {@link first}
 * @see {@link findIndex}
 * @see {@link take}
 *
 * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate
 * A function called with each item to test for condition matching.
 * @param {any} [thisArg] An optional argument to determine the value of `this`
 * in the `predicate` function.
 * @return {Observable<T>} An Observable of the first item that matches the
 * condition.
 * @method find
 * @owner Observable
 */
function find(predicate, thisArg) {
    if (typeof predicate !== 'function') {
        throw new TypeError('predicate is not a function');
    }
    return this.lift(new FindValueOperator(predicate, this, false, thisArg));
}
exports.find = find;
var FindValueOperator = (function () {
    function FindValueOperator(predicate, source, yieldIndex, thisArg) {
        this.predicate = predicate;
        this.source = source;
        this.yieldIndex = yieldIndex;
        this.thisArg = thisArg;
    }
    FindValueOperator.prototype.call = function (observer, source) {
        return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));
    };
    return FindValueOperator;
}());
exports.FindValueOperator = FindValueOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FindValueSubscriber = (function (_super) {
    __extends(FindValueSubscriber, _super);
    function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.source = source;
        this.yieldIndex = yieldIndex;
        this.thisArg = thisArg;
        this.index = 0;
    }
    FindValueSubscriber.prototype.notifyComplete = function (value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
    };
    FindValueSubscriber.prototype._next = function (value) {
        var _a = this, predicate = _a.predicate, thisArg = _a.thisArg;
        var index = this.index++;
        try {
            var result = predicate.call(thisArg || this, value, index, this.source);
            if (result) {
                this.notifyComplete(this.yieldIndex ? index : value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    FindValueSubscriber.prototype._complete = function () {
        this.notifyComplete(this.yieldIndex ? -1 : undefined);
    };
    return FindValueSubscriber;
}(Subscriber_1.Subscriber));
exports.FindValueSubscriber = FindValueSubscriber;
//# sourceMappingURL=find.js.map

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var ArrayObservable_1 = __webpack_require__(10);
var mergeAll_1 = __webpack_require__(20);
var isScheduler_1 = __webpack_require__(12);
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which concurrently emits all values from every
 * given input Observable.
 *
 * <span class="informal">Flattens multiple Observables together by blending
 * their values into one Observable.</span>
 *
 * <img src="./img/merge.png" width="100%">
 *
 * `merge` subscribes to each given input Observable (either the source or an
 * Observable given as argument), and simply forwards (without doing any
 * transformation) all the values from all the input Observables to the output
 * Observable. The output Observable only completes once all input Observables
 * have completed. Any error delivered by an input Observable will be immediately
 * emitted on the output Observable.
 *
 * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var timer = Rx.Observable.interval(1000);
 * var clicksOrTimer = clicks.merge(timer);
 * clicksOrTimer.subscribe(x => console.log(x));
 *
 * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var concurrent = 2; // the argument
 * var merged = timer1.merge(timer2, timer3, concurrent);
 * merged.subscribe(x => console.log(x));
 *
 * @see {@link mergeAll}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 *
 * @param {ObservableInput} other An input Observable to merge with the source
 * Observable. More than one input Observables may be given as argument.
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @param {Scheduler} [scheduler=null] The IScheduler to use for managing
 * concurrency of input Observables.
 * @return {Observable} An Observable that emits items that are the result of
 * every input Observable.
 * @method merge
 * @owner Observable
 */
function merge() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return this.lift.call(mergeStatic.apply(void 0, [this].concat(observables)));
}
exports.merge = merge;
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which concurrently emits all values from every
 * given input Observable.
 *
 * <span class="informal">Flattens multiple Observables together by blending
 * their values into one Observable.</span>
 *
 * <img src="./img/merge.png" width="100%">
 *
 * `merge` subscribes to each given input Observable (as arguments), and simply
 * forwards (without doing any transformation) all the values from all the input
 * Observables to the output Observable. The output Observable only completes
 * once all input Observables have completed. Any error delivered by an input
 * Observable will be immediately emitted on the output Observable.
 *
 * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var timer = Rx.Observable.interval(1000);
 * var clicksOrTimer = Rx.Observable.merge(clicks, timer);
 * clicksOrTimer.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // timer will emit ascending values, one every second(1000ms) to console
 * // clicks logs MouseEvents to console everytime the "document" is clicked
 * // Since the two streams are merged you see these happening
 * // as they occur.
 *
 * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var concurrent = 2; // the argument
 * var merged = Rx.Observable.merge(timer1, timer2, timer3, concurrent);
 * merged.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // - First timer1 and timer2 will run concurrently
 * // - timer1 will emit a value every 1000ms for 10 iterations
 * // - timer2 will emit a value every 2000ms for 6 iterations
 * // - after timer1 hits it's max iteration, timer2 will
 * //   continue, and timer3 will start to run concurrently with timer2
 * // - when timer2 hits it's max iteration it terminates, and
 * //   timer3 will continue to emit a value every 500ms until it is complete
 *
 * @see {@link mergeAll}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 *
 * @param {...ObservableInput} observables Input Observables to merge together.
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @param {Scheduler} [scheduler=null] The IScheduler to use for managing
 * concurrency of input Observables.
 * @return {Observable} an Observable that emits items that are the result of
 * every input Observable.
 * @static true
 * @name merge
 * @owner Observable
 */
function mergeStatic() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var concurrent = Number.POSITIVE_INFINITY;
    var scheduler = null;
    var last = observables[observables.length - 1];
    if (isScheduler_1.isScheduler(last)) {
        scheduler = observables.pop();
        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
            concurrent = observables.pop();
        }
    }
    else if (typeof last === 'number') {
        concurrent = observables.pop();
    }
    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable_1.Observable) {
        return observables[0];
    }
    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(concurrent));
}
exports.mergeStatic = mergeStatic;
//# sourceMappingURL=merge.js.map

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var subscribeToResult_1 = __webpack_require__(3);
var OuterSubscriber_1 = __webpack_require__(2);
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link mergeAll}.</span>
 *
 * <img src="./img/mergeMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an Observable, and then merging those resulting Observables and
 * emitting the results of this merger.
 *
 * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>
 * var letters = Rx.Observable.of('a', 'b', 'c');
 * var result = letters.mergeMap(x =>
 *   Rx.Observable.interval(1000).map(i => x+i)
 * );
 * result.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // a0
 * // b0
 * // c0
 * // a1
 * // b1
 * // c1
 * // continues to list a,b,c with respective ascending integers
 *
 * @see {@link concatMap}
 * @see {@link exhaustMap}
 * @see {@link merge}
 * @see {@link mergeAll}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 * @see {@link switchMap}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and merging the results of the Observables obtained
 * from this transformation.
 * @method mergeMap
 * @owner Observable
 */
function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
        resultSelector = null;
    }
    return this.lift(new MergeMapOperator(project, resultSelector, concurrent));
}
exports.mergeMap = mergeMap;
var MergeMapOperator = (function () {
    function MergeMapOperator(project, resultSelector, concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        this.project = project;
        this.resultSelector = resultSelector;
        this.concurrent = concurrent;
    }
    MergeMapOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.resultSelector, this.concurrent));
    };
    return MergeMapOperator;
}());
exports.MergeMapOperator = MergeMapOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MergeMapSubscriber = (function (_super) {
    __extends(MergeMapSubscriber, _super);
    function MergeMapSubscriber(destination, project, resultSelector, concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        _super.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.concurrent = concurrent;
        this.hasCompleted = false;
        this.buffer = [];
        this.active = 0;
        this.index = 0;
    }
    MergeMapSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            this._tryNext(value);
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeMapSubscriber.prototype._tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.active++;
        this._innerSub(result, value, index);
    };
    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));
    };
    MergeMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
    };
    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (this.resultSelector) {
            this._notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);
        }
        else {
            this.destination.next(innerValue);
        }
    };
    MergeMapSubscriber.prototype._notifyResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {
        var result;
        try {
            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.MergeMapSubscriber = MergeMapSubscriber;
//# sourceMappingURL=mergeMap.js.map

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(2);
var subscribeToResult_1 = __webpack_require__(3);
/* tslint:enable:max-line-length */
/**
 * Projects each source value to the same Observable which is merged multiple
 * times in the output Observable.
 *
 * <span class="informal">It's like {@link mergeMap}, but maps each value always
 * to the same inner Observable.</span>
 *
 * <img src="./img/mergeMapTo.png" width="100%">
 *
 * Maps each source value to the given Observable `innerObservable` regardless
 * of the source value, and then merges those resulting Observables into one
 * single Observable, which is the output Observable.
 *
 * @example <caption>For each click event, start an interval Observable ticking every 1 second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.mergeMapTo(Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMapTo}
 * @see {@link merge}
 * @see {@link mergeAll}
 * @see {@link mergeMap}
 * @see {@link mergeScan}
 * @see {@link switchMapTo}
 *
 * @param {ObservableInput} innerObservable An Observable to replace each value from
 * the source Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits items from the given
 * `innerObservable` (and optionally transformed through `resultSelector`) every
 * time a value is emitted on the source Observable.
 * @method mergeMapTo
 * @owner Observable
 */
function mergeMapTo(innerObservable, resultSelector, concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
        resultSelector = null;
    }
    return this.lift(new MergeMapToOperator(innerObservable, resultSelector, concurrent));
}
exports.mergeMapTo = mergeMapTo;
// TODO: Figure out correct signature here: an Operator<Observable<T>, R>
//       needs to implement call(observer: Subscriber<R>): Subscriber<Observable<T>>
var MergeMapToOperator = (function () {
    function MergeMapToOperator(ish, resultSelector, concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        this.ish = ish;
        this.resultSelector = resultSelector;
        this.concurrent = concurrent;
    }
    MergeMapToOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeMapToSubscriber(observer, this.ish, this.resultSelector, this.concurrent));
    };
    return MergeMapToOperator;
}());
exports.MergeMapToOperator = MergeMapToOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MergeMapToSubscriber = (function (_super) {
    __extends(MergeMapToSubscriber, _super);
    function MergeMapToSubscriber(destination, ish, resultSelector, concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        _super.call(this, destination);
        this.ish = ish;
        this.resultSelector = resultSelector;
        this.concurrent = concurrent;
        this.hasCompleted = false;
        this.buffer = [];
        this.active = 0;
        this.index = 0;
    }
    MergeMapToSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            var resultSelector = this.resultSelector;
            var index = this.index++;
            var ish = this.ish;
            var destination = this.destination;
            this.active++;
            this._innerSub(ish, destination, resultSelector, value, index);
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeMapToSubscriber.prototype._innerSub = function (ish, destination, resultSelector, value, index) {
        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));
    };
    MergeMapToSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
    };
    MergeMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
        if (resultSelector) {
            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);
        }
        else {
            destination.next(innerValue);
        }
    };
    MergeMapToSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {
        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
        var result;
        try {
            result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        destination.next(result);
    };
    MergeMapToSubscriber.prototype.notifyError = function (err) {
        this.destination.error(err);
    };
    MergeMapToSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeMapToSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.MergeMapToSubscriber = MergeMapToSubscriber;
//# sourceMappingURL=mergeMapTo.js.map

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var FromObservable_1 = __webpack_require__(42);
var isArray_1 = __webpack_require__(11);
var OuterSubscriber_1 = __webpack_require__(2);
var subscribeToResult_1 = __webpack_require__(3);
/* tslint:enable:max-line-length */
function onErrorResumeNext() {
    var nextSources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        nextSources[_i - 0] = arguments[_i];
    }
    if (nextSources.length === 1 && isArray_1.isArray(nextSources[0])) {
        nextSources = nextSources[0];
    }
    return this.lift(new OnErrorResumeNextOperator(nextSources));
}
exports.onErrorResumeNext = onErrorResumeNext;
/* tslint:enable:max-line-length */
function onErrorResumeNextStatic() {
    var nextSources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        nextSources[_i - 0] = arguments[_i];
    }
    var source = null;
    if (nextSources.length === 1 && isArray_1.isArray(nextSources[0])) {
        nextSources = nextSources[0];
    }
    source = nextSources.shift();
    return new FromObservable_1.FromObservable(source, null).lift(new OnErrorResumeNextOperator(nextSources));
}
exports.onErrorResumeNextStatic = onErrorResumeNextStatic;
var OnErrorResumeNextOperator = (function () {
    function OnErrorResumeNextOperator(nextSources) {
        this.nextSources = nextSources;
    }
    OnErrorResumeNextOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));
    };
    return OnErrorResumeNextOperator;
}());
var OnErrorResumeNextSubscriber = (function (_super) {
    __extends(OnErrorResumeNextSubscriber, _super);
    function OnErrorResumeNextSubscriber(destination, nextSources) {
        _super.call(this, destination);
        this.destination = destination;
        this.nextSources = nextSources;
    }
    OnErrorResumeNextSubscriber.prototype.notifyError = function (error, innerSub) {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype.notifyComplete = function (innerSub) {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype._error = function (err) {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype._complete = function () {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype.subscribeToNextSource = function () {
        var next = this.nextSources.shift();
        if (next) {
            this.add(subscribeToResult_1.subscribeToResult(this, next));
        }
        else {
            this.destination.complete();
        }
    };
    return OnErrorResumeNextSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=onErrorResumeNext.js.map

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isArray_1 = __webpack_require__(11);
var ArrayObservable_1 = __webpack_require__(10);
var OuterSubscriber_1 = __webpack_require__(2);
var subscribeToResult_1 = __webpack_require__(3);
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that mirrors the first source Observable to emit an item
 * from the combination of this Observable and supplied Observables.
 * @param {...Observables} ...observables Sources used to race for which Observable emits first.
 * @return {Observable} An Observable that mirrors the output of the first Observable to emit an item.
 * @method race
 * @owner Observable
 */
function race() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    // if the only argument is an array, it was most likely called with
    // `pair([obs1, obs2, ...])`
    if (observables.length === 1 && isArray_1.isArray(observables[0])) {
        observables = observables[0];
    }
    return this.lift.call(raceStatic.apply(void 0, [this].concat(observables)));
}
exports.race = race;
function raceStatic() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    // if the only argument is an array, it was most likely called with
    // `pair([obs1, obs2, ...])`
    if (observables.length === 1) {
        if (isArray_1.isArray(observables[0])) {
            observables = observables[0];
        }
        else {
            return observables[0];
        }
    }
    return new ArrayObservable_1.ArrayObservable(observables).lift(new RaceOperator());
}
exports.raceStatic = raceStatic;
var RaceOperator = (function () {
    function RaceOperator() {
    }
    RaceOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RaceSubscriber(subscriber));
    };
    return RaceOperator;
}());
exports.RaceOperator = RaceOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var RaceSubscriber = (function (_super) {
    __extends(RaceSubscriber, _super);
    function RaceSubscriber(destination) {
        _super.call(this, destination);
        this.hasFirst = false;
        this.observables = [];
        this.subscriptions = [];
    }
    RaceSubscriber.prototype._next = function (observable) {
        this.observables.push(observable);
    };
    RaceSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            for (var i = 0; i < len && !this.hasFirst; i++) {
                var observable = observables[i];
                var subscription = subscribeToResult_1.subscribeToResult(this, observable, observable, i);
                if (this.subscriptions) {
                    this.subscriptions.push(subscription);
                }
                this.add(subscription);
            }
            this.observables = null;
        }
    };
    RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (!this.hasFirst) {
            this.hasFirst = true;
            for (var i = 0; i < this.subscriptions.length; i++) {
                if (i !== outerIndex) {
                    var subscription = this.subscriptions[i];
                    subscription.unsubscribe();
                    this.remove(subscription);
                }
            }
            this.subscriptions = null;
        }
        this.destination.next(innerValue);
    };
    return RaceSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.RaceSubscriber = RaceSubscriber;
//# sourceMappingURL=race.js.map

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(1);
var async_1 = __webpack_require__(9);
/**
 * @param scheduler
 * @return {Observable<TimeInterval<any>>|WebSocketSubject<T>|Observable<T>}
 * @method timeInterval
 * @owner Observable
 */
function timeInterval(scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return this.lift(new TimeIntervalOperator(scheduler));
}
exports.timeInterval = timeInterval;
var TimeInterval = (function () {
    function TimeInterval(value, interval) {
        this.value = value;
        this.interval = interval;
    }
    return TimeInterval;
}());
exports.TimeInterval = TimeInterval;
;
var TimeIntervalOperator = (function () {
    function TimeIntervalOperator(scheduler) {
        this.scheduler = scheduler;
    }
    TimeIntervalOperator.prototype.call = function (observer, source) {
        return source.subscribe(new TimeIntervalSubscriber(observer, this.scheduler));
    };
    return TimeIntervalOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TimeIntervalSubscriber = (function (_super) {
    __extends(TimeIntervalSubscriber, _super);
    function TimeIntervalSubscriber(destination, scheduler) {
        _super.call(this, destination);
        this.scheduler = scheduler;
        this.lastTime = 0;
        this.lastTime = scheduler.now();
    }
    TimeIntervalSubscriber.prototype._next = function (value) {
        var now = this.scheduler.now();
        var span = now - this.lastTime;
        this.lastTime = now;
        this.destination.next(new TimeInterval(value, span));
    };
    return TimeIntervalSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=timeInterval.js.map

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(1);
var async_1 = __webpack_require__(9);
/**
 * @param scheduler
 * @return {Observable<Timestamp<any>>|WebSocketSubject<T>|Observable<T>}
 * @method timestamp
 * @owner Observable
 */
function timestamp(scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return this.lift(new TimestampOperator(scheduler));
}
exports.timestamp = timestamp;
var Timestamp = (function () {
    function Timestamp(value, timestamp) {
        this.value = value;
        this.timestamp = timestamp;
    }
    return Timestamp;
}());
exports.Timestamp = Timestamp;
;
var TimestampOperator = (function () {
    function TimestampOperator(scheduler) {
        this.scheduler = scheduler;
    }
    TimestampOperator.prototype.call = function (observer, source) {
        return source.subscribe(new TimestampSubscriber(observer, this.scheduler));
    };
    return TimestampOperator;
}());
var TimestampSubscriber = (function (_super) {
    __extends(TimestampSubscriber, _super);
    function TimestampSubscriber(destination, scheduler) {
        _super.call(this, destination);
        this.scheduler = scheduler;
    }
    TimestampSubscriber.prototype._next = function (value) {
        var now = this.scheduler.now();
        this.destination.next(new Timestamp(value, now));
    };
    return TimestampSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=timestamp.js.map

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var AsyncAction_1 = __webpack_require__(16);
var AsyncScheduler_1 = __webpack_require__(17);
var VirtualTimeScheduler = (function (_super) {
    __extends(VirtualTimeScheduler, _super);
    function VirtualTimeScheduler(SchedulerAction, maxFrames) {
        var _this = this;
        if (SchedulerAction === void 0) { SchedulerAction = VirtualAction; }
        if (maxFrames === void 0) { maxFrames = Number.POSITIVE_INFINITY; }
        _super.call(this, SchedulerAction, function () { return _this.frame; });
        this.maxFrames = maxFrames;
        this.frame = 0;
        this.index = -1;
    }
    /**
     * Prompt the Scheduler to execute all of its queued actions, therefore
     * clearing its queue.
     * @return {void}
     */
    VirtualTimeScheduler.prototype.flush = function () {
        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
        var error, action;
        while ((action = actions.shift()) && (this.frame = action.delay) <= maxFrames) {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        }
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    VirtualTimeScheduler.frameTimeFactor = 10;
    return VirtualTimeScheduler;
}(AsyncScheduler_1.AsyncScheduler));
exports.VirtualTimeScheduler = VirtualTimeScheduler;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var VirtualAction = (function (_super) {
    __extends(VirtualAction, _super);
    function VirtualAction(scheduler, work, index) {
        if (index === void 0) { index = scheduler.index += 1; }
        _super.call(this, scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
        this.index = index;
        this.index = scheduler.index = index;
    }
    VirtualAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        if (!this.id) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        // If an action is rescheduled, we save allocations by mutating its state,
        // pushing it to the end of the scheduler queue, and recycling the action.
        // But since the VirtualTimeScheduler is used for testing, VirtualActions
        // must be immutable so they can be inspected later.
        var action = new VirtualAction(this.scheduler, this.work);
        this.add(action);
        return action.schedule(state, delay);
    };
    VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        this.delay = scheduler.frame + delay;
        var actions = scheduler.actions;
        actions.push(this);
        actions.sort(VirtualAction.sortActions);
        return true;
    };
    VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        return undefined;
    };
    VirtualAction.sortActions = function (a, b) {
        if (a.delay === b.delay) {
            if (a.index === b.index) {
                return 0;
            }
            else if (a.index > b.index) {
                return 1;
            }
            else {
                return -1;
            }
        }
        else if (a.delay > b.delay) {
            return 1;
        }
        else {
            return -1;
        }
    };
    return VirtualAction;
}(AsyncAction_1.AsyncAction));
exports.VirtualAction = VirtualAction;
//# sourceMappingURL=VirtualTimeScheduler.js.map

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var AsapAction_1 = __webpack_require__(336);
var AsapScheduler_1 = __webpack_require__(337);
/**
 *
 * Asap Scheduler
 *
 * <span class="informal">Perform task as fast as it can be performed asynchronously</span>
 *
 * `asap` scheduler behaves the same as {@link async} scheduler when you use it to delay task
 * in time. If however you set delay to `0`, `asap` will wait for current synchronously executing
 * code to end and then it will try to execute given task as fast as possible.
 *
 * `asap` scheduler will do its best to minimize time between end of currently executing code
 * and start of scheduled task. This makes it best candidate for performing so called "deferring".
 * Traditionally this was achieved by calling `setTimeout(deferredTask, 0)`, but that technique involves
 * some (although minimal) unwanted delay.
 *
 * Note that using `asap` scheduler does not necessarily mean that your task will be first to process
 * after currently executing code. In particular, if some task was also scheduled with `asap` before,
 * that task will execute first. That being said, if you need to schedule task asynchronously, but
 * as soon as possible, `asap` scheduler is your best bet.
 *
 * @example <caption>Compare async and asap scheduler</caption>
 *
 * Rx.Scheduler.async.schedule(() => console.log('async')); // scheduling 'async' first...
 * Rx.Scheduler.asap.schedule(() => console.log('asap'));
 *
 * // Logs:
 * // "asap"
 * // "async"
 * // ... but 'asap' goes first!
 *
 * @static true
 * @name asap
 * @owner Scheduler
 */
exports.asap = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);
//# sourceMappingURL=asap.js.map

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var QueueAction_1 = __webpack_require__(338);
var QueueScheduler_1 = __webpack_require__(339);
/**
 *
 * Queue Scheduler
 *
 * <span class="informal">Put every next task on a queue, instead of executing it immediately</span>
 *
 * `queue` scheduler, when used with delay, behaves the same as {@link async} scheduler.
 *
 * When used without delay, it schedules given task synchronously - executes it right when
 * it is scheduled. However when called recursively, that is when inside the scheduled task,
 * another task is scheduled with queue scheduler, instead of executing immediately as well,
 * that task will be put on a queue and wait for current one to finish.
 *
 * This means that when you execute task with `queue` scheduler, you are sure it will end
 * before any other task scheduled with that scheduler will start.
 *
 * @examples <caption>Schedule recursively first, then do something</caption>
 *
 * Rx.Scheduler.queue.schedule(() => {
 *   Rx.Scheduler.queue.schedule(() => console.log('second')); // will not happen now, but will be put on a queue
 *
 *   console.log('first');
 * });
 *
 * // Logs:
 * // "first"
 * // "second"
 *
 *
 * @example <caption>Reschedule itself recursively</caption>
 *
 * Rx.Scheduler.queue.schedule(function(state) {
 *   if (state !== 0) {
 *     console.log('before', state);
 *     this.schedule(state - 1); // `this` references currently executing Action,
 *                               // which we reschedule with new state
 *     console.log('after', state);
 *   }
 * }, 0, 3);
 *
 * // In scheduler that runs recursively, you would expect:
 * // "before", 3
 * // "before", 2
 * // "before", 1
 * // "after", 1
 * // "after", 2
 * // "after", 3
 *
 * // But with queue it logs:
 * // "before", 3
 * // "after", 3
 * // "before", 2
 * // "after", 2
 * // "before", 1
 * // "after", 1
 *
 *
 * @static true
 * @name queue
 * @owner Scheduler
 */
exports.queue = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);
//# sourceMappingURL=queue.js.map

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var SubscriptionLog = (function () {
    function SubscriptionLog(subscribedFrame, unsubscribedFrame) {
        if (unsubscribedFrame === void 0) { unsubscribedFrame = Number.POSITIVE_INFINITY; }
        this.subscribedFrame = subscribedFrame;
        this.unsubscribedFrame = unsubscribedFrame;
    }
    return SubscriptionLog;
}());
exports.SubscriptionLog = SubscriptionLog;
//# sourceMappingURL=SubscriptionLog.js.map

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var SubscriptionLog_1 = __webpack_require__(58);
var SubscriptionLoggable = (function () {
    function SubscriptionLoggable() {
        this.subscriptions = [];
    }
    SubscriptionLoggable.prototype.logSubscribedFrame = function () {
        this.subscriptions.push(new SubscriptionLog_1.SubscriptionLog(this.scheduler.now()));
        return this.subscriptions.length - 1;
    };
    SubscriptionLoggable.prototype.logUnsubscribedFrame = function (index) {
        var subscriptionLogs = this.subscriptions;
        var oldSubscriptionLog = subscriptionLogs[index];
        subscriptionLogs[index] = new SubscriptionLog_1.SubscriptionLog(oldSubscriptionLog.subscribedFrame, this.scheduler.now());
    };
    return SubscriptionLoggable;
}());
exports.SubscriptionLoggable = SubscriptionLoggable;
//# sourceMappingURL=SubscriptionLoggable.js.map

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when duetime elapses.
 *
 * @see {@link timeout}
 *
 * @class TimeoutError
 */
var TimeoutError = (function (_super) {
    __extends(TimeoutError, _super);
    function TimeoutError() {
        var err = _super.call(this, 'Timeout has occurred');
        this.name = err.name = 'TimeoutError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return TimeoutError;
}(Error));
exports.TimeoutError = TimeoutError;
//# sourceMappingURL=TimeoutError.js.map

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when one or more errors have occurred during the
 * `unsubscribe` of a {@link Subscription}.
 */
var UnsubscriptionError = (function (_super) {
    __extends(UnsubscriptionError, _super);
    function UnsubscriptionError(errors) {
        _super.call(this);
        this.errors = errors;
        var err = Error.call(this, errors ?
            errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) { return ((i + 1) + ") " + err.toString()); }).join('\n  ') : '');
        this.name = err.name = 'UnsubscriptionError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return UnsubscriptionError;
}(Error));
exports.UnsubscriptionError = UnsubscriptionError;
//# sourceMappingURL=UnsubscriptionError.js.map

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function applyMixins(derivedCtor, baseCtors) {
    for (var i = 0, len = baseCtors.length; i < len; i++) {
        var baseCtor = baseCtors[i];
        var propertyKeys = Object.getOwnPropertyNames(baseCtor.prototype);
        for (var j = 0, len2 = propertyKeys.length; j < len2; j++) {
            var name_1 = propertyKeys[j];
            derivedCtor.prototype[name_1] = baseCtor.prototype[name_1];
        }
    }
}
exports.applyMixins = applyMixins;
//# sourceMappingURL=applyMixins.js.map

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.isArrayLike = (function (x) { return x && typeof x.length === 'number'; });
//# sourceMappingURL=isArrayLike.js.map

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function isObject(x) {
    return x != null && typeof x === 'object';
}
exports.isObject = isObject;
//# sourceMappingURL=isObject.js.map

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function isPromise(value) {
    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
}
exports.isPromise = isPromise;
//# sourceMappingURL=isPromise.js.map

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* tslint:disable:no-empty */
function noop() { }
exports.noop = noop;
//# sourceMappingURL=noop.js.map

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(353);
exports.setImmediate = setImmediate;
exports.clearImmediate = clearImmediate;


/***/ }),
/* 68 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 69 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__sources__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__sources___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__sources__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__selection__ = __webpack_require__(74);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_rxjs__);
/* harmony export (immutable) */ __webpack_exports__["a"] = startFrameMessageRouter;
/* harmony export (immutable) */ __webpack_exports__["b"] = registerWithFrameMessageRouter;




var ipcRenderer = window.ipcRenderer;
var isElectron = !!ipcRenderer;

function isTop() {
    return window.top === window;
}

function hasPendoAgent() {
    return window.pendo && window.pendo.isReady && window.pendo.isReady();
}

function typeEquals(type) {
    return function (event) {
        return event.data.type === type;
    };
}

function destinationEquals(destination) {
    return function (event) {
        return event.data.destination === destination;
    };
}

function openPanelIfClosed(event) {
    var container = document.getElementById('pendo-designer-container');
    if (container) {
        container.classList.remove('closed');
    }
}

function receiveFrameInfo(frames) {
    return function (event) {
        var message = event.data;
        var frame = frames.find(function (f) {
            return f.window === event.source;
        });

        if (frame) {
            Object.assign(frame, message);
        } else {
            frames.push(Object.assign({
                id: frames.length + 1,
                window: event.source
            }, message));
        }
    };
}

function sendFrameInfo() {
    var message = {
        type: 'frame_info',
        source: __WEBPACK_IMPORTED_MODULE_0__sources__["plugin"],
        destination: __WEBPACK_IMPORTED_MODULE_0__sources__["plugin"],
        url: location.href,
        isTop: isTop()
    };
    if (hasPendoAgent()) {
        Object.assign(message, {
            agent: {
                ENV: window.pendo.ENV,
                HOST: window.pendo.HOST,
                hostLocation: location.origin
            }
        });
    }
    window.top.postMessage(message, '*');
}

function readPendoAgentSettings(frames) {
    return function (event) {
        var frame = frames.find(function (f) {
            return f.agent;
        });

        var messageObj = {
            type: 'pendo_agent_settings',
            source: __WEBPACK_IMPORTED_MODULE_0__sources__["plugin"],
            payload: frame && frame.agent,
            destination: __WEBPACK_IMPORTED_MODULE_0__sources__["designer"]
        };

        if (isElectron) {
            ipcRenderer.send('pendo-designer-message', messageObj);
        } else {
            event.source.postMessage(messageObj, '*');
        }
    };
}

function readLocation(frames) {
    return function (event) {
        var frame = frames.find(function (f) {
            return f.agent;
        });

        var messageObj = {
            type: 'remote_location',
            url: frame.url,
            source: __WEBPACK_IMPORTED_MODULE_0__sources__["plugin"],
            destination: __WEBPACK_IMPORTED_MODULE_0__sources__["designer"]
        };

        if (isElectron) {
            ipcRenderer.send('pendo-designer-message', messageObj);
        } else {
            event.source.postMessage(messageObj, '*');
        }
    };
}

function forwardToFramesWithAnInstalledAgent(frames, topWindow) {
    return function (event) {
        var message = event.data;
        frames.filter(function (f) {
            if (message.frameId) {
                return f.id === message.frameId;
            } else {
                return f.agent;
            }
        }).filter(function (f) {
            // the top window already has a handler attached for agent-bound messages
            return f.window !== topWindow;
        }).forEach(function (f) {
            f.window.postMessage(message, '*');
        });
    };
}

function handleGuidePreview(frames) {
    return function (event) {
        // FIXME - special case for guide preview, only preview in the top-most
        // frame, for now. Eventually, preview in the correct frame, if possible,
        // or just float in the top-most.
        var topFrame = frames.find(function (f) {
            return f.isTop;
        });
        var frame = frames.find(function (f) {
            return f.agent && !f.isTop;
        });

        if (frame && !topFrame.agent) {
            frame.window.postMessage(event.data, '*');
        }
    };
}

function forwardToContentScript(event) {
    if (event.source === window) return;
    window.postMessage(event.data, '*');
}

function forwardToDesigner(frames) {
    return function (event) {
        var message = event.data;
        var frame = frames.find(function (f) {
            return f.window === event.source;
        });
        if (frame) {
            message.frameId = frame.id;
        }
        sendToDesigner(message);
    };
}

function pollForPendoAgent() {
    if (hasPendoAgent()) {
        startAgentMessageListener();
        sendFrameInfo();
        window.pendo.url.watch(sendFrameInfo);
    } else {
        setTimeout(pollForPendoAgent, 1000);
    }
}

function sendToDesigner(message) {
    if (isElectron) {
        ipcRenderer.send('pendo-designer-message', message);
    } else {
        var frame = document.getElementById('pendo-designer-iframe');
        if (frame && frame.contentWindow) {
            frame.contentWindow.postMessage(message, '*');
        }
    }
}

function startAgentMessageListener() {
    if (!window.pendo) return;

    // The agent doesn't listen to messages if it isn't in an iframe
    var agent = __WEBPACK_IMPORTED_MODULE_2_rxjs__["Observable"].fromEvent(window, 'message').filter(destinationEquals(__WEBPACK_IMPORTED_MODULE_0__sources__["agent"]));

    agent.subscribe(window.pendo.messageDispatcher); // Skip "validation" (parsing) and origin testing

    agent.filter(typeEquals('connect')).subscribe(function () {
        if (window.selmo) return;
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__selection__["a" /* default */])(window, document);
    });
}

function startFrameMessageRouter() {
    if (!isTop()) return;

    if (isElectron) {
        ipcRenderer.on('pendo-designer-message', function (event, message) {
            window.postMessage(message, '*');
        });
    }

    var frames = [];

    var messages = __WEBPACK_IMPORTED_MODULE_2_rxjs__["Observable"].fromEvent(window, 'message').filter(function (event) {
        return !!event.data;
    });

    var plugin = messages.filter(destinationEquals(__WEBPACK_IMPORTED_MODULE_0__sources__["plugin"]));

    plugin.filter(typeEquals('frame_info')).subscribe(receiveFrameInfo(frames));

    plugin.filter(typeEquals('read_pendo_agent_settings')).subscribe(readPendoAgentSettings(frames));

    plugin.filter(typeEquals('open_panel_if_closed')).subscribe(openPanelIfClosed);

    plugin.filter(typeEquals('read_location')).subscribe(readLocation(frames));

    var agent = messages.filter(destinationEquals(__WEBPACK_IMPORTED_MODULE_0__sources__["agent"]));

    agent.filter(function (event) {
        return event.data.type !== 'preview-guide';
    }).subscribe(forwardToFramesWithAnInstalledAgent(frames, window));

    agent.filter(typeEquals('preview-guide')).subscribe(handleGuidePreview(frames));

    messages.filter(destinationEquals(__WEBPACK_IMPORTED_MODULE_0__sources__["background"])).subscribe(forwardToContentScript);

    messages.filter(destinationEquals(__WEBPACK_IMPORTED_MODULE_0__sources__["designer"])).subscribe(forwardToDesigner(frames));
}

function registerWithFrameMessageRouter() {
    sendFrameInfo();
    pollForPendoAgent();
}

/***/ }),
/* 70 */
/***/ (function(module, exports) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*eslint-disable*/
// too many eslint violations, this file has a high risk of being damaged 
// by eslint modifications

/*
  html2canvas 0.4.1 <http://html2canvas.hertzen.com>
  Copyright (c) 2013 Niklas von Hertzen

  Released under MIT License
*/

(function (window, document, undefined) {
    var _html2canvas = {},
        previousElement,
        computedCSS,
        html2canvas;

    _html2canvas.Util = {};

    _html2canvas.Util.log = function (a) {
        if (_html2canvas.logging && window.console && window.console.log) {
            window.console.log(a);
        }
    };

    _html2canvas.Util.trimText = function (isNative) {
        return function (input) {
            return isNative ? isNative.apply(input) : ((input || '') + '').replace(/^\s+|\s+$/g, '');
        };
    }(String.prototype.trim);

    _html2canvas.Util.asFloat = function (v) {
        return parseFloat(v);
    };

    (function () {
        // TODO: support all possible length values
        var TEXT_SHADOW_PROPERTY = /((rgba|rgb)\([^\)]+\)(\s-?\d+px){0,})/g;
        var TEXT_SHADOW_VALUES = /(-?\d+px)|(#.+)|(rgb\(.+\))|(rgba\(.+\))/g;
        _html2canvas.Util.parseTextShadows = function (value) {
            if (!value || value === 'none') {
                return [];
            }

            // find multiple shadow declarations
            var shadows = value.match(TEXT_SHADOW_PROPERTY),
                results = [];
            for (var i = 0; shadows && i < shadows.length; i++) {
                var s = shadows[i].match(TEXT_SHADOW_VALUES);
                results.push({
                    color: s[0],
                    offsetX: s[1] ? s[1].replace('px', '') : 0,
                    offsetY: s[2] ? s[2].replace('px', '') : 0,
                    blur: s[3] ? s[3].replace('px', '') : 0
                });
            }
            return results;
        };
    })();

    _html2canvas.Util.parseBackgroundImage = function (value) {
        var whitespace = ' \r\n\t',
            method,
            definition,
            prefix,
            prefix_i,
            block,
            results = [],
            c,
            mode = 0,
            numParen = 0,
            quote,
            args;

        var appendResult = function appendResult() {
            if (method) {
                if (definition.substr(0, 1) === '"') {
                    definition = definition.substr(1, definition.length - 2);
                }
                if (definition) {
                    args.push(definition);
                }
                if (method.substr(0, 1) === '-' && (prefix_i = method.indexOf('-', 1) + 1) > 0) {
                    prefix = method.substr(0, prefix_i);
                    method = method.substr(prefix_i);
                }
                results.push({
                    prefix: prefix,
                    method: method.toLowerCase(),
                    value: block,
                    args: args
                });
            }
            args = []; // for some odd reason, setting .length = 0 didn't work in safari
            method = prefix = definition = block = '';
        };

        appendResult();
        for (var i = 0, ii = value.length; i < ii; i++) {
            c = value[i];
            if (mode === 0 && whitespace.indexOf(c) > -1) {
                continue;
            }
            switch (c) {
                case '"':
                    if (!quote) {
                        quote = c;
                    } else if (quote === c) {
                        quote = null;
                    }
                    break;

                case '(':
                    if (quote) {
                        break;
                    } else if (mode === 0) {
                        mode = 1;
                        block += c;
                        continue;
                    } else {
                        numParen++;
                    }
                    break;

                case ')':
                    if (quote) {
                        break;
                    } else if (mode === 1) {
                        if (numParen === 0) {
                            mode = 0;
                            block += c;
                            appendResult();
                            continue;
                        } else {
                            numParen--;
                        }
                    }
                    break;

                case ',':
                    if (quote) {
                        break;
                    } else if (mode === 0) {
                        appendResult();
                        continue;
                    } else if (mode === 1) {
                        if (numParen === 0 && !method.match(/^url$/i)) {
                            args.push(definition);
                            definition = '';
                            block += c;
                            continue;
                        }
                    }
                    break;
            }

            block += c;
            if (mode === 0) {
                method += c;
            } else {
                definition += c;
            }
        }
        appendResult();

        return results;
    };

    _html2canvas.Util.Bounds = function (element) {
        var clientRect,
            bounds = {};

        if (element.getBoundingClientRect) {
            clientRect = element.getBoundingClientRect();

            // TODO add scroll position to bounds, so no scrolling of window necessary
            bounds.top = clientRect.top;
            bounds.bottom = clientRect.bottom || clientRect.top + clientRect.height;
            bounds.left = clientRect.left;

            bounds.width = element.offsetWidth;
            bounds.height = element.offsetHeight;
        }

        return bounds;
    };

    // TODO ideally, we'd want everything to go through this function instead of Util.Bounds,
    // but would require further work to calculate the correct positions for elements with offsetParents
    _html2canvas.Util.OffsetBounds = function (element) {
        var parent = element.offsetParent ? _html2canvas.Util.OffsetBounds(element.offsetParent) : { top: 0, left: 0 };

        return {
            top: element.offsetTop + parent.top,
            bottom: element.offsetTop + element.offsetHeight + parent.top,
            left: element.offsetLeft + parent.left,
            width: element.offsetWidth,
            height: element.offsetHeight
        };
    };

    function toPX(element, attribute, value) {
        var rsLeft = element.runtimeStyle && element.runtimeStyle[attribute],
            left,
            style = element.style;

        // Check if we are not dealing with pixels, (Opera has issues with this)
        // Ported from jQuery css.js
        // From the awesome hack by Dean Edwards
        // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

        // If we're not dealing with a regular pixel number
        // but a number that has a weird ending, we need to convert it to pixels

        if (!/^-?[0-9]+\.?[0-9]*(?:px)?$/i.test(value) && /^-?\d/.test(value)) {
            // Remember the original values
            left = style.left;

            // Put in the new values to get a computed value out
            if (rsLeft) {
                element.runtimeStyle.left = element.currentStyle.left;
            }
            style.left = attribute === 'fontSize' ? '1em' : value || 0;
            value = style.pixelLeft + 'px';

            // Revert the changed values
            style.left = left;
            if (rsLeft) {
                element.runtimeStyle.left = rsLeft;
            }
        }

        if (!/^(thin|medium|thick)$/i.test(value)) {
            return Math.round(parseFloat(value)) + 'px';
        }

        return value;
    }

    function asInt(val) {
        return parseInt(val, 10);
    }

    function parseBackgroundSizePosition(value, element, attribute, index) {
        value = (value || '').split(',');
        value = value[index || 0] || value[0] || 'auto';
        value = _html2canvas.Util.trimText(value).split(' ');

        if (attribute === 'backgroundSize' && (!value[0] || value[0].match(/cover|contain|auto/))) {
            // these values will be handled in the parent function
        } else {
            value[0] = value[0].indexOf('%') === -1 ? toPX(element, attribute + 'X', value[0]) : value[0];
            if (value[1] === undefined) {
                if (attribute === 'backgroundSize') {
                    value[1] = 'auto';
                    return value;
                } else {
                    // IE 9 doesn't return double digit always
                    value[1] = value[0];
                }
            }
            value[1] = value[1].indexOf('%') === -1 ? toPX(element, attribute + 'Y', value[1]) : value[1];
        }
        return value;
    }

    _html2canvas.Util.getCSS = function (element, attribute, index) {
        if (previousElement !== element) {
            computedCSS = document.defaultView.getComputedStyle(element, null);
        }

        var value = computedCSS[attribute];

        if (/^background(Size|Position)$/.test(attribute)) {
            return parseBackgroundSizePosition(value, element, attribute, index);
        } else if (/border(Top|Bottom)(Left|Right)Radius/.test(attribute)) {
            var arr = value.split(' ');
            if (arr.length <= 1) {
                arr[1] = arr[0];
            }
            return arr.map(asInt);
        }

        return value;
    };

    _html2canvas.Util.resizeBounds = function (current_width, current_height, target_width, target_height, stretch_mode) {
        var target_ratio = target_width / target_height,
            current_ratio = current_width / current_height,
            output_width,
            output_height;

        if (!stretch_mode || stretch_mode === 'auto') {
            output_width = target_width;
            output_height = target_height;
        } else if (target_ratio < current_ratio ^ stretch_mode === 'contain') {
            output_height = target_height;
            output_width = target_height * current_ratio;
        } else {
            output_width = target_width;
            output_height = target_width / current_ratio;
        }

        return {
            width: output_width,
            height: output_height
        };
    };

    function backgroundBoundsFactory(prop, el, bounds, image, imageIndex, backgroundSize) {
        var bgposition = _html2canvas.Util.getCSS(el, prop, imageIndex),
            topPos,
            left,
            percentage,
            val;

        if (bgposition.length === 1) {
            val = bgposition[0];

            bgposition = [];

            bgposition[0] = val;
            bgposition[1] = val;
        }

        if (bgposition[0].toString().indexOf('%') !== -1) {
            percentage = parseFloat(bgposition[0]) / 100;
            left = bounds.width * percentage;
            if (prop !== 'backgroundSize') {
                left -= (backgroundSize || image).width * percentage;
            }
        } else {
            if (prop === 'backgroundSize') {
                if (bgposition[0] === 'auto') {
                    left = image.width;
                } else {
                    if (/contain|cover/.test(bgposition[0])) {
                        var resized = _html2canvas.Util.resizeBounds(image.width, image.height, bounds.width, bounds.height, bgposition[0]);
                        left = resized.width;
                        topPos = resized.height;
                    } else {
                        left = parseInt(bgposition[0], 10);
                    }
                }
            } else {
                left = parseInt(bgposition[0], 10);
            }
        }

        if (bgposition[1] === 'auto') {
            topPos = left / image.width * image.height;
        } else if (bgposition[1].toString().indexOf('%') !== -1) {
            percentage = parseFloat(bgposition[1]) / 100;
            topPos = bounds.height * percentage;
            if (prop !== 'backgroundSize') {
                topPos -= (backgroundSize || image).height * percentage;
            }
        } else {
            topPos = parseInt(bgposition[1], 10);
        }

        return [left, topPos];
    }

    _html2canvas.Util.BackgroundPosition = function (el, bounds, image, imageIndex, backgroundSize) {
        var result = backgroundBoundsFactory('backgroundPosition', el, bounds, image, imageIndex, backgroundSize);
        return { left: result[0], top: result[1] };
    };

    _html2canvas.Util.BackgroundSize = function (el, bounds, image, imageIndex) {
        var result = backgroundBoundsFactory('backgroundSize', el, bounds, image, imageIndex);
        return { width: result[0], height: result[1] };
    };

    _html2canvas.Util.Extend = function (options, defaults) {
        for (var key in options) {
            if (options.hasOwnProperty(key)) {
                defaults[key] = options[key];
            }
        }
        return defaults;
    };

    /*
     * Derived from jQuery.contents()
     * Copyright 2010, John Resig
     * Dual licensed under the MIT or GPL Version 2 licenses.
     * http://jquery.org/license
     */
    _html2canvas.Util.Children = function (elem) {
        var children;
        try {
            children = elem.nodeName && elem.nodeName.toUpperCase() === 'IFRAME' ? elem.contentDocument || elem.contentWindow.document : function (array) {
                var ret = [];
                if (array !== null) {
                    (function (first, second) {
                        var i = first.length,
                            j = 0;

                        if (typeof second.length === 'number') {
                            for (var l = second.length; j < l; j++) {
                                first[i++] = second[j];
                            }
                        } else {
                            while (second[j] !== undefined) {
                                first[i++] = second[j++];
                            }
                        }

                        first.length = i;

                        return first;
                    })(ret, array);
                }
                return ret;
            }(elem.childNodes);
        } catch (ex) {
            _html2canvas.Util.log('html2canvas.Util.Children failed with exception: ' + ex.message);
            children = [];
        }
        return children;
    };

    _html2canvas.Util.isTransparent = function (backgroundColor) {
        return backgroundColor === 'transparent' || backgroundColor === 'rgba(0, 0, 0, 0)';
    };
    _html2canvas.Util.Font = function () {
        var fontData = {};

        return function (font, fontSize, doc) {
            if (fontData[font + '-' + fontSize] !== undefined) {
                return fontData[font + '-' + fontSize];
            }

            var container = doc.createElement('div'),
                img = doc.createElement('img'),
                span = doc.createElement('span'),
                sampleText = 'Hidden Text',
                baseline,
                middle,
                metricsObj;

            container.style.visibility = 'hidden';
            container.style.fontFamily = font;
            container.style.fontSize = fontSize;
            container.style.margin = 0;
            container.style.padding = 0;

            doc.body.appendChild(container);

            // http://probablyprogramming.com/2009/03/15/the-tiniest-gif-ever (handtinywhite.gif)
            img.src = 'data:image/gif;base64,R0lGODlhAQABAIABAP///wAAACwAAAAAAQABAAACAkQBADs=';
            img.width = 1;
            img.height = 1;

            img.style.margin = 0;
            img.style.padding = 0;
            img.style.verticalAlign = 'baseline';

            span.style.fontFamily = font;
            span.style.fontSize = fontSize;
            span.style.margin = 0;
            span.style.padding = 0;

            span.appendChild(doc.createTextNode(sampleText));
            container.appendChild(span);
            container.appendChild(img);
            baseline = img.offsetTop - span.offsetTop + 1;

            container.removeChild(span);
            container.appendChild(doc.createTextNode(sampleText));

            container.style.lineHeight = 'normal';
            img.style.verticalAlign = 'super';

            middle = img.offsetTop - container.offsetTop + 1;
            metricsObj = {
                baseline: baseline,
                lineWidth: 1,
                middle: middle
            };

            fontData[font + '-' + fontSize] = metricsObj;

            doc.body.removeChild(container);

            return metricsObj;
        };
    }();

    (function () {
        var Util = _html2canvas.Util,
            Generate = {};

        _html2canvas.Generate = Generate;

        var reGradients = [/^(-webkit-linear-gradient)\(([a-z\s]+)([\w\d\.\s,%\(\)]+)\)$/, /^(-o-linear-gradient)\(([a-z\s]+)([\w\d\.\s,%\(\)]+)\)$/, /^(-webkit-gradient)\((linear|radial),\s((?:\d{1,3}%?)\s(?:\d{1,3}%?),\s(?:\d{1,3}%?)\s(?:\d{1,3}%?))([\w\d\.\s,%\(\)\-]+)\)$/, /^(-moz-linear-gradient)\(((?:\d{1,3}%?)\s(?:\d{1,3}%?))([\w\d\.\s,%\(\)]+)\)$/, /^(-webkit-radial-gradient)\(((?:\d{1,3}%?)\s(?:\d{1,3}%?)),\s(\w+)\s([a-z\-]+)([\w\d\.\s,%\(\)]+)\)$/, /^(-moz-radial-gradient)\(((?:\d{1,3}%?)\s(?:\d{1,3}%?)),\s(\w+)\s?([a-z\-]*)([\w\d\.\s,%\(\)]+)\)$/, /^(-o-radial-gradient)\(((?:\d{1,3}%?)\s(?:\d{1,3}%?)),\s(\w+)\s([a-z\-]+)([\w\d\.\s,%\(\)]+)\)$/];

        /*
        * TODO: Add IE10 vendor prefix (-ms) support
        * TODO: Add W3C gradient (linear-gradient) support
        * TODO: Add old Webkit -webkit-gradient(radial, ...) support
        * TODO: Maybe some RegExp optimizations are possible ;o)
        */
        Generate.parseGradient = function (css, bounds) {
            var gradient,
                i,
                len = reGradients.length,
                m1,
                stop,
                m2,
                m2Len,
                step,
                m3,
                tl,
                tr,
                br,
                bl;

            for (i = 0; i < len; i += 1) {
                m1 = css.match(reGradients[i]);
                if (m1) {
                    break;
                }
            }

            if (m1) {
                switch (m1[1]) {
                    case '-webkit-linear-gradient':
                    case '-o-linear-gradient':

                        gradient = {
                            type: 'linear',
                            x0: null,
                            y0: null,
                            x1: null,
                            y1: null,
                            colorStops: []
                        };

                        // get coordinates
                        m2 = m1[2].match(/\w+/g);
                        if (m2) {
                            m2Len = m2.length;
                            for (i = 0; i < m2Len; i += 1) {
                                switch (m2[i]) {
                                    case 'top':
                                        gradient.y0 = 0;
                                        gradient.y1 = bounds.height;
                                        break;

                                    case 'right':
                                        gradient.x0 = bounds.width;
                                        gradient.x1 = 0;
                                        break;

                                    case 'bottom':
                                        gradient.y0 = bounds.height;
                                        gradient.y1 = 0;
                                        break;

                                    case 'left':
                                        gradient.x0 = 0;
                                        gradient.x1 = bounds.width;
                                        break;
                                }
                            }
                        }
                        if (gradient.x0 === null && gradient.x1 === null) {
                            // center
                            gradient.x0 = gradient.x1 = bounds.width / 2;
                        }
                        if (gradient.y0 === null && gradient.y1 === null) {
                            // center
                            gradient.y0 = gradient.y1 = bounds.height / 2;
                        }

                        // get colors and stops
                        m2 = m1[3].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\)(?:\s\d{1,3}(?:%|px))?)+/g);
                        if (m2) {
                            m2Len = m2.length;
                            step = 1 / Math.max(m2Len - 1, 1);
                            for (i = 0; i < m2Len; i += 1) {
                                m3 = m2[i].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\))\s*(\d{1,3})?(%|px)?/);
                                if (m3[2]) {
                                    stop = parseFloat(m3[2]);
                                    if (m3[3] === '%') {
                                        stop /= 100;
                                    } else {
                                        // px - stupid opera
                                        stop /= bounds.width;
                                    }
                                } else {
                                    stop = i * step;
                                }
                                gradient.colorStops.push({
                                    color: m3[1],
                                    stop: stop
                                });
                            }
                        }
                        break;

                    case '-webkit-gradient':

                        gradient = {
                            type: m1[2] === 'radial' ? 'circle' : m1[2], // TODO: Add radial gradient support for older mozilla definitions
                            x0: 0,
                            y0: 0,
                            x1: 0,
                            y1: 0,
                            colorStops: []
                        };

                        // get coordinates
                        m2 = m1[3].match(/(\d{1,3})%?\s(\d{1,3})%?,\s(\d{1,3})%?\s(\d{1,3})%?/);
                        if (m2) {
                            gradient.x0 = m2[1] * bounds.width / 100;
                            gradient.y0 = m2[2] * bounds.height / 100;
                            gradient.x1 = m2[3] * bounds.width / 100;
                            gradient.y1 = m2[4] * bounds.height / 100;
                        }

                        // get colors and stops
                        m2 = m1[4].match(/((?:from|to|color-stop)\((?:[0-9\.]+,\s)?(?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\)\))+/g);
                        if (m2) {
                            m2Len = m2.length;
                            for (i = 0; i < m2Len; i += 1) {
                                m3 = m2[i].match(/(from|to|color-stop)\(([0-9\.]+)?(?:,\s)?((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\))\)/);
                                stop = parseFloat(m3[2]);
                                if (m3[1] === 'from') {
                                    stop = 0.0;
                                }
                                if (m3[1] === 'to') {
                                    stop = 1.0;
                                }
                                gradient.colorStops.push({
                                    color: m3[3],
                                    stop: stop
                                });
                            }
                        }
                        break;

                    case '-moz-linear-gradient':

                        gradient = {
                            type: 'linear',
                            x0: 0,
                            y0: 0,
                            x1: 0,
                            y1: 0,
                            colorStops: []
                        };

                        // get coordinates
                        m2 = m1[2].match(/(\d{1,3})%?\s(\d{1,3})%?/);

                        // m2[1] == 0%   -> left
                        // m2[1] == 50%  -> center
                        // m2[1] == 100% -> right

                        // m2[2] == 0%   -> top
                        // m2[2] == 50%  -> center
                        // m2[2] == 100% -> bottom

                        if (m2) {
                            gradient.x0 = m2[1] * bounds.width / 100;
                            gradient.y0 = m2[2] * bounds.height / 100;
                            gradient.x1 = bounds.width - gradient.x0;
                            gradient.y1 = bounds.height - gradient.y0;
                        }

                        // get colors and stops
                        m2 = m1[3].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\)(?:\s\d{1,3}%)?)+/g);
                        if (m2) {
                            m2Len = m2.length;
                            step = 1 / Math.max(m2Len - 1, 1);
                            for (i = 0; i < m2Len; i += 1) {
                                m3 = m2[i].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\))\s*(\d{1,3})?(%)?/);
                                if (m3[2]) {
                                    stop = parseFloat(m3[2]);
                                    if (m3[3]) {
                                        // percentage
                                        stop /= 100;
                                    }
                                } else {
                                    stop = i * step;
                                }
                                gradient.colorStops.push({
                                    color: m3[1],
                                    stop: stop
                                });
                            }
                        }
                        break;

                    case '-webkit-radial-gradient':
                    case '-moz-radial-gradient':
                    case '-o-radial-gradient':

                        gradient = {
                            type: 'circle',
                            x0: 0,
                            y0: 0,
                            x1: bounds.width,
                            y1: bounds.height,
                            cx: 0,
                            cy: 0,
                            rx: 0,
                            ry: 0,
                            colorStops: []
                        };

                        // center
                        m2 = m1[2].match(/(\d{1,3})%?\s(\d{1,3})%?/);
                        if (m2) {
                            gradient.cx = m2[1] * bounds.width / 100;
                            gradient.cy = m2[2] * bounds.height / 100;
                        }

                        // size
                        m2 = m1[3].match(/\w+/);
                        m3 = m1[4].match(/[a-z\-]*/);
                        if (m2 && m3) {
                            switch (m3[0]) {
                                case 'farthest-corner':
                                case 'cover': // is equivalent to farthest-corner
                                case '':
                                    // mozilla removes "cover" from definition :(
                                    tl = Math.sqrt(Math.pow(gradient.cx, 2) + Math.pow(gradient.cy, 2));
                                    tr = Math.sqrt(Math.pow(gradient.cx, 2) + Math.pow(gradient.y1 - gradient.cy, 2));
                                    br = Math.sqrt(Math.pow(gradient.x1 - gradient.cx, 2) + Math.pow(gradient.y1 - gradient.cy, 2));
                                    bl = Math.sqrt(Math.pow(gradient.x1 - gradient.cx, 2) + Math.pow(gradient.cy, 2));
                                    gradient.rx = gradient.ry = Math.max(tl, tr, br, bl);
                                    break;
                                case 'closest-corner':
                                    tl = Math.sqrt(Math.pow(gradient.cx, 2) + Math.pow(gradient.cy, 2));
                                    tr = Math.sqrt(Math.pow(gradient.cx, 2) + Math.pow(gradient.y1 - gradient.cy, 2));
                                    br = Math.sqrt(Math.pow(gradient.x1 - gradient.cx, 2) + Math.pow(gradient.y1 - gradient.cy, 2));
                                    bl = Math.sqrt(Math.pow(gradient.x1 - gradient.cx, 2) + Math.pow(gradient.cy, 2));
                                    gradient.rx = gradient.ry = Math.min(tl, tr, br, bl);
                                    break;
                                case 'farthest-side':
                                    if (m2[0] === 'circle') {
                                        gradient.rx = gradient.ry = Math.max(gradient.cx, gradient.cy, gradient.x1 - gradient.cx, gradient.y1 - gradient.cy);
                                    } else {
                                        // ellipse

                                        gradient.type = m2[0];

                                        gradient.rx = Math.max(gradient.cx, gradient.x1 - gradient.cx);
                                        gradient.ry = Math.max(gradient.cy, gradient.y1 - gradient.cy);
                                    }
                                    break;
                                case 'closest-side':
                                case 'contain':
                                    // is equivalent to closest-side
                                    if (m2[0] === 'circle') {
                                        gradient.rx = gradient.ry = Math.min(gradient.cx, gradient.cy, gradient.x1 - gradient.cx, gradient.y1 - gradient.cy);
                                    } else {
                                        // ellipse

                                        gradient.type = m2[0];

                                        gradient.rx = Math.min(gradient.cx, gradient.x1 - gradient.cx);
                                        gradient.ry = Math.min(gradient.cy, gradient.y1 - gradient.cy);
                                    }
                                    break;

                                // TODO: add support for "30px 40px" sizes (webkit only)
                            }
                        }

                        // color stops
                        m2 = m1[5].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\)(?:\s\d{1,3}(?:%|px))?)+/g);
                        if (m2) {
                            m2Len = m2.length;
                            step = 1 / Math.max(m2Len - 1, 1);
                            for (i = 0; i < m2Len; i += 1) {
                                m3 = m2[i].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\))\s*(\d{1,3})?(%|px)?/);
                                if (m3[2]) {
                                    stop = parseFloat(m3[2]);
                                    if (m3[3] === '%') {
                                        stop /= 100;
                                    } else {
                                        // px - stupid opera
                                        stop /= bounds.width;
                                    }
                                } else {
                                    stop = i * step;
                                }
                                gradient.colorStops.push({
                                    color: m3[1],
                                    stop: stop
                                });
                            }
                        }
                        break;
                }
            }

            return gradient;
        };

        function addScrollStops(grad) {
            return function (colorStop) {
                try {
                    grad.addColorStop(colorStop.stop, colorStop.color);
                } catch (e) {
                    Util.log(['failed to add color stop: ', e, '; tried to add: ', colorStop]);
                }
            };
        }

        Generate.Gradient = function (src, bounds) {
            if (bounds.width === 0 || bounds.height === 0) {
                return;
            }

            var canvas = document.createElement('canvas'),
                ctx = canvas.getContext('2d'),
                gradient,
                grad;

            canvas.width = bounds.width;
            canvas.height = bounds.height;

            // TODO: add support for multi defined background gradients
            gradient = _html2canvas.Generate.parseGradient(src, bounds);

            if (gradient) {
                switch (gradient.type) {
                    case 'linear':
                        grad = ctx.createLinearGradient(gradient.x0, gradient.y0, gradient.x1, gradient.y1);
                        gradient.colorStops.forEach(addScrollStops(grad));
                        ctx.fillStyle = grad;
                        ctx.fillRect(0, 0, bounds.width, bounds.height);
                        break;

                    case 'circle':
                        grad = ctx.createRadialGradient(gradient.cx, gradient.cy, 0, gradient.cx, gradient.cy, gradient.rx);
                        gradient.colorStops.forEach(addScrollStops(grad));
                        ctx.fillStyle = grad;
                        ctx.fillRect(0, 0, bounds.width, bounds.height);
                        break;

                    case 'ellipse':
                        var canvasRadial = document.createElement('canvas'),
                            ctxRadial = canvasRadial.getContext('2d'),
                            ri = Math.max(gradient.rx, gradient.ry),
                            di = ri * 2;

                        canvasRadial.width = canvasRadial.height = di;

                        grad = ctxRadial.createRadialGradient(gradient.rx, gradient.ry, 0, gradient.rx, gradient.ry, ri);
                        gradient.colorStops.forEach(addScrollStops(grad));

                        ctxRadial.fillStyle = grad;
                        ctxRadial.fillRect(0, 0, di, di);

                        ctx.fillStyle = gradient.colorStops[gradient.colorStops.length - 1].color;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.drawImage(canvasRadial, gradient.cx - gradient.rx, gradient.cy - gradient.ry, 2 * gradient.rx, 2 * gradient.ry);
                        break;
                }
            }

            return canvas;
        };

        Generate.ListAlpha = function (number) {
            var tmp = '',
                modulus;

            do {
                modulus = number % 26;
                tmp = String.fromCharCode(modulus + 64) + tmp;
                number = number / 26;
            } while (number * 26 > 26);

            return tmp;
        };

        Generate.ListRoman = function (number) {
            var romanArray = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],
                decimal = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
                roman = '',
                v,
                len = romanArray.length;

            if (number <= 0 || number >= 4000) {
                return number;
            }

            for (v = 0; v < len; v += 1) {
                while (number >= decimal[v]) {
                    number -= decimal[v];
                    roman += romanArray[v];
                }
            }

            return roman;
        };
    })();
    function h2cRenderContext(width, height) {
        var storage = [];
        return {
            storage: storage,
            width: width,
            height: height,
            clip: function clip() {
                storage.push({
                    type: 'function',
                    name: 'clip',
                    'arguments': arguments
                });
            },
            translate: function translate() {
                storage.push({
                    type: 'function',
                    name: 'translate',
                    'arguments': arguments
                });
            },
            fill: function fill() {
                storage.push({
                    type: 'function',
                    name: 'fill',
                    'arguments': arguments
                });
            },
            save: function save() {
                storage.push({
                    type: 'function',
                    name: 'save',
                    'arguments': arguments
                });
            },
            restore: function restore() {
                storage.push({
                    type: 'function',
                    name: 'restore',
                    'arguments': arguments
                });
            },
            fillRect: function fillRect() {
                storage.push({
                    type: 'function',
                    name: 'fillRect',
                    'arguments': arguments
                });
            },
            createPattern: function createPattern() {
                storage.push({
                    type: 'function',
                    name: 'createPattern',
                    'arguments': arguments
                });
            },
            drawShape: function drawShape() {
                var shape = [];

                storage.push({
                    type: 'function',
                    name: 'drawShape',
                    'arguments': shape
                });

                return {
                    moveTo: function moveTo() {
                        shape.push({
                            name: 'moveTo',
                            'arguments': arguments
                        });
                    },
                    lineTo: function lineTo() {
                        shape.push({
                            name: 'lineTo',
                            'arguments': arguments
                        });
                    },
                    arcTo: function arcTo() {
                        shape.push({
                            name: 'arcTo',
                            'arguments': arguments
                        });
                    },
                    bezierCurveTo: function bezierCurveTo() {
                        shape.push({
                            name: 'bezierCurveTo',
                            'arguments': arguments
                        });
                    },
                    quadraticCurveTo: function quadraticCurveTo() {
                        shape.push({
                            name: 'quadraticCurveTo',
                            'arguments': arguments
                        });
                    }
                };
            },
            drawImage: function drawImage() {
                storage.push({
                    type: 'function',
                    name: 'drawImage',
                    'arguments': arguments
                });
            },
            fillText: function fillText() {
                storage.push({
                    type: 'function',
                    name: 'fillText',
                    'arguments': arguments
                });
            },
            setVariable: function setVariable(variable, value) {
                storage.push({
                    type: 'variable',
                    name: variable,
                    'arguments': value
                });
                return value;
            }
        };
    }
    _html2canvas.Parse = function (images, options) {
        window.scroll(0, 0);

        var element = options.elements === undefined ? document.body : options.elements[0],
            // select body by default
        numDraws = 0,
            doc = element.ownerDocument,
            Util = _html2canvas.Util,
            support = Util.Support(options, doc),
            ignoreElementsRegExp = new RegExp('(' + options.ignoreElements + ')'),
            body = doc.body,
            getCSS = Util.getCSS,
            pseudoHide = '___html2canvas___pseudoelement',
            hidePseudoElements = doc.createElement('style');

        hidePseudoElements.innerHTML = '.' + pseudoHide + '-before:before { content: "" !important; display: none !important; }' + '.' + pseudoHide + '-after:after { content: "" !important; display: none !important; }';

        body.appendChild(hidePseudoElements);

        images = images || {};

        function documentWidth() {
            return Math.max(Math.max(doc.body.scrollWidth, doc.documentElement.scrollWidth), Math.max(doc.body.offsetWidth, doc.documentElement.offsetWidth), Math.max(doc.body.clientWidth, doc.documentElement.clientWidth));
        }

        function documentHeight() {
            return Math.max(Math.max(doc.body.scrollHeight, doc.documentElement.scrollHeight), Math.max(doc.body.offsetHeight, doc.documentElement.offsetHeight), Math.max(doc.body.clientHeight, doc.documentElement.clientHeight));
        }

        function getCSSInt(element, attribute) {
            var val = parseInt(getCSS(element, attribute), 10);
            return isNaN(val) ? 0 : val; // borders in old IE are throwing 'medium' for demo.html
        }

        function renderRect(ctx, x, y, w, h, bgcolor) {
            if (bgcolor !== 'transparent') {
                ctx.setVariable('fillStyle', bgcolor);
                ctx.fillRect(x, y, w, h);
                numDraws += 1;
            }
        }

        function capitalize(m, p1, p2) {
            if (m.length > 0) {
                return p1 + p2.toUpperCase();
            }
        }

        function textTransform(text, transform) {
            switch (transform) {
                case 'lowercase':
                    return text.toLowerCase();
                case 'capitalize':
                    return text.replace(/(^|\s|:|-|\(|\))([a-z])/g, capitalize);
                case 'uppercase':
                    return text.toUpperCase();
                default:
                    return text;
            }
        }

        function noLetterSpacing(letter_spacing) {
            return (/^(normal|none|0px)$/.test(letter_spacing)
            );
        }

        function drawText(currentText, x, y, ctx) {
            if (currentText !== null && Util.trimText(currentText).length > 0) {
                ctx.fillText(currentText, x, y);
                numDraws += 1;
            }
        }

        function setTextVariables(ctx, el, text_decoration, color) {
            var align = false,
                bold = getCSS(el, 'fontWeight'),
                family = getCSS(el, 'fontFamily'),
                size = getCSS(el, 'fontSize'),
                shadows = Util.parseTextShadows(getCSS(el, 'textShadow'));

            switch (parseInt(bold, 10)) {
                case 401:
                    bold = 'bold';
                    break;
                case 400:
                    bold = 'normal';
                    break;
            }

            ctx.setVariable('fillStyle', color);
            ctx.setVariable('font', [getCSS(el, 'fontStyle'), getCSS(el, 'fontVariant'), bold, size, family].join(' '));
            ctx.setVariable('textAlign', align ? 'right' : 'left');

            if (shadows.length) {
                // TODO: support multiple text shadows
                // apply the first text shadow
                ctx.setVariable('shadowColor', shadows[0].color);
                ctx.setVariable('shadowOffsetX', shadows[0].offsetX);
                ctx.setVariable('shadowOffsetY', shadows[0].offsetY);
                ctx.setVariable('shadowBlur', shadows[0].blur);
            }

            if (text_decoration !== 'none') {
                return Util.Font(family, size, doc);
            }
        }

        function renderTextDecoration(ctx, text_decoration, bounds, metrics, color) {
            switch (text_decoration) {
                case 'underline':
                    // Draws a line at the baseline of the font
                    // TODO As some browsers display the line as more than 1px if the font-size is big, need to take that into account both in position and size
                    renderRect(ctx, bounds.left, Math.round(bounds.top + metrics.baseline + metrics.lineWidth), bounds.width, 1, color);
                    break;
                case 'overline':
                    renderRect(ctx, bounds.left, Math.round(bounds.top), bounds.width, 1, color);
                    break;
                case 'line-through':
                    // TODO try and find exact position for line-through
                    renderRect(ctx, bounds.left, Math.ceil(bounds.top + metrics.middle + metrics.lineWidth), bounds.width, 1, color);
                    break;
            }
        }

        function getTextBounds(state, text, textDecoration, isLast, transform) {
            var bounds;
            if (support.rangeBounds && !transform) {
                if (textDecoration !== 'none' || Util.trimText(text).length !== 0) {
                    bounds = textRangeBounds(text, state.node, state.textOffset);
                }
                state.textOffset += text.length;
            } else if (state.node && typeof state.node.nodeValue === 'string') {
                var newTextNode = isLast ? state.node.splitText(text.length) : null;
                bounds = textWrapperBounds(state.node, transform);
                state.node = newTextNode;
            }
            return bounds;
        }

        function textRangeBounds(text, textNode, textOffset) {
            var range = doc.createRange();
            range.setStart(textNode, textOffset);
            range.setEnd(textNode, textOffset + text.length);
            return range.getBoundingClientRect();
        }

        function textWrapperBounds(oldTextNode, transform) {
            var parent = oldTextNode.parentNode,
                wrapElement = doc.createElement('wrapper'),
                backupText = oldTextNode.cloneNode(true);

            wrapElement.appendChild(oldTextNode.cloneNode(true));
            parent.replaceChild(wrapElement, oldTextNode);

            var bounds = transform ? Util.OffsetBounds(wrapElement) : Util.Bounds(wrapElement);
            parent.replaceChild(backupText, wrapElement);
            return bounds;
        }

        function renderText(el, textNode, stack) {
            var ctx = stack.ctx,
                color = getCSS(el, 'color'),
                textDecoration = getCSS(el, 'textDecoration'),
                textAlign = getCSS(el, 'textAlign'),
                metrics,
                textList,
                state = {
                node: textNode,
                textOffset: 0
            };

            if (Util.trimText(textNode.nodeValue).length > 0) {
                textNode.nodeValue = textTransform(textNode.nodeValue, getCSS(el, 'textTransform'));
                textAlign = textAlign.replace(['-webkit-auto'], ['auto']);

                textList = !options.letterRendering && /^(left|right|justify|auto)$/.test(textAlign) && noLetterSpacing(getCSS(el, 'letterSpacing')) ? textNode.nodeValue.split(/(\b| )/) : textNode.nodeValue.split('');

                metrics = setTextVariables(ctx, el, textDecoration, color);

                if (options.chinese) {
                    textList.forEach(function (word, index) {
                        if (/.*[\u4E00-\u9FA5].*$/.test(word)) {
                            word = word.split('');
                            word.unshift(index, 1);
                            textList.splice.apply(textList, word);
                        }
                    });
                }

                textList.forEach(function (text, index) {
                    var bounds = getTextBounds(state, text, textDecoration, index < textList.length - 1, stack.transform.matrix);
                    if (bounds) {
                        drawText(text, bounds.left, bounds.bottom, ctx);
                        renderTextDecoration(ctx, textDecoration, bounds, metrics, color);
                    }
                });
            }
        }

        function listPosition(element, val) {
            var boundElement = doc.createElement('boundelement'),
                originalType,
                bounds;

            boundElement.style.display = 'inline';

            originalType = element.style.listStyleType;
            element.style.listStyleType = 'none';

            boundElement.appendChild(doc.createTextNode(val));

            element.insertBefore(boundElement, element.firstChild);

            bounds = Util.Bounds(boundElement);
            element.removeChild(boundElement);
            element.style.listStyleType = originalType;
            return bounds;
        }

        function elementIndex(el) {
            var i = -1,
                count = 1,
                childs = el.parentNode.childNodes;

            if (el.parentNode) {
                while (childs[++i] !== el) {
                    if (childs[i].nodeType === 1) {
                        count++;
                    }
                }
                return count;
            } else {
                return -1;
            }
        }

        function listItemText(element, type) {
            var currentIndex = elementIndex(element),
                text;
            switch (type) {
                case 'decimal':
                    text = currentIndex;
                    break;
                case 'decimal-leading-zero':
                    text = currentIndex.toString().length === 1 ? currentIndex = '0' + currentIndex.toString() : currentIndex.toString();
                    break;
                case 'upper-roman':
                    text = _html2canvas.Generate.ListRoman(currentIndex);
                    break;
                case 'lower-roman':
                    text = _html2canvas.Generate.ListRoman(currentIndex).toLowerCase();
                    break;
                case 'lower-alpha':
                    text = _html2canvas.Generate.ListAlpha(currentIndex).toLowerCase();
                    break;
                case 'upper-alpha':
                    text = _html2canvas.Generate.ListAlpha(currentIndex);
                    break;
            }

            return text + '. ';
        }

        function renderListItem(element, stack, elBounds) {
            var x,
                text,
                ctx = stack.ctx,
                type = getCSS(element, 'listStyleType'),
                listBounds;

            if (/^(decimal|decimal-leading-zero|upper-alpha|upper-latin|upper-roman|lower-alpha|lower-greek|lower-latin|lower-roman)$/i.test(type)) {
                text = listItemText(element, type);
                listBounds = listPosition(element, text);
                setTextVariables(ctx, element, 'none', getCSS(element, 'color'));

                if (getCSS(element, 'listStylePosition') === 'inside') {
                    ctx.setVariable('textAlign', 'left');
                    x = elBounds.left;
                } else {
                    return;
                }

                drawText(text, x, listBounds.bottom, ctx);
            }
        }

        function loadImage(src) {
            var img = images[src];
            return img && img.succeeded === true ? img.img : false;
        }

        function clipBounds(src, dst) {
            var x = Math.max(src.left, dst.left),
                y = Math.max(src.top, dst.top),
                x2 = Math.min(src.left + src.width, dst.left + dst.width),
                y2 = Math.min(src.top + src.height, dst.top + dst.height);

            return {
                left: x,
                top: y,
                width: x2 - x,
                height: y2 - y
            };
        }

        function setZ(element, stack, parentStack) {
            var newContext,
                isPositioned = stack.cssPosition !== 'static',
                zIndex = isPositioned ? getCSS(element, 'zIndex') : 'auto',
                opacity = getCSS(element, 'opacity'),
                isFloated = getCSS(element, 'cssFloat') !== 'none';

            // https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context
            // When a new stacking context should be created:
            // the root element (HTML),
            // positioned (absolutely or relatively) with a z-index value other than "auto",
            // elements with an opacity value less than 1. (See the specification for opacity),
            // on mobile WebKit and Chrome 22+, position: fixed always creates a new stacking context, even when z-index is "auto" (See this post)

            stack.zIndex = newContext = h2czContext(zIndex);
            newContext.isPositioned = isPositioned;
            newContext.isFloated = isFloated;
            newContext.opacity = opacity;
            newContext.ownStacking = zIndex !== 'auto' || opacity < 1;

            if (parentStack) {
                parentStack.zIndex.children.push(stack);
            }
        }

        function renderImage(ctx, element, image, bounds, borders) {
            var paddingLeft = getCSSInt(element, 'paddingLeft'),
                paddingTop = getCSSInt(element, 'paddingTop'),
                paddingRight = getCSSInt(element, 'paddingRight'),
                paddingBottom = getCSSInt(element, 'paddingBottom');

            drawImage(ctx, image, 0, // sx
            0, // sy
            image.width, // sw
            image.height, // sh
            bounds.left + paddingLeft + borders[3].width, // dx
            bounds.top + paddingTop + borders[0].width, // dy
            bounds.width - (borders[1].width + borders[3].width + paddingLeft + paddingRight), // dw
            bounds.height - (borders[0].width + borders[2].width + paddingTop + paddingBottom) // dh
            );
        }

        function getBorderData(element) {
            return ['Top', 'Right', 'Bottom', 'Left'].map(function (side) {
                return {
                    width: getCSSInt(element, 'border' + side + 'Width'),
                    color: getCSS(element, 'border' + side + 'Color')
                };
            });
        }

        function getBorderRadiusData(element) {
            return ['TopLeft', 'TopRight', 'BottomRight', 'BottomLeft'].map(function (side) {
                return getCSS(element, 'border' + side + 'Radius');
            });
        }

        var getCurvePoints = function (kappa) {
            return function (x, y, r1, r2) {
                var ox = r1 * kappa,
                    // control point offset horizontal
                oy = r2 * kappa,
                    // control point offset vertical
                xm = x + r1,
                    // x-middle
                ym = y + r2; // y-middle
                return {
                    topLeft: bezierCurve({
                        x: x,
                        y: ym
                    }, {
                        x: x,
                        y: ym - oy
                    }, {
                        x: xm - ox,
                        y: y
                    }, {
                        x: xm,
                        y: y
                    }),
                    topRight: bezierCurve({
                        x: x,
                        y: y
                    }, {
                        x: x + ox,
                        y: y
                    }, {
                        x: xm,
                        y: ym - oy
                    }, {
                        x: xm,
                        y: ym
                    }),
                    bottomRight: bezierCurve({
                        x: xm,
                        y: y
                    }, {
                        x: xm,
                        y: y + oy
                    }, {
                        x: x + ox,
                        y: ym
                    }, {
                        x: x,
                        y: ym
                    }),
                    bottomLeft: bezierCurve({
                        x: xm,
                        y: ym
                    }, {
                        x: xm - ox,
                        y: ym
                    }, {
                        x: x,
                        y: y + oy
                    }, {
                        x: x,
                        y: y
                    })
                };
            };
        }(4 * ((Math.sqrt(2) - 1) / 3));

        function bezierCurve(start, startControl, endControl, end) {
            var lerp = function lerp(a, b, t) {
                return {
                    x: a.x + (b.x - a.x) * t,
                    y: a.y + (b.y - a.y) * t
                };
            };

            return {
                start: start,
                startControl: startControl,
                endControl: endControl,
                end: end,
                subdivide: function subdivide(t) {
                    var ab = lerp(start, startControl, t),
                        bc = lerp(startControl, endControl, t),
                        cd = lerp(endControl, end, t),
                        abbc = lerp(ab, bc, t),
                        bccd = lerp(bc, cd, t),
                        dest = lerp(abbc, bccd, t);
                    return [bezierCurve(start, ab, abbc, dest), bezierCurve(dest, bccd, cd, end)];
                },
                curveTo: function curveTo(borderArgs) {
                    borderArgs.push(['bezierCurve', startControl.x, startControl.y, endControl.x, endControl.y, end.x, end.y]);
                },
                curveToReversed: function curveToReversed(borderArgs) {
                    borderArgs.push(['bezierCurve', endControl.x, endControl.y, startControl.x, startControl.y, start.x, start.y]);
                }
            };
        }

        function parseCorner(borderArgs, radius1, radius2, corner1, corner2, x, y) {
            if (radius1[0] > 0 || radius1[1] > 0) {
                borderArgs.push(['line', corner1[0].start.x, corner1[0].start.y]);
                corner1[0].curveTo(borderArgs);
                corner1[1].curveTo(borderArgs);
            } else {
                borderArgs.push(['line', x, y]);
            }

            if (radius2[0] > 0 || radius2[1] > 0) {
                borderArgs.push(['line', corner2[0].start.x, corner2[0].start.y]);
            }
        }

        function drawSide(borderData, radius1, radius2, outer1, inner1, outer2, inner2) {
            var borderArgs = [];

            if (radius1[0] > 0 || radius1[1] > 0) {
                borderArgs.push(['line', outer1[1].start.x, outer1[1].start.y]);
                outer1[1].curveTo(borderArgs);
            } else {
                borderArgs.push(['line', borderData.c1[0], borderData.c1[1]]);
            }

            if (radius2[0] > 0 || radius2[1] > 0) {
                borderArgs.push(['line', outer2[0].start.x, outer2[0].start.y]);
                outer2[0].curveTo(borderArgs);
                borderArgs.push(['line', inner2[0].end.x, inner2[0].end.y]);
                inner2[0].curveToReversed(borderArgs);
            } else {
                borderArgs.push(['line', borderData.c2[0], borderData.c2[1]]);
                borderArgs.push(['line', borderData.c3[0], borderData.c3[1]]);
            }

            if (radius1[0] > 0 || radius1[1] > 0) {
                borderArgs.push(['line', inner1[1].end.x, inner1[1].end.y]);
                inner1[1].curveToReversed(borderArgs);
            } else {
                borderArgs.push(['line', borderData.c4[0], borderData.c4[1]]);
            }

            return borderArgs;
        }

        function calculateCurvePoints(bounds, borderRadius, borders) {
            var x = bounds.left,
                y = bounds.top,
                width = bounds.width,
                height = bounds.height,
                tlh = borderRadius[0][0],
                tlv = borderRadius[0][1],
                trh = borderRadius[1][0],
                trv = borderRadius[1][1],
                brh = borderRadius[2][0],
                brv = borderRadius[2][1],
                blh = borderRadius[3][0],
                blv = borderRadius[3][1],
                topWidth = width - trh,
                rightHeight = height - brv,
                bottomWidth = width - brh,
                leftHeight = height - blv;

            return {
                topLeftOuter: getCurvePoints(x, y, tlh, tlv).topLeft.subdivide(0.5),

                topLeftInner: getCurvePoints(x + borders[3].width, y + borders[0].width, Math.max(0, tlh - borders[3].width), Math.max(0, tlv - borders[0].width)).topLeft.subdivide(0.5),

                topRightOuter: getCurvePoints(x + topWidth, y, trh, trv).topRight.subdivide(0.5),

                topRightInner: getCurvePoints(x + Math.min(topWidth, width + borders[3].width), y + borders[0].width, topWidth > width + borders[3].width ? 0 : trh - borders[3].width, trv - borders[0].width).topRight.subdivide(0.5),

                bottomRightOuter: getCurvePoints(x + bottomWidth, y + rightHeight, brh, brv).bottomRight.subdivide(0.5),

                bottomRightInner: getCurvePoints(x + Math.min(bottomWidth, width + borders[3].width), y + Math.min(rightHeight, height + borders[0].width), Math.max(0, brh - borders[1].width), Math.max(0, brv - borders[2].width)).bottomRight.subdivide(0.5),

                bottomLeftOuter: getCurvePoints(x, y + leftHeight, blh, blv).bottomLeft.subdivide(0.5),

                bottomLeftInner: getCurvePoints(x + borders[3].width, y + leftHeight, Math.max(0, blh - borders[3].width), Math.max(0, blv - borders[2].width)).bottomLeft.subdivide(0.5)
            };
        }

        function getBorderClip(element, borderPoints, borders, radius, bounds) {
            var backgroundClip = getCSS(element, 'backgroundClip'),
                borderArgs = [];

            switch (backgroundClip) {
                case 'content-box':
                case 'padding-box':
                    parseCorner(borderArgs, radius[0], radius[1], borderPoints.topLeftInner, borderPoints.topRightInner, bounds.left + borders[3].width, bounds.top + borders[0].width);
                    parseCorner(borderArgs, radius[1], radius[2], borderPoints.topRightInner, borderPoints.bottomRightInner, bounds.left + bounds.width - borders[1].width, bounds.top + borders[0].width);
                    parseCorner(borderArgs, radius[2], radius[3], borderPoints.bottomRightInner, borderPoints.bottomLeftInner, bounds.left + bounds.width - borders[1].width, bounds.top + bounds.height - borders[2].width);
                    parseCorner(borderArgs, radius[3], radius[0], borderPoints.bottomLeftInner, borderPoints.topLeftInner, bounds.left + borders[3].width, bounds.top + bounds.height - borders[2].width);
                    break;

                default:
                    parseCorner(borderArgs, radius[0], radius[1], borderPoints.topLeftOuter, borderPoints.topRightOuter, bounds.left, bounds.top);
                    parseCorner(borderArgs, radius[1], radius[2], borderPoints.topRightOuter, borderPoints.bottomRightOuter, bounds.left + bounds.width, bounds.top);
                    parseCorner(borderArgs, radius[2], radius[3], borderPoints.bottomRightOuter, borderPoints.bottomLeftOuter, bounds.left + bounds.width, bounds.top + bounds.height);
                    parseCorner(borderArgs, radius[3], radius[0], borderPoints.bottomLeftOuter, borderPoints.topLeftOuter, bounds.left, bounds.top + bounds.height);
                    break;
            }

            return borderArgs;
        }

        function parseBorders(element, bounds, borders) {
            var x = bounds.left,
                y = bounds.top,
                width = bounds.width,
                height = bounds.height,
                borderSide,
                bx,
                by,
                bw,
                bh,
                borderArgs,

            // http://www.w3.org/TR/css3-background/#the-border-radius
            borderRadius = getBorderRadiusData(element),
                borderPoints = calculateCurvePoints(bounds, borderRadius, borders),
                borderData = {
                clip: getBorderClip(element, borderPoints, borders, borderRadius, bounds),
                borders: []
            };

            for (borderSide = 0; borderSide < 4; borderSide++) {
                if (borders[borderSide].width > 0) {
                    bx = x;
                    by = y;
                    bw = width;
                    bh = height - borders[2].width;

                    switch (borderSide) {
                        case 0:
                            // top border
                            bh = borders[0].width;

                            borderArgs = drawSide({
                                c1: [bx, by],
                                c2: [bx + bw, by],
                                c3: [bx + bw - borders[1].width, by + bh],
                                c4: [bx + borders[3].width, by + bh]
                            }, borderRadius[0], borderRadius[1], borderPoints.topLeftOuter, borderPoints.topLeftInner, borderPoints.topRightOuter, borderPoints.topRightInner);
                            break;
                        case 1:
                            // right border
                            bx = x + width - borders[1].width;
                            bw = borders[1].width;

                            borderArgs = drawSide({
                                c1: [bx + bw, by],
                                c2: [bx + bw, by + bh + borders[2].width],
                                c3: [bx, by + bh],
                                c4: [bx, by + borders[0].width]
                            }, borderRadius[1], borderRadius[2], borderPoints.topRightOuter, borderPoints.topRightInner, borderPoints.bottomRightOuter, borderPoints.bottomRightInner);
                            break;
                        case 2:
                            // bottom border
                            by = by + height - borders[2].width;
                            bh = borders[2].width;

                            borderArgs = drawSide({
                                c1: [bx + bw, by + bh],
                                c2: [bx, by + bh],
                                c3: [bx + borders[3].width, by],
                                c4: [bx + bw - borders[3].width, by]
                            }, borderRadius[2], borderRadius[3], borderPoints.bottomRightOuter, borderPoints.bottomRightInner, borderPoints.bottomLeftOuter, borderPoints.bottomLeftInner);
                            break;
                        case 3:
                            // left border
                            bw = borders[3].width;

                            borderArgs = drawSide({
                                c1: [bx, by + bh + borders[2].width],
                                c2: [bx, by],
                                c3: [bx + bw, by + borders[0].width],
                                c4: [bx + bw, by + bh]
                            }, borderRadius[3], borderRadius[0], borderPoints.bottomLeftOuter, borderPoints.bottomLeftInner, borderPoints.topLeftOuter, borderPoints.topLeftInner);
                            break;
                    }

                    borderData.borders.push({
                        args: borderArgs,
                        color: borders[borderSide].color
                    });
                }
            }

            return borderData;
        }

        function createShape(ctx, args) {
            var shape = ctx.drawShape();
            args.forEach(function (border, index) {
                shape[index === 0 ? 'moveTo' : border[0] + 'To'].apply(null, border.slice(1));
            });
            return shape;
        }

        function renderBorders(ctx, borderArgs, color) {
            if (color !== 'transparent') {
                ctx.setVariable('fillStyle', color);
                createShape(ctx, borderArgs);
                ctx.fill();
                numDraws += 1;
            }
        }

        function renderFormValue(el, bounds, stack) {
            var valueWrap = doc.createElement('valuewrap'),
                cssPropertyArray = ['lineHeight', 'textAlign', 'fontFamily', 'color', 'fontSize', 'paddingLeft', 'paddingTop', 'width', 'height', 'border', 'borderLeftWidth', 'borderTopWidth'],
                textValue,
                textNode;

            cssPropertyArray.forEach(function (property) {
                try {
                    valueWrap.style[property] = getCSS(el, property);
                } catch (e) {
                    // Older IE has issues with "border"
                    Util.log('html2canvas: Parse: Exception caught in renderFormValue: ' + e.message);
                }
            });

            valueWrap.style.borderColor = 'black';
            valueWrap.style.borderStyle = 'solid';
            valueWrap.style.display = 'block';
            valueWrap.style.position = 'absolute';

            if (/^(submit|reset|button|text|password)$/.test(el.type) || el.nodeName === 'SELECT') {
                valueWrap.style.lineHeight = getCSS(el, 'height');
            }

            valueWrap.style.top = bounds.top + 'px';
            valueWrap.style.left = bounds.left + 'px';

            textValue = el.nodeName === 'SELECT' ? (el.options[el.selectedIndex] || 0).text : el.value;
            if (!textValue) {
                textValue = el.placeholder;
            }

            textNode = doc.createTextNode(textValue);

            valueWrap.appendChild(textNode);
            body.appendChild(valueWrap);

            renderText(el, textNode, stack);
            body.removeChild(valueWrap);
        }

        function drawImage(ctx) {
            ctx.drawImage.apply(ctx, Array.prototype.slice.call(arguments, 1));
            numDraws += 1;
        }

        function getPseudoElement(el, which) {
            var elStyle = window.getComputedStyle(el, which);
            if (!elStyle || !elStyle.content || elStyle.content === 'none' || elStyle.content === '-moz-alt-content' || elStyle.display === 'none') {
                return;
            }
            var content = elStyle.content + '',
                first = content.substr(0, 1);
            // strips quotes
            if (first === content.substr(content.length - 1) && first.match(/'|"/)) {
                content = content.substr(1, content.length - 2);
            }

            var isImage = content.substr(0, 3) === 'url',
                elps = document.createElement(isImage ? 'img' : 'span');

            elps.className = pseudoHide + '-before ' + pseudoHide + '-after';

            Object.keys(elStyle).filter(indexedProperty).forEach(function (prop) {
                // Prevent assigning of read only CSS Rules, ex. length, parentRule
                try {
                    elps.style[prop] = elStyle[prop];
                } catch (e) {
                    Util.log(['Tried to assign readonly property ', prop, 'Error:', e]);
                }
            });

            if (isImage) {
                elps.src = Util.parseBackgroundImage(content)[0].args[0];
            } else {
                elps.innerHTML = content;
            }
            return elps;
        }

        function indexedProperty(property) {
            return isNaN(window.parseInt(property, 10));
        }

        function injectPseudoElements(el, stack) {
            var before = getPseudoElement(el, ':before'),
                after = getPseudoElement(el, ':after');
            if (!before && !after) {
                return;
            }

            if (before) {
                el.className += ' ' + pseudoHide + '-before';
                el.parentNode.insertBefore(before, el);
                parseElement(before, stack, true);
                el.parentNode.removeChild(before);
                el.className = el.className.replace(pseudoHide + '-before', '').trim();
            }

            if (after) {
                el.className += ' ' + pseudoHide + '-after';
                el.appendChild(after);
                parseElement(after, stack, true);
                el.removeChild(after);
                el.className = el.className.replace(pseudoHide + '-after', '').trim();
            }
        }

        function renderBackgroundRepeat(ctx, image, backgroundPosition, bounds) {
            var offsetX = Math.round(bounds.left + backgroundPosition.left),
                offsetY = Math.round(bounds.top + backgroundPosition.top);

            ctx.createPattern(image);
            ctx.translate(offsetX, offsetY);
            ctx.fill();
            ctx.translate(-offsetX, -offsetY);
        }

        function backgroundRepeatShape(ctx, image, backgroundPosition, bounds, left, top, width, height) {
            var args = [];
            args.push(['line', Math.round(left), Math.round(top)]);
            args.push(['line', Math.round(left + width), Math.round(top)]);
            args.push(['line', Math.round(left + width), Math.round(height + top)]);
            args.push(['line', Math.round(left), Math.round(height + top)]);
            createShape(ctx, args);
            ctx.save();
            ctx.clip();
            renderBackgroundRepeat(ctx, image, backgroundPosition, bounds);
            ctx.restore();
        }

        function renderBackgroundColor(ctx, backgroundBounds, bgcolor) {
            renderRect(ctx, backgroundBounds.left, backgroundBounds.top, backgroundBounds.width, backgroundBounds.height, bgcolor);
        }

        function renderBackgroundRepeating(el, bounds, ctx, image, imageIndex) {
            var backgroundSize = Util.BackgroundSize(el, bounds, image, imageIndex),
                backgroundPosition = Util.BackgroundPosition(el, bounds, image, imageIndex, backgroundSize),
                backgroundRepeat = getCSS(el, 'backgroundRepeat').split(',').map(Util.trimText);

            image = resizeImage(image, backgroundSize);

            backgroundRepeat = backgroundRepeat[imageIndex] || backgroundRepeat[0];

            switch (backgroundRepeat) {
                case 'repeat-x':
                    backgroundRepeatShape(ctx, image, backgroundPosition, bounds, bounds.left, bounds.top + backgroundPosition.top, 99999, image.height);
                    break;

                case 'repeat-y':
                    backgroundRepeatShape(ctx, image, backgroundPosition, bounds, bounds.left + backgroundPosition.left, bounds.top, image.width, 99999);
                    break;

                case 'no-repeat':
                    backgroundRepeatShape(ctx, image, backgroundPosition, bounds, bounds.left + backgroundPosition.left, bounds.top + backgroundPosition.top, image.width, image.height);
                    break;

                default:
                    renderBackgroundRepeat(ctx, image, backgroundPosition, {
                        top: bounds.top,
                        left: bounds.left,
                        width: image.width,
                        height: image.height
                    });
                    break;
            }
        }

        function renderBackgroundImage(element, bounds, ctx) {
            var backgroundImage = getCSS(element, 'backgroundImage'),
                backgroundImages = Util.parseBackgroundImage(backgroundImage),
                image,
                imageIndex = backgroundImages.length;

            while (imageIndex--) {
                backgroundImage = backgroundImages[imageIndex];

                if (!backgroundImage.args || backgroundImage.args.length === 0) {
                    continue;
                }

                var key = backgroundImage.method === 'url' ? backgroundImage.args[0] : backgroundImage.value;

                image = loadImage(key);

                // TODO add support for background-origin
                if (image) {
                    renderBackgroundRepeating(element, bounds, ctx, image, imageIndex);
                } else {
                    Util.log('html2canvas: Error loading background:', backgroundImage);
                }
            }
        }

        function resizeImage(image, bounds) {
            if (image.width === bounds.width && image.height === bounds.height) {
                return image;
            }

            var ctx,
                canvas = doc.createElement('canvas');
            canvas.width = bounds.width;
            canvas.height = bounds.height;
            ctx = canvas.getContext('2d');
            drawImage(ctx, image, 0, 0, image.width, image.height, 0, 0, bounds.width, bounds.height);
            return canvas;
        }

        function setOpacity(ctx, element, parentStack) {
            return ctx.setVariable('globalAlpha', getCSS(element, 'opacity') * (parentStack ? parentStack.opacity : 1));
        }

        function removePx(str) {
            return str.replace('px', '');
        }

        var transformRegExp = /(matrix)\((.+)\)/;

        function getTransform(element, parentStack) {
            var transform = getCSS(element, 'transform') || getCSS(element, '-webkit-transform') || getCSS(element, '-moz-transform') || getCSS(element, '-ms-transform') || getCSS(element, '-o-transform');
            var transformOrigin = getCSS(element, 'transform-origin') || getCSS(element, '-webkit-transform-origin') || getCSS(element, '-moz-transform-origin') || getCSS(element, '-ms-transform-origin') || getCSS(element, '-o-transform-origin') || '0px 0px';

            transformOrigin = transformOrigin.split(' ').map(removePx).map(Util.asFloat);

            var matrix;
            if (transform && transform !== 'none') {
                var match = transform.match(transformRegExp);
                if (match) {
                    switch (match[1]) {
                        case 'matrix':
                            matrix = match[2].split(',').map(Util.trimText).map(Util.asFloat);
                            break;
                    }
                }
            }

            return {
                origin: transformOrigin,
                matrix: matrix
            };
        }

        function createStack(element, parentStack, bounds, transform) {
            var ctx = h2cRenderContext(!parentStack ? documentWidth() : bounds.width, !parentStack ? documentHeight() : bounds.height),
                stack = {
                ctx: ctx,
                opacity: setOpacity(ctx, element, parentStack),
                cssPosition: getCSS(element, 'position'),
                borders: getBorderData(element),
                transform: transform,
                clip: parentStack && parentStack.clip ? Util.Extend({}, parentStack.clip) : null
            };

            setZ(element, stack, parentStack);

            // TODO correct overflow for absolute content residing under a static position
            if (options.useOverflow === true && /(hidden|scroll|auto)/.test(getCSS(element, 'overflow')) === true && /(BODY)/i.test(element.nodeName) === false) {
                stack.clip = stack.clip ? clipBounds(stack.clip, bounds) : bounds;
            }

            return stack;
        }

        function getBackgroundBounds(borders, bounds, clip) {
            var backgroundBounds = {
                left: bounds.left + borders[3].width,
                top: bounds.top + borders[0].width,
                width: bounds.width - (borders[1].width + borders[3].width),
                height: bounds.height - (borders[0].width + borders[2].width)
            };

            if (clip) {
                backgroundBounds = clipBounds(backgroundBounds, clip);
            }

            return backgroundBounds;
        }

        function getBounds(element, transform) {
            var bounds = transform.matrix ? Util.OffsetBounds(element) : Util.Bounds(element);
            transform.origin[0] += bounds.left;
            transform.origin[1] += bounds.top;
            return bounds;
        }

        function renderElement(element, parentStack, pseudoElement, ignoreBackground) {
            var transform = getTransform(element, parentStack),
                bounds = getBounds(element, transform),
                image,
                stack = createStack(element, parentStack, bounds, transform),
                borders = stack.borders,
                ctx = stack.ctx,
                backgroundBounds = getBackgroundBounds(borders, bounds, stack.clip),
                borderData = parseBorders(element, bounds, borders),
                backgroundColor = ignoreElementsRegExp.test(element.nodeName) ? '#efefef' : getCSS(element, 'backgroundColor');

            createShape(ctx, borderData.clip);

            ctx.save();
            ctx.clip();

            if (backgroundBounds.height > 0 && backgroundBounds.width > 0 && !ignoreBackground) {
                renderBackgroundColor(ctx, bounds, backgroundColor);
                renderBackgroundImage(element, backgroundBounds, ctx);
            } else if (ignoreBackground) {
                stack.backgroundColor = backgroundColor;
            }

            ctx.restore();

            borderData.borders.forEach(function (border) {
                renderBorders(ctx, border.args, border.color);
            });

            if (!pseudoElement) {
                injectPseudoElements(element, stack);
            }

            switch (element.nodeName) {
                case 'IMG':
                    if (image = loadImage(element.getAttribute('src'))) {
                        renderImage(ctx, element, image, bounds, borders);
                    } else {
                        Util.log('html2canvas: Error loading <img>:' + element.getAttribute('src'));
                    }
                    break;
                case 'INPUT':
                    // TODO add all relevant type's, i.e. HTML5 new stuff
                    // todo add support for placeholder attribute for browsers which support it
                    if (/^(text|url|email|submit|button|reset)$/.test(element.type) && (element.value || element.placeholder || '').length > 0) {
                        renderFormValue(element, bounds, stack);
                    }
                    break;
                case 'TEXTAREA':
                    if ((element.value || element.placeholder || '').length > 0) {
                        renderFormValue(element, bounds, stack);
                    }
                    break;
                case 'SELECT':
                    if ((element.options || element.placeholder || '').length > 0) {
                        renderFormValue(element, bounds, stack);
                    }
                    break;
                case 'LI':
                    renderListItem(element, stack, backgroundBounds);
                    break;
                case 'CANVAS':
                    renderImage(ctx, element, element, bounds, borders);
                    break;
            }

            return stack;
        }

        function isElementVisible(element) {
            return getCSS(element, 'display') !== 'none' && getCSS(element, 'visibility') !== 'hidden' && !element.hasAttribute('data-html2canvas-ignore');
        }

        function parseElement(element, stack, pseudoElement) {
            if (isElementVisible(element)) {
                stack = renderElement(element, stack, pseudoElement, false) || stack;
                if (!ignoreElementsRegExp.test(element.nodeName)) {
                    parseChildren(element, stack, pseudoElement);
                }
            }
        }

        function parseChildren(element, stack, pseudoElement) {
            Util.Children(element).forEach(function (node) {
                if (node.nodeType === node.ELEMENT_NODE) {
                    parseElement(node, stack, pseudoElement);
                } else if (node.nodeType === node.TEXT_NODE) {
                    renderText(element, node, stack);
                }
            });
        }

        function init() {
            var background = options.background || getCSS(document.documentElement, 'backgroundColor'),
                // MJD - added manual background color option
            transparentBackground = Util.isTransparent(background) && element === document.body,
                stack = renderElement(element, null, false, transparentBackground);
            parseChildren(element, stack);

            if (transparentBackground) {
                background = stack.backgroundColor;
            }

            body.removeChild(hidePseudoElements);
            return {
                backgroundColor: background,
                stack: stack
            };
        }

        return init();
    };

    function h2czContext(zindex) {
        return {
            zindex: zindex,
            children: []
        };
    }

    _html2canvas.Preload = function (options) {
        var images = {
            numLoaded: 0, // also failed are counted here
            numFailed: 0,
            numTotal: 0,
            cleanupDone: false
        },
            pageOrigin,
            Util = _html2canvas.Util,
            methods,
            i,
            count = 0,
            element = options.elements[0] || document.body,
            doc = element.ownerDocument,
            domImages = element.getElementsByTagName('img'),
            // Fetch images of the present element only
        imgLen = domImages.length,
            link = doc.createElement('a'),
            supportCORS = function (img) {
            return img.crossOrigin !== undefined;
        }(new Image()),
            timeoutTimer;

        link.href = window.location.href;
        pageOrigin = link.protocol + link.host;

        function isSameOrigin(url) {
            link.href = url;
            link.href = link.href; // YES, BELIEVE IT OR NOT, that is required for IE9 - http://jsfiddle.net/niklasvh/2e48b/
            var origin = link.protocol + link.host;
            return origin === pageOrigin;
        }

        function start() {
            Util.log('html2canvas: start: images: ' + images.numLoaded + ' / ' + images.numTotal + ' (failed: ' + images.numFailed + ')');
            if (!images.firstRun && images.numLoaded >= images.numTotal) {
                Util.log('Finished loading images: # ' + images.numTotal + ' (failed: ' + images.numFailed + ')');

                if (typeof options.complete === 'function') {
                    options.complete(images);
                }
            }
        }

        // TODO modify proxy to serve images with CORS enabled, where available
        function proxyGetImage(url, img, imageObj) {
            var callback_name,
                scriptUrl = options.proxy,
                script;

            link.href = url;
            url = link.href; // work around for pages with base href="" set - WARNING: this may change the url

            callback_name = 'html2canvas_' + count++;
            imageObj.callbackname = callback_name;

            if (scriptUrl.indexOf('?') > -1) {
                scriptUrl += '&';
            } else {
                scriptUrl += '?';
            }
            scriptUrl += 'url=' + encodeURIComponent(url) + '&callback=' + callback_name;
            script = doc.createElement('script');

            window[callback_name] = function (a) {
                if (a.substring(0, 6) === 'error:') {
                    imageObj.succeeded = false;
                    images.numLoaded++;
                    images.numFailed++;
                    start();
                } else {
                    setImageLoadHandlers(img, imageObj);
                    img.src = a;
                }
                window[callback_name] = undefined; // to work with IE<9  // NOTE: that the undefined callback property-name still exists on the window object (for IE<9)
                try {
                    delete window[callback_name]; // for all browser that support this
                } catch (ex) {}
                script.parentNode.removeChild(script);
                script = null;
                delete imageObj.script;
                delete imageObj.callbackname;
            };

            script.setAttribute('type', 'text/javascript');
            script.setAttribute('src', scriptUrl);
            imageObj.script = script;
            window.document.body.appendChild(script);
        }

        function loadPseudoElement(element, type) {
            var style = window.getComputedStyle(element, type),
                content = style.content;
            if (content.substr(0, 3) === 'url') {
                methods.loadImage(_html2canvas.Util.parseBackgroundImage(content)[0].args[0]);
            }
            loadBackgroundImages(style.backgroundImage, element);
        }

        function loadPseudoElementImages(element) {
            loadPseudoElement(element, ':before');
            loadPseudoElement(element, ':after');
        }

        function loadGradientImage(backgroundImage, bounds) {
            var img = _html2canvas.Generate.Gradient(backgroundImage, bounds);

            if (img !== undefined) {
                images[backgroundImage] = {
                    img: img,
                    succeeded: true
                };
                images.numTotal++;
                images.numLoaded++;
                start();
            }
        }

        function invalidBackgrounds(background_image) {
            return background_image && background_image.method && background_image.args && background_image.args.length > 0;
        }

        function loadBackgroundImages(background_image, el) {
            var bounds;

            _html2canvas.Util.parseBackgroundImage(background_image).filter(invalidBackgrounds).forEach(function (background_image) {
                if (background_image.method === 'url') {
                    methods.loadImage(background_image.args[0]);
                } else if (background_image.method.match(/\-?gradient$/)) {
                    if (bounds === undefined) {
                        bounds = _html2canvas.Util.Bounds(el);
                    }
                    loadGradientImage(background_image.value, bounds);
                }
            });
        }

        function getImages(el) {
            var elNodeType = false;

            // Firefox fails with permission denied on pages with iframes
            try {
                Util.Children(el).forEach(getImages);
            } catch (e) {}

            try {
                elNodeType = el.nodeType;
            } catch (ex) {
                elNodeType = false;
                Util.log("html2canvas: failed to access some element's nodeType - Exception: " + ex.message);
            }

            if (elNodeType === 1 || elNodeType === undefined) {
                loadPseudoElementImages(el);
                try {
                    loadBackgroundImages(Util.getCSS(el, 'backgroundImage'), el);
                } catch (e) {
                    Util.log('html2canvas: failed to get background-image - Exception: ' + e.message);
                }
                loadBackgroundImages(el);
            }
        }

        function setImageLoadHandlers(img, imageObj) {
            img.onload = function () {
                if (imageObj.timer !== undefined) {
                    // CORS succeeded
                    window.clearTimeout(imageObj.timer);
                }

                images.numLoaded++;
                imageObj.succeeded = true;
                img.onerror = img.onload = null;
                start();
            };
            img.onerror = function () {
                if (img.crossOrigin === 'anonymous') {
                    // CORS failed
                    window.clearTimeout(imageObj.timer);

                    // let's try with proxy instead
                    if (options.proxy) {
                        var src = img.src;
                        img = new Image();
                        imageObj.img = img;
                        img.src = src;

                        proxyGetImage(img.src, img, imageObj);
                        return;
                    }
                }

                images.numLoaded++;
                images.numFailed++;
                imageObj.succeeded = false;
                img.onerror = img.onload = null;
                start();
            };
        }

        methods = {
            loadImage: function loadImage(src) {
                var img, imageObj;
                if (src && images[src] === undefined) {
                    img = new Image();
                    if (src.match(/data:image\/.*;base64,/i)) {
                        img.src = src.replace(/url\(['"]{0,}|['"]{0,}\)$/ig, '');
                        imageObj = images[src] = {
                            img: img
                        };
                        images.numTotal++;
                        setImageLoadHandlers(img, imageObj);
                    } else if (isSameOrigin(src) || options.allowTaint === true) {
                        imageObj = images[src] = {
                            img: img
                        };
                        images.numTotal++;
                        setImageLoadHandlers(img, imageObj);
                        img.src = src;
                    } else if (supportCORS && !options.allowTaint && options.useCORS) {
                        // attempt to load with CORS

                        img.crossOrigin = 'anonymous';
                        imageObj = images[src] = {
                            img: img
                        };
                        images.numTotal++;
                        setImageLoadHandlers(img, imageObj);
                        img.src = src;
                    } else if (options.proxy) {
                        imageObj = images[src] = {
                            img: img
                        };
                        images.numTotal++;
                        proxyGetImage(src, img, imageObj);
                    }
                }
            },
            cleanupDOM: function cleanupDOM(cause) {
                var img, src;
                if (!images.cleanupDone) {
                    if (cause && typeof cause === 'string') {
                        Util.log('html2canvas: Cleanup because: ' + cause);
                    } else {
                        Util.log('html2canvas: Cleanup after timeout: ' + options.timeout + ' ms.');
                    }

                    for (src in images) {
                        if (images.hasOwnProperty(src)) {
                            img = images[src];
                            if ((typeof img === 'undefined' ? 'undefined' : _typeof(img)) === 'object' && img.callbackname && img.succeeded === undefined) {
                                // cancel proxy image request
                                window[img.callbackname] = undefined; // to work with IE<9  // NOTE: that the undefined callback property-name still exists on the window object (for IE<9)
                                try {
                                    delete window[img.callbackname]; // for all browser that support this
                                } catch (ex) {}
                                if (img.script && img.script.parentNode) {
                                    img.script.setAttribute('src', 'about:blank'); // try to cancel running request
                                    img.script.parentNode.removeChild(img.script);
                                }
                                images.numLoaded++;
                                images.numFailed++;
                                Util.log("html2canvas: Cleaned up failed img: '" + src + "' Steps: " + images.numLoaded + ' / ' + images.numTotal);
                            }
                        }
                    }

                    // cancel any pending requests
                    if (window.stop !== undefined) {
                        window.stop();
                    } else if (document.execCommand !== undefined) {
                        document.execCommand('Stop', false);
                    }
                    if (document.close !== undefined) {
                        document.close();
                    }
                    images.cleanupDone = true;
                    if (!(cause && typeof cause === 'string')) {
                        start();
                    }
                }
            },

            renderingDone: function renderingDone() {
                if (timeoutTimer) {
                    window.clearTimeout(timeoutTimer);
                }
            }
        };

        if (options.timeout > 0) {
            timeoutTimer = window.setTimeout(methods.cleanupDOM, options.timeout);
        }

        Util.log('html2canvas: Preload starts: finding background-images');
        images.firstRun = true;

        getImages(element);

        Util.log('html2canvas: Preload: Finding images');
        // load <img> images
        for (i = 0; i < imgLen; i += 1) {
            methods.loadImage(domImages[i].getAttribute('src'));
        }

        images.firstRun = false;
        Util.log('html2canvas: Preload: Done.');
        if (images.numTotal === images.numLoaded) {
            start();
        }

        return methods;
    };

    _html2canvas.Renderer = function (parseQueue, options) {
        // http://www.w3.org/TR/CSS21/zindex.html
        function createRenderQueue(parseQueue) {
            var queue = [],
                rootContext;

            rootContext = function buildStackingContext(rootNode) {
                var rootContext = {};
                function insert(context, node, specialParent) {
                    var zi = node.zIndex.zindex === 'auto' ? 0 : Number(node.zIndex.zindex),
                        contextForChildren = context,
                        // the stacking context for children
                    isPositioned = node.zIndex.isPositioned,
                        isFloated = node.zIndex.isFloated,
                        stub = { node: node },
                        childrenDest = specialParent; // where children without z-index should be pushed into

                    if (node.zIndex.ownStacking) {
                        // '!' comes before numbers in sorted array
                        contextForChildren = stub.context = { '!': [{ node: node, children: [] }] };
                        childrenDest = undefined;
                    } else if (isPositioned || isFloated) {
                        childrenDest = stub.children = [];
                    }

                    if (zi === 0 && specialParent) {
                        specialParent.push(stub);
                    } else {
                        if (!context[zi]) {
                            context[zi] = [];
                        }
                        context[zi].push(stub);
                    }

                    node.zIndex.children.forEach(function (childNode) {
                        insert(contextForChildren, childNode, childrenDest);
                    });
                }
                insert(rootContext, rootNode);
                return rootContext;
            }(parseQueue);

            function sortZ(context) {
                Object.keys(context).sort().forEach(function (zi) {
                    var nonPositioned = [],
                        floated = [],
                        positioned = [],
                        list = [];

                    // positioned after static
                    context[zi].forEach(function (v) {
                        if (v.node.zIndex.isPositioned || v.node.zIndex.opacity < 1) {
                            // http://www.w3.org/TR/css3-color/#transparency
                            // non-positioned element with opactiy < 1 should be stacked as if it were a positioned element with z-index: 0 and opacity: 1.
                            positioned.push(v);
                        } else if (v.node.zIndex.isFloated) {
                            floated.push(v);
                        } else {
                            nonPositioned.push(v);
                        }
                    });

                    (function walk(arr) {
                        arr.forEach(function (v) {
                            list.push(v);
                            if (v.children) {
                                walk(v.children);
                            }
                        });
                    })(nonPositioned.concat(floated, positioned));

                    list.forEach(function (v) {
                        if (v.context) {
                            sortZ(v.context);
                        } else {
                            queue.push(v.node);
                        }
                    });
                });
            }

            sortZ(rootContext);

            return queue;
        }

        function getRenderer(rendererName) {
            var renderer;

            if (typeof options.renderer === 'string' && _html2canvas.Renderer[rendererName] !== undefined) {
                renderer = _html2canvas.Renderer[rendererName](options);
            } else if (typeof rendererName === 'function') {
                renderer = rendererName(options);
            } else {
                throw new Error('Unknown renderer');
            }

            if (typeof renderer !== 'function') {
                throw new Error('Invalid renderer defined');
            }
            return renderer;
        }

        return getRenderer(options.renderer)(parseQueue, options, document, createRenderQueue(parseQueue.stack), _html2canvas);
    };

    _html2canvas.Util.Support = function (options, doc) {
        function supportSVGRendering() {
            var img = new Image(),
                canvas = doc.createElement('canvas'),
                ctx = canvas.getContext === undefined ? false : canvas.getContext('2d');
            if (ctx === false) {
                return false;
            }
            canvas.width = canvas.height = 10;
            img.src = ['data:image/svg+xml,', "<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'>", "<foreignObject width='10' height='10'>", "<div xmlns='http://www.w3.org/1999/xhtml' style='width:10;height:10;'>", 'sup', '</div>', '</foreignObject>', '</svg>'].join('');
            try {
                ctx.drawImage(img, 0, 0);
                canvas.toDataURL();
            } catch (e) {
                return false;
            }
            _html2canvas.Util.log('html2canvas: Parse: SVG powered rendering available');
            return true;
        }

        // Test whether we can use ranges to measure bounding boxes
        // Opera doesn't provide valid bounds.height/bottom even though it supports the method.

        function supportRangeBounds() {
            var r,
                testElement,
                rangeBounds,
                rangeHeight,
                support = false;

            if (doc.createRange) {
                r = doc.createRange();
                if (r.getBoundingClientRect) {
                    testElement = doc.createElement('boundtest');
                    testElement.style.height = '123px';
                    testElement.style.display = 'block';
                    doc.body.appendChild(testElement);

                    r.selectNode(testElement);
                    rangeBounds = r.getBoundingClientRect();
                    rangeHeight = rangeBounds.height;

                    if (rangeHeight === 123) {
                        support = true;
                    }
                    doc.body.removeChild(testElement);
                }
            }

            return support;
        }

        return {
            rangeBounds: supportRangeBounds(),
            svgRendering: options.svgRendering && supportSVGRendering()
        };
    };
    window.html2canvas = function (elements, opts) {
        elements = elements.length ? elements : [elements];
        var queue,
            canvas,
            options = {
            // general
            logging: false,
            elements: elements,
            background: '#fff',

            // preload options
            proxy: null,
            timeout: 0, // no timeout
            useCORS: false, // try to load images as CORS (where available), before falling back to proxy
            allowTaint: false, // whether to allow images to taint the canvas, won't need proxy if set to true

            // parse options
            svgRendering: false, // use svg powered rendering where available (FF11+)
            ignoreElements: 'IFRAME|OBJECT|PARAM',
            useOverflow: true,
            letterRendering: false,
            chinese: false,

            // render options

            width: null,
            height: null,
            taintTest: true, // do a taint test with all images before applying to canvas
            renderer: 'Canvas'
        };

        options = _html2canvas.Util.Extend(opts, options);

        _html2canvas.logging = options.logging;
        options.complete = function (images) {
            if (typeof options.onpreloaded === 'function') {
                if (options.onpreloaded(images) === false) {
                    return;
                }
            }
            queue = _html2canvas.Parse(images, options);

            if (typeof options.onparsed === 'function') {
                if (options.onparsed(queue) === false) {
                    return;
                }
            }

            canvas = _html2canvas.Renderer(queue, options);

            if (typeof options.onrendered === 'function') {
                options.onrendered(canvas);
            }
        };

        // for pages without images, we still want this to be async, i.e. return methods before executing
        window.setTimeout(function () {
            _html2canvas.Preload(options);
        }, 0);

        return {
            render: function render(queue, opts) {
                return _html2canvas.Renderer(queue, _html2canvas.Util.Extend(opts, options));
            },
            parse: function parse(images, opts) {
                return _html2canvas.Parse(images, _html2canvas.Util.Extend(opts, options));
            },
            preload: function preload(opts) {
                return _html2canvas.Preload(_html2canvas.Util.Extend(opts, options));
            },
            log: _html2canvas.Util.log
        };
    };

    window.html2canvas.log = _html2canvas.Util.log; // for renderers
    window.html2canvas.Renderer = {
        Canvas: undefined // We are assuming this will be used
    };
    _html2canvas.Renderer.Canvas = function (options) {
        options = options || {};

        var doc = document,
            safeImages = [],
            testCanvas = document.createElement('canvas'),
            testctx = testCanvas.getContext('2d'),
            Util = _html2canvas.Util,
            canvas = options.canvas || doc.createElement('canvas');

        function createShape(ctx, args) {
            ctx.beginPath();
            args.forEach(function (arg) {
                ctx[arg.name].apply(ctx, arg['arguments']);
            });
            ctx.closePath();
        }

        function safeImage(item) {
            if (safeImages.indexOf(item['arguments'][0].src) === -1) {
                testctx.drawImage(item['arguments'][0], 0, 0);
                try {
                    testctx.getImageData(0, 0, 1, 1);
                } catch (e) {
                    testCanvas = doc.createElement('canvas');
                    testctx = testCanvas.getContext('2d');
                    return false;
                }
                safeImages.push(item['arguments'][0].src);
            }
            return true;
        }

        function renderItem(ctx, item) {
            switch (item.type) {
                case 'variable':
                    ctx[item.name] = item['arguments'];
                    break;
                case 'function':
                    switch (item.name) {
                        case 'createPattern':
                            if (item['arguments'][0].width > 0 && item['arguments'][0].height > 0) {
                                try {
                                    ctx.fillStyle = ctx.createPattern(item['arguments'][0], 'repeat');
                                } catch (e) {
                                    Util.log('html2canvas: Renderer: Error creating pattern', e.message);
                                }
                            }
                            break;
                        case 'drawShape':
                            createShape(ctx, item['arguments']);
                            break;
                        case 'drawImage':
                            if (item['arguments'][8] > 0 && item['arguments'][7] > 0) {
                                if (!options.taintTest || options.taintTest && safeImage(item)) {
                                    ctx.drawImage.apply(ctx, item['arguments']);
                                }
                            }
                            break;
                        default:
                            ctx[item.name].apply(ctx, item['arguments']);
                    }
                    break;
            }
        }

        return function (parsedData, options, document, queue, _html2canvas) {
            var ctx = canvas.getContext('2d'),
                newCanvas,
                bounds,
                fstyle,
                zStack = parsedData.stack;

            canvas.width = canvas.style.width = options.width || zStack.ctx.width;
            canvas.height = canvas.style.height = options.height || zStack.ctx.height;

            fstyle = ctx.fillStyle;
            ctx.fillStyle = Util.isTransparent(zStack.backgroundColor) && options.background !== undefined ? options.background : parsedData.backgroundColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = fstyle;

            queue.forEach(function (storageContext) {
                // set common settings for canvas
                ctx.textBaseline = 'bottom';
                ctx.save();

                if (storageContext.transform.matrix) {
                    ctx.translate(storageContext.transform.origin[0], storageContext.transform.origin[1]);
                    ctx.transform.apply(ctx, storageContext.transform.matrix);
                    ctx.translate(-storageContext.transform.origin[0], -storageContext.transform.origin[1]);
                }

                if (storageContext.clip) {
                    ctx.beginPath();
                    ctx.rect(storageContext.clip.left, storageContext.clip.top, storageContext.clip.width, storageContext.clip.height);
                    ctx.clip();
                }

                if (storageContext.ctx.storage) {
                    storageContext.ctx.storage.forEach(function (item) {
                        renderItem(ctx, item);
                    });
                }

                ctx.restore();
            });

            Util.log('html2canvas: Renderer: Canvas renderer done - returning canvas obj');

            if (options.elements.length === 1) {
                if (_typeof(options.elements[0]) === 'object' && options.elements[0].nodeName !== 'BODY') {
                    // crop image to the bounds of selected (single) element
                    bounds = _html2canvas.Util.Bounds(options.elements[0]);
                    newCanvas = document.createElement('canvas');
                    newCanvas.width = Math.ceil(bounds.width);
                    newCanvas.height = Math.ceil(bounds.height);
                    ctx = newCanvas.getContext('2d');

                    ctx.drawImage(canvas, bounds.left, bounds.top, bounds.width, bounds.height, 0, 0, bounds.width, bounds.height);
                    canvas = null;
                    return newCanvas;
                }
            }

            return canvas;
        };
    };
})(window, document);

/***/ }),
/* 71 */
/***/ (function(module, exports) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*eslint-disable*/
// too many eslint violations, this file has a high risk of being damaged 
// by eslint modifications
/*! tether 0.6.5 */

// Modified to remove AMD support, and attach Tether to the pendo object
(function () {
    (function () {
        var Evented,
            addClass,
            defer,
            deferred,
            extend,
            flush,
            getBounds,
            getClassName,
            getOffsetParent,
            getOrigin,
            getScrollBarSize,
            getScrollParent,
            hasClass,
            node,
            removeClass,
            setClassName,
            uniqueId,
            updateClasses,
            zeroPosCache,
            __hasProp = {}.hasOwnProperty,
            __indexOf = [].indexOf || function (item) {
            for (var i = 0, l = this.length; i < l; i++) {
                if (i in this && this[i] === item) return i;
            }return -1;
        },
            __slice = [].slice;

        if (this.Tether == null) {
            this.Tether = {
                modules: []
            };
        }

        var body = window.pendo && pendo.designer ? pendo.designer.dom.getBody ? pendo.designer.dom.getBody() : document.body : document.body;

        getScrollParent = function getScrollParent(el) {
            var parent, position, scrollParent, style, _ref, isRelative;
            position = getComputedStyle(el).position;
            if (position === 'fixed') {
                return el;
            }
            scrollParent = void 0;
            parent = el;
            isRelative = false;
            while (parent = parent.parentNode) {
                try {
                    style = getComputedStyle(parent);
                } catch (_error) {}
                if (style == null) {
                    return parent;
                }
                if (style['position'] === 'relative') {
                    isRelative;
                }
                if (/(auto|scroll)/.test(style['overflow'] + style['overflowY'] + style['overflowX'])) {
                    if (position !== 'absolute' || position === 'absolute' && isRelative || (_ref = style['position']) === 'relative' || _ref === 'absolute' || _ref === 'fixed') {
                        return parent;
                    }
                }
            }
            return body;
        };

        uniqueId = function () {
            var id;
            id = 0;
            return function () {
                return id++;
            };
        }();

        zeroPosCache = {};

        getOrigin = function getOrigin(doc) {
            var id, k, node, v, _ref;
            node = doc._tetherZeroElement;
            if (node == null) {
                node = doc.createElement('div');
                node.setAttribute('data-tether-id', uniqueId());
                extend(node.style, {
                    top: 0,
                    left: 0,
                    position: 'absolute'
                });
                doc.body.appendChild(node);
                doc._tetherZeroElement = node;
            }
            id = node.getAttribute('data-tether-id');
            if (zeroPosCache[id] == null) {
                zeroPosCache[id] = {};
                _ref = node.getBoundingClientRect();
                for (k in _ref) {
                    v = _ref[k];
                    zeroPosCache[id][k] = v;
                }
                defer(function () {
                    return zeroPosCache[id] = void 0;
                });
            }
            return zeroPosCache[id];
        };

        node = null;

        getBounds = function getBounds(el) {
            var box, doc, docEl, k, origin, v, _ref;
            if (el === document) {
                doc = document;
                el = document.documentElement;
            } else {
                doc = el.ownerDocument;
            }
            docEl = doc.documentElement;
            box = {};
            _ref = el.getBoundingClientRect();
            for (k in _ref) {
                v = _ref[k];
                box[k] = v;
            }
            origin = getOrigin(doc);
            box.top -= origin.top;
            box.left -= origin.left;
            if (box.width == null) {
                box.width = body.scrollWidth - box.left - box.right;
            }
            if (box.height == null) {
                box.height = body.scrollHeight - box.top - box.bottom;
            }
            box.top = box.top - docEl.clientTop;
            box.left = box.left - docEl.clientLeft;
            box.right = doc.body.clientWidth - box.width - box.left;
            box.bottom = doc.body.clientHeight - box.height - box.top;
            return box;
        };

        getOffsetParent = function getOffsetParent(el) {
            return el.offsetParent || document.documentElement;
        };

        getScrollBarSize = function getScrollBarSize() {
            var inner, outer, width, widthContained, widthScroll;
            inner = document.createElement('div');
            inner.style.width = '100%';
            inner.style.height = '200px';
            outer = document.createElement('div');
            extend(outer.style, {
                position: 'absolute',
                top: 0,
                left: 0,
                pointerEvents: 'none',
                visibility: 'hidden',
                width: '200px',
                height: '150px',
                overflow: 'hidden'
            });
            outer.appendChild(inner);
            body.appendChild(outer);
            widthContained = inner.offsetWidth;
            outer.style.overflow = 'scroll';
            widthScroll = inner.offsetWidth;
            if (widthContained === widthScroll) {
                widthScroll = outer.clientWidth;
            }
            body.removeChild(outer);
            width = widthContained - widthScroll;
            return {
                width: width,
                height: width
            };
        };

        extend = function extend(out) {
            var args, key, obj, val, _i, _len, _ref;
            if (out == null) {
                out = {};
            }
            args = [];
            Array.prototype.push.apply(args, arguments);
            _ref = args.slice(1);
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                obj = _ref[_i];
                if (obj) {
                    for (key in obj) {
                        if (!__hasProp.call(obj, key)) continue;
                        val = obj[key];
                        out[key] = val;
                    }
                }
            }
            return out;
        };

        removeClass = function removeClass(el, name) {
            var className, cls, _i, _len, _ref, _results;
            if (el.classList != null) {
                _ref = name.split(' ');
                _results = [];
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                    cls = _ref[_i];
                    if (cls.trim()) {
                        _results.push(el.classList.remove(cls));
                    }
                }
                return _results;
            } else {
                className = getClassName(el).replace(new RegExp('(^| )' + name.split(' ').join('|') + '( |$)', 'gi'), ' ');
                return setClassName(el, className);
            }
        };

        addClass = function addClass(el, name) {
            var cls, _i, _len, _ref, _results;
            if (el.classList != null) {
                _ref = name.split(' ');
                _results = [];
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                    cls = _ref[_i];
                    if (cls.trim()) {
                        _results.push(el.classList.add(cls));
                    }
                }
                return _results;
            } else {
                removeClass(el, name);
                cls = getClassName(el) + (' ' + name);
                return setClassName(el, cls);
            }
        };

        hasClass = function hasClass(el, name) {
            if (el.classList != null) {
                return el.classList.contains(name);
            } else {
                return new RegExp('(^| )' + name + '( |$)', 'gi').test(getClassName(el));
            }
        };

        getClassName = function getClassName(el) {
            if (el.className instanceof SVGAnimatedString) {
                return el.className.baseVal;
            } else {
                return el.className;
            }
        };

        setClassName = function setClassName(el, className) {
            return el.setAttribute('class', className);
        };

        updateClasses = function updateClasses(el, add, all) {
            var cls, _i, _j, _len, _len1, _results;
            for (_i = 0, _len = all.length; _i < _len; _i++) {
                cls = all[_i];
                if (__indexOf.call(add, cls) < 0) {
                    if (hasClass(el, cls)) {
                        removeClass(el, cls);
                    }
                }
            }
            _results = [];
            for (_j = 0, _len1 = add.length; _j < _len1; _j++) {
                cls = add[_j];
                if (!hasClass(el, cls)) {
                    _results.push(addClass(el, cls));
                } else {
                    _results.push(void 0);
                }
            }
            return _results;
        };

        deferred = [];

        defer = function defer(fn) {
            return deferred.push(fn);
        };

        flush = function flush() {
            var fn, _results;
            _results = [];
            while (fn = deferred.pop()) {
                _results.push(fn());
            }
            return _results;
        };

        Evented = function () {
            function Evented() {}

            Evented.prototype.on = function (event, handler, ctx, once) {
                var _base;
                if (once == null) {
                    once = false;
                }
                if (this.bindings == null) {
                    this.bindings = {};
                }
                if ((_base = this.bindings)[event] == null) {
                    _base[event] = [];
                }
                return this.bindings[event].push({
                    handler: handler,
                    ctx: ctx,
                    once: once
                });
            };

            Evented.prototype.once = function (event, handler, ctx) {
                return this.on(event, handler, ctx, true);
            };

            Evented.prototype.off = function (event, handler) {
                var i, _ref, _results;
                if (((_ref = this.bindings) != null ? _ref[event] : void 0) == null) {
                    return;
                }
                if (handler == null) {
                    return delete this.bindings[event];
                } else {
                    i = 0;
                    _results = [];
                    while (i < this.bindings[event].length) {
                        if (this.bindings[event][i].handler === handler) {
                            _results.push(this.bindings[event].splice(i, 1));
                        } else {
                            _results.push(i++);
                        }
                    }
                    return _results;
                }
            };

            Evented.prototype.trigger = function () {
                var args, ctx, event, handler, i, once, _ref, _ref1, _results;
                event = arguments[0], args = arguments.length >= 2 ? __slice.call(arguments, 1) : [];
                if ((_ref = this.bindings) != null ? _ref[event] : void 0) {
                    i = 0;
                    _results = [];
                    while (i < this.bindings[event].length) {
                        _ref1 = this.bindings[event][i], handler = _ref1.handler, ctx = _ref1.ctx, once = _ref1.once;
                        handler.apply(ctx != null ? ctx : this, args);
                        if (once) {
                            _results.push(this.bindings[event].splice(i, 1));
                        } else {
                            _results.push(i++);
                        }
                    }
                    return _results;
                }
            };

            return Evented;
        }();

        this.Tether.Utils = {
            getScrollParent: getScrollParent,
            getBounds: getBounds,
            getOffsetParent: getOffsetParent,
            extend: extend,
            addClass: addClass,
            removeClass: removeClass,
            hasClass: hasClass,
            updateClasses: updateClasses,
            defer: defer,
            flush: flush,
            uniqueId: uniqueId,
            Evented: Evented,
            getScrollBarSize: getScrollBarSize
        };
    }).call(this);

    (function () {
        var MIRROR_LR,
            MIRROR_TB,
            OFFSET_MAP,
            Tether,
            addClass,
            addOffset,
            attachmentToOffset,
            autoToFixedAttachment,
            defer,
            extend,
            flush,
            getBounds,
            getOffsetParent,
            getOuterSize,
            getScrollBarSize,
            getScrollParent,
            getSize,
            now,
            offsetToPx,
            parseAttachment,
            parseOffset,
            position,
            removeClass,
            tethers,
            transformKey,
            updateClasses,
            within,
            _Tether,
            _ref,
            __slice = [].slice,
            __bind = function __bind(fn, me) {
            return function () {
                return fn.apply(me, arguments);
            };
        };

        if (this.Tether == null) {
            throw new Error('You must include the utils.js file before tether.js');
        }

        Tether = this.Tether;

        _ref = Tether.Utils, getScrollParent = _ref.getScrollParent, getSize = _ref.getSize, getOuterSize = _ref.getOuterSize, getBounds = _ref.getBounds, getOffsetParent = _ref.getOffsetParent, extend = _ref.extend, addClass = _ref.addClass, removeClass = _ref.removeClass, updateClasses = _ref.updateClasses, defer = _ref.defer, flush = _ref.flush, getScrollBarSize = _ref.getScrollBarSize;

        within = function within(a, b, diff) {
            if (diff == null) {
                diff = 1;
            }
            return a + diff >= b && b >= a - diff;
        };

        transformKey = function () {
            var el, key, _i, _len, _ref1;
            el = document.createElement('div');
            _ref1 = ['transform', 'webkitTransform', 'OTransform', 'MozTransform', 'msTransform'];
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                key = _ref1[_i];
                if (el.style[key] !== void 0) {
                    return key;
                }
            }
        }();

        tethers = [];

        position = function position() {
            var tether, _i, _len;
            for (_i = 0, _len = tethers.length; _i < _len; _i++) {
                tether = tethers[_i];
                tether.position(false);
            }
            return flush();
        };

        now = function now() {
            var _ref1;
            return (_ref1 = typeof performance !== 'undefined' && performance !== null ? typeof performance.now === 'function' ? performance.now() : void 0 : void 0) != null ? _ref1 : +new Date();
        };

        (function () {
            var event, lastCall, lastDuration, pendingTimeout, _tick, _i, _len, _ref1, _results;
            lastCall = null;
            lastDuration = null;
            pendingTimeout = null;
            _tick = function tick() {
                if (lastDuration != null && lastDuration > 16) {
                    lastDuration = Math.min(lastDuration - 16, 250);
                    pendingTimeout = setTimeout(_tick, 250);
                    return;
                }
                if (lastCall != null && now() - lastCall < 10) {
                    return;
                }
                if (pendingTimeout != null) {
                    clearTimeout(pendingTimeout);
                    pendingTimeout = null;
                }
                lastCall = now();
                position();
                return lastDuration = now() - lastCall;
            };
            _ref1 = ['resize', 'scroll', 'touchmove'];
            _results = [];
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                event = _ref1[_i];
                _results.push(window.addEventListener(event, _tick));
            }
            return _results;
        })();

        MIRROR_LR = {
            center: 'center',
            left: 'right',
            right: 'left'
        };

        MIRROR_TB = {
            middle: 'middle',
            top: 'bottom',
            bottom: 'top'
        };

        OFFSET_MAP = {
            top: 0,
            left: 0,
            middle: '50%',
            center: '50%',
            bottom: '100%',
            right: '100%'
        };

        autoToFixedAttachment = function autoToFixedAttachment(attachment, relativeToAttachment) {
            var left, top;
            left = attachment.left, top = attachment.top;
            if (left === 'auto') {
                left = MIRROR_LR[relativeToAttachment.left];
            }
            if (top === 'auto') {
                top = MIRROR_TB[relativeToAttachment.top];
            }
            return {
                left: left,
                top: top
            };
        };

        attachmentToOffset = function attachmentToOffset(attachment) {
            var _ref1, _ref2;
            return {
                left: (_ref1 = OFFSET_MAP[attachment.left]) != null ? _ref1 : attachment.left,
                top: (_ref2 = OFFSET_MAP[attachment.top]) != null ? _ref2 : attachment.top
            };
        };

        addOffset = function addOffset() {
            var left, offsets, out, top, _i, _len, _ref1;
            offsets = arguments.length >= 1 ? __slice.call(arguments, 0) : [];
            out = {
                top: 0,
                left: 0
            };
            for (_i = 0, _len = offsets.length; _i < _len; _i++) {
                _ref1 = offsets[_i], top = _ref1.top, left = _ref1.left;
                if (typeof top === 'string') {
                    top = parseFloat(top, 10);
                }
                if (typeof left === 'string') {
                    left = parseFloat(left, 10);
                }
                out.top += top;
                out.left += left;
            }
            return out;
        };

        offsetToPx = function offsetToPx(offset, size) {
            if (typeof offset.left === 'string' && offset.left.indexOf('%') !== -1) {
                offset.left = parseFloat(offset.left, 10) / 100 * size.width;
            }
            if (typeof offset.top === 'string' && offset.top.indexOf('%') !== -1) {
                offset.top = parseFloat(offset.top, 10) / 100 * size.height;
            }
            return offset;
        };

        parseAttachment = parseOffset = function parseOffset(value) {
            var left, top, _ref1;
            _ref1 = value.split(' '), top = _ref1[0], left = _ref1[1];
            return {
                top: top,
                left: left
            };
        };

        _Tether = function () {
            _Tether.modules = [];

            function _Tether(options) {
                this.position = __bind(this.position, this);
                var module, _i, _len, _ref1, _ref2;
                tethers.push(this);
                this.history = [];
                this.setOptions(options, false);
                _ref1 = Tether.modules;
                for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                    module = _ref1[_i];
                    if ((_ref2 = module.initialize) != null) {
                        _ref2.call(this);
                    }
                }
                this.position();
            }

            _Tether.prototype.getClass = function (key) {
                var _ref1, _ref2;
                if ((_ref1 = this.options.classes) != null ? _ref1[key] : void 0) {
                    return this.options.classes[key];
                } else if (((_ref2 = this.options.classes) != null ? _ref2[key] : void 0) !== false) {
                    if (this.options.classPrefix) {
                        return '' + this.options.classPrefix + '-' + key;
                    } else {
                        return key;
                    }
                } else {
                    return '';
                }
            };

            _Tether.prototype.setOptions = function (options, position) {
                var defaults, key, _i, _len, _ref1, _ref2;
                this.options = options;
                if (position == null) {
                    position = true;
                }
                defaults = {
                    offset: '0 0',
                    targetOffset: '0 0',
                    targetAttachment: 'auto auto',
                    classPrefix: 'tether'
                };
                this.options = extend(defaults, this.options);
                _ref1 = this.options, this.element = _ref1.element, this.target = _ref1.target, this.targetModifier = _ref1.targetModifier;
                if (this.target === 'viewport') {
                    this.target = body;
                    this.targetModifier = 'visible';
                } else if (this.target === 'scroll-handle') {
                    this.target = body;
                    this.targetModifier = 'scroll-handle';
                }
                _ref2 = ['element', 'target'];
                for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
                    key = _ref2[_i];
                    if (this[key] == null) {
                        throw new Error('Tether Error: Both element and target must be defined');
                    }
                    if (this[key].jquery != null) {
                        this[key] = this[key][0];
                    } else if (typeof this[key] === 'string') {
                        this[key] = document.querySelector(this[key]);
                    }
                }
                addClass(this.element, this.getClass('element'));
                addClass(this.target, this.getClass('target'));
                if (!this.options.attachment) {
                    throw new Error('Tether Error: You must provide an attachment');
                }
                this.targetAttachment = parseAttachment(this.options.targetAttachment);
                this.attachment = parseAttachment(this.options.attachment);
                this.offset = parseOffset(this.options.offset);
                this.targetOffset = parseOffset(this.options.targetOffset);
                if (this.scrollParent != null) {
                    this.disable();
                }
                if (this.targetModifier === 'scroll-handle') {
                    this.scrollParent = this.target;
                } else {
                    this.scrollParent = getScrollParent(this.target);
                }
                if (this.options.enabled !== false) {
                    return this.enable(position);
                }
            };

            _Tether.prototype.getTargetBounds = function () {
                var bounds, fitAdj, hasBottomScroll, height, out, scrollBottom, scrollPercentage, style, target;
                if (this.targetModifier != null) {
                    switch (this.targetModifier) {
                        case 'visible':
                            if (this.target === body) {
                                return {
                                    top: pageYOffset,
                                    left: pageXOffset,
                                    height: innerHeight,
                                    width: innerWidth
                                };
                            } else {
                                bounds = getBounds(this.target);
                                out = {
                                    height: bounds.height,
                                    width: bounds.width,
                                    top: bounds.top,
                                    left: bounds.left
                                };
                                out.height = Math.min(out.height, bounds.height - (pageYOffset - bounds.top));
                                out.height = Math.min(out.height, bounds.height - (bounds.top + bounds.height - (pageYOffset + innerHeight)));
                                out.height = Math.min(innerHeight, out.height);
                                out.height -= 2;
                                out.width = Math.min(out.width, bounds.width - (pageXOffset - bounds.left));
                                out.width = Math.min(out.width, bounds.width - (bounds.left + bounds.width - (pageXOffset + innerWidth)));
                                out.width = Math.min(innerWidth, out.width);
                                out.width -= 2;
                                if (out.top < pageYOffset) {
                                    out.top = pageYOffset;
                                }
                                if (out.left < pageXOffset) {
                                    out.left = pageXOffset;
                                }
                                return out;
                            }
                            break;
                        case 'scroll-handle':
                            target = this.target;
                            if (target === body) {
                                target = document.documentElement;
                                bounds = {
                                    left: pageXOffset,
                                    top: pageYOffset,
                                    height: innerHeight,
                                    width: innerWidth
                                };
                            } else {
                                bounds = getBounds(target);
                            }
                            style = getComputedStyle(target);
                            hasBottomScroll = target.scrollWidth > target.clientWidth || [style.overflow, style.overflowX] === 'scroll' || this.target !== document.body;
                            scrollBottom = 0;
                            if (hasBottomScroll) {
                                scrollBottom = 15;
                            }
                            height = bounds.height - parseFloat(style.borderTopWidth) - parseFloat(style.borderBottomWidth) - scrollBottom;
                            out = {
                                width: 15,
                                height: height * 0.975 * (height / target.scrollHeight),
                                left: bounds.left + bounds.width - parseFloat(style.borderLeftWidth) - 15
                            };
                            fitAdj = 0;
                            if (height < 408 && this.target === document.body) {
                                fitAdj = -0.00011 * Math.pow(height, 2) - 0.00727 * height + 22.58;
                            }
                            if (this.target !== document.body) {
                                out.height = Math.max(out.height, 24);
                            }
                            scrollPercentage = this.target.scrollTop / (target.scrollHeight - height);
                            out.top = scrollPercentage * (height - out.height - fitAdj) + bounds.top + parseFloat(style.borderTopWidth);
                            if (this.target === document.body) {
                                out.height = Math.max(out.height, 24);
                            }
                            return out;
                    }
                } else {
                    return getBounds(this.target);
                }
            };

            _Tether.prototype.clearCache = function () {
                return this._cache = {};
            };

            _Tether.prototype.cache = function (k, getter) {
                if (this._cache == null) {
                    this._cache = {};
                }
                if (this._cache[k] == null) {
                    this._cache[k] = getter.call(this);
                }
                return this._cache[k];
            };

            _Tether.prototype.enable = function (position) {
                if (position == null) {
                    position = true;
                }
                addClass(this.target, this.getClass('enabled'));
                addClass(this.element, this.getClass('enabled'));
                this.enabled = true;
                if (this.scrollParent !== document) {
                    this.scrollParent.addEventListener('scroll', this.position);
                }
                if (position) {
                    return this.position();
                }
            };

            _Tether.prototype.disable = function () {
                removeClass(this.target, this.getClass('enabled'));
                removeClass(this.element, this.getClass('enabled'));
                this.enabled = false;
                if (this.scrollParent != null) {
                    return this.scrollParent.removeEventListener('scroll', this.position);
                }
            };

            _Tether.prototype.destroy = function () {
                var i, tether, _i, _len, _results;
                this.disable();
                _results = [];
                for (i = _i = 0, _len = tethers.length; _i < _len; i = ++_i) {
                    tether = tethers[i];
                    if (tether === this) {
                        tethers.splice(i, 1);
                        break;
                    } else {
                        _results.push(void 0);
                    }
                }
                return _results;
            };

            _Tether.prototype.updateAttachClasses = function (elementAttach, targetAttach) {
                var add,
                    all,
                    side,
                    sides,
                    _i,
                    _j,
                    _len,
                    _len1,
                    _ref1,
                    _this = this;
                if (elementAttach == null) {
                    elementAttach = this.attachment;
                }
                if (targetAttach == null) {
                    targetAttach = this.targetAttachment;
                }
                sides = ['left', 'top', 'bottom', 'right', 'middle', 'center'];
                if ((_ref1 = this._addAttachClasses) != null ? _ref1.length : void 0) {
                    this._addAttachClasses.splice(0, this._addAttachClasses.length);
                }
                add = this._addAttachClasses != null ? this._addAttachClasses : this._addAttachClasses = [];
                if (elementAttach.top) {
                    add.push('' + this.getClass('element-attached') + '-' + elementAttach.top);
                }
                if (elementAttach.left) {
                    add.push('' + this.getClass('element-attached') + '-' + elementAttach.left);
                }
                if (targetAttach.top) {
                    add.push('' + this.getClass('target-attached') + '-' + targetAttach.top);
                }
                if (targetAttach.left) {
                    add.push('' + this.getClass('target-attached') + '-' + targetAttach.left);
                }
                all = [];
                for (_i = 0, _len = sides.length; _i < _len; _i++) {
                    side = sides[_i];
                    all.push('' + this.getClass('element-attached') + '-' + side);
                }
                for (_j = 0, _len1 = sides.length; _j < _len1; _j++) {
                    side = sides[_j];
                    all.push('' + this.getClass('target-attached') + '-' + side);
                }
                return defer(function () {
                    if (_this._addAttachClasses == null) {
                        return;
                    }
                    updateClasses(_this.element, _this._addAttachClasses, all);
                    updateClasses(_this.target, _this._addAttachClasses, all);
                    return _this._addAttachClasses = void 0;
                });
            };

            _Tether.prototype.position = function (flushChanges) {
                var elementPos,
                    elementStyle,
                    height,
                    left,
                    manualOffset,
                    manualTargetOffset,
                    module,
                    next,
                    offset,
                    offsetBorder,
                    offsetParent,
                    offsetParentSize,
                    offsetParentStyle,
                    offsetPosition,
                    ret,
                    scrollLeft,
                    scrollTop,
                    scrollbarSize,
                    side,
                    targetAttachment,
                    targetOffset,
                    targetPos,
                    targetSize,
                    top,
                    width,
                    _i,
                    _j,
                    _len,
                    _len1,
                    _ref1,
                    _ref2,
                    _ref3,
                    _ref4,
                    _ref5,
                    _ref6,
                    _this = this;
                if (flushChanges == null) {
                    flushChanges = true;
                }
                if (!this.enabled) {
                    return;
                }
                this.clearCache();
                targetAttachment = autoToFixedAttachment(this.targetAttachment, this.attachment);
                this.updateAttachClasses(this.attachment, targetAttachment);
                elementPos = this.cache('element-bounds', function () {
                    return getBounds(_this.element);
                });
                width = elementPos.width, height = elementPos.height;
                if (width === 0 && height === 0 && this.lastSize != null) {
                    _ref1 = this.lastSize, width = _ref1.width, height = _ref1.height;
                } else {
                    this.lastSize = {
                        width: width,
                        height: height
                    };
                }
                targetSize = targetPos = this.cache('target-bounds', function () {
                    return _this.getTargetBounds();
                });
                offset = offsetToPx(attachmentToOffset(this.attachment), {
                    width: width,
                    height: height
                });
                targetOffset = offsetToPx(attachmentToOffset(targetAttachment), targetSize);
                manualOffset = offsetToPx(this.offset, {
                    width: width,
                    height: height
                });
                manualTargetOffset = offsetToPx(this.targetOffset, targetSize);
                offset = addOffset(offset, manualOffset);
                targetOffset = addOffset(targetOffset, manualTargetOffset);
                left = targetPos.left + targetOffset.left - offset.left;
                top = targetPos.top + targetOffset.top - offset.top;
                _ref2 = Tether.modules;
                for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
                    module = _ref2[_i];
                    ret = module.position.call(this, {
                        left: left,
                        top: top,
                        targetAttachment: targetAttachment,
                        targetPos: targetPos,
                        attachment: this.attachment,
                        elementPos: elementPos,
                        offset: offset,
                        targetOffset: targetOffset,
                        manualOffset: manualOffset,
                        manualTargetOffset: manualTargetOffset,
                        scrollbarSize: scrollbarSize
                    });
                    if (ret == null || (typeof ret === 'undefined' ? 'undefined' : _typeof(ret)) !== 'object') {
                        continue;
                    } else if (ret === false) {
                        return false;
                    } else {
                        top = ret.top, left = ret.left;
                    }
                }
                next = {
                    page: {
                        top: top,
                        left: left
                    },
                    viewport: {
                        top: top - pageYOffset,
                        bottom: pageYOffset - top - height + innerHeight,
                        left: left - pageXOffset,
                        right: pageXOffset - left - width + innerWidth
                    }
                };
                if (document.body.scrollWidth > window.innerWidth) {
                    scrollbarSize = this.cache('scrollbar-size', getScrollBarSize);
                    next.viewport.bottom -= scrollbarSize.height;
                }
                if (document.body.scrollHeight > window.innerHeight) {
                    scrollbarSize = this.cache('scrollbar-size', getScrollBarSize);
                    next.viewport.right -= scrollbarSize.width;
                }
                if ((_ref3 = document.body.style.position) !== '' && _ref3 !== 'static' || (_ref4 = document.body.parentElement.style.position) !== '' && _ref4 !== 'static') {
                    next.page.bottom = document.body.scrollHeight - top - height;
                    next.page.right = document.body.scrollWidth - left - width;
                }
                if (((_ref5 = this.options.optimizations) != null ? _ref5.moveElement : void 0) !== false && this.targetModifier == null) {
                    offsetParent = this.cache('target-offsetparent', function () {
                        return getOffsetParent(_this.target);
                    });
                    offsetPosition = this.cache('target-offsetparent-bounds', function () {
                        return getBounds(offsetParent);
                    });
                    offsetParentStyle = getComputedStyle(offsetParent);
                    elementStyle = getComputedStyle(this.element);
                    offsetParentSize = offsetPosition;
                    offsetBorder = {};
                    _ref6 = ['Top', 'Left', 'Bottom', 'Right'];
                    for (_j = 0, _len1 = _ref6.length; _j < _len1; _j++) {
                        side = _ref6[_j];
                        offsetBorder[side.toLowerCase()] = parseFloat(offsetParentStyle['border' + side + 'Width']);
                    }
                    offsetPosition.right = document.body.scrollWidth - offsetPosition.left - offsetParentSize.width + offsetBorder.right;
                    offsetPosition.bottom = document.body.scrollHeight - offsetPosition.top - offsetParentSize.height + offsetBorder.bottom;
                    if (next.page.top >= offsetPosition.top + offsetBorder.top && next.page.bottom >= offsetPosition.bottom) {
                        if (next.page.left >= offsetPosition.left + offsetBorder.left && next.page.right >= offsetPosition.right) {
                            scrollTop = offsetParent.scrollTop;
                            scrollLeft = offsetParent.scrollLeft;
                            next.offset = {
                                top: next.page.top - offsetPosition.top + scrollTop - offsetBorder.top,
                                left: next.page.left - offsetPosition.left + scrollLeft - offsetBorder.left
                            };
                        }
                    }
                }
                this.move(next);
                this.history.unshift(next);
                if (this.history.length > 3) {
                    this.history.pop();
                }
                if (flushChanges) {
                    flush();
                }
                return true;
            };

            _Tether.prototype.move = function (position) {
                var css,
                    elVal,
                    found,
                    key,
                    moved,
                    offsetParent,
                    point,
                    same,
                    transcribe,
                    type,
                    val,
                    write,
                    writeCSS,
                    _i,
                    _len,
                    _ref1,
                    _ref2,
                    _this = this;
                if (this.element.parentNode == null) {
                    return;
                }
                same = {};
                for (type in position) {
                    same[type] = {};
                    for (key in position[type]) {
                        found = false;
                        _ref1 = this.history;
                        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                            point = _ref1[_i];
                            if (!within((_ref2 = point[type]) != null ? _ref2[key] : void 0, position[type][key])) {
                                found = true;
                                break;
                            }
                        }
                        if (!found) {
                            same[type][key] = true;
                        }
                    }
                }
                css = {
                    top: '',
                    left: '',
                    right: '',
                    bottom: ''
                };
                transcribe = function transcribe(same, pos) {
                    var xPos, yPos, _ref3;
                    if (((_ref3 = _this.options.optimizations) != null ? _ref3.gpu : void 0) !== false) {
                        if (same.top) {
                            css.top = 0;
                            yPos = pos.top;
                        } else {
                            css.bottom = 0;
                            yPos = -pos.bottom;
                        }
                        if (same.left) {
                            css.left = 0;
                            xPos = pos.left;
                        } else {
                            css.right = 0;
                            xPos = -pos.right;
                        }
                        css[transformKey] = 'translateX(' + Math.round(xPos) + 'px) translateY(' + Math.round(yPos) + 'px)';
                        if (transformKey !== 'msTransform') {
                            return css[transformKey] += ' translateZ(0)';
                        }
                    } else {
                        if (same.top) {
                            css.top = '' + pos.top + 'px';
                        } else {
                            css.bottom = '' + pos.bottom + 'px';
                        }
                        if (same.left) {
                            return css.left = '' + pos.left + 'px';
                        } else {
                            return css.right = '' + pos.right + 'px';
                        }
                    }
                };
                moved = false;
                if ((same.page.top || same.page.bottom) && (same.page.left || same.page.right)) {
                    css.position = 'absolute';
                    transcribe(same.page, position.page);
                } else if ((same.viewport.top || same.viewport.bottom) && (same.viewport.left || same.viewport.right)) {
                    css.position = 'fixed';
                    transcribe(same.viewport, position.viewport);
                } else if (same.offset != null && same.offset.top && same.offset.left) {
                    css.position = 'absolute';
                    offsetParent = this.cache('target-offsetparent', function () {
                        return getOffsetParent(_this.target);
                    });
                    if (getOffsetParent(this.element) !== offsetParent) {
                        defer(function () {
                            _this.element.parentNode.removeChild(_this.element);
                            return offsetParent.appendChild(_this.element);
                        });
                    }
                    transcribe(same.offset, position.offset);
                    moved = true;
                } else {
                    css.position = 'absolute';
                    transcribe({
                        top: true,
                        left: true
                    }, position.page);
                }
                if (!moved && this.element.parentNode.tagName !== 'BODY') {
                    this.element.parentNode.removeChild(this.element);
                    document.body.appendChild(this.element);
                }
                writeCSS = {};
                write = false;
                for (key in css) {
                    val = css[key];
                    elVal = this.element.style[key];
                    if (elVal !== '' && val !== '' && (key === 'top' || key === 'left' || key === 'bottom' || key === 'right')) {
                        elVal = parseFloat(elVal);
                        val = parseFloat(val);
                    }
                    if (elVal !== val) {
                        write = true;
                        writeCSS[key] = css[key];
                    }
                }
                if (write) {
                    return defer(function () {
                        return extend(_this.element.style, writeCSS);
                    });
                }
            };

            return _Tether;
        }();

        Tether.position = position;

        this.Tether = extend(_Tether, Tether);
    }).call(this);

    (function () {
        var BOUNDS_FORMAT,
            MIRROR_ATTACH,
            defer,
            extend,
            getBoundingRect,
            getBounds,
            getOuterSize,
            getSize,
            updateClasses,
            _ref,
            __indexOf = [].indexOf || function (item) {
            for (var i = 0, l = this.length; i < l; i++) {
                if (i in this && this[i] === item) return i;
            }return -1;
        };

        _ref = this.Tether.Utils, getOuterSize = _ref.getOuterSize, getBounds = _ref.getBounds, getSize = _ref.getSize, extend = _ref.extend, updateClasses = _ref.updateClasses, defer = _ref.defer;

        MIRROR_ATTACH = {
            left: 'right',
            right: 'left',
            top: 'bottom',
            bottom: 'top',
            middle: 'middle'
        };

        BOUNDS_FORMAT = ['left', 'top', 'right', 'bottom'];

        getBoundingRect = function getBoundingRect(tether, to) {
            var i, pos, side, size, style, _i, _len;
            if (to === 'scrollParent') {
                to = tether.scrollParent;
            } else if (to === 'window') {
                to = [pageXOffset, pageYOffset, innerWidth + pageXOffset, innerHeight + pageYOffset];
            }
            if (to === document) {
                to = to.documentElement;
            }
            if (to.nodeType != null) {
                pos = size = getBounds(to);
                style = getComputedStyle(to);
                to = [pos.left, pos.top, size.width + pos.left, size.height + pos.top];
                for (i = _i = 0, _len = BOUNDS_FORMAT.length; _i < _len; i = ++_i) {
                    side = BOUNDS_FORMAT[i];
                    side = side[0].toUpperCase() + side.substr(1);
                    if (side === 'Top' || side === 'Left') {
                        to[i] += parseFloat(style['border' + side + 'Width']);
                    } else {
                        to[i] -= parseFloat(style['border' + side + 'Width']);
                    }
                }
            }
            return to;
        };

        this.Tether.modules.push({
            position: function position(_arg) {
                var addClasses,
                    allClasses,
                    attachment,
                    bounds,
                    changeAttachX,
                    changeAttachY,
                    cls,
                    constraint,
                    eAttachment,
                    height,
                    left,
                    oob,
                    oobClass,
                    p,
                    pin,
                    pinned,
                    pinnedClass,
                    removeClass,
                    side,
                    tAttachment,
                    targetAttachment,
                    targetHeight,
                    targetSize,
                    targetWidth,
                    to,
                    top,
                    width,
                    _i,
                    _j,
                    _k,
                    _l,
                    _len,
                    _len1,
                    _len2,
                    _len3,
                    _len4,
                    _len5,
                    _m,
                    _n,
                    _ref1,
                    _ref2,
                    _ref3,
                    _ref4,
                    _ref5,
                    _ref6,
                    _ref7,
                    _ref8,
                    _this = this;
                top = _arg.top, left = _arg.left, targetAttachment = _arg.targetAttachment;
                if (!this.options.constraints) {
                    return true;
                }
                removeClass = function removeClass(prefix) {
                    var side, _i, _len, _results;
                    _this.removeClass(prefix);
                    _results = [];
                    for (_i = 0, _len = BOUNDS_FORMAT.length; _i < _len; _i++) {
                        side = BOUNDS_FORMAT[_i];
                        _results.push(_this.removeClass('' + prefix + '-' + side));
                    }
                    return _results;
                };
                _ref1 = this.cache('element-bounds', function () {
                    return getBounds(_this.element);
                }), height = _ref1.height, width = _ref1.width;
                if (width === 0 && height === 0 && this.lastSize != null) {
                    _ref2 = this.lastSize, width = _ref2.width, height = _ref2.height;
                }
                targetSize = this.cache('target-bounds', function () {
                    return _this.getTargetBounds();
                });
                targetHeight = targetSize.height;
                targetWidth = targetSize.width;
                tAttachment = {};
                eAttachment = {};
                allClasses = [this.getClass('pinned'), this.getClass('out-of-bounds')];
                _ref3 = this.options.constraints;
                for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
                    constraint = _ref3[_i];
                    if (constraint.outOfBoundsClass) {
                        allClasses.push(constraint.outOfBoundsClass);
                    }
                    if (constraint.pinnedClass) {
                        allClasses.push(constraint.pinnedClass);
                    }
                }
                for (_j = 0, _len1 = allClasses.length; _j < _len1; _j++) {
                    cls = allClasses[_j];
                    _ref4 = ['left', 'top', 'right', 'bottom'];
                    for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
                        side = _ref4[_k];
                        allClasses.push('' + cls + '-' + side);
                    }
                }
                addClasses = [];
                tAttachment = extend({}, targetAttachment);
                eAttachment = extend({}, this.attachment);
                _ref5 = this.options.constraints;
                for (_l = 0, _len3 = _ref5.length; _l < _len3; _l++) {
                    constraint = _ref5[_l];
                    to = constraint.to, attachment = constraint.attachment, pin = constraint.pin;
                    if (attachment == null) {
                        attachment = '';
                    }
                    if (__indexOf.call(attachment, ' ') >= 0) {
                        _ref6 = attachment.split(' '), changeAttachY = _ref6[0], changeAttachX = _ref6[1];
                    } else {
                        changeAttachX = changeAttachY = attachment;
                    }
                    bounds = getBoundingRect(this, to);
                    if (changeAttachY === 'target' || changeAttachY === 'both') {
                        if (top < bounds[1] && tAttachment.top === 'top') {
                            top += targetHeight;
                            tAttachment.top = 'bottom';
                        }
                        if (top + height > bounds[3] && tAttachment.top === 'bottom') {
                            top -= targetHeight;
                            tAttachment.top = 'top';
                        }
                    }
                    if (changeAttachY === 'together') {
                        if (top < bounds[1] && tAttachment.top === 'top') {
                            if (eAttachment.top === 'bottom') {
                                top += targetHeight;
                                tAttachment.top = 'bottom';
                                top += height;
                                eAttachment.top = 'top';
                            } else if (eAttachment.top === 'top') {
                                top += targetHeight;
                                tAttachment.top = 'bottom';
                                top -= height;
                                eAttachment.top = 'bottom';
                            }
                        }
                        if (top + height > bounds[3] && tAttachment.top === 'bottom') {
                            if (eAttachment.top === 'top') {
                                top -= targetHeight;
                                tAttachment.top = 'top';
                                top -= height;
                                eAttachment.top = 'bottom';
                            } else if (eAttachment.top === 'bottom') {
                                top -= targetHeight;
                                tAttachment.top = 'top';
                                top += height;
                                eAttachment.top = 'top';
                            }
                        }
                        if (tAttachment.top === 'middle') {
                            if (top + height > bounds[3] && eAttachment.top === 'top') {
                                top -= height;
                                eAttachment.top = 'bottom';
                            } else if (top < bounds[1] && eAttachment.top === 'bottom') {
                                top += height;
                                eAttachment.top = 'top';
                            }
                        }
                    }
                    if (changeAttachX === 'target' || changeAttachX === 'both') {
                        if (left < bounds[0] && tAttachment.left === 'left') {
                            left += targetWidth;
                            tAttachment.left = 'right';
                        }
                        if (left + width > bounds[2] && tAttachment.left === 'right') {
                            left -= targetWidth;
                            tAttachment.left = 'left';
                        }
                    }
                    if (changeAttachX === 'together') {
                        if (left < bounds[0] && tAttachment.left === 'left') {
                            if (eAttachment.left === 'right') {
                                left += targetWidth;
                                tAttachment.left = 'right';
                                left += width;
                                eAttachment.left = 'left';
                            } else if (eAttachment.left === 'left') {
                                left += targetWidth;
                                tAttachment.left = 'right';
                                left -= width;
                                eAttachment.left = 'right';
                            }
                        } else if (left + width > bounds[2] && tAttachment.left === 'right') {
                            if (eAttachment.left === 'left') {
                                left -= targetWidth;
                                tAttachment.left = 'left';
                                left -= width;
                                eAttachment.left = 'right';
                            } else if (eAttachment.left === 'right') {
                                left -= targetWidth;
                                tAttachment.left = 'left';
                                left += width;
                                eAttachment.left = 'left';
                            }
                        } else if (tAttachment.left === 'center') {
                            if (left + width > bounds[2] && eAttachment.left === 'left') {
                                left -= width;
                                eAttachment.left = 'right';
                            } else if (left < bounds[0] && eAttachment.left === 'right') {
                                left += width;
                                eAttachment.left = 'left';
                            }
                        }
                    }
                    if (changeAttachY === 'element' || changeAttachY === 'both') {
                        if (top < bounds[1] && eAttachment.top === 'bottom') {
                            top += height;
                            eAttachment.top = 'top';
                        }
                        if (top + height > bounds[3] && eAttachment.top === 'top') {
                            top -= height;
                            eAttachment.top = 'bottom';
                        }
                    }
                    if (changeAttachX === 'element' || changeAttachX === 'both') {
                        if (left < bounds[0] && eAttachment.left === 'right') {
                            left += width;
                            eAttachment.left = 'left';
                        }
                        if (left + width > bounds[2] && eAttachment.left === 'left') {
                            left -= width;
                            eAttachment.left = 'right';
                        }
                    }
                    if (typeof pin === 'string') {
                        pin = function () {
                            var _len4, _m, _ref7, _results;
                            _ref7 = pin.split(',');
                            _results = [];
                            for (_m = 0, _len4 = _ref7.length; _m < _len4; _m++) {
                                p = _ref7[_m];
                                _results.push(p.trim());
                            }
                            return _results;
                        }();
                    } else if (pin === true) {
                        pin = ['top', 'left', 'right', 'bottom'];
                    }
                    pin || (pin = []);
                    pinned = [];
                    oob = [];
                    if (top < bounds[1]) {
                        if (__indexOf.call(pin, 'top') >= 0) {
                            top = bounds[1];
                            pinned.push('top');
                        } else {
                            oob.push('top');
                        }
                    }
                    if (top + height > bounds[3]) {
                        if (__indexOf.call(pin, 'bottom') >= 0) {
                            top = bounds[3] - height;
                            pinned.push('bottom');
                        } else {
                            oob.push('bottom');
                        }
                    }
                    if (left < bounds[0]) {
                        if (__indexOf.call(pin, 'left') >= 0) {
                            left = bounds[0];
                            pinned.push('left');
                        } else {
                            oob.push('left');
                        }
                    }
                    if (left + width > bounds[2]) {
                        if (__indexOf.call(pin, 'right') >= 0) {
                            left = bounds[2] - width;
                            pinned.push('right');
                        } else {
                            oob.push('right');
                        }
                    }
                    if (pinned.length) {
                        pinnedClass = (_ref7 = this.options.pinnedClass) != null ? _ref7 : this.getClass('pinned');
                        addClasses.push(pinnedClass);
                        for (_m = 0, _len4 = pinned.length; _m < _len4; _m++) {
                            side = pinned[_m];
                            addClasses.push('' + pinnedClass + '-' + side);
                        }
                    }
                    if (oob.length) {
                        oobClass = (_ref8 = this.options.outOfBoundsClass) != null ? _ref8 : this.getClass('out-of-bounds');
                        addClasses.push(oobClass);
                        for (_n = 0, _len5 = oob.length; _n < _len5; _n++) {
                            side = oob[_n];
                            addClasses.push('' + oobClass + '-' + side);
                        }
                    }
                    if (__indexOf.call(pinned, 'left') >= 0 || __indexOf.call(pinned, 'right') >= 0) {
                        eAttachment.left = tAttachment.left = false;
                    }
                    if (__indexOf.call(pinned, 'top') >= 0 || __indexOf.call(pinned, 'bottom') >= 0) {
                        eAttachment.top = tAttachment.top = false;
                    }
                    if (tAttachment.top !== targetAttachment.top || tAttachment.left !== targetAttachment.left || eAttachment.top !== this.attachment.top || eAttachment.left !== this.attachment.left) {
                        this.updateAttachClasses(eAttachment, tAttachment);
                    }
                }
                defer(function () {
                    updateClasses(_this.target, addClasses, allClasses);
                    return updateClasses(_this.element, addClasses, allClasses);
                });
                return {
                    top: top,
                    left: left
                };
            }
        });
    }).call(this);

    (function () {
        var defer, getBounds, updateClasses, _ref;

        _ref = this.Tether.Utils, getBounds = _ref.getBounds, updateClasses = _ref.updateClasses, defer = _ref.defer;

        this.Tether.modules.push({
            position: function position(_arg) {
                var abutted,
                    addClasses,
                    allClasses,
                    bottom,
                    height,
                    left,
                    right,
                    side,
                    sides,
                    targetPos,
                    top,
                    width,
                    _i,
                    _j,
                    _k,
                    _l,
                    _len,
                    _len1,
                    _len2,
                    _len3,
                    _ref1,
                    _ref2,
                    _ref3,
                    _ref4,
                    _ref5,
                    _this = this;
                top = _arg.top, left = _arg.left;
                _ref1 = this.cache('element-bounds', function () {
                    return getBounds(_this.element);
                }), height = _ref1.height, width = _ref1.width;
                targetPos = this.getTargetBounds();
                bottom = top + height;
                right = left + width;
                abutted = [];
                if (top <= targetPos.bottom && bottom >= targetPos.top) {
                    _ref2 = ['left', 'right'];
                    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
                        side = _ref2[_i];
                        if ((_ref3 = targetPos[side]) === left || _ref3 === right) {
                            abutted.push(side);
                        }
                    }
                }
                if (left <= targetPos.right && right >= targetPos.left) {
                    _ref4 = ['top', 'bottom'];
                    for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
                        side = _ref4[_j];
                        if ((_ref5 = targetPos[side]) === top || _ref5 === bottom) {
                            abutted.push(side);
                        }
                    }
                }
                allClasses = [];
                addClasses = [];
                sides = ['left', 'top', 'right', 'bottom'];
                allClasses.push(this.getClass('abutted'));
                for (_k = 0, _len2 = sides.length; _k < _len2; _k++) {
                    side = sides[_k];
                    allClasses.push('' + this.getClass('abutted') + '-' + side);
                }
                if (abutted.length) {
                    addClasses.push(this.getClass('abutted'));
                }
                for (_l = 0, _len3 = abutted.length; _l < _len3; _l++) {
                    side = abutted[_l];
                    addClasses.push('' + this.getClass('abutted') + '-' + side);
                }
                defer(function () {
                    updateClasses(_this.target, addClasses, allClasses);
                    return updateClasses(_this.element, addClasses, allClasses);
                });
                return true;
            }
        });
    }).call(this);

    (function () {
        this.Tether.modules.push({
            position: function position(_arg) {
                var left, result, shift, shiftLeft, shiftTop, top, _ref;
                top = _arg.top, left = _arg.left;
                if (!this.options.shift) {
                    return;
                }
                result = function result(val) {
                    if (typeof val === 'function') {
                        return val.call(this, {
                            top: top,
                            left: left
                        });
                    } else {
                        return val;
                    }
                };
                shift = result(this.options.shift);
                if (typeof shift === 'string') {
                    shift = shift.split(' ');
                    shift[1] || (shift[1] = shift[0]);
                    shiftTop = shift[0], shiftLeft = shift[1];
                    shiftTop = parseFloat(shiftTop, 10);
                    shiftLeft = parseFloat(shiftLeft, 10);
                } else {
                    _ref = [shift.top, shift.left], shiftTop = _ref[0], shiftLeft = _ref[1];
                }
                top += shiftTop;
                left += shiftLeft;
                return {
                    top: top,
                    left: left
                };
            }
        });
    }).call(this);
}).call(this.pendo);

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(75);
if(typeof content === 'string') content = [[module.i, content, '']];
// add the styles to the DOM
var update = __webpack_require__(354)(content, {});
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../node_modules/css-loader/index.js??ref--2-1!./selection.css", function() {
			var newContent = require("!!../node_modules/css-loader/index.js??ref--2-1!./selection.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*eslint-disable*/
// too many eslint violations, this file has a high risk of being damaged 
// by eslint modifications
/** !
 * Sortable
 * @author	RubaXa   <trash@rubaxa.org>
 * @license MIT
 */

/* unused harmony default export */ var _unused_webpack_default_export = SortableFactory();

function SortableFactory() {
    var dragEl,
        ghostEl,
        cloneEl,
        rootEl,
        nextEl,
        scrollEl,
        scrollParentEl,
        lastEl,
        lastCSS,
        oldIndex,
        newIndex,
        activeGroup,
        autoScroll = {},
        tapEvt,
        touchEvt,


    /** @const */
    RSPACE = /\s+/g,
        expando = 'Sortable' + new Date().getTime(),
        win = window,
        document = win.document,
        parseInt = win.parseInt,
        supportDraggable = !!('draggable' in document.createElement('div')),
        _silent = false,
        _dispatchEvent = function _dispatchEvent(sortable, rootEl, name, targetEl, fromEl, startIndex, newIndex) {
        var evt = document.createEvent('Event'),
            options = (sortable || rootEl[expando]).options,
            onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1);

        evt.initEvent(name, true, true);

        evt.item = targetEl || rootEl;
        evt.from = fromEl || rootEl;
        evt.clone = cloneEl;

        evt.oldIndex = startIndex;
        evt.newIndex = newIndex;

        if (options[onName]) {
            options[onName].call(sortable, evt);
        }

        rootEl.dispatchEvent(evt);
    },
        abs = Math.abs,
        slice = [].slice,
        touchDragOverListeners = [],
        _autoScroll = _throttle(function ( /** Event*/evt, /** Object*/options, /** HTMLElement*/rootEl) {
        // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
        if (rootEl && options.scroll) {
            var el,
                rect,
                sens = options.scrollSensitivity,
                speed = options.scrollSpeed,
                x = evt.clientX,
                y = evt.clientY,
                winWidth = window.innerWidth,
                winHeight = window.innerHeight,
                vx,
                vy;

            // Delect scrollEl
            if (scrollParentEl !== rootEl) {
                scrollEl = options.scroll;
                scrollParentEl = rootEl;

                if (scrollEl === true) {
                    scrollEl = rootEl;

                    do {
                        if (scrollEl.offsetWidth < scrollEl.scrollWidth || scrollEl.offsetHeight < scrollEl.scrollHeight) {
                            break;
                        }
                        /* jshint boss:true */
                    } while (scrollEl = scrollEl.parentNode);
                }
            }

            if (scrollEl) {
                el = scrollEl;
                rect = scrollEl.getBoundingClientRect();
                vx = (abs(rect.right - x) <= sens) - (abs(rect.left - x) <= sens);
                vy = (abs(rect.bottom - y) <= sens) - (abs(rect.top - y) <= sens);
            }

            if (!(vx || vy)) {
                vx = (winWidth - x <= sens) - (x <= sens);
                vy = (winHeight - y <= sens) - (y <= sens);

                /* jshint expr:true */
                (vx || vy) && (el = win);
            }

            if (autoScroll.vx !== vx || autoScroll.vy !== vy || autoScroll.el !== el) {
                autoScroll.el = el;
                autoScroll.vx = vx;
                autoScroll.vy = vy;

                clearInterval(autoScroll.pid);

                if (el) {
                    autoScroll.pid = setInterval(function () {
                        if (el === win) {
                            win.scrollTo(win.pageXOffset + vx * speed, win.pageYOffset + vy * speed);
                        } else {
                            vy && (el.scrollTop += vy * speed);
                            vx && (el.scrollLeft += vx * speed);
                        }
                    }, 24);
                }
            }
        }
    }, 30);

    /**
     * @class  Sortable
     * @param  {HTMLElement}  el
     * @param  {Object}       [options]
     */
    function Sortable(el, options) {
        this.el = el; // root element
        this.options = options = _extend({}, options);

        // Export instance
        el[expando] = this;

        // Default options
        var defaults = {
            group: Math.random(),
            sort: true,
            disabled: false,
            store: null,
            handle: null,
            scroll: true,
            scrollSensitivity: 30,
            scrollSpeed: 10,
            draggable: /[uo]l/i.test(el.nodeName) ? 'li' : '>*',
            ghostClass: 'sortable-ghost',
            ignore: 'a, img',
            filter: null,
            animation: 0,
            setData: function setData(dataTransfer, dragEl) {
                dataTransfer.setData('Text', dragEl.textContent);
            },
            dropBubble: false,
            dragoverBubble: false,
            dataIdAttr: 'data-id',
            delay: 0
        };

        // Set default options
        for (var name in defaults) {
            !(name in options) && (options[name] = defaults[name]);
        }

        var group = options.group;

        if (!group || (typeof group === 'undefined' ? 'undefined' : _typeof(group)) !== 'object') {
            group = options.group = { name: group };
        }

        ['pull', 'put'].forEach(function (key) {
            if (!(key in group)) {
                group[key] = true;
            }
        });

        options.groups = ' ' + group.name + (group.put.join ? ' ' + group.put.join(' ') : '') + ' ';

        // Bind all private methods
        for (var fn in this) {
            if (fn.charAt(0) === '_') {
                this[fn] = _bind(this, this[fn]);
            }
        }

        // Bind events
        _on(el, 'mousedown', this._onTapStart);
        _on(el, 'touchstart', this._onTapStart);

        _on(el, 'dragover', this);
        _on(el, 'dragenter', this);

        touchDragOverListeners.push(this._onDragOver);

        // Restore sorting
        options.store && this.sort(options.store.get(this));
    }

    Sortable.prototype = /** @lends Sortable.prototype */{
        constructor: Sortable,

        _onTapStart: function _onTapStart( /** Event|TouchEvent */evt) {
            var _this = this,
                el = this.el,
                options = this.options,
                type = evt.type,
                touch = evt.touches && evt.touches[0],
                target = (touch || evt).target,
                originalTarget = target,
                filter = options.filter;

            if (type === 'mousedown' && evt.button !== 0 || options.disabled) {
                return; // only left button or enabled
            }

            target = _closest(target, options.draggable, el);

            if (!target) {
                return;
            }

            // get the index of the dragged element within its parent
            oldIndex = _index(target);

            // Check filter
            if (typeof filter === 'function') {
                if (filter.call(this, evt, target, this)) {
                    _dispatchEvent(_this, originalTarget, 'filter', target, el, oldIndex);
                    evt.preventDefault();
                    return; // cancel dnd
                }
            } else if (filter) {
                filter = filter.split(',').some(function (criteria) {
                    criteria = _closest(originalTarget, criteria.trim(), el);

                    if (criteria) {
                        _dispatchEvent(_this, criteria, 'filter', target, el, oldIndex);
                        return true;
                    }
                });

                if (filter) {
                    evt.preventDefault();
                    return; // cancel dnd
                }
            }

            if (options.handle && !_closest(originalTarget, options.handle, el)) {
                return;
            }

            // Prepare `dragstart`
            this._prepareDragStart(evt, touch, target);
        },

        _prepareDragStart: function _prepareDragStart( /** Event */evt, /** Touch */touch, /** HTMLElement */target) {
            var _this = this,
                el = _this.el,
                options = _this.options,
                ownerDocument = el.ownerDocument,
                dragStartFn;

            if (target && !dragEl && target.parentNode === el) {
                tapEvt = evt;

                rootEl = el;
                dragEl = target;
                nextEl = dragEl.nextSibling;
                activeGroup = options.group;

                dragStartFn = function dragStartFn() {
                    // Delayed drag has been triggered
                    // we can re-enable the events: touchmove/mousemove
                    _this._disableDelayedDrag();

                    // Make the element draggable
                    dragEl.draggable = true;

                    // Disable "draggable"
                    options.ignore.split(',').forEach(function (criteria) {
                        _find(dragEl, criteria.trim(), _disableDraggable);
                    });

                    // Bind the events: dragstart/dragend
                    _this._triggerDragStart(touch);
                };

                _on(ownerDocument, 'mouseup', _this._onDrop);
                _on(ownerDocument, 'touchend', _this._onDrop);
                _on(ownerDocument, 'touchcancel', _this._onDrop);

                if (options.delay) {
                    // If the user moves the pointer before the delay has been reached:
                    // disable the delayed drag
                    _on(ownerDocument, 'mousemove', _this._disableDelayedDrag);
                    _on(ownerDocument, 'touchmove', _this._disableDelayedDrag);

                    _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
                } else {
                    dragStartFn();
                }
            }
        },

        _disableDelayedDrag: function _disableDelayedDrag() {
            var ownerDocument = this.el.ownerDocument;

            clearTimeout(this._dragStartTimer);

            _off(ownerDocument, 'mousemove', this._disableDelayedDrag);
            _off(ownerDocument, 'touchmove', this._disableDelayedDrag);
        },

        _triggerDragStart: function _triggerDragStart( /** Touch */touch) {
            if (touch) {
                // Touch device support
                tapEvt = {
                    target: dragEl,
                    clientX: touch.clientX,
                    clientY: touch.clientY
                };

                this._onDragStart(tapEvt, 'touch');
            } else if (!supportDraggable) {
                this._onDragStart(tapEvt, true);
            } else {
                _on(dragEl, 'dragend', this);
                _on(rootEl, 'dragstart', this._onDragStart);
            }

            try {
                if (document.selection) {
                    document.selection.empty();
                } else {
                    window.getSelection().removeAllRanges();
                }
            } catch (err) {}
        },

        _dragStarted: function _dragStarted() {
            if (rootEl && dragEl) {
                // Apply effect
                _toggleClass(dragEl, this.options.ghostClass, true);

                Sortable.active = this;

                // Drag start event
                _dispatchEvent(this, rootEl, 'start', dragEl, rootEl, oldIndex);
            }
        },

        _emulateDragOver: function _emulateDragOver() {
            if (touchEvt) {
                _css(ghostEl, 'display', 'none');

                var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY),
                    parent = target,
                    groupName = ' ' + this.options.group.name + '',
                    i = touchDragOverListeners.length;

                if (parent) {
                    do {
                        if (parent[expando] && parent[expando].options.groups.indexOf(groupName) > -1) {
                            while (i--) {
                                touchDragOverListeners[i]({
                                    clientX: touchEvt.clientX,
                                    clientY: touchEvt.clientY,
                                    target: target,
                                    rootEl: parent
                                });
                            }

                            break;
                        }

                        target = parent; // store last element
                    }
                    /* jshint boss:true */
                    while (parent = parent.parentNode);
                }

                _css(ghostEl, 'display', '');
            }
        },

        _onTouchMove: function _onTouchMove( /** TouchEvent*/evt) {
            if (tapEvt) {
                var touch = evt.touches ? evt.touches[0] : evt,
                    dx = touch.clientX - tapEvt.clientX,
                    dy = touch.clientY - tapEvt.clientY,
                    translate3d = evt.touches ? 'translate3d(' + dx + 'px,' + dy + 'px,0)' : 'translate(' + dx + 'px,' + dy + 'px)';

                touchEvt = touch;

                _css(ghostEl, 'webkitTransform', translate3d);
                _css(ghostEl, 'mozTransform', translate3d);
                _css(ghostEl, 'msTransform', translate3d);
                _css(ghostEl, 'transform', translate3d);

                evt.preventDefault();
            }
        },

        _onDragStart: function _onDragStart( /** Event*/evt, /** boolean*/useFallback) {
            var dataTransfer = evt.dataTransfer,
                options = this.options;

            this._offUpEvents();

            if (activeGroup.pull == 'clone') {
                cloneEl = dragEl.cloneNode(true);
                _css(cloneEl, 'display', 'none');
                rootEl.insertBefore(cloneEl, dragEl);
            }

            if (useFallback) {
                var rect = dragEl.getBoundingClientRect(),
                    css = _css(dragEl),
                    ghostRect;

                ghostEl = dragEl.cloneNode(true);

                _css(ghostEl, 'top', rect.top - parseInt(css.marginTop, 10));
                _css(ghostEl, 'left', rect.left - parseInt(css.marginLeft, 10));
                _css(ghostEl, 'width', rect.width);
                _css(ghostEl, 'height', rect.height);
                _css(ghostEl, 'opacity', '0.8');
                _css(ghostEl, 'position', 'fixed');
                _css(ghostEl, 'zIndex', '100000');

                rootEl.appendChild(ghostEl);

                // Fixing dimensions.
                ghostRect = ghostEl.getBoundingClientRect();
                _css(ghostEl, 'width', rect.width * 2 - ghostRect.width);
                _css(ghostEl, 'height', rect.height * 2 - ghostRect.height);

                if (useFallback === 'touch') {
                    // Bind touch events
                    _on(document, 'touchmove', this._onTouchMove);
                    _on(document, 'touchend', this._onDrop);
                    _on(document, 'touchcancel', this._onDrop);
                } else {
                    // Old brwoser
                    _on(document, 'mousemove', this._onTouchMove);
                    _on(document, 'mouseup', this._onDrop);
                }

                this._loopId = setInterval(this._emulateDragOver, 150);
            } else {
                if (dataTransfer) {
                    dataTransfer.effectAllowed = 'move';
                    options.setData && options.setData.call(this, dataTransfer, dragEl);
                }

                _on(document, 'drop', this);
            }

            setTimeout(this._dragStarted, 0);
        },

        _onDragOver: function _onDragOver( /** Event*/evt) {
            var el = this.el,
                target,
                dragRect,
                revert,
                options = this.options,
                group = options.group,
                groupPut = group.put,
                isOwner = activeGroup === group,
                canSort = options.sort;

            if (evt.preventDefault !== void 0) {
                evt.preventDefault();
                !options.dragoverBubble && evt.stopPropagation();
            }

            if (activeGroup && !options.disabled && (isOwner ? canSort || (revert = !rootEl.contains(dragEl)) : activeGroup.pull && groupPut && (activeGroup.name === group.name || // by Name
            groupPut.indexOf && ~groupPut.indexOf(activeGroup.name) // by Array
            )) && (evt.rootEl === void 0 || evt.rootEl === this.el)) {
                // Smart auto-scrolling
                _autoScroll(evt, options, this.el);

                if (_silent) {
                    return;
                }

                target = _closest(evt.target, options.draggable, el);
                dragRect = dragEl.getBoundingClientRect();

                if (revert) {
                    _cloneHide(true);

                    if (cloneEl || nextEl) {
                        rootEl.insertBefore(dragEl, cloneEl || nextEl);
                    } else if (!canSort) {
                        rootEl.appendChild(dragEl);
                    }

                    return;
                }

                if (el.children.length === 0 || el.children[0] === ghostEl || el === evt.target && (target = _ghostInBottom(el, evt))) {
                    if (target) {
                        if (target.animated) {
                            return;
                        }
                        targetRect = target.getBoundingClientRect();
                    }

                    _cloneHide(isOwner);

                    el.appendChild(dragEl);
                    this._animate(dragRect, dragEl);
                    target && this._animate(targetRect, target);
                } else if (target && !target.animated && target !== dragEl && target.parentNode[expando] !== void 0) {
                    if (lastEl !== target) {
                        lastEl = target;
                        lastCSS = _css(target);
                    }

                    var targetRect = target.getBoundingClientRect(),
                        width = targetRect.right - targetRect.left,
                        height = targetRect.bottom - targetRect.top,
                        floating = /left|right|inline/.test(lastCSS.cssFloat + lastCSS.display),
                        isWide = target.offsetWidth > dragEl.offsetWidth,
                        isLong = target.offsetHeight > dragEl.offsetHeight,
                        halfway = (floating ? (evt.clientX - targetRect.left) / width : (evt.clientY - targetRect.top) / height) > 0.5,
                        nextSibling = target.nextElementSibling,
                        after;

                    _silent = true;
                    setTimeout(_unsilent, 30);

                    _cloneHide(isOwner);

                    if (floating) {
                        after = target.previousElementSibling === dragEl && !isWide || halfway && isWide;
                    } else {
                        after = nextSibling !== dragEl && !isLong || halfway && isLong;
                    }

                    if (after && !nextSibling) {
                        el.appendChild(dragEl);
                    } else {
                        target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
                    }

                    this._animate(dragRect, dragEl);
                    this._animate(targetRect, target);
                }
            }
        },

        _animate: function _animate(prevRect, target) {
            var ms = this.options.animation;

            if (ms) {
                var currentRect = target.getBoundingClientRect();

                _css(target, 'transition', 'none');
                _css(target, 'transform', 'translate3d(' + (prevRect.left - currentRect.left) + 'px,' + (prevRect.top - currentRect.top) + 'px,0)');

                target.offsetWidth; // repaint

                _css(target, 'transition', 'all ' + ms + 'ms');
                _css(target, 'transform', 'translate3d(0,0,0)');

                clearTimeout(target.animated);
                target.animated = setTimeout(function () {
                    _css(target, 'transition', '');
                    _css(target, 'transform', '');
                    target.animated = false;
                }, ms);
            }
        },

        _offUpEvents: function _offUpEvents() {
            var ownerDocument = this.el.ownerDocument;

            _off(document, 'touchmove', this._onTouchMove);
            _off(ownerDocument, 'mouseup', this._onDrop);
            _off(ownerDocument, 'touchend', this._onDrop);
            _off(ownerDocument, 'touchcancel', this._onDrop);
        },

        _onDrop: function _onDrop( /** Event*/evt) {
            var el = this.el,
                options = this.options;

            clearInterval(this._loopId);
            clearInterval(autoScroll.pid);

            clearTimeout(this.dragStartTimer);

            // Unbind events
            _off(document, 'drop', this);
            _off(document, 'mousemove', this._onTouchMove);
            _off(el, 'dragstart', this._onDragStart);

            this._offUpEvents();

            if (evt) {
                evt.preventDefault();
                !options.dropBubble && evt.stopPropagation();

                ghostEl && ghostEl.parentNode.removeChild(ghostEl);

                if (dragEl) {
                    _off(dragEl, 'dragend', this);

                    _disableDraggable(dragEl);
                    _toggleClass(dragEl, this.options.ghostClass, false);

                    if (rootEl !== dragEl.parentNode) {
                        newIndex = _index(dragEl);

                        // drag from one list and drop into another
                        _dispatchEvent(null, dragEl.parentNode, 'sort', dragEl, rootEl, oldIndex, newIndex);
                        _dispatchEvent(this, rootEl, 'sort', dragEl, rootEl, oldIndex, newIndex);

                        // Add event
                        _dispatchEvent(null, dragEl.parentNode, 'add', dragEl, rootEl, oldIndex, newIndex);

                        // Remove event
                        _dispatchEvent(this, rootEl, 'remove', dragEl, rootEl, oldIndex, newIndex);
                    } else {
                        // Remove clone
                        cloneEl && cloneEl.parentNode.removeChild(cloneEl);

                        if (dragEl.nextSibling !== nextEl) {
                            // Get the index of the dragged element within its parent
                            newIndex = _index(dragEl);

                            // drag & drop within the same list
                            _dispatchEvent(this, rootEl, 'update', dragEl, rootEl, oldIndex, newIndex);
                            _dispatchEvent(this, rootEl, 'sort', dragEl, rootEl, oldIndex, newIndex);
                        }
                    }

                    // Drag end event
                    Sortable.active && _dispatchEvent(this, rootEl, 'end', dragEl, rootEl, oldIndex, newIndex);
                }

                // Nulling
                rootEl = dragEl = ghostEl = nextEl = cloneEl = scrollEl = scrollParentEl = tapEvt = touchEvt = lastEl = lastCSS = activeGroup = Sortable.active = null;

                // Save sorting
                this.save();
            }
        },

        handleEvent: function handleEvent( /** Event*/evt) {
            var type = evt.type;

            if (type === 'dragover' || type === 'dragenter') {
                if (dragEl) {
                    this._onDragOver(evt);
                    _globalDragOver(evt);
                }
            } else if (type === 'drop' || type === 'dragend') {
                this._onDrop(evt);
            }
        },

        /**
         * Serializes the item into an array of string.
         * @returns {String[]}
         */
        toArray: function toArray() {
            var order = [],
                el,
                children = this.el.children,
                i = 0,
                n = children.length,
                options = this.options;

            for (; i < n; i++) {
                el = children[i];
                if (_closest(el, options.draggable, this.el)) {
                    order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
                }
            }

            return order;
        },

        /**
         * Sorts the elements according to the array.
         * @param  {String[]}  order  order of the items
         */
        sort: function sort(order) {
            var items = {},
                rootEl = this.el;

            this.toArray().forEach(function (id, i) {
                var el = rootEl.children[i];

                if (_closest(el, this.options.draggable, rootEl)) {
                    items[id] = el;
                }
            }, this);

            order.forEach(function (id) {
                if (items[id]) {
                    rootEl.removeChild(items[id]);
                    rootEl.appendChild(items[id]);
                }
            });
        },

        /**
         * Save the current sorting
         */
        save: function save() {
            var store = this.options.store;
            store && store.set(this);
        },

        /**
         * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
         * @param   {HTMLElement}  el
         * @param   {String}       [selector]  default: `options.draggable`
         * @returns {HTMLElement|null}
         */
        closest: function closest(el, selector) {
            return _closest(el, selector || this.options.draggable, this.el);
        },

        /**
         * Set/get option
         * @param   {string} name
         * @param   {*}      [value]
         * @returns {*}
         */
        option: function option(name, value) {
            var options = this.options;

            if (value === void 0) {
                return options[name];
            } else {
                options[name] = value;
            }
        },

        /**
         * Destroy
         */
        destroy: function destroy() {
            var el = this.el;

            el[expando] = null;

            _off(el, 'mousedown', this._onTapStart);
            _off(el, 'touchstart', this._onTapStart);

            _off(el, 'dragover', this);
            _off(el, 'dragenter', this);

            // Remove draggable attributes
            Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
                el.removeAttribute('draggable');
            });

            touchDragOverListeners.splice(touchDragOverListeners.indexOf(this._onDragOver), 1);

            this._onDrop();

            this.el = el = null;
        }
    };

    function _cloneHide(state) {
        if (cloneEl && cloneEl.state !== state) {
            _css(cloneEl, 'display', state ? 'none' : '');
            !state && cloneEl.state && rootEl.insertBefore(cloneEl, dragEl);
            cloneEl.state = state;
        }
    }

    function _bind(ctx, fn) {
        var args = slice.call(arguments, 2);
        return fn.bind ? fn.bind.apply(fn, [ctx].concat(args)) : function () {
            return fn.apply(ctx, args.concat(slice.call(arguments)));
        };
    }

    function _closest( /** HTMLElement*/el, /** String*/selector, /** HTMLElement*/ctx) {
        if (el) {
            ctx = ctx || document;
            selector = selector.split('.');

            var tag = selector.shift().toUpperCase(),
                re = new RegExp('\\s(' + selector.join('|') + ')\\s', 'g');

            do {
                if (tag === '>*' && el.parentNode === ctx || (tag === '' || el.nodeName.toUpperCase() == tag) && (!selector.length || ((' ' + el.className + ' ').match(re) || []).length == selector.length)) {
                    return el;
                }
            } while (el !== ctx && (el = el.parentNode));
        }

        return null;
    }

    function _globalDragOver( /** Event*/evt) {
        evt.dataTransfer.dropEffect = 'move';
        evt.preventDefault();
    }

    function _on(el, event, fn) {
        el.addEventListener(event, fn, false);
    }

    function _off(el, event, fn) {
        el.removeEventListener(event, fn, false);
    }

    function _toggleClass(el, name, state) {
        if (el) {
            if (el.classList) {
                el.classList[state ? 'add' : 'remove'](name);
            } else {
                var className = (' ' + el.className + ' ').replace(RSPACE, ' ').replace(' ' + name + ' ', ' ');
                el.className = (className + (state ? ' ' + name : '')).replace(RSPACE, ' ');
            }
        }
    }

    function _css(el, prop, val) {
        var style = el && el.style;

        if (style) {
            if (val === void 0) {
                if (document.defaultView && document.defaultView.getComputedStyle) {
                    val = document.defaultView.getComputedStyle(el, '');
                } else if (el.currentStyle) {
                    val = el.currentStyle;
                }

                return prop === void 0 ? val : val[prop];
            } else {
                if (!(prop in style)) {
                    prop = '-webkit-' + prop;
                }

                style[prop] = val + (typeof val === 'string' ? '' : 'px');
            }
        }
    }

    function _find(ctx, tagName, iterator) {
        if (ctx) {
            var list = ctx.getElementsByTagName(tagName),
                i = 0,
                n = list.length;

            if (iterator) {
                for (; i < n; i++) {
                    iterator(list[i], i);
                }
            }

            return list;
        }

        return [];
    }

    function _disableDraggable(el) {
        el.draggable = false;
    }

    function _unsilent() {
        _silent = false;
    }

    /** @returns {HTMLElement|false} */
    function _ghostInBottom(el, evt) {
        var lastEl = el.lastElementChild,
            rect = lastEl.getBoundingClientRect();
        return evt.clientY - (rect.top + rect.height) > 5 && lastEl; // min delta
    }

    /**
     * Generate id
     * @param   {HTMLElement} el
     * @returns {String}
     * @private
     */
    function _generateId(el) {
        var str = el.tagName + el.className + el.src + el.href + el.textContent,
            i = str.length,
            sum = 0;

        while (i--) {
            sum += str.charCodeAt(i);
        }

        return sum.toString(36);
    }

    /**
     * Returns the index of an element within its parent
     * @param el
     * @returns {number}
     * @private
     */
    function _index( /** HTMLElement*/el) {
        var index = 0;
        while (el && (el = el.previousElementSibling)) {
            if (el.nodeName.toUpperCase() !== 'TEMPLATE') {
                index++;
            }
        }
        return index;
    }

    function _throttle(callback, ms) {
        var args, _this;

        return function () {
            if (args === void 0) {
                args = arguments;
                _this = this;

                setTimeout(function () {
                    if (args.length === 1) {
                        callback.call(_this, args[0]);
                    } else {
                        callback.apply(_this, args);
                    }

                    args = void 0;
                }, ms);
            }
        };
    }

    function _extend(dst, src) {
        if (dst && src) {
            for (var key in src) {
                if (src.hasOwnProperty(key)) {
                    dst[key] = src[key];
                }
            }
        }

        return dst;
    }

    // Export utils
    Sortable.utils = {
        on: _on,
        off: _off,
        css: _css,
        find: _find,
        bind: _bind,
        is: function is(el, selector) {
            return !!_closest(el, selector, el);
        },
        extend: _extend,
        throttle: _throttle,
        closest: _closest,
        toggleClass: _toggleClass,
        index: _index
    };

    Sortable.version = '1.2.0';

    /**
     * Create sortable instance
     * @param {HTMLElement}  el
     * @param {Object}      [options]
     */
    Sortable.create = function (el, options) {
        return new Sortable(el, options);
    };

    // Export
    return Sortable;
}

/***/ }),
/* 74 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Sortable__ = __webpack_require__(73);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__sources__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__sources___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__sources__);
/* harmony export (immutable) */ __webpack_exports__["a"] = selection;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*eslint-disable*/
// too many eslint violations, this file has a high risk of being damaged
// by eslint modifications



function tellMasterShim(message) {
    window.top.postMessage(Object.assign(message, {
        source: __WEBPACK_IMPORTED_MODULE_1__sources__["plugin"],
        destination: __WEBPACK_IMPORTED_MODULE_1__sources__["designer"]
    }), '*');
}

function selection(window, document) {
    var selmo = window.selmo = {};

    // TODO: Support backwards compatibility
    var attachEvent = pendo.designer.attachEvent;
    var Sizzle = pendo.designer.sizzle;
    var tellMaster = tellMasterShim;
    var registerMessageHandler = pendo.designer.registerMessageHandler;
    var placeBadge = pendo.designer.placeBadge;
    var dom = pendo.designer.dom;
    var _ = pendo.designer._ || pendo._;
    var log = pendo.designer.log;
    var stopGuides = pendo.designer.stopGuides;
    var removeAllBadges = pendo.designer.removeAllBadges;
    var DEFAULT_TIMER_LENGTH = pendo.designer.DEFAULT_TIMER_LENGTH;
    var removeLauncher = pendo.designer.removeLauncher;
    var createLauncher = pendo.designer.createLauncher;
    var addGuideToLauncher = pendo.designer.addGuideToLauncher || pendo._addGuideToLauncher;
    var updateLauncherContent = pendo.designer.updateLauncherContent;
    var getOffsetPosition = pendo.designer.getOffsetPosition;
    var getScreenDimensions = pendo.designer.getScreenDimensions;
    var whenLoadedCall = pendo.designer.whenLoadedCall;
    var GuideFactory = pendo.designer.GuideFactory;
    var GuideStep = pendo.designer.GuideStep;
    var loadGuideCss = pendo.designer.loadGuideCss || function () {};
    var areGuidesEnabled = pendo.designer.areGuidesEnabled;
    var showLauncher = pendo.showLauncher;
    var hideLauncher = pendo.hideLauncher;
    var getVisitorId = pendo.getVisitorId;

    var extractElementTreeContext = pendo.designer.extractElementTreeContext || extractElementTreeContextBackFill;

    // Add onth-child pseudo selector to support old (broken) nth-child implementation
    Sizzle.selectors.pseudos['onth-child'] = Sizzle.selectors.createPseudo(function (index) {
        var i = parseInt(index, 10);
        return function (elem) {
            var parent = elem.parentNode;
            if (isNaN(i)) {
                return false;
            }
            return elem === parent.childNodes[i];
        };
    });

    var getBody = dom.getBody || function () {
        return document.body;
    };

    if (GuideStep) {
        GuideStep.behaviors.push(function Preview() {
            var step = this,
                fixedTarget,
                warningReason;

            /*
            This is to "trick" the tooltip renderer into showing the tooltip
            with fixed position so that the body doesn't scroll.
            */
            fixedTarget = dom('<div>').css({
                position: 'fixed',
                display: 'block',
                left: 0,
                top: 0,
                width: 1,
                height: 1,
                'pointer-events': 'none'
            });

            var centerFloatingTooltip = function centerFloatingTooltip() {
                if (warningReason && step.isShown() && step.type == 'tooltip') {
                    // Center and fixed position the guide
                    var screen = getScreenDimensions(),
                        guide = dom('._pendo-guide_');
                    guide.css({
                        position: 'fixed',
                        left: Math.floor((screen.width - guide.width()) / 2),
                        top: Math.floor((screen.height - guide.height()) / 2)
                    });
                }
            };

            step.canShow = function () {
                return true; // Previews can always show
            };

            step.before('render', function () {
                warningReason = null;
                if (!step.canShowOnPage(pendo.getCurrentUrl())) {
                    // Guide not meant for this page
                    warningReason = 'page';
                } else if (step.elementPathRule) {
                    var elements = Sizzle(step.elementPathRule);
                    if (!elements.length) {
                        // No matches found
                        warningReason = 'elementNotFound';
                    } else if (!_.any(elements, selmo.isElementVisible)) {
                        // Matches found, but no matches are visible
                        warningReason = 'elementNotVisible';
                    }
                }

                if (warningReason) {
                    delete step.elementPathRule;

                    if (step.type == 'tooltip') {
                        fixedTarget.appendTo('body');
                        step.overrideElement = fixedTarget[0];
                    }
                }
            });

            step.after('render', function () {
                if (warningReason && step.isShown()) {
                    tellMaster({ type: 'preview-warning', reason: warningReason });

                    centerFloatingTooltip();
                }
            });

            step.after('hide', function () {
                fixedTarget.remove();
            });

            step.after('reposition', function () {
                centerFloatingTooltip();
            });

            return step;
        });
    }

    // NOTE:  These next two functions: getScrollParent and isElementVisible
    //        are now build into the Agent as of version 1.2.1.  From
    //        that point on this designer plugin will use the
    //        functions provided by the agent instead of redefining
    //        its own.  For now, until it's ready they will be
    //        available locally defined just to be safe.

    // Basically the same scroll parent utility seen throughout the internet... but this
    // includes overflow:hidden as a "scrollable" element for the purposes of visibility testing
    selmo.getScrollParent = dom.getScrollParent || function (element) {
        var style, parentPosition;
        style = selmo.getComputedStyle(element);
        var elementPosition = style && style.position;
        if (elementPosition === 'fixed') {
            return element;
        }
        var parent = element;
        while (parent = parent.parentNode) {
            style = selmo.getComputedStyle(parent);
            if (style == null) {
                return parent;
            }
            if (/(auto|scroll|hidden)/.test(style['overflow'] + style['overflowY'] + style['overflowX'])) {
                parentPosition = style.position;
                if (elementPosition !== 'absolute' || parentPosition === 'relative' || parentPosition === 'absolute' || parentPosition === 'fixed') {
                    return parent;
                }
            }
        }
        return getBody();
    };

    selmo.isElementVisible = dom.isElementVisible || function (element) {
        // Check if the element has no client width/height (display: none or removed from dom)
        if (element.offsetWidth === 0 || element.offsetHeight === 0) {
            return false;
        }

        // Check if the element is outside of the viewport
        var clientRect = selmo.getClientRect(element);
        var viewportRect = selmo.getClientRect(window);
        if (!selmo.intersectRect(clientRect, viewportRect)) {
            return false;
        }

        // Check if the element or any parent is invisible, but still has client width/height
        var style,
            parentNode = element;
        while (parentNode) {
            try {
                style = getComputedStyle(parentNode);
            } catch (error) {}
            if (!style) {
                break;
            }
            if (Number(style.opacity) <= 0) {
                return false;
            }
            if (style.visibility === 'hidden') {
                return false;
            }
            parentNode = parentNode.parentNode;
        }

        // Check if element is visible within any scrollable areas that are not the overall viewport
        var scrollParent = selmo.getScrollParent(element);
        var body = getBody();
        var prevScrollParent = null;

        while (scrollParent !== body && scrollParent !== document && scrollParent !== prevScrollParent) {
            var scrollRect = selmo.getClientRect(scrollParent);
            if (!selmo.intersectRect(clientRect, scrollRect)) {
                return false;
            }

            prevScrollParent = scrollParent;
            scrollParent = selmo.getScrollParent(scrollParent);
        }

        // Must be visible...
        return true;
    };

    if (!dom.removeNode) {
        dom.removeNode = function (domNode) {
            domNode.parentNode.removeChild(domNode);
        };

        dom.removeClass = function (selector, classname) {
            if (typeof selector === 'string') {
                var elems = pendo.Sizzle(selector);
                elems.map(function (elem) {
                    dom._removeClass(elem, classname);
                });
            } else {
                dom._removeClass(selector, classname);
            }
        };

        dom.addClass = function (selector, classname) {
            if (typeof selector === 'string') {
                var elems = pendo.Sizzle(selector);
                elems.map(function (elem) {
                    dom._addClass(elem, classname);
                });
            } else {
                dom._addClass(selector, classname);
            }
        };

        // from http://www.openjs.com/scripts/dom/class_manipulation.php
        dom.hasClass = function (ele, cls) {
            try {
                return ele.className.match(new RegExp('(\\s|^)' + cls + '(\\s|$)'));
            } catch (e) {
                return false;
            }
        };
        dom._addClass = function (ele, cls) {
            try {
                if (!dom.hasClass(ele, cls)) ele.className += ' ' + cls;
            } catch (e) {}
        };
        dom._removeClass = function (ele, cls) {
            try {
                if (dom.hasClass(ele, cls)) {
                    var reg = new RegExp('(\\s|^)' + cls + '(\\s|$)');
                    ele.className = ele.className.replace(reg, ' ');
                }
            } catch (e) {}
        };
    }

    // "Constants"
    var NAVIGATION_MODE = 'nav';
    var SELECTION_MODE = 'sel';
    var OVERLAY_MODE = 'overlay';

    var _PENDO_TETHER_CLASS_PREFIX = 'pendo-tether';
    var _PENDO_OVERLAY_CLASS = 'pendo-overlay';
    var _PENDO_OVERLAY_TARGET_CLASS = 'pendo-overlay-target';
    var _PENDO_TOOLTIP_CLASS = 'pendo-tooltip';
    var _PENDO_TOOLTIP_CONTENT_CLASS = 'pendo-tooltip-content';
    var _PENDO_SELECTION_CLASS = 'pendo-selection';
    var _PENDO_SELECTION_HIGHLIGHT_CLASS = 'pendo-selection-HL'; // TODO consider making this more obscure to prevent accidental collision
    var _PENDO_TAGGED_CLASS = 'pendo-tagged-HL';

    var IGNORE_CLASSES = [_PENDO_SELECTION_HIGHLIGHT_CLASS, 'orig-' + _PENDO_SELECTION_HIGHLIGHT_CLASS, _PENDO_SELECTION_CLASS, _PENDO_TAGGED_CLASS, _PENDO_OVERLAY_CLASS, _PENDO_TOOLTIP_CLASS, _PENDO_OVERLAY_TARGET_CLASS,

    // Ignore meaningless classes based on framework...
    // Angular
    'ng-isolate-scope', 'ng-scope', 'ng-hide', 'ng-show', 'ng-binding',

    // Bootstrap
    'pull-left', 'pull-right'];

    var handleModeChange = function handleModeChange(data) {
        if (selmo.currentMode !== data.mode) {
            selmo.currentMode = data.mode;
            selmo.MODES[data.mode]();

            tellMaster({ type: 'mode', msg: 'started ' + data.mode });
        } else {
            tellMaster({ msg: 'sent message to change mode to ' + data.mode + ' but already in that mode.' });
        }
    };

    var taggedFeatures = new TaggedFeatures();
    selmo.updateTaggedFeatures = function (data) {
        taggedFeatures.update(data.features, data.pages, data.isReadOnly);
        if (selmo.isInState(SELECTION_MODE)) {
            taggedFeatures.showOutlines();
        } else if (selmo.isInState(OVERLAY_MODE)) {
            taggedFeatures.showOverlays();
        } else {
            taggedFeatures.hide();
        }
    };

    var isBadge = function isBadge(guide) {
        return guide.launchMethod.indexOf('badge') != -1;
    };

    var showBadge = function showBadge(guide) {
        // removing for now
        // placeBadge(guide, []);
    };

    var isInLauncher = function isInLauncher(guide) {
        return guide.launchMethod.indexOf('launcher') != -1;
    };

    selmo.updateActiveGuides = function (data) {
        if (!data || !data.guides) {
            data = {
                guides: pendo.guides
            };
        }
        pendo.guides = _.map(data.guides, GuideFactory);

        // update badges
        _.map(Sizzle('._pendo-badge_'), dom.removeNode);
        _.map(_.filter(pendo.guides, isBadge), showBadge);

        // update launcher
        var launcherGuides = selmo.launcherGuides = _.filter(pendo.guides, isInLauncher);
        if (_.isFunction(updateLauncherContent)) {
            // Agent supports custom launcher
            if (pendo.guideWidget && pendo.guideWidget.data && pendo.guideWidget.data.enabled) {
                removeLauncher();
                createLauncher(pendo.guideWidget.data);
                updateLauncherContent(launcherGuides);
            }
        } else {
            _.map(Sizzle('._pendo-launcher-item_'), dom.removeNode);
            _.map(launcherGuides, addGuideToLauncher);

            _.map(Sizzle('._pendo-launcher-item_ > a'), function (a) {
                a.onclick = undefined;
            });
        }

        var listing = Sizzle('._pendo-launcher-guide-listing_')[0];
        if (listing) {
            pendo.Sortable.create(listing, {
                onUpdate: function onUpdate(e) {
                    var guide = selmo.launcherGuides[e.oldIndex],
                        displacedGuide = selmo.launcherGuides[e.newIndex],
                        newPriority = displacedGuide.attributes.priority;

                    tellMaster({
                        type: 'update-guide-priority',
                        guideId: guide.id,
                        priority: newPriority
                    });
                }
            });
        }

        setTimeout(function () {
            sendGuideCss();
        }, 2000);
    };

    // TODO: implement this for live edits of guides
    var dirtyEditGuide = function dirtyEditGuide(data) {};
    var clearDirtyEdits = function clearDirtyEdits() {};

    selmo.getComputedStyle = function (element) {
        try {
            return getComputedStyle(element);
        } catch (error) {}
    };

    selmo.getClientRect = function (element) {
        var body = getBody();
        if (element == null) {
            return;
        } else if (element === body || element === document || element === window) {
            var viewport = {
                left: window.pageXOffset || body.scrollLeft,
                top: window.pageYOffset || body.scrollTop,
                width: window.innerWidth,
                height: window.innerHeight
            };
            viewport.right = viewport.left + viewport.width;
            viewport.bottom = viewport.top + viewport.height;
            return viewport;
        } else {
            var node = element;
            var clientRect = {
                width: node.offsetWidth,
                height: node.offsetHeight
            };
            clientRect.left = 0;
            clientRect.top = 0;
            while (node && !isNaN(node.offsetLeft) && !isNaN(node.offsetTop)) {
                clientRect.left += node.offsetLeft;
                clientRect.top += node.offsetTop;
                node = node.offsetParent;
            }
            clientRect.right = clientRect.left + clientRect.width;
            clientRect.bottom = clientRect.top + clientRect.height;
            return clientRect;
        }
    };

    selmo.intersectRect = function (rect1, rect2) {
        if (rect1.top >= rect2.bottom) {
            return false;
        }
        if (rect1.bottom <= rect2.top) {
            return false;
        }
        if (rect1.left >= rect2.right) {
            return false;
        }
        if (rect1.right <= rect2.left) {
            return false;
        }
        return true;
    };

    // functionality extracted from the theme-plucker project
    selmo.getSiteTheme = function getSiteTheme() {
        function stylesFromNodes(nodes) {
            var lookupTable = {
                'font-family': {},
                'background-color': {}
            };

            nodes.forEach(function (element) {
                var computedStyle = window.getComputedStyle(element, null);
                var fontList = computedStyle.getPropertyValue('font-family') || '';

                fontList.split(',').forEach(function (font) {
                    lookupTable['font-family'][font.trim()] = true;
                });

                var color = computedStyle.getPropertyValue('background-color');
                lookupTable['background-color'][color] = rgb2hex(color);
            });

            return lookupTable;
        }

        function buildThemeList() {
            var whitelist = 'body, label, div, span, h1, h2, h3, h4, h5, pre, code, p, button, a';
            var elements = document.querySelectorAll(whitelist);
            var styles = stylesFromNodes(elements);
            return styles;
        }

        function rgb2hex(inputRgb) {
            if (inputRgb.indexOf('rgb(') !== -1) {
                var rgb = inputRgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
                return '#' + hex(rgb[1]) + hex(rgb[2]) + hex(rgb[3]);
            }
            return '';
        }

        function hex(x) {
            var hexDigits = new Array('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f');
            return isNaN(x) ? '00' : hexDigits[(x - x % 16) / 16] + hexDigits[x % 16];
        }

        return buildThemeList();
    };

    selmo.elementContains = function (container, containee) {
        for (var parentNode = containee; parentNode != null; parentNode = parentNode.parentNode) {
            if (parentNode === container) {
                return true;
            }
        }
        return false;
    };

    function TaggedFeatures() {
        var self = this;
        self.overlays = [];
        self.activePages = {};
        self.features = [];
        self.maxNumEvents = 0;

        attachEvent(document, 'mousemove', function (event) {
            self.hover(event);
        }, true);

        attachEvent(document, 'click', function (event) {
            self.click(event);
        }, true);
    }

    TaggedFeatures.prototype.startWatching = function () {
        if (this.interval === undefined) {
            var self = this;
            var refresh = function refresh() {
                self.refresh();
                self.interval = setTimeout(refresh, 200);
            };
            refresh();
        }
    };

    TaggedFeatures.prototype.stopWatching = function () {
        if (this.interval !== undefined) {
            clearTimeout(this.interval);
            delete this.interval;
        }
    };

    TaggedFeatures.prototype.refresh = function () {
        if (this.refreshPosition == null) {
            this.refreshPosition = 0;
        }
        var i = 0,
            batchSize = 10,
            len = this.overlays.length;
        while (i++ < batchSize && i < len) {
            this.overlays[this.refreshPosition].refresh();
            this.refreshPosition = (this.refreshPosition + 1) % len;
        }
    };

    TaggedFeatures.prototype.isFeatureOnPage = function (feature) {
        if (!feature.pageId) {
            return true; // Feature is defined on all pages
        }
        return !!this.activePages[feature.pageId];
    };

    TaggedFeatures.prototype.update = function (features, pages, isReadOnly) {
        var i,
            ii,
            feature,
            overlays = this.overlays;

        this.features = features;

        // Rank features
        features.sort(function (a, b) {
            return a.numEvents - b.numEvents;
        });
        var rank = 0;
        for (i = 0, ii = features.length; i < ii; ++i) {
            if (i > 0 && features[i].numEvents > features[i - 1].numEvents) {
                rank++;
            }
            features[i].rank = rank;
        }

        // update max values (global, not just features for this page)
        var maximums = {
            rank: this.max(features, 'rank'),
            numEvents: this.max(features, 'numEvents'),
            numVisitors: this.max(features, 'numVisitors'),
            numAccounts: this.max(features, 'numAccounts')
        };

        // Lookup table for active pages (only the active pages are sent)
        var activePages = this.activePages = {};
        for (i = 0, ii = pages.length; i < ii; ++i) {
            var page = pages[i];
            activePages[page.id] = page;
        }

        // Filter to only features on this page(s)
        for (i = 0; i < features.length; ++i) {
            if (!this.isFeatureOnPage(features[i])) {
                features.splice(i--, 1);
            }
        }

        // destroy current overlays (if any)
        this.clear();

        // add new overlays
        for (i = 0, ii = features.length; i < ii; ++i) {
            feature = features[i];
            var overlay = new FeatureOverlay(feature, maximums, isReadOnly);
            overlays.push(overlay);
        }
    };

    TaggedFeatures.prototype.clear = function () {
        for (var i = 0, ii = this.overlays.length; i < ii; ++i) {
            this.overlays[i].destroy();
        }
        this.overlays.length = 0;
    };

    TaggedFeatures.prototype.hide = function () {
        this.stopWatching();
        this.hideOverlays();
        this.hideOutlines();
    };

    TaggedFeatures.prototype.hideOverlays = function () {
        for (var i = 0, ii = this.overlays.length; i < ii; ++i) {
            this.overlays[i].remove();
        }
    };

    TaggedFeatures.prototype.showOverlays = function (isReadOnly) {
        this.hideOutlines();
        this.startWatching();
        for (var i = 0, ii = this.overlays.length; i < ii; ++i) {
            this.overlays[i].show(isReadOnly);
        }
    };

    TaggedFeatures.prototype.hideOutlines = function () {
        for (var i = 0, ii = this.overlays.length; i < ii; ++i) {
            this.overlays[i].hideOutline();
        }
    };

    TaggedFeatures.prototype.showOutlines = function () {
        this.hideOverlays();
        this.startWatching();
        for (var i = 0, ii = this.overlays.length; i < ii; ++i) {
            this.overlays[i].showOutline();
        }
    };

    TaggedFeatures.prototype.hover = function (event) {
        for (var i = 0, ii = this.overlays.length; i < ii; ++i) {
            this.overlays[i].hover(event);
        }
    };

    TaggedFeatures.prototype.click = function (event) {
        for (var i = 0, ii = this.overlays.length; i < ii; ++i) {
            this.overlays[i].click(event);
        }
    };

    TaggedFeatures.prototype.max = function (array, property) {
        var max;
        for (var i = 0, ii = array.length; i < ii; ++i) {
            var value = array[i][property];
            if (max === undefined || value > max) {
                max = value;
            }
        }
        return max;
    };

    // Wraps an element overlay with a tooltip
    function FeatureOverlay(feature, max, isReadOnly) {
        this.max = max;
        this.feature = feature;
        this.tooltip = new Tooltip(this.content(isReadOnly));
        this.overlays = [];
        this.refresh();
        this.visible = false;
        this.outlined = false;
        this.editButton = Sizzle('.pendo-edit-feature > a', this.tooltip.element)[0];
    }

    FeatureOverlay.prototype.hasOverlay = function (element) {
        return !!dom.hasClass(element, _PENDO_OVERLAY_TARGET_CLASS);
    };

    FeatureOverlay.prototype.refresh = function () {
        var i, ii, overlay;
        var overlays = this.overlays;
        for (i = 0; i < overlays.length; ++i) {
            overlay = overlays[i];
            if (selmo.isElementVisible(overlay.target)) {
                // Refresh overlays that are still visible
                overlay.refresh();
            } else {
                // Remove overlays that no longer have valid targets
                overlay.destroy();
                overlays.splice(i--, 1);
            }
        }

        // Add overlays for new elements
        var feature = this.feature;
        for (i = 0, ii = feature.elementPathRules.length; i < ii; ++i) {
            var selector = feature.elementPathRules[i];
            var elements = Sizzle(selector);

            // TODO - handle duplicates within and across features?
            for (var j = 0, jj = elements.length; j < jj; ++j) {
                var element = elements[j];
                if (selmo.isElementVisible(element) && !this.hasOverlay(element)) {
                    overlay = new ElementOverlay(element, selector, this.color(), feature.color);
                    if (this.outlined) {
                        overlay.showOutline();
                    }
                    if (this.visible) {
                        overlay.show();
                    }
                    this.overlays.push(overlay);
                }
            }
        }
    };

    FeatureOverlay.prototype.content = function (isReadOnly) {
        var feature = this.feature;
        var template = [];
        if (feature.dirty) {
            template.push('<table>', '<tr><td colspan="3">', feature.name, '</td></tr>', '<tr><td colspan="3" class="pendo-processing-feature">Processing</td></tr>', '</table>');
        } else {
            template.push('<table>', '<tr><td colspan="3">', feature.name, '</td></tr>', '<tr>', '<td><div class="pendo-progressbar"><div style="width:', this.percentage('numEvents'), '%"></div></div></td>', '<td><strong>', feature.numEvents, '</strong></td>', '<td>total clicks</td>', '</tr>', '<tr>', '<td><div class="pendo-progressbar"><div style="width:', this.percentage('numVisitors'), '%"></div></div></td>', '<td><strong>', feature.numVisitors, '</strong></td>', '<td>visitors</td>', '</tr>', '<tr>', '<td><div class="pendo-progressbar"><div style="width:', this.percentage('numAccounts'), '%"></div></div></td>', '<td><strong>', feature.numAccounts, '</strong></td>', '<td>accounts</td>', '</tr>', '</table>');
        }

        if (!isReadOnly) {
            template.push('<div class="pendo-edit-feature"><a href="javascript:void(0);">Edit</a></div>');
        }

        return template.join('');
    };

    FeatureOverlay.prototype.percentage = function (property) {
        var max = this.max[property];
        return max > 0 ? Math.round(this.feature[property] / max * 100) : 0;
    };

    FeatureOverlay.prototype.color = function () {
        if (this.feature.dirty) {
            return '#9a9ca5';
        }
        // Hue should go from 240 (blue, least used) to 0 (red, most used)
        var maxRank = this.max.rank;
        var hue = maxRank > 0 ? Math.floor(240 - 240 * (this.feature.rank / maxRank)) : 240;
        return 'hsl(' + hue + ',100%,50%)';
    };

    FeatureOverlay.prototype.hideOutline = function () {
        this.outlined = false;
        for (var i = 0, ii = this.overlays.length; i < ii; ++i) {
            this.overlays[i].hideOutline();
        }
    };

    FeatureOverlay.prototype.showOutline = function () {
        this.outlined = true;
        for (var i = 0, ii = this.overlays.length; i < ii; ++i) {
            this.overlays[i].showOutline();
        }
    };

    FeatureOverlay.prototype.show = function () {
        this.visible = true;
        for (var i = 0, ii = this.overlays.length; i < ii; ++i) {
            this.overlays[i].show();
        }
    };

    FeatureOverlay.prototype.hover = function (event) {
        if (this.visible) {
            if (selmo.elementContains(this.tooltip.element, event.target)) {
                // If we're hovering the tooltip, leave it visible
                return;
            }
            for (var i = 0, ii = this.overlays.length; i < ii; ++i) {
                var overlay = this.overlays[i];
                if (event.target === overlay.element) {
                    // If we're hovering an overlay, show and reposition the tooltip
                    this.activeOverlay = overlay;
                    this.tooltip.show(overlay.element);
                    return;
                }
            }
            // No overlay or tooltip was hovered, so remove the tooltip
            delete this.activeOverlay;
            this.tooltip.remove();
        }
    };

    FeatureOverlay.prototype.click = function (event) {
        if (this.visible && event.target === this.editButton) {
            tellMaster({
                type: 'edit-feature',
                featureId: this.feature.id,
                url: location.toString(),
                target: {
                    elementPathRule: this.activeOverlay.selector
                }
            });
        }
    };

    FeatureOverlay.prototype.remove = function () {
        this.visible = false;
        for (var i = 0, ii = this.overlays.length; i < ii; ++i) {
            this.overlays[i].remove();
        }
        delete this.activeOverlay;
        this.tooltip.remove();
    };

    FeatureOverlay.prototype.destroy = function () {
        this.visible = false;
        for (var i = 0, ii = this.overlays.length; i < ii; ++i) {
            this.overlays[i].destroy();
        }
        this.overlays.length = 0;
        this.tooltip.destroy();
    };

    // Tooltip
    function Tooltip(content) {
        var element = this.element = document.createElement('div');
        var tooltipContent = document.createElement('div');
        tooltipContent.innerHTML = content;
        element.appendChild(tooltipContent);
        dom.addClass(element, _PENDO_TOOLTIP_CLASS);
        dom.addClass(tooltipContent, _PENDO_TOOLTIP_CONTENT_CLASS);
        this.visible = false;
    }

    Tooltip.prototype.show = function (target) {
        if (!this.visible) {
            getBody().appendChild(this.element);
            this.visible = true;
        }
        this.tether = new pendo.Tether({
            classPrefix: _PENDO_TETHER_CLASS_PREFIX,
            element: this.element,
            target: target,
            attachment: 'top center',
            targetAttachment: 'bottom center',
            constraints: [{ to: 'scrollParent', attachment: 'together' }]
        });
    };

    Tooltip.prototype.remove = function () {
        var element = this.element;
        var parentNode = element.parentNode;
        if (parentNode) {
            parentNode.removeChild(element);
        }
        if (this.tether) {
            this.tether.destroy();
            delete this.tether;
        }
        this.visible = false;
    };

    Tooltip.prototype.destroy = function () {
        this.remove();
    };

    // Overlays a transparent div on top of an element
    function ElementOverlay(target, selector, color, outlineColor) {
        this.target = target;
        var element = this.element = document.createElement('div');
        dom.addClass(element, _PENDO_OVERLAY_CLASS);
        dom.addClass(target, _PENDO_OVERLAY_TARGET_CLASS);
        element.style.backgroundColor = color;
        this.outlineColor = outlineColor || color;
        this.tether = new pendo.Tether({
            classPrefix: _PENDO_TETHER_CLASS_PREFIX,
            element: element,
            target: target,
            attachment: 'middle center',
            targetAttachment: 'middle center',
            enabled: false
        });
        this.visible = false;
        this.selector = selector;
    }

    ElementOverlay.prototype.destroy = function () {
        this.remove();
        dom.removeClass(this.target, _PENDO_OVERLAY_TARGET_CLASS);
        this.tether.destroy();
    };

    ElementOverlay.prototype.show = function () {
        this.visible = true;
        getBody().appendChild(this.element);
        this.tether.enable();
        this.refresh();
    };

    ElementOverlay.prototype.refresh = function () {
        if (!this.visible) {
            return;
        }
        var element = this.element;
        var target = this.target;
        element.style.width = target.offsetWidth + 'px';
        element.style.height = target.offsetHeight + 'px';
        this.tether.position();
    };

    ElementOverlay.prototype.remove = function () {
        this.visible = false;
        this.tether.disable();
        var element = this.element;
        var parentNode = element.parentNode;
        if (parentNode) {
            parentNode.removeChild(element);
        }
    };

    ElementOverlay.prototype.hideOutline = function () {
        dom.removeClass(this.target, _PENDO_TAGGED_CLASS);
        if (this.originalOutlineColor !== undefined) {
            this.target.style.outlineColor = this.originalOutlineColor;
            delete this.originalOutlineColor;
        }
    };

    ElementOverlay.prototype.showOutline = function () {
        this.originalOutlineColor = this.target.style.outlineColor;
        dom.addClass(this.target, _PENDO_TAGGED_CLASS);
        this.target.style.outlineColor = this.outlineColor;
    };

    selmo.stopEventBubbling = function (evt) {
        evt.stopPropagation();
        evt.preventDefault();
        return false;
    };

    // we're tracking selection vs navigation
    // and locked on target vs unlocked (when in selection)
    selmo.hasLock = function () {
        return selmo._state.length == 2;
    };
    selmo.addLock = function () {
        selmo._state.push('lock');
    };
    var clearLock = function clearLock() {
        selmo._state.splice(1, 1);
        dom.removeClass('.orig-' + _PENDO_SELECTION_HIGHLIGHT_CLASS, 'orig-' + _PENDO_SELECTION_HIGHLIGHT_CLASS);
        dom.removeClass('.' + _PENDO_SELECTION_HIGHLIGHT_CLASS, _PENDO_SELECTION_HIGHLIGHT_CLASS);
    };

    selmo._state = [null];
    selmo.isInState = function (st) {
        return selmo._state[0] === st;
    };

    selmo.setState = function (st) {
        if (st !== NAVIGATION_MODE && st !== SELECTION_MODE && st !== OVERLAY_MODE) {
            return;
        }

        if (selmo.isInState(st)) {
            // Already in state
            return;
        }

        if (st === SELECTION_MODE) {
            // change from nav/overlay to selection
            clearLock();
            dom.addClass('body', _PENDO_SELECTION_CLASS);
            dom.removeClass('.orig-' + _PENDO_SELECTION_HIGHLIGHT_CLASS, 'orig-' + _PENDO_SELECTION_HIGHLIGHT_CLASS);
        } else {
            // change from selection to nav/overlay
            dom.removeClass('body', _PENDO_SELECTION_CLASS);
            dom.removeClass('.' + _PENDO_SELECTION_HIGHLIGHT_CLASS, _PENDO_SELECTION_HIGHLIGHT_CLASS);
            dom.removeClass('.orig-' + _PENDO_SELECTION_HIGHLIGHT_CLASS, 'orig-' + _PENDO_SELECTION_HIGHLIGHT_CLASS);
        }

        selmo._state[0] = st;
    };

    selmo.startNavigationMode = function () {
        selmo.setState(NAVIGATION_MODE);
        taggedFeatures.hide();
    };

    selmo.startSelectionMode = function () {
        selmo.setState(SELECTION_MODE);
        taggedFeatures.showOutlines();
    };

    selmo.startOverlayMode = function () {
        selmo.setState(OVERLAY_MODE);
        taggedFeatures.showOverlays();
    };

    // TODO: make this smart.  if the target doesn't match our specs for a
    // Tag then climb the tree until we find an element that does.
    selmo.findTarget = function (evt) {
        return evt.target;
    };

    selmo.isPreviewing = function () {
        return Sizzle('._pendo-guide_').length > 0;
    };

    selmo.overrideOnClick = function (elem) {
        if (elem.onclick) {
            elem.oldOnclick = elem.onclick;
            elem.onclick = null;
        }
    };

    selmo.fixOnClick = function (elem) {
        if (elem && elem.oldOnclick) {
            elem.onclick = elem.oldOnclick;
            elem.oldOnclick = null;
        }
    };

    selmo.unhighlight = function (evt) {
        if (!selmo.isInState(SELECTION_MODE)) return;
        if (selmo.hasLock()) return;
        if (selmo.isPreviewing()) return;

        var target = selmo.findTarget(evt);

        var oldTarget = Sizzle('.' + _PENDO_SELECTION_HIGHLIGHT_CLASS)[0];
        dom.removeClass('.' + _PENDO_SELECTION_HIGHLIGHT_CLASS, _PENDO_SELECTION_HIGHLIGHT_CLASS);

        selmo.fixOnClick(oldTarget);
    };

    function detectIgnoredElement(evt) {
        return evt.target.classList.contains('pendo-nonselect-element');
    }

    function detectModKeys(evt) {
        return evt.shiftKey || evt.ctrlKey || evt.altKey || detectIgnoredElement(evt);
    };

    selmo.highlight = function (evt) {
        if (!selmo.isInState(SELECTION_MODE)) return;
        if (selmo.hasLock()) return;
        if (selmo.isPreviewing()) return;

        var target = selmo.findTarget(evt);

        var oldTarget = Sizzle('.' + _PENDO_SELECTION_HIGHLIGHT_CLASS)[0];
        dom.removeClass('.' + _PENDO_SELECTION_HIGHLIGHT_CLASS, _PENDO_SELECTION_HIGHLIGHT_CLASS);

        if (detectModKeys(evt)) {
            // Don't highlight if modifier key is down
            return;
        }

        selmo.fixOnClick(oldTarget);

        dom.addClass(target, _PENDO_SELECTION_HIGHLIGHT_CLASS);

        selmo.overrideOnClick(target);

        return selmo.stopEventBubbling(evt);
    };

    var getClassName = function getClassName(element) {
        if (_.isFunction(dom.getClass)) {
            return dom.getClass(element);
        } else {
            return element.className;
        }
    };

    // FIXME - should merge with extractElementTreeContext
    selmo.getTargetPath = function (target) {
        var pathElemsArr = [];
        while (target.parentNode !== null) {
            var classes = selmo._getValidClassNames(target);

            var elem = {
                tag: target.nodeName,
                id: target.getAttribute('id') || '',
                classes: classes,
                href: target.getAttribute('href')
            };
            pathElemsArr.unshift(elem);
            target = target.parentNode;
        }

        return pathElemsArr;
    };

    selmo.isBadClass = function (cls) {
        for (var i = 0; i < IGNORE_CLASSES.length; i++) {
            if (IGNORE_CLASSES[i].toLowerCase() === cls.toLowerCase()) {
                return true;
            }
        }

        // Exclude all the classes generated by Tether
        return new RegExp('^' + _PENDO_TETHER_CLASS_PREFIX + '-').test(cls);
    };

    selmo._getValidClassNames = function (element) {
        var classes = [];
        var clsStr = typeof element.className == 'string' ? element.className : element.getAttribute('class');
        if (clsStr && clsStr !== '') {
            var rawClasses = clsStr.split(' ');
            for (var i = 0; i < rawClasses.length; i++) {
                var cls = rawClasses[i];
                cls.replace(/^\s+|\s+$/g, '');
                if (cls !== '' && selmo.isBadClass(cls) === false) {
                    classes.push(cls);
                }
            }
        }
        return classes;
    };

    selmo.testCssSelector = function (data) {
        var elems = null;

        try {
            elems = Sizzle(data.cssSelector);
        } catch (e) {
            tellMaster({
                type: 'cssTestResult',
                message: 'Invalid CSS Selector',
                isInvalid: true,
                success: false
            });
        }

        var msg = '';
        var success = false;

        // Checking for unaccepted CSS selectors
        //No * + ~ unless followed by =
        if (new RegExp('/[\+~\*](?!=)/g').exec(data.cssSelector)) {
            tellMaster({
                type: 'cssTestResult',
                message: 'Disallowed CSS Selector',
                isInvalid: true,
                success: false
            });
            return;
        } else if (elems.length === 0) {
            msg = 'No elements found.';
        } else if (elems.length === 1 || data.allowMultiple) {
            success = true;
        } else {
            msg = 'More than 1 element found.  Please change.';
        }
        if (success) {
            // Highlight
            dom.removeClass('.' + _PENDO_SELECTION_HIGHLIGHT_CLASS, _PENDO_SELECTION_HIGHLIGHT_CLASS);
            dom.addClass(data.cssSelector, _PENDO_SELECTION_HIGHLIGHT_CLASS);
        }
        tellMaster({
            type: 'cssTestResult',
            message: msg,
            success: success
        });
    };

    selmo.ID_BLACKLIST = [/ext-gen\d+/, /ext-comp-\d+/, /x-auto-\d+/, /gwt-uid-\d+/];
    selmo._isBlackListedId = function (id) {
        for (var i = 0; i < selmo.ID_BLACKLIST.length; i++) {
            if (new RegExp(selmo.ID_BLACKLIST[i]).exec(id)) {
                return true;
            }
        }
        return false;
    };

    function CssSelectorBuilder(element, context) {
        var path = [];
        var conjunction = ' > ';
        var currentContext = context;

        return {
            selector: selector,
            up: up
        };

        function up() {
            if (!currentContext.parentElem) {
                return false;
            }

            path.unshift(createPathNode(element, currentContext));
            element = element.parentNode;
            currentContext = currentContext.parentElem;

            return path[0].matchCount !== 1;
        }

        function selector(options) {
            if (!context.parentElem) {
                return 'body';
            }

            options = options || {};
            return _.chain(path).map(function (pathNode) {
                if (pathNode.contains && options.contains) {
                    return pathNode.bestSelector + pathNode.contains;
                } else if (pendo.doesExist(pathNode.nthChild) && options.nthChild) {
                    return pathNode.bestSelector + pathNode.nthChild;
                } else {
                    return pathNode.bestSelector;
                }
            }).value().join(conjunction);
        }

        function createPathNode(element, context) {
            if (context.id && !selmo._isBlackListedId(context.id)) {
                var idSelector = '[id="' + context.id + '"]';
                if (Sizzle(idSelector).length === 1) {
                    // Make sure it really is unique
                    return { // Don't bother doing anything else if we found a unique id
                        bestSelector: '#' + escapeCss(context.id),
                        matchCount: 1
                    };
                }
            }

            var parentNode = element.parentNode;

            var selectors = _.map(getValidAttributes(context.attrs), function (attrName) {
                return '[' + attrName + '="' + context.attrs[attrName] + '"]';
            }).concat(_.map(selmo._getValidClassNames(element), function (className) {
                return '.' + escapeCss(className);
            }));

            if (idSelector) {
                selectors.push(idSelector);
            }

            selectors.push(context.tag.toLowerCase());

            /*
            Filter for potential selectors that provide high specificity
            among this element's siblings.
            This might mean that we drop something that provides high global
            specificity, but, hey... we gotta limit this thing somehow.
            Also, trying to avoid running Sizzle against the full document
            (with likely inefficient selectors) too many times.
            */
            selectors = _.chain(selectors).map(function (selector) {
                return {
                    matchCount: Sizzle('>' + selector, parentNode).length,
                    selector: selector
                };
            }).sortBy('matchCount').pluck('selector').first(3).value();

            var pathNode = {
                selectors: selectors
            };

            if (pendo.doesExist(context.childIndex) && parentNode.children.length > 1) {
                // element has siblings
                pathNode.nthChild = ':nth-child(' + (context.childIndex + 1) + ')';
            }

            if (context.txt) {
                pathNode.contains = buildContainsRule(context.txt);
            }

            return electBestSelector(pathNode);
        }

        function electBestSelector(pathNode) {
            var bestSelectorSoFar = _.chain(path).pluck('bestSelector').value();

            pathNode.matchCount = Infinity;
            _.find(pathNode.selectors, function (selector) {
                var matchCount = Sizzle([selector].concat(bestSelectorSoFar).join(conjunction)).length;
                if (matchCount > 0 && matchCount < pathNode.matchCount) {
                    pathNode.bestSelector = selector;
                    pathNode.matchCount = matchCount;
                }
                return pathNode.matchCount === 1; // Stop early if we find a unique match
            });

            return pathNode;
        }

        function getValidAttributes(attrs) {
            return _.chain(attrs).keys().without('id', 'class', 'title', 'tabindex').filter(function (attrName) {
                return attrs[attrName];
            }).value();
        }

        function escapeCss(css) {
            // https://mathiasbynens.be/notes/css-escapes#css
            return css.replace(/[!"#\$%&'\(\)\*\+,\.\/:;<=>\?@\[\\\]\^`\{\|\}~]/g, function (match) {
                return '\\' + match;
            });
        }

        function buildContainsRule(text) {
            var singleQuoteIndex, doubleQuoteIndex, quote;
            if ((text = text.trim()) && text.length > 0 && text.length < 128 && !/\u00a0/.test(text)) {
                singleQuoteIndex = text.indexOf('\'');
                doubleQuoteIndex = text.indexOf('"');
                // Choosing whether to use `'` or `"` when wrapping :contains input.
                // `'` if it's not found in text.
                // OR if a `"` is found before an instance of `'`
                if (singleQuoteIndex === -1 || doubleQuoteIndex !== -1 && doubleQuoteIndex < singleQuoteIndex) {
                    quote = '\'';
                    // Using `"` if `'` is used in input before `"`
                } else {
                    quote = '"';
                }

                // text set to first substring of text that doesn't include
                // \f, \n, \r, and the type of quotation mark used to wrap :contains.
                text = new RegExp('^[^\\f\\n\\r' + quote + ']+').exec(text);
                return text ? ':contains(' + quote + text[0] + quote + ')' : '';
            }
            return '';
        }
    }

    function computeCssMatch(element) {
        var context = extractElementTreeContext(element);
        var selectorBuilder = CssSelectorBuilder(element, context);

        while (selectorBuilder.up()) {
            var selector = _.find([selectorBuilder.selector(), selectorBuilder.selector({ contains: true }), selectorBuilder.selector({ contains: true, nthChild: true }), selectorBuilder.selector({ nthChild: true })], function (selector) {
                var match = Sizzle(selector);
                return match.length === 1 && match[0] === element;
            });

            if (selector) {
                return selector;
            }
        }

        return selectorBuilder.selector();
    }

    /**
     * @typedef {Object} ElementTreeContext
     * @property {String} id
     * @property {String} tag
     * @property {String} cls
     * @property {String|undefined} txt
     * @property {Number} childIndex
     * @property {ElementTreeContext|undefined} parentElem
     */

    /**
     * Used to build an agent-style representation of the path
     * to the DOM element, if the agent does not export
     * pendo.designer.extractElementTreeContext (>=2.3.0).
     * This is a simplified version of extractElementTreeContext
     * from the agent, since the designer requires the use
     * of more modern browsers. It also excludes attributes
     * because attributes were not part of suggested matches
     * until agent >=2.3.0
     * @param  {HTMLElement} element
     * @return {ElementTreeContext}
     */
    function extractElementTreeContextBackFill(element) {
        var context = {};
        var currentContext = context;
        var currentElement = element;

        while (currentElement) {
            currentContext.id = currentElement.id;
            currentContext.tag = currentElement.nodeName;
            currentContext.cls = currentElement.className;

            if (currentElement.parentElement) {
                currentContext.parentElem = {};
                currentContext.childIndex = _.indexOf(currentElement.parentElement.children, currentElement);
            }

            currentContext = currentContext.parentElem;
            currentElement = currentElement.parentElement;
        }

        if (!pendo.excludeAllText && _.isFunction(pendo.getText)) {
            context.txt = pendo.getText(element);
        }

        return context;
    }

    selmo.computeCssMatch = computeCssMatch;

    selmo.getSelectedElement = function () {
        var origClass = 'orig-' + _PENDO_SELECTION_HIGHLIGHT_CLASS;
        return document.getElementsByClassName(origClass)[0];
    };

    selmo.click = function (evt) {
        if (selmo.isInState(NAVIGATION_MODE) || selmo.isInState(OVERLAY_MODE)) {
            tellMaster({ type: 'nav-click' });
            return;
        } else if (selmo.isInState(SELECTION_MODE) && !selmo.hasLock()) {
            if (detectModKeys(evt)) {
                // Treat like a normal click if shift key is down
                return true;
            }

            selmo.addLock();

            dom.addClass(evt.target, 'orig-' + _PENDO_SELECTION_HIGHLIGHT_CLASS);
            selmo.fixOnClick(evt.target);

            var client_coords = { x: evt.clientX, y: evt.clientY };
            var screen_coords = { x: evt.screenX, y: evt.screenY };

            // NOTE: can't stringify evt or evt.target: circular reference
            tellMaster({
                type: 'click',
                url: location.toString(),
                target: {
                    tagName: evt.target.tagName,
                    path: selmo.getTargetPath(evt.target),
                    cssMatch: selmo.computeCssMatch(evt.target)
                },
                location: {
                    client: client_coords,
                    screen: screen_coords
                }
            });

            return selmo.stopEventBubbling(evt);
        } else if (selmo.isPreviewElement(evt.target) === true) {
            return true;
        }

        return true;
        // return selmo.stopEventBubbling(evt);
    };

    selmo.findNthParent = function (elem, nth) {
        var p = elem.parentNode;
        var count = 1;

        while (count < nth) {
            p = p.parentNode;
            count++;
        }

        return p;
    };

    selmo.handleMoveSelectionUp = function (data) {
        var nth = data.distance;

        var origClass = 'orig-' + _PENDO_SELECTION_HIGHLIGHT_CLASS;

        dom.removeClass('.' + _PENDO_SELECTION_HIGHLIGHT_CLASS, _PENDO_SELECTION_HIGHLIGHT_CLASS);

        if (nth === 0) {
            dom.addClass('.' + origClass, _PENDO_SELECTION_HIGHLIGHT_CLASS);
        } else {
            var elem = document.getElementsByClassName(origClass)[0];
            var target = selmo.findNthParent(elem, nth);

            dom.addClass(target, _PENDO_SELECTION_HIGHLIGHT_CLASS);

            if (data.returnCss) {
                var cssMatch = selmo.computeCssMatch(target);
                tellMaster({ type: 'cssMatch', match: cssMatch });
            }
        }
    };

    selmo.MODES = {
        selection: selmo.startSelectionMode,
        navigation: selmo.startNavigationMode,
        overlay: selmo.startOverlayMode
    };

    selmo.editorInstance = null; // CKEDITOR INSTANCE
    selmo.currentUploadInfo = null;

    selmo.showGuidePreview = function (guideOrStep) {
        if (!pendo.designer || !pendo.designer.GuideFactory) {
            return false;
        }

        selmo.closePreview(true); // don't tell master about this closePreview

        var guide = guideOrStep;
        if (guideOrStep.guideId) {
            guide = {
                id: guideOrStep.guideId,
                steps: [guideOrStep],
                attributes: {}
            };
            if (guideOrStep.badgeInfo) {
                guide.launchMethod = 'badge';
                guide.attributes.badge = guideOrStep.badgeInfo;
            }
        }
        guide = pendo.designer.GuideFactory(guide);

        guide.placeBadge();
        guide.show();

        selmo.previewedGuide = guide;
        previewPoll(selmo.pollPreviewMode);
        return guide.isShown();
    };

    selmo.previewGuide = function (data) {
        var guide = data.guide;

        guide.hideCredits = data.config.hidePoweredBy;

        var shown = selmo.showGuidePreview(guide);

        if (guide.isEditable && !shown) {
            selmo.previewGuideThreadHandle = window.setTimeout(function () {
                selmo.previewGuide(data);
            }, DEFAULT_TIMER_LENGTH);
        } else if (shown) {
            var elms = getGuidePreviewDOM();
            var guideContentElement = elms;
            if (guide.upload) {
                selmo.currentUploadInfo = guide.upload;
            }
            if (guideContentElement) {
                if (guide.isEditable) {
                    guideContentElement.setAttribute('contenteditable', 'true');
                }
                var editPreviewClickFn = function editPreviewClickFn() {
                    detachEvent(guideContentElement.parentNode, 'click', editPreviewClickFn);
                    _.delay(function () {
                        initEditor(guide);
                    }, 200);
                };
                attachEvent(guideContentElement.parentNode, 'click', editPreviewClickFn);
            }

            sendGuideCss();
        }
    };

    var getGuidePreviewDOM = function getGuidePreviewDOM() {
        var guideElem = Sizzle('._pendo-guide_')[0],
            contentElem = Sizzle('._pendo-guide-content_', guideElem)[0];

        if (!Sizzle('#pendo_cke_toolbar').length) {
            // add a spot for the CKEDITOR toolbar to live
            var toolbarElem = document.createElement('div');
            toolbarElem.id = 'pendo_cke_toolbar';
            guideElem.appendChild(toolbarElem);
        }

        if (contentElem) {
            contentElem.id = 'editing_guide_preview';
        }
        return contentElem;
    };

    selmo.updateUploadInfo = function (data) {
        selmo.currentUploadInfo = data.upload;
    };

    var initEditor = function initEditor(guide) {
        if (guide && guide.isEditable) {
            log('calling ckeditor inline');

            var basePath = window.PENDO_CKEDITOR_BASEPATH = PENDO_CKEDITOR.basePath = pendo.HOST + '/js/lib/ckeditor/';

            var plugins = PENDO_CKEDITOR.plugins;
            if (!plugins.externals['pendo-poll']) {
                plugins.addExternal('pendo-poll', pendo.HOST + '/modules/pendo.designer/plugins/ckeditor/pendo-poll/');
            }

            var ck = PENDO_CKEDITOR.inline('editing_guide_preview', {
                customConfig: '',
                removePlugins: 'elementspath',
                removeButtons: 'Subscript,Superscript,StrikeThrough',
                extraPlugins: 'simpleuploads,oembed,justify,widget,lineutils,font,richcombo,panelbutton,floatpanel,colorbutton,image2,sharedspace,pendo-poll',
                simpleuploads_acceptedExtensions: 'jpg|jpeg|png|gif',
                filebrowserImageUploadUrl: '/test/upload',
                removeDialogTabs: 'image:advanced;link:advanced',
                baseFloatZIndex: 9999999,
                allowedContent: true,
                // TODO: add `protectedSource` regex for `<%= %>` tags?
                startupFocus: true,
                sharedSpaces: {
                    top: 'pendo_cke_toolbar'
                },
                toolbar: [['Source', '-', 'JustifyLeft', 'JustifyCenter', 'JustifyRight', 'JustifyBlock', '-', 'Bold', 'Italic', 'Underline', 'Link', 'Image', 'Youtube', 'oembed', 'Font', 'FontSize', 'TextColor']]
            });

            selmo.editorInstance = ck;

            ck.on('instanceReady', function (ev) {
                var editor = ev.editor;
                editor.setReadOnly(false);

                var el = getGuidePreviewDOM();
                var editor_id = editor.ui.spaceId('contents');
            });

            ck.on('simpleuploads.startUpload', function (ev) {
                var upload = selmo.currentUploadInfo;
                ev.data.extraFields = upload.extraFields || upload.extraData;
                ev.data.url = upload.url || upload.uploadUrl;
                ev.data.downloadUrl = upload.downloadUrl;
            });

            // Get new upload info when an upload finishes
            var prepareUpload = function prepareUpload() {
                tellMaster({ type: 'prepare-upload' });
            };
            ck.on('simpleuploads.finishedUpload', function () {
                prepareUpload();
                var html = selmo.editorInstance.getData();
                updateGuideObjectContent(html);
                tellMaster({ type: 'content-changed', html: html });
            });
            ck.on('simpleuploads.endUpload', prepareUpload);

            ck.on('change', function (evt) {
                var html = selmo.editorInstance.getData();
                updateGuideObjectContent(html);
                tellMaster({ type: 'content-changed', html: html });
            });
        }
    };

    selmo.killEditor = function () {
        if (selmo.editorInstance) {
            selmo.editorInstance.destroy();
            selmo.editorInstance = null;
        }
    };

    selmo.closePreview = function (silent) {
        window.clearTimeout(selmo.previewGuideThreadHandle);
        delete selmo.previewGuideThreadHandle;

        if (selmo.isPreviewing()) {
            if (selmo.previewedGuide) {
                selmo.previewedGuide.hide();
                delete selmo.previewedGuide;
            }

            stopGuides();
            removeAllBadges();

            selmo.killEditor();

            if (!silent) {
                tellMaster({ status: 'success', type: 'preview-dismissed', msg: 'preview is over' });
            }
        }
    };

    var updateGuideObjectContent = function updateGuideObjectContent(newContent) {
        var guide = selmo.previewedGuide;
        if (guide) {
            _.each(guide.steps, function (step) {
                step.content = newContent;
            });
        }
        resizeGuidePreview();
    };

    var resizeGuidePreview = function resizeGuidePreview(newContent) {
        var guide = selmo.previewedGuide;
        if (guide) {
            _.each(guide.steps, function (step) {
                if (_.isFunction(step.resize)) {
                    step.resize();
                }
            });
        }
    };

    selmo.updateContent = function (data) {
        updateGuideObjectContent(data.html);
        if (selmo.editorInstance) {
            // If there is an editor, just update the content
            selmo.editorInstance.setData(data.html);
        } else {
            var content = document.getElementById('editing_guide_preview');
            if (content) {
                var guide = selmo.previewedGuide,
                    step = guide && _.first(guide.steps);
                if (step && _.isFunction(step.getContent)) {
                    delete step.template; // force template recompilation
                    content.innerHTML = step.getContent();
                } else {
                    content.innerHTML = data.html;
                }
            }
        }
        previewPoll(selmo.pollPreviewMode);
    };

    var updateGuideWidget = function updateGuideWidget(data) {
        var guideWidget = pendo.guideWidget = pendo.guideWidget || { data: {} };
        if (data && data.config) {
            _.extend(guideWidget.data, data.config);
            guideWidget.template = null;
        }
    };

    selmo.toggleLauncher = function (data) {
        updateGuideWidget(data);
        if (data.config.enabled) {
            removeLauncher();
            createLauncher(data.config);
            selmo.updateActiveGuides();

            data.config.hide ? hideLauncher() : showLauncher();
        } else {
            // Kill the thing.
            removeLauncher();
        }

        selmo.updateGuideCss(data);
    };

    selmo.updateGuideCss = function (data) {
        var style = Sizzle('#_pendo-css_')[0];
        if (_.isString(data)) {
            style.textContent = data;
        } else {
            if (style) {
                style.parentNode.removeChild(style);
            }
            updateGuideWidget(data);
            loadGuideCss();
        }
    };

    // ----------------------------------------------------------------

    // !?
    // WHY:  why is this function isPreviewElement needed?

    // We should definitely not let the user attempt to select any
    // Pendo generated content inside their own app.

    // Ok, this appears to be

    selmo.isPreviewElement = function (elem) {
        while (elem) {
            if (dom.hasClass(elem, '_pendo-guide-content_') || dom.hasClass(elem, 'cke_')) {
                return true;
            }
            // if(elem.className.indexOf("_pendo-guide-content_") >= 0 || elem.className.indexOf("cke_") >= 0) {
            //     return true;
            // }
            elem = elem.parentElement;
        }
        return false;
    };

    selmo.selectElement = function (data) {
        var element;

        try {
            element = Sizzle(data.cssMatch)[0];
        } catch (e) {}

        var target = {};

        if (!element) {
            target.available = false;
        } else {
            dom.addClass(element, 'orig-' + _PENDO_SELECTION_HIGHLIGHT_CLASS);

            target = {
                tagName: element.tagName,
                path: selmo.getTargetPath(element),
                cssMatch: data.cssMatch,
                available: true
            };
        }

        tellMaster({
            type: 'elementInfo',
            promiseId: data.promiseId,
            target: target
        });
    };

    /* This is a RPC call.  Simply know that for now. */
    selmo.takeSnapshot = function (data) {
        try {
            var guide = selmo.previewedGuide;
            if (guide) {
                var contentDiv = Sizzle('._pendo-guide_ ._pendo-guide-content_');
                // Make sure templates are evaluated before screenshot
                guide.hide();
                _.each(guide.steps, function (step) {
                    step.template = pendo._.template(step.content || '');
                    delete step.isEditable;
                });
                guide.placeBadge();
                guide.show();
            }

            selmo.killEditor();

            var guideDiv = dom('._pendo-guide_');
            if (guideDiv.length && selmo.isElementVisible(guideDiv[0])) {
                html2canvas(guideDiv[0], {
                    background: 'transparent',
                    onrendered: function onrendered(canvas) {
                        try {
                            var resizedCanvas = document.createElement('canvas');
                            var resizedContext = resizedCanvas.getContext('2d');

                            var sx = 0;
                            var sy = 0;
                            var guideWidth = guideDiv.width();
                            var guideHeight = guideDiv.height();
                            var maxBannerWidth = 600;

                            // Restrict the width of banner guide snapshots
                            if (dom.hasClass(guideDiv[0], '_pendo-guide-banner_')) {
                                sx = Math.floor(Math.max(0, guideWidth / 2 - maxBannerWidth / 2));
                                guideWidth = Math.min(guideWidth, maxBannerWidth);
                            }

                            var guideRatio = guideHeight / guideWidth;
                            var dRatio = 3 / 4;
                            var dw = guideWidth;
                            var dh = guideHeight;
                            var dx = 0;
                            var dy = 0;

                            // screenshot using 3:4 aspect ratio
                            if (guideRatio > dRatio) {
                                dw = Math.floor(guideHeight / dRatio);
                                dx = Math.floor(Math.abs((dw - guideWidth) / 2));
                            } else {
                                dh = Math.floor(guideWidth * dRatio);
                                dy = Math.floor(Math.abs((dh - guideHeight) / 2));
                            }

                            resizedCanvas.width = dw;
                            resizedCanvas.height = dh;

                            resizedContext.drawImage(canvas, sx, sy, dw, guideHeight, dx, dy, dw, guideHeight);

                            var image = resizedCanvas.toDataURL('image/png');
                            tellMaster({
                                type: 'snapshot',
                                promiseId: data.promiseId,
                                image: image
                            });
                        } catch (e) {
                            tellMaster({
                                type: 'snapshot',
                                promiseId: data.promiseId
                            });
                        }
                    },
                    useCORS: true
                });
            } else {
                tellMaster({
                    type: 'snapshot',
                    promiseId: data.promiseId
                });
            }
        } catch (e) {
            tellMaster({
                type: 'snapshot',
                promiseId: data.promiseId
            });
        }
    };

    selmo.stopIfSelecting = function (evt) {
        // add support for shiftkey here
        if (selmo.isInState(SELECTION_MODE) && !selmo.isPreviewElement(evt.target) && !detectModKeys(evt)) {
            return selmo.stopEventBubbling(evt);
        }
    };

    selmo.attachTo = function (eventTuple) {
        attachEvent(document, eventTuple[0], eventTuple[1], true);
    };

    selmo.normalizedUrl = function (data) {
        pendo.normalizedUrl = data.url;
    };

    // TODO: update this to use the one exported from Agent
    var detachEvent = function detachEvent(element, evt, fn, useCapture) {
        if (!useCapture) useCapture = false;
        if (element.removeEventListener) {
            element.removeEventListener(evt, fn, useCapture);
        } else {
            element.detachEvent('on' + evt, fn);
        }
    };

    var onLoaded = function onLoaded() {
        selmo.updateGuideCss();
        addMessages(_.partial(addEvents, finishInit));
    };

    var addMessages = function addMessages(cb) {
        tellMaster({ status: 'success', type: 'module', msg: 'selection is loaded', module: 'selection' });
        registerMessageHandler('selection-mode', handleModeChange);
        registerMessageHandler('move-selection-up', selmo.handleMoveSelectionUp);
        registerMessageHandler('test-css-selector', selmo.testCssSelector);

        registerMessageHandler('preview-guide', selmo.previewGuide);
        registerMessageHandler('stop-preview', selmo.closePreview);

        registerMessageHandler('update-content', selmo.updateContent);
        registerMessageHandler('take-snapshot', selmo.takeSnapshot);
        registerMessageHandler('select-element', selmo.selectElement);
        registerMessageHandler('toggle-launcher', selmo.toggleLauncher);
        registerMessageHandler('tagged-features', selmo.updateTaggedFeatures);
        registerMessageHandler('active-guides', selmo.updateActiveGuides);
        registerMessageHandler('upload-info', selmo.updateUploadInfo);
        registerMessageHandler('normalized-url', selmo.normalizedUrl);

        registerMessageHandler('preview-html', _.partial(setupRpc, previewHtml));
        registerMessageHandler('preview-css', _.partial(setupRpc, previewCss));
        registerMessageHandler('preview-poll', _.partial(setupRpc, previewPoll));
        registerMessageHandler('stop-preview-html-css', _.partial(setupRpc, stopPreviewHtmlCss));
        registerMessageHandler('check-guides-enabled', _.partial(setupRpc, checkGuidesEnabled));
        registerMessageHandler('get-site-theme', _.partial(setupRpc, selmo.getSiteTheme));

        // Latest: added for Guide-Templates.  Next steps are to either makes these the
        // only ones or get rid of them and use the others
        registerMessageHandler('previewGuide', _.partial(setupRpc, previewGuide));
        registerMessageHandler('stopPreviewGuide', _.partial(setupRpc, stopPreviewGuide));
        registerMessageHandler('reconnect', finishInit);

        cb();
    };

    var lastPreviewedGuide = null;
    var previewGuide = function previewGuide(msgContent) {
        stopPreviewGuide();
        _.each(msgContent.guide.steps, function (step) {
            step.hideCredits = msgContent.config.hidePoweredBy;
        });
        var guide = GuideFactory(msgContent.guide, true);
        lastPreviewedGuide = guide;
        return guide.show();
    };

    var stopPreviewGuide = function stopPreviewGuide(msgContent) {
        if (lastPreviewedGuide) lastPreviewedGuide.hide();
    };

    var addEvents = function addEvents(cb) {
        // setup handlers
        var events = [['mouseout', selmo.unhighlight], ['mousemove', selmo.highlight], ['click', selmo.click], ['mousedown', selmo.stopIfSelecting], ['mouseup', selmo.stopIfSelecting], ['dblclick', selmo.stopIfSelecting]];
        // now, map this to...
        events.map(selmo.attachTo);

        cb();
    };

    var setupRpc = function setupRpc(fn, data) {
        var pId = data.promiseId;
        var obj = fn(data);
        return masterAck(pId, obj);
    };

    var masterAck = function masterAck(pId, data) {
        if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== undefined && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object') {
            data = { value: data };
        }

        data = data || {};
        data.promiseId = pId;

        tellMaster(data);
    };

    var addDefaultCss = function addDefaultCss() {
        var cssLink = Sizzle('link#_pendo-css_');
        if (cssLink == 0) {
            loadGuideCss();
        }
    };

    var removeDefaultCss = function removeDefaultCss() {
        var cssLink = Sizzle('link#_pendo-css_');
        if (cssLink.length > 0) {
            _.each(cssLink, function (link) {
                link.parentNode.removeChild(link);
            });
        }
    };

    var previewCss = function previewCss(data) {
        var html = data.preview.html,
            css = data.preview.css,
            type = data.preview.type || 'lightbox',
            config = data.config || {};

        if (css) {
            removeDefaultCss();
        } else {
            addDefaultCss();
        }

        var content = addCssToHtml(css, html);

        previewHtmlCss(type, content, config);
    };

    var addCssToHtml = function addCssToHtml(css, html) {
        css = "<style type='text/css'>" + css + '</style>';
        return css + html;
    };

    // TODO:
    // - how to handle tooltip (what element to anchor to)?
    // - how to handle different tooltip arrow directions?
    // - Launcher customizations?
    var previewHtml = function previewHtml(obj) {
        var html = obj.preview.html,
            css = obj.preview.css,
            type = obj.preview.type,
            config = obj.config || {};

        var content = html;

        if (css) {
            content = addCssToHtml(css, html);
        }

        previewHtmlCss(type, content, config);
    };

    var previewPoll = function previewPoll(obj) {
        if (!obj) return;
        selmo.pollPreviewMode = obj;
        var poll = dom('._pendo-poll_'),
            message = dom('._pendo-poll-message_'),
            npsRating = dom('._pendo-poll-npsrating_'),
            submit = dom('._pendo-poll-submit_');
        if (poll.length) {
            var submitted = '_pendo-poll-submitted_',
                npsRatingSelected = '_pendo-poll-npsrating-selected_';
            poll.removeClass(submitted);
            poll.removeClass(npsRatingSelected);
            if (npsRating.length) {
                submit.css({ display: 'none' });
            }
            if (obj.preview == 'message' && message.length) {
                poll.addClass(submitted);
                message.css('margin-top:-' + message.height() / 2 + 'px');
            } else if (obj.preview == 'npsreason') {
                poll.addClass(npsRatingSelected);
                submit.css({ display: '' });
            }
            resizeGuidePreview();
        }
    };

    var previewHtmlCss = _.throttle(function (type, content, config) {
        removePreviewHtmlCss();

        var guide = GuideFactory({
            id: 'preview-guide',
            steps: [{
                id: 'preview-step',
                type: type,
                content: content,
                hideCredits: config.hidePoweredBy
            }],
            attributes: {}
        });

        guide.show();

        if (type == 'tooltip') {
            dom('#_pendo_g_preview-step').css('top: 0px;');
            var pos = getOffsetPosition(dom('#_pendo_g_preview-step')[0]);
            var xScrollAmt = pos.left + pos.width - window.innerWidth;
            var yScrollamt = pos.top + pos.height - window.innerHeight;
            window.scrollTo(xScrollAmt, 0);
        }
    }, 100, { leading: false });

    var removePreviewHtmlCss = function removePreviewHtmlCss() {
        dom('#_pendo_g_preview-step').remove();
        stopGuides();
    };

    var stopPreviewHtmlCss = function stopPreviewHtmlCss() {
        removePreviewHtmlCss();
        addDefaultCss();
    };

    var checkGuidesEnabled = function checkGuidesEnabled() {
        return areGuidesEnabled;
    };

    // Clobber guide events to prevent dismiss/advance buttons from doing anything
    pendo.onGuideAdvanced = function () {};
    pendo.onGuideDismissed = function () {};
    pendo.onGuidePrevious = function () {};

    var finishInit = function finishInit() {
        tellMaster({
            type: 'ready',
            version: pendo.VERSION,
            visitorId: getVisitorId()
        });
    };

    var sendGuideCss = function sendGuideCss() {
        var curGuideContainer = dom('._pendo-guide_ ._pendo-guide-container_');

        if (curGuideContainer.length > 0) {
            var backgroundColor = getComputedStyle(curGuideContainer[0])['background-color'];
            tellMaster({
                type: 'guidePreview',
                backgroundColor: backgroundColor
            });
        }
    };

    whenLoadedCall(onLoaded);

    var allowContains = function allowContains(selectors) {
        return !/:contains\(/.test(selectors.join(' '));
    };
}

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(76)();
// imports


// module
exports.push([module.i, "body.pendo-selection .pendo-selection-HL {\n    outline: 2px solid red !important;\n}\n\nbody.pendo-selection .pendo-tagged-HL {\n    outline: 2px solid #999;\n}\n\n.pendo-overlay {\n    z-index: 10000;\n    opacity: 0.7;\n}\n\n.pendo-tooltip {\n    position: absolute;\n    visibility: hidden;\n    z-index: 10000;\n    padding: 4px;\n}\n\n.pendo-tooltip.pendo-tether-enabled {\n    visibility: visible;\n}\n\n.pendo-tooltip>.pendo-tooltip-content {\n    position: relative;\n    z-index: 2;\n    background-color: #EEE;\n    padding: 5px;\n    box-shadow: 1px 1px 2px 0px #CCC;\n    font-size: 10px;\n    text-transform: uppercase;\n    color: #333;\n}\n\n.pendo-tooltip:before,\n.pendo-tooltip:after {\n    content: '';\n    width: 10px;\n    height: 10px;\n    background-color: #EEE;\n    -webkit-transform: rotate(45deg);\n    -moz-transform: rotate(45deg);\n    -ms-transform: rotate(45deg);\n    -o-transform: rotate(45deg);\n    transform: rotate(45deg);\n    position: absolute;\n    top: auto;\n    bottom: auto;\n    left: auto;\n    right: auto;\n    margin: 0;\n}\n\n.pendo-tooltip:before {\n    z-index: 3;\n}\n\n.pendo-tooltip:after {\n    z-index: 1;\n    box-shadow: 1px 1px 2px 0px #CCC;\n}\n\n.pendo-tooltip.pendo-tether-target-attached-center:before,\n.pendo-tooltip.pendo-tether-target-attached-center:after {\n    left: 50%;\n    margin-left: -5px;\n}\n\n.pendo-tooltip.pendo-tether-target-attached-bottom:before,\n.pendo-tooltip.pendo-tether-target-attached-bottom:after {\n    top: -1px;\n}\n\n.pendo-tooltip.pendo-tether-target-attached-top:before,\n.pendo-tooltip.pendo-tether-target-attached-top:after {\n    bottom: -1px;\n}\n\n.pendo-tooltip.pendo-tether-target-attached-middle:before,\n.pendo-tooltip.pendo-tether-target-attached-middle:after {\n    top: 50%;\n    margin-top: -5px;\n}\n\n.pendo-tooltip.pendo-tether-target-attached-right:before,\n.pendo-tooltip.pendo-tether-target-attached-right:after {\n    left: -1px;\n}\n\n.pendo-tooltip.pendo-tether-target-attached-left:before,\n.pendo-tooltip.pendo-tether-target-attached-left:after {\n    right: -1px;\n}\n\n.pendo-tooltip strong {\n    font-size: 11px;\n}\n\n.pendo-tooltip table tr td {\n    padding-left: 5px;\n    vertical-align: bottom;\n    text-align: right;\n}\n\n.pendo-tooltip table tr td:first-child {\n    text-align: left;\n    vertical-align: middle;\n    padding-left: 0;\n}\n\n.pendo-tooltip table tr td:last-child {\n    text-align: left;\n}\n\n.pendo-tooltip table tr td[colspan] {\n    text-align: center;\n}\n\n.pendo-tooltip table tr td.pendo-processing-feature {\n    font-style: italic;\n    text-transform: none;\n}\n\n.pendo-tooltip .pendo-progressbar {\n    height: 6px;\n    width: 40px;\n    text-align: left;\n    padding: 0;\n    background-color: #CCC;\n}\n\n.pendo-tooltip .pendo-progressbar > div {\n    height: 100%;\n    background-color: #333;\n}\n\n.pendo-tooltip .pendo-edit-feature {\n    padding-top: 5px;\n    text-align: right;\n}\n\n.pendo-tooltip .pendo-edit-feature > a {\n    color: darkblue;\n    text-decoration: none;\n}\n\n.pendo-tooltip .pendo-edit-feature > a:hover {\n    text-decoration: underline;\n}\n\n._pendo-guide_ > ._pendo-guide-container_ > ._pendo-guide-content_[contenteditable] {\n    outline-style: none;\n}\n\n._pendo-launcher-item_,\n._pendo-launcher-item_ > a {\n    cursor: move;\n}\n\n#pendo_cke_toolbar {\n    position: absolute;\n    top: -29px;\n    left: 15px;\n    min-width: 520px;\n    z-index: 1000;\n    /* make sure the toolbar is visible */\n    display: block !important;\n    visibility: visible !important;\n    opacity: 1 !important;\n}\n\n@media screen and (max-width: 320px) {\n    ._pendo-launcher-active_ {\n        display: none !important;\n    }\n}\n", ""]);

// exports


/***/ }),
/* 76 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function() {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		var result = [];
		for(var i = 0; i < this.length; i++) {
			var item = this[i];
			if(item[2]) {
				result.push("@media " + item[2] + "{" + item[1] + "}");
			} else {
				result.push(item[1]);
			}
		}
		return result.join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};


/***/ }),
/* 77 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(1);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var InnerSubscriber = (function (_super) {
    __extends(InnerSubscriber, _super);
    function InnerSubscriber(parent, outerValue, outerIndex) {
        _super.call(this);
        this.parent = parent;
        this.outerValue = outerValue;
        this.outerIndex = outerIndex;
        this.index = 0;
    }
    InnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };
    InnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
    };
    InnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return InnerSubscriber;
}(Subscriber_1.Subscriber));
exports.InnerSubscriber = InnerSubscriber;
//# sourceMappingURL=InnerSubscriber.js.map

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* tslint:disable:no-unused-variable */
// Subject imported before Observable to bypass circular dependency issue since
// Subject extends Observable and Observable references Subject in it's
// definition
var Subject_1 = __webpack_require__(5);
exports.Subject = Subject_1.Subject;
exports.AnonymousSubject = Subject_1.AnonymousSubject;
/* tslint:enable:no-unused-variable */
var Observable_1 = __webpack_require__(0);
exports.Observable = Observable_1.Observable;
// statics
/* tslint:disable:no-use-before-declare */
__webpack_require__(81);
__webpack_require__(82);
__webpack_require__(83);
__webpack_require__(84);
__webpack_require__(85);
__webpack_require__(88);
__webpack_require__(89);
__webpack_require__(90);
__webpack_require__(91);
__webpack_require__(92);
__webpack_require__(93);
__webpack_require__(94);
__webpack_require__(95);
__webpack_require__(96);
__webpack_require__(97);
__webpack_require__(102);
__webpack_require__(98);
__webpack_require__(99);
__webpack_require__(100);
__webpack_require__(101);
__webpack_require__(103);
__webpack_require__(106);
__webpack_require__(104);
__webpack_require__(105);
__webpack_require__(107);
//dom
__webpack_require__(86);
__webpack_require__(87);
//operators
__webpack_require__(110);
__webpack_require__(111);
__webpack_require__(112);
__webpack_require__(113);
__webpack_require__(114);
__webpack_require__(115);
__webpack_require__(116);
__webpack_require__(117);
__webpack_require__(118);
__webpack_require__(119);
__webpack_require__(120);
__webpack_require__(121);
__webpack_require__(122);
__webpack_require__(128);
__webpack_require__(123);
__webpack_require__(124);
__webpack_require__(125);
__webpack_require__(126);
__webpack_require__(127);
__webpack_require__(129);
__webpack_require__(130);
__webpack_require__(131);
__webpack_require__(132);
__webpack_require__(135);
__webpack_require__(136);
__webpack_require__(137);
__webpack_require__(133);
__webpack_require__(138);
__webpack_require__(139);
__webpack_require__(140);
__webpack_require__(141);
__webpack_require__(142);
__webpack_require__(143);
__webpack_require__(144);
__webpack_require__(145);
__webpack_require__(108);
__webpack_require__(109);
__webpack_require__(146);
__webpack_require__(147);
__webpack_require__(134);
__webpack_require__(148);
__webpack_require__(149);
__webpack_require__(150);
__webpack_require__(151);
__webpack_require__(152);
__webpack_require__(153);
__webpack_require__(154);
__webpack_require__(155);
__webpack_require__(156);
__webpack_require__(157);
__webpack_require__(158);
__webpack_require__(159);
__webpack_require__(160);
__webpack_require__(161);
__webpack_require__(162);
__webpack_require__(163);
__webpack_require__(164);
__webpack_require__(165);
__webpack_require__(167);
__webpack_require__(166);
__webpack_require__(168);
__webpack_require__(169);
__webpack_require__(170);
__webpack_require__(171);
__webpack_require__(172);
__webpack_require__(173);
__webpack_require__(174);
__webpack_require__(175);
__webpack_require__(176);
__webpack_require__(177);
__webpack_require__(178);
__webpack_require__(179);
__webpack_require__(180);
__webpack_require__(181);
__webpack_require__(182);
__webpack_require__(183);
__webpack_require__(184);
__webpack_require__(185);
__webpack_require__(186);
__webpack_require__(187);
__webpack_require__(188);
__webpack_require__(189);
__webpack_require__(190);
__webpack_require__(191);
__webpack_require__(192);
__webpack_require__(193);
__webpack_require__(194);
__webpack_require__(195);
__webpack_require__(196);
__webpack_require__(197);
__webpack_require__(198);
__webpack_require__(199);
__webpack_require__(200);
__webpack_require__(201);
__webpack_require__(202);
__webpack_require__(203);
__webpack_require__(204);
__webpack_require__(205);
__webpack_require__(206);
__webpack_require__(207);
/* tslint:disable:no-unused-variable */
var Subscription_1 = __webpack_require__(4);
exports.Subscription = Subscription_1.Subscription;
var Subscriber_1 = __webpack_require__(1);
exports.Subscriber = Subscriber_1.Subscriber;
var AsyncSubject_1 = __webpack_require__(19);
exports.AsyncSubject = AsyncSubject_1.AsyncSubject;
var ReplaySubject_1 = __webpack_require__(29);
exports.ReplaySubject = ReplaySubject_1.ReplaySubject;
var BehaviorSubject_1 = __webpack_require__(38);
exports.BehaviorSubject = BehaviorSubject_1.BehaviorSubject;
var ConnectableObservable_1 = __webpack_require__(41);
exports.ConnectableObservable = ConnectableObservable_1.ConnectableObservable;
var Notification_1 = __webpack_require__(15);
exports.Notification = Notification_1.Notification;
var EmptyError_1 = __webpack_require__(24);
exports.EmptyError = EmptyError_1.EmptyError;
var ArgumentOutOfRangeError_1 = __webpack_require__(23);
exports.ArgumentOutOfRangeError = ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
var ObjectUnsubscribedError_1 = __webpack_require__(25);
exports.ObjectUnsubscribedError = ObjectUnsubscribedError_1.ObjectUnsubscribedError;
var TimeoutError_1 = __webpack_require__(60);
exports.TimeoutError = TimeoutError_1.TimeoutError;
var UnsubscriptionError_1 = __webpack_require__(61);
exports.UnsubscriptionError = UnsubscriptionError_1.UnsubscriptionError;
var timeInterval_1 = __webpack_require__(53);
exports.TimeInterval = timeInterval_1.TimeInterval;
var timestamp_1 = __webpack_require__(54);
exports.Timestamp = timestamp_1.Timestamp;
var TestScheduler_1 = __webpack_require__(343);
exports.TestScheduler = TestScheduler_1.TestScheduler;
var VirtualTimeScheduler_1 = __webpack_require__(55);
exports.VirtualTimeScheduler = VirtualTimeScheduler_1.VirtualTimeScheduler;
var AjaxObservable_1 = __webpack_require__(44);
exports.AjaxResponse = AjaxObservable_1.AjaxResponse;
exports.AjaxError = AjaxObservable_1.AjaxError;
exports.AjaxTimeoutError = AjaxObservable_1.AjaxTimeoutError;
var asap_1 = __webpack_require__(56);
var async_1 = __webpack_require__(9);
var queue_1 = __webpack_require__(57);
var animationFrame_1 = __webpack_require__(340);
var rxSubscriber_1 = __webpack_require__(22);
var iterator_1 = __webpack_require__(18);
var observable_1 = __webpack_require__(21);
/* tslint:enable:no-unused-variable */
/**
 * @typedef {Object} Rx.Scheduler
 * @property {Scheduler} queue Schedules on a queue in the current event frame
 * (trampoline scheduler). Use this for iteration operations.
 * @property {Scheduler} asap Schedules on the micro task queue, which uses the
 * fastest transport mechanism available, either Node.js' `process.nextTick()`
 * or Web Worker MessageChannel or setTimeout or others. Use this for
 * asynchronous conversions.
 * @property {Scheduler} async Schedules work with `setInterval`. Use this for
 * time-based operations.
 * @property {Scheduler} animationFrame Schedules work with `requestAnimationFrame`.
 * Use this for synchronizing with the platform's painting
 */
var Scheduler = {
    asap: asap_1.asap,
    queue: queue_1.queue,
    animationFrame: animationFrame_1.animationFrame,
    async: async_1.async
};
exports.Scheduler = Scheduler;
/**
 * @typedef {Object} Rx.Symbol
 * @property {Symbol|string} rxSubscriber A symbol to use as a property name to
 * retrieve an "Rx safe" Observer from an object. "Rx safety" can be defined as
 * an object that has all of the traits of an Rx Subscriber, including the
 * ability to add and remove subscriptions to the subscription chain and
 * guarantees involving event triggering (can't "next" after unsubscription,
 * etc).
 * @property {Symbol|string} observable A symbol to use as a property name to
 * retrieve an Observable as defined by the [ECMAScript "Observable" spec](https://github.com/zenparsing/es-observable).
 * @property {Symbol|string} iterator The ES6 symbol to use as a property name
 * to retrieve an iterator from an object.
 */
var Symbol = {
    rxSubscriber: rxSubscriber_1.$$rxSubscriber,
    observable: observable_1.$$observable,
    iterator: iterator_1.$$iterator
};
exports.Symbol = Symbol;
//# sourceMappingURL=Rx.js.map

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * An execution context and a data structure to order tasks and schedule their
 * execution. Provides a notion of (potentially virtual) time, through the
 * `now()` getter method.
 *
 * Each unit of work in a Scheduler is called an {@link Action}.
 *
 * ```ts
 * class Scheduler {
 *   now(): number;
 *   schedule(work, delay?, state?): Subscription;
 * }
 * ```
 *
 * @class Scheduler
 */
var Scheduler = (function () {
    function Scheduler(SchedulerAction, now) {
        if (now === void 0) { now = Scheduler.now; }
        this.SchedulerAction = SchedulerAction;
        this.now = now;
    }
    /**
     * Schedules a function, `work`, for execution. May happen at some point in
     * the future, according to the `delay` parameter, if specified. May be passed
     * some context object, `state`, which will be passed to the `work` function.
     *
     * The given arguments will be processed an stored as an Action object in a
     * queue of actions.
     *
     * @param {function(state: ?T): ?Subscription} work A function representing a
     * task, or some unit of work to be executed by the Scheduler.
     * @param {number} [delay] Time to wait before executing the work, where the
     * time unit is implicit and defined by the Scheduler itself.
     * @param {T} [state] Some contextual data that the `work` function uses when
     * called by the Scheduler.
     * @return {Subscription} A subscription in order to be able to unsubscribe
     * the scheduled work.
     */
    Scheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) { delay = 0; }
        return new this.SchedulerAction(this, work).schedule(state, delay);
    };
    Scheduler.now = Date.now ? Date.now : function () { return +new Date(); };
    return Scheduler;
}());
exports.Scheduler = Scheduler;
//# sourceMappingURL=Scheduler.js.map

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var bindCallback_1 = __webpack_require__(226);
Observable_1.Observable.bindCallback = bindCallback_1.bindCallback;
//# sourceMappingURL=bindCallback.js.map

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var bindNodeCallback_1 = __webpack_require__(227);
Observable_1.Observable.bindNodeCallback = bindNodeCallback_1.bindNodeCallback;
//# sourceMappingURL=bindNodeCallback.js.map

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var combineLatest_1 = __webpack_require__(228);
Observable_1.Observable.combineLatest = combineLatest_1.combineLatest;
//# sourceMappingURL=combineLatest.js.map

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var concat_1 = __webpack_require__(229);
Observable_1.Observable.concat = concat_1.concat;
//# sourceMappingURL=concat.js.map

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var defer_1 = __webpack_require__(230);
Observable_1.Observable.defer = defer_1.defer;
//# sourceMappingURL=defer.js.map

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var ajax_1 = __webpack_require__(232);
Observable_1.Observable.ajax = ajax_1.ajax;
//# sourceMappingURL=ajax.js.map

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var webSocket_1 = __webpack_require__(233);
Observable_1.Observable.webSocket = webSocket_1.webSocket;
//# sourceMappingURL=webSocket.js.map

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var empty_1 = __webpack_require__(234);
Observable_1.Observable.empty = empty_1.empty;
//# sourceMappingURL=empty.js.map

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var forkJoin_1 = __webpack_require__(235);
Observable_1.Observable.forkJoin = forkJoin_1.forkJoin;
//# sourceMappingURL=forkJoin.js.map

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var from_1 = __webpack_require__(236);
Observable_1.Observable.from = from_1.from;
//# sourceMappingURL=from.js.map

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var fromEvent_1 = __webpack_require__(237);
Observable_1.Observable.fromEvent = fromEvent_1.fromEvent;
//# sourceMappingURL=fromEvent.js.map

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var fromEventPattern_1 = __webpack_require__(238);
Observable_1.Observable.fromEventPattern = fromEventPattern_1.fromEventPattern;
//# sourceMappingURL=fromEventPattern.js.map

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var fromPromise_1 = __webpack_require__(239);
Observable_1.Observable.fromPromise = fromPromise_1.fromPromise;
//# sourceMappingURL=fromPromise.js.map

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var GenerateObservable_1 = __webpack_require__(216);
Observable_1.Observable.generate = GenerateObservable_1.GenerateObservable.create;
//# sourceMappingURL=generate.js.map

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var if_1 = __webpack_require__(240);
Observable_1.Observable.if = if_1._if;
//# sourceMappingURL=if.js.map

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var interval_1 = __webpack_require__(241);
Observable_1.Observable.interval = interval_1.interval;
//# sourceMappingURL=interval.js.map

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var merge_1 = __webpack_require__(242);
Observable_1.Observable.merge = merge_1.merge;
//# sourceMappingURL=merge.js.map

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var never_1 = __webpack_require__(243);
Observable_1.Observable.never = never_1.never;
//# sourceMappingURL=never.js.map

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var of_1 = __webpack_require__(244);
Observable_1.Observable.of = of_1.of;
//# sourceMappingURL=of.js.map

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var onErrorResumeNext_1 = __webpack_require__(51);
Observable_1.Observable.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNextStatic;
//# sourceMappingURL=onErrorResumeNext.js.map

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var pairs_1 = __webpack_require__(245);
Observable_1.Observable.pairs = pairs_1.pairs;
//# sourceMappingURL=pairs.js.map

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var race_1 = __webpack_require__(52);
Observable_1.Observable.race = race_1.raceStatic;
//# sourceMappingURL=race.js.map

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var range_1 = __webpack_require__(246);
Observable_1.Observable.range = range_1.range;
//# sourceMappingURL=range.js.map

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var throw_1 = __webpack_require__(247);
Observable_1.Observable.throw = throw_1._throw;
//# sourceMappingURL=throw.js.map

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var timer_1 = __webpack_require__(248);
Observable_1.Observable.timer = timer_1.timer;
//# sourceMappingURL=timer.js.map

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var using_1 = __webpack_require__(249);
Observable_1.Observable.using = using_1.using;
//# sourceMappingURL=using.js.map

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var zip_1 = __webpack_require__(250);
Observable_1.Observable.zip = zip_1.zip;
//# sourceMappingURL=zip.js.map

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var audit_1 = __webpack_require__(251);
Observable_1.Observable.prototype.audit = audit_1.audit;
//# sourceMappingURL=audit.js.map

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var auditTime_1 = __webpack_require__(252);
Observable_1.Observable.prototype.auditTime = auditTime_1.auditTime;
//# sourceMappingURL=auditTime.js.map

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var buffer_1 = __webpack_require__(253);
Observable_1.Observable.prototype.buffer = buffer_1.buffer;
//# sourceMappingURL=buffer.js.map

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var bufferCount_1 = __webpack_require__(254);
Observable_1.Observable.prototype.bufferCount = bufferCount_1.bufferCount;
//# sourceMappingURL=bufferCount.js.map

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var bufferTime_1 = __webpack_require__(255);
Observable_1.Observable.prototype.bufferTime = bufferTime_1.bufferTime;
//# sourceMappingURL=bufferTime.js.map

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var bufferToggle_1 = __webpack_require__(256);
Observable_1.Observable.prototype.bufferToggle = bufferToggle_1.bufferToggle;
//# sourceMappingURL=bufferToggle.js.map

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var bufferWhen_1 = __webpack_require__(257);
Observable_1.Observable.prototype.bufferWhen = bufferWhen_1.bufferWhen;
//# sourceMappingURL=bufferWhen.js.map

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var catch_1 = __webpack_require__(258);
Observable_1.Observable.prototype.catch = catch_1._catch;
Observable_1.Observable.prototype._catch = catch_1._catch;
//# sourceMappingURL=catch.js.map

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var combineAll_1 = __webpack_require__(259);
Observable_1.Observable.prototype.combineAll = combineAll_1.combineAll;
//# sourceMappingURL=combineAll.js.map

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var combineLatest_1 = __webpack_require__(31);
Observable_1.Observable.prototype.combineLatest = combineLatest_1.combineLatest;
//# sourceMappingURL=combineLatest.js.map

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var concat_1 = __webpack_require__(32);
Observable_1.Observable.prototype.concat = concat_1.concat;
//# sourceMappingURL=concat.js.map

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var concatAll_1 = __webpack_require__(260);
Observable_1.Observable.prototype.concatAll = concatAll_1.concatAll;
//# sourceMappingURL=concatAll.js.map

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var concatMap_1 = __webpack_require__(261);
Observable_1.Observable.prototype.concatMap = concatMap_1.concatMap;
//# sourceMappingURL=concatMap.js.map

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var concatMapTo_1 = __webpack_require__(262);
Observable_1.Observable.prototype.concatMapTo = concatMapTo_1.concatMapTo;
//# sourceMappingURL=concatMapTo.js.map

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var count_1 = __webpack_require__(263);
Observable_1.Observable.prototype.count = count_1.count;
//# sourceMappingURL=count.js.map

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var debounce_1 = __webpack_require__(264);
Observable_1.Observable.prototype.debounce = debounce_1.debounce;
//# sourceMappingURL=debounce.js.map

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var debounceTime_1 = __webpack_require__(265);
Observable_1.Observable.prototype.debounceTime = debounceTime_1.debounceTime;
//# sourceMappingURL=debounceTime.js.map

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var defaultIfEmpty_1 = __webpack_require__(266);
Observable_1.Observable.prototype.defaultIfEmpty = defaultIfEmpty_1.defaultIfEmpty;
//# sourceMappingURL=defaultIfEmpty.js.map

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var delay_1 = __webpack_require__(267);
Observable_1.Observable.prototype.delay = delay_1.delay;
//# sourceMappingURL=delay.js.map

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var delayWhen_1 = __webpack_require__(268);
Observable_1.Observable.prototype.delayWhen = delayWhen_1.delayWhen;
//# sourceMappingURL=delayWhen.js.map

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var dematerialize_1 = __webpack_require__(269);
Observable_1.Observable.prototype.dematerialize = dematerialize_1.dematerialize;
//# sourceMappingURL=dematerialize.js.map

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var distinct_1 = __webpack_require__(270);
Observable_1.Observable.prototype.distinct = distinct_1.distinct;
//# sourceMappingURL=distinct.js.map

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var distinctUntilChanged_1 = __webpack_require__(45);
Observable_1.Observable.prototype.distinctUntilChanged = distinctUntilChanged_1.distinctUntilChanged;
//# sourceMappingURL=distinctUntilChanged.js.map

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var distinctUntilKeyChanged_1 = __webpack_require__(271);
Observable_1.Observable.prototype.distinctUntilKeyChanged = distinctUntilKeyChanged_1.distinctUntilKeyChanged;
//# sourceMappingURL=distinctUntilKeyChanged.js.map

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var do_1 = __webpack_require__(272);
Observable_1.Observable.prototype.do = do_1._do;
Observable_1.Observable.prototype._do = do_1._do;
//# sourceMappingURL=do.js.map

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var elementAt_1 = __webpack_require__(273);
Observable_1.Observable.prototype.elementAt = elementAt_1.elementAt;
//# sourceMappingURL=elementAt.js.map

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var every_1 = __webpack_require__(274);
Observable_1.Observable.prototype.every = every_1.every;
//# sourceMappingURL=every.js.map

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var exhaust_1 = __webpack_require__(275);
Observable_1.Observable.prototype.exhaust = exhaust_1.exhaust;
//# sourceMappingURL=exhaust.js.map

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var exhaustMap_1 = __webpack_require__(276);
Observable_1.Observable.prototype.exhaustMap = exhaustMap_1.exhaustMap;
//# sourceMappingURL=exhaustMap.js.map

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var expand_1 = __webpack_require__(277);
Observable_1.Observable.prototype.expand = expand_1.expand;
//# sourceMappingURL=expand.js.map

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var filter_1 = __webpack_require__(46);
Observable_1.Observable.prototype.filter = filter_1.filter;
//# sourceMappingURL=filter.js.map

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var finally_1 = __webpack_require__(278);
Observable_1.Observable.prototype.finally = finally_1._finally;
Observable_1.Observable.prototype._finally = finally_1._finally;
//# sourceMappingURL=finally.js.map

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var find_1 = __webpack_require__(47);
Observable_1.Observable.prototype.find = find_1.find;
//# sourceMappingURL=find.js.map

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var findIndex_1 = __webpack_require__(279);
Observable_1.Observable.prototype.findIndex = findIndex_1.findIndex;
//# sourceMappingURL=findIndex.js.map

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var first_1 = __webpack_require__(280);
Observable_1.Observable.prototype.first = first_1.first;
//# sourceMappingURL=first.js.map

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var groupBy_1 = __webpack_require__(281);
Observable_1.Observable.prototype.groupBy = groupBy_1.groupBy;
//# sourceMappingURL=groupBy.js.map

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var ignoreElements_1 = __webpack_require__(282);
Observable_1.Observable.prototype.ignoreElements = ignoreElements_1.ignoreElements;
//# sourceMappingURL=ignoreElements.js.map

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var isEmpty_1 = __webpack_require__(283);
Observable_1.Observable.prototype.isEmpty = isEmpty_1.isEmpty;
//# sourceMappingURL=isEmpty.js.map

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var last_1 = __webpack_require__(284);
Observable_1.Observable.prototype.last = last_1.last;
//# sourceMappingURL=last.js.map

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var let_1 = __webpack_require__(285);
Observable_1.Observable.prototype.let = let_1.letProto;
Observable_1.Observable.prototype.letBind = let_1.letProto;
//# sourceMappingURL=let.js.map

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var map_1 = __webpack_require__(33);
Observable_1.Observable.prototype.map = map_1.map;
//# sourceMappingURL=map.js.map

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var mapTo_1 = __webpack_require__(286);
Observable_1.Observable.prototype.mapTo = mapTo_1.mapTo;
//# sourceMappingURL=mapTo.js.map

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var materialize_1 = __webpack_require__(287);
Observable_1.Observable.prototype.materialize = materialize_1.materialize;
//# sourceMappingURL=materialize.js.map

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var max_1 = __webpack_require__(288);
Observable_1.Observable.prototype.max = max_1.max;
//# sourceMappingURL=max.js.map

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var merge_1 = __webpack_require__(48);
Observable_1.Observable.prototype.merge = merge_1.merge;
//# sourceMappingURL=merge.js.map

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var mergeAll_1 = __webpack_require__(20);
Observable_1.Observable.prototype.mergeAll = mergeAll_1.mergeAll;
//# sourceMappingURL=mergeAll.js.map

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var mergeMap_1 = __webpack_require__(49);
Observable_1.Observable.prototype.mergeMap = mergeMap_1.mergeMap;
Observable_1.Observable.prototype.flatMap = mergeMap_1.mergeMap;
//# sourceMappingURL=mergeMap.js.map

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var mergeMapTo_1 = __webpack_require__(50);
Observable_1.Observable.prototype.flatMapTo = mergeMapTo_1.mergeMapTo;
Observable_1.Observable.prototype.mergeMapTo = mergeMapTo_1.mergeMapTo;
//# sourceMappingURL=mergeMapTo.js.map

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var mergeScan_1 = __webpack_require__(289);
Observable_1.Observable.prototype.mergeScan = mergeScan_1.mergeScan;
//# sourceMappingURL=mergeScan.js.map

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var min_1 = __webpack_require__(290);
Observable_1.Observable.prototype.min = min_1.min;
//# sourceMappingURL=min.js.map

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var multicast_1 = __webpack_require__(14);
Observable_1.Observable.prototype.multicast = multicast_1.multicast;
//# sourceMappingURL=multicast.js.map

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var observeOn_1 = __webpack_require__(34);
Observable_1.Observable.prototype.observeOn = observeOn_1.observeOn;
//# sourceMappingURL=observeOn.js.map

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var onErrorResumeNext_1 = __webpack_require__(51);
Observable_1.Observable.prototype.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNext;
//# sourceMappingURL=onErrorResumeNext.js.map

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var pairwise_1 = __webpack_require__(291);
Observable_1.Observable.prototype.pairwise = pairwise_1.pairwise;
//# sourceMappingURL=pairwise.js.map

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var partition_1 = __webpack_require__(292);
Observable_1.Observable.prototype.partition = partition_1.partition;
//# sourceMappingURL=partition.js.map

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var pluck_1 = __webpack_require__(293);
Observable_1.Observable.prototype.pluck = pluck_1.pluck;
//# sourceMappingURL=pluck.js.map

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var publish_1 = __webpack_require__(294);
Observable_1.Observable.prototype.publish = publish_1.publish;
//# sourceMappingURL=publish.js.map

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var publishBehavior_1 = __webpack_require__(295);
Observable_1.Observable.prototype.publishBehavior = publishBehavior_1.publishBehavior;
//# sourceMappingURL=publishBehavior.js.map

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var publishLast_1 = __webpack_require__(296);
Observable_1.Observable.prototype.publishLast = publishLast_1.publishLast;
//# sourceMappingURL=publishLast.js.map

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var publishReplay_1 = __webpack_require__(297);
Observable_1.Observable.prototype.publishReplay = publishReplay_1.publishReplay;
//# sourceMappingURL=publishReplay.js.map

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var race_1 = __webpack_require__(52);
Observable_1.Observable.prototype.race = race_1.race;
//# sourceMappingURL=race.js.map

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var reduce_1 = __webpack_require__(35);
Observable_1.Observable.prototype.reduce = reduce_1.reduce;
//# sourceMappingURL=reduce.js.map

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var repeat_1 = __webpack_require__(298);
Observable_1.Observable.prototype.repeat = repeat_1.repeat;
//# sourceMappingURL=repeat.js.map

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var repeatWhen_1 = __webpack_require__(299);
Observable_1.Observable.prototype.repeatWhen = repeatWhen_1.repeatWhen;
//# sourceMappingURL=repeatWhen.js.map

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var retry_1 = __webpack_require__(300);
Observable_1.Observable.prototype.retry = retry_1.retry;
//# sourceMappingURL=retry.js.map

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var retryWhen_1 = __webpack_require__(301);
Observable_1.Observable.prototype.retryWhen = retryWhen_1.retryWhen;
//# sourceMappingURL=retryWhen.js.map

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var sample_1 = __webpack_require__(302);
Observable_1.Observable.prototype.sample = sample_1.sample;
//# sourceMappingURL=sample.js.map

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var sampleTime_1 = __webpack_require__(303);
Observable_1.Observable.prototype.sampleTime = sampleTime_1.sampleTime;
//# sourceMappingURL=sampleTime.js.map

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var scan_1 = __webpack_require__(304);
Observable_1.Observable.prototype.scan = scan_1.scan;
//# sourceMappingURL=scan.js.map

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var sequenceEqual_1 = __webpack_require__(305);
Observable_1.Observable.prototype.sequenceEqual = sequenceEqual_1.sequenceEqual;
//# sourceMappingURL=sequenceEqual.js.map

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var share_1 = __webpack_require__(306);
Observable_1.Observable.prototype.share = share_1.share;
//# sourceMappingURL=share.js.map

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var single_1 = __webpack_require__(307);
Observable_1.Observable.prototype.single = single_1.single;
//# sourceMappingURL=single.js.map

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var skip_1 = __webpack_require__(308);
Observable_1.Observable.prototype.skip = skip_1.skip;
//# sourceMappingURL=skip.js.map

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var skipUntil_1 = __webpack_require__(309);
Observable_1.Observable.prototype.skipUntil = skipUntil_1.skipUntil;
//# sourceMappingURL=skipUntil.js.map

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var skipWhile_1 = __webpack_require__(310);
Observable_1.Observable.prototype.skipWhile = skipWhile_1.skipWhile;
//# sourceMappingURL=skipWhile.js.map

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var startWith_1 = __webpack_require__(311);
Observable_1.Observable.prototype.startWith = startWith_1.startWith;
//# sourceMappingURL=startWith.js.map

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var subscribeOn_1 = __webpack_require__(312);
Observable_1.Observable.prototype.subscribeOn = subscribeOn_1.subscribeOn;
//# sourceMappingURL=subscribeOn.js.map

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var switch_1 = __webpack_require__(313);
Observable_1.Observable.prototype.switch = switch_1._switch;
Observable_1.Observable.prototype._switch = switch_1._switch;
//# sourceMappingURL=switch.js.map

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var switchMap_1 = __webpack_require__(314);
Observable_1.Observable.prototype.switchMap = switchMap_1.switchMap;
//# sourceMappingURL=switchMap.js.map

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var switchMapTo_1 = __webpack_require__(315);
Observable_1.Observable.prototype.switchMapTo = switchMapTo_1.switchMapTo;
//# sourceMappingURL=switchMapTo.js.map

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var take_1 = __webpack_require__(316);
Observable_1.Observable.prototype.take = take_1.take;
//# sourceMappingURL=take.js.map

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var takeLast_1 = __webpack_require__(317);
Observable_1.Observable.prototype.takeLast = takeLast_1.takeLast;
//# sourceMappingURL=takeLast.js.map

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var takeUntil_1 = __webpack_require__(318);
Observable_1.Observable.prototype.takeUntil = takeUntil_1.takeUntil;
//# sourceMappingURL=takeUntil.js.map

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var takeWhile_1 = __webpack_require__(319);
Observable_1.Observable.prototype.takeWhile = takeWhile_1.takeWhile;
//# sourceMappingURL=takeWhile.js.map

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var throttle_1 = __webpack_require__(320);
Observable_1.Observable.prototype.throttle = throttle_1.throttle;
//# sourceMappingURL=throttle.js.map

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var throttleTime_1 = __webpack_require__(321);
Observable_1.Observable.prototype.throttleTime = throttleTime_1.throttleTime;
//# sourceMappingURL=throttleTime.js.map

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var timeInterval_1 = __webpack_require__(53);
Observable_1.Observable.prototype.timeInterval = timeInterval_1.timeInterval;
//# sourceMappingURL=timeInterval.js.map

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var timeout_1 = __webpack_require__(322);
Observable_1.Observable.prototype.timeout = timeout_1.timeout;
//# sourceMappingURL=timeout.js.map

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var timeoutWith_1 = __webpack_require__(323);
Observable_1.Observable.prototype.timeoutWith = timeoutWith_1.timeoutWith;
//# sourceMappingURL=timeoutWith.js.map

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var timestamp_1 = __webpack_require__(54);
Observable_1.Observable.prototype.timestamp = timestamp_1.timestamp;
//# sourceMappingURL=timestamp.js.map

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var toArray_1 = __webpack_require__(324);
Observable_1.Observable.prototype.toArray = toArray_1.toArray;
//# sourceMappingURL=toArray.js.map

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var toPromise_1 = __webpack_require__(325);
Observable_1.Observable.prototype.toPromise = toPromise_1.toPromise;
//# sourceMappingURL=toPromise.js.map

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var window_1 = __webpack_require__(326);
Observable_1.Observable.prototype.window = window_1.window;
//# sourceMappingURL=window.js.map

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var windowCount_1 = __webpack_require__(327);
Observable_1.Observable.prototype.windowCount = windowCount_1.windowCount;
//# sourceMappingURL=windowCount.js.map

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var windowTime_1 = __webpack_require__(328);
Observable_1.Observable.prototype.windowTime = windowTime_1.windowTime;
//# sourceMappingURL=windowTime.js.map

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var windowToggle_1 = __webpack_require__(329);
Observable_1.Observable.prototype.windowToggle = windowToggle_1.windowToggle;
//# sourceMappingURL=windowToggle.js.map

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var windowWhen_1 = __webpack_require__(330);
Observable_1.Observable.prototype.windowWhen = windowWhen_1.windowWhen;
//# sourceMappingURL=windowWhen.js.map

/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var withLatestFrom_1 = __webpack_require__(331);
Observable_1.Observable.prototype.withLatestFrom = withLatestFrom_1.withLatestFrom;
//# sourceMappingURL=withLatestFrom.js.map

/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var zip_1 = __webpack_require__(36);
Observable_1.Observable.prototype.zip = zip_1.zipProto;
//# sourceMappingURL=zip.js.map

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var zipAll_1 = __webpack_require__(332);
Observable_1.Observable.prototype.zipAll = zipAll_1.zipAll;
//# sourceMappingURL=zipAll.js.map

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(0);
var ScalarObservable_1 = __webpack_require__(30);
var EmptyObservable_1 = __webpack_require__(13);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ArrayLikeObservable = (function (_super) {
    __extends(ArrayLikeObservable, _super);
    function ArrayLikeObservable(arrayLike, scheduler) {
        _super.call(this);
        this.arrayLike = arrayLike;
        this.scheduler = scheduler;
        if (!scheduler && arrayLike.length === 1) {
            this._isScalar = true;
            this.value = arrayLike[0];
        }
    }
    ArrayLikeObservable.create = function (arrayLike, scheduler) {
        var length = arrayLike.length;
        if (length === 0) {
            return new EmptyObservable_1.EmptyObservable();
        }
        else if (length === 1) {
            return new ScalarObservable_1.ScalarObservable(arrayLike[0], scheduler);
        }
        else {
            return new ArrayLikeObservable(arrayLike, scheduler);
        }
    };
    ArrayLikeObservable.dispatch = function (state) {
        var arrayLike = state.arrayLike, index = state.index, length = state.length, subscriber = state.subscriber;
        if (subscriber.closed) {
            return;
        }
        if (index >= length) {
            subscriber.complete();
            return;
        }
        subscriber.next(arrayLike[index]);
        state.index = index + 1;
        this.schedule(state);
    };
    ArrayLikeObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var _a = this, arrayLike = _a.arrayLike, scheduler = _a.scheduler;
        var length = arrayLike.length;
        if (scheduler) {
            return scheduler.schedule(ArrayLikeObservable.dispatch, 0, {
                arrayLike: arrayLike, index: index, length: length, subscriber: subscriber
            });
        }
        else {
            for (var i = 0; i < length && !subscriber.closed; i++) {
                subscriber.next(arrayLike[i]);
            }
            subscriber.complete();
        }
    };
    return ArrayLikeObservable;
}(Observable_1.Observable));
exports.ArrayLikeObservable = ArrayLikeObservable;
//# sourceMappingURL=ArrayLikeObservable.js.map

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(0);
var tryCatch_1 = __webpack_require__(8);
var errorObject_1 = __webpack_require__(6);
var AsyncSubject_1 = __webpack_require__(19);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var BoundCallbackObservable = (function (_super) {
    __extends(BoundCallbackObservable, _super);
    function BoundCallbackObservable(callbackFunc, selector, args, context, scheduler) {
        _super.call(this);
        this.callbackFunc = callbackFunc;
        this.selector = selector;
        this.args = args;
        this.context = context;
        this.scheduler = scheduler;
    }
    /* tslint:enable:max-line-length */
    /**
     * Converts a callback API to a function that returns an Observable.
     *
     * <span class="informal">Give it a function `f` of type `f(x, callback)` and
     * it will return a function `g` that when called as `g(x)` will output an
     * Observable.</span>
     *
     * `bindCallback` is not an operator because its input and output are not
     * Observables. The input is a function `func` with some parameters, but the
     * last parameter must be a callback function that `func` calls when it is
     * done.
     *
     * The output of `bindCallback` is a function that takes the same parameters
     * as `func`, except the last one (the callback). When the output function
     * is called with arguments, it will return an Observable. If `func` function
     * calls its callback with one argument, the Observable will emit that value.
     * If on the other hand callback is called with multiple values, resulting
     * Observable will emit an array with these arguments.
     *
     * It is very important to remember, that input function `func` is not called
     * when output function is, but rather when Observable returned by output
     * function is subscribed. This means if `func` makes AJAX request, that request
     * will be made every time someone subscribes to resulting Observable, but not before.
     *
     * Optionally, selector function can be passed to `bindObservable`. That function
     * takes the same arguments as callback, and returns value
     * that will be emitted by Observable instead of callback parameters themselves.
     * Even though by default multiple arguments passed to callback appear in the stream as array,
     * selector function will be called with arguments directly, just as callback would.
     * This means you can imagine default selector (when one is not provided explicitly)
     * as function that aggregates all its arguments into array, or simply returns first argument,
     * if there is only one.
     *
     * Last optional parameter - {@link Scheduler} - can be used to control when call
     * to `func` happens after someone subscribes to Observable, as well as when results
     * passed to callback will be emitted. By default subscription to Observable calls `func`
     * synchronously, but using `Scheduler.async` as last parameter will defer call to input function,
     * just like wrapping that call in `setTimeout` with time `0` would. So if you use async Scheduler
     * and call `subscribe` on output Observable, all function calls that are currently executing,
     * will end before `func` is invoked.
     *
     * When it comes to emitting results passed to callback, by default they are emitted
     * immediately after `func` invokes callback. In particular, if callback is called synchronously,
     * then subscription to resulting Observable will call `next` function synchronously as well.
     * If you want to defer that call, using `Scheduler.async` will, again, do the job.
     * This means that by using `Scheduler.async` you can, in a sense, ensure that `func`
     * always calls its callback asynchronously, thus avoiding terrifying Zalgo.
     *
     * Note that Observable created by output function will always emit only one value
     * and then complete right after. Even if `func` calls callback multiple times, values from
     * second and following calls will never appear in the stream. If you need to
     * listen for multiple calls, you probably want to use {@link fromEvent} or
     * {@link fromEventPattern} instead.
     *
     * If `func` depends on some context (`this` property), that context will be set
     * to the same context that output function has at call time. In particular, if `func`
     * is called as method of some object, in order to preserve proper behaviour,
     * it is recommended to set context of output function to that object as well,
     * provided `func` is not already bound.
     *
     * If input function calls its callback in "node style" (i.e. first argument to callback is
     * optional error parameter signaling whether call failed or not), {@link bindNodeCallback}
     * provides convenient error handling and probably is a better choice.
     * `bindCallback` will treat such functions without any difference and error parameter
     * (whether passed or not) will always be interpreted as regular callback argument.
     *
     *
     * @example <caption>Convert jQuery's getJSON to an Observable API</caption>
     * // Suppose we have jQuery.getJSON('/my/url', callback)
     * var getJSONAsObservable = Rx.Observable.bindCallback(jQuery.getJSON);
     * var result = getJSONAsObservable('/my/url');
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     *
     * @example <caption>Receive array of arguments passed to callback</caption>
     * someFunction((a, b, c) => {
     *   console.log(a); // 5
     *   console.log(b); // 'some string'
     *   console.log(c); // {someProperty: 'someValue'}
     * });
     *
     * const boundSomeFunction = Rx.Observable.bindCallback(someFunction);
     * boundSomeFunction.subscribe(values => {
     *   console.log(values) // [5, 'some string', {someProperty: 'someValue'}]
     * });
     *
     *
     * @example <caption>Use bindCallback with selector function</caption>
     * someFunction((a, b, c) => {
     *   console.log(a); // 'a'
     *   console.log(b); // 'b'
     *   console.log(c); // 'c'
     * });
     *
     * const boundSomeFunction = Rx.Observable.bindCallback(someFunction, (a, b, c) => a + b + c);
     * boundSomeFunction.subscribe(value => {
     *   console.log(value) // 'abc'
     * });
     *
     *
     * @example <caption>Compare behaviour with and without async Scheduler</caption>
     * function iCallMyCallbackSynchronously(cb) {
     *   cb();
     * }
     *
     * const boundSyncFn = Rx.Observable.bindCallback(iCallMyCallbackSynchronously);
     * const boundAsyncFn = Rx.Observable.bindCallback(iCallMyCallbackSynchronously, null, Rx.Scheduler.async);
     *
     * boundSyncFn().subscribe(() => console.log('I was sync!'));
     * boundAsyncFn().subscribe(() => console.log('I was async!'));
     * console.log('This happened...');
     *
     * // Logs:
     * // I was sync!
     * // This happened...
     * // I was async!
     *
     *
     * @example <caption>Use bindCallback on object method</caption>
     * const boundMethod = Rx.Observable.bindCallback(someObject.methodWithCallback);
     * boundMethod.call(someObject) // make sure methodWithCallback has access to someObject
     * .subscribe(subscriber);
     *
     *
     * @see {@link bindNodeCallback}
     * @see {@link from}
     * @see {@link fromPromise}
     *
     * @param {function} func Function with a callback as the last parameter.
     * @param {function} [selector] A function which takes the arguments from the
     * callback and maps those to a value to emit on the output Observable.
     * @param {Scheduler} [scheduler] The scheduler on which to schedule the
     * callbacks.
     * @return {function(...params: *): Observable} A function which returns the
     * Observable that delivers the same values the callback would deliver.
     * @static true
     * @name bindCallback
     * @owner Observable
     */
    BoundCallbackObservable.create = function (func, selector, scheduler) {
        if (selector === void 0) { selector = undefined; }
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            return new BoundCallbackObservable(func, selector, args, this, scheduler);
        };
    };
    BoundCallbackObservable.prototype._subscribe = function (subscriber) {
        var callbackFunc = this.callbackFunc;
        var args = this.args;
        var scheduler = this.scheduler;
        var subject = this.subject;
        if (!scheduler) {
            if (!subject) {
                subject = this.subject = new AsyncSubject_1.AsyncSubject();
                var handler = function handlerFn() {
                    var innerArgs = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        innerArgs[_i - 0] = arguments[_i];
                    }
                    var source = handlerFn.source;
                    var selector = source.selector, subject = source.subject;
                    if (selector) {
                        var result_1 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);
                        if (result_1 === errorObject_1.errorObject) {
                            subject.error(errorObject_1.errorObject.e);
                        }
                        else {
                            subject.next(result_1);
                            subject.complete();
                        }
                    }
                    else {
                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
                        subject.complete();
                    }
                };
                // use named function instance to avoid closure.
                handler.source = this;
                var result = tryCatch_1.tryCatch(callbackFunc).apply(this.context, args.concat(handler));
                if (result === errorObject_1.errorObject) {
                    subject.error(errorObject_1.errorObject.e);
                }
            }
            return subject.subscribe(subscriber);
        }
        else {
            return scheduler.schedule(BoundCallbackObservable.dispatch, 0, { source: this, subscriber: subscriber, context: this.context });
        }
    };
    BoundCallbackObservable.dispatch = function (state) {
        var self = this;
        var source = state.source, subscriber = state.subscriber, context = state.context;
        var callbackFunc = source.callbackFunc, args = source.args, scheduler = source.scheduler;
        var subject = source.subject;
        if (!subject) {
            subject = source.subject = new AsyncSubject_1.AsyncSubject();
            var handler = function handlerFn() {
                var innerArgs = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    innerArgs[_i - 0] = arguments[_i];
                }
                var source = handlerFn.source;
                var selector = source.selector, subject = source.subject;
                if (selector) {
                    var result_2 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);
                    if (result_2 === errorObject_1.errorObject) {
                        self.add(scheduler.schedule(dispatchError, 0, { err: errorObject_1.errorObject.e, subject: subject }));
                    }
                    else {
                        self.add(scheduler.schedule(dispatchNext, 0, { value: result_2, subject: subject }));
                    }
                }
                else {
                    var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
                    self.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));
                }
            };
            // use named function to pass values in without closure
            handler.source = source;
            var result = tryCatch_1.tryCatch(callbackFunc).apply(context, args.concat(handler));
            if (result === errorObject_1.errorObject) {
                subject.error(errorObject_1.errorObject.e);
            }
        }
        self.add(subject.subscribe(subscriber));
    };
    return BoundCallbackObservable;
}(Observable_1.Observable));
exports.BoundCallbackObservable = BoundCallbackObservable;
function dispatchNext(arg) {
    var value = arg.value, subject = arg.subject;
    subject.next(value);
    subject.complete();
}
function dispatchError(arg) {
    var err = arg.err, subject = arg.subject;
    subject.error(err);
}
//# sourceMappingURL=BoundCallbackObservable.js.map

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(0);
var tryCatch_1 = __webpack_require__(8);
var errorObject_1 = __webpack_require__(6);
var AsyncSubject_1 = __webpack_require__(19);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var BoundNodeCallbackObservable = (function (_super) {
    __extends(BoundNodeCallbackObservable, _super);
    function BoundNodeCallbackObservable(callbackFunc, selector, args, context, scheduler) {
        _super.call(this);
        this.callbackFunc = callbackFunc;
        this.selector = selector;
        this.args = args;
        this.context = context;
        this.scheduler = scheduler;
    }
    /* tslint:enable:max-line-length */
    /**
     * Converts a Node.js-style callback API to a function that returns an
     * Observable.
     *
     * <span class="informal">It's just like {@link bindCallback}, but the
     * callback is expected to be of type `callback(error, result)`.</span>
     *
     * `bindNodeCallback` is not an operator because its input and output are not
     * Observables. The input is a function `func` with some parameters, but the
     * last parameter must be a callback function that `func` calls when it is
     * done. The callback function is expected to follow Node.js conventions,
     * where the first argument to the callback is an error object, signaling
     * whether call was successful. If that object is passed to callback, it means
     * something went wrong.
     *
     * The output of `bindNodeCallback` is a function that takes the same
     * parameters as `func`, except the last one (the callback). When the output
     * function is called with arguments, it will return an Observable.
     * If `func` calls its callback with error parameter present, Observable will
     * error with that value as well. If error parameter is not passed, Observable will emit
     * second parameter. If there are more parameters (third and so on),
     * Observable will emit an array with all arguments, except first error argument.
     *
     * Optionally `bindNodeCallback` accepts selector function, which allows you to
     * make resulting Observable emit value computed by selector, instead of regular
     * callback arguments. It works similarly to {@link bindCallback} selector, but
     * Node.js-style error argument will never be passed to that function.
     *
     * Note that `func` will not be called at the same time output function is,
     * but rather whenever resulting Observable is subscribed. By default call to
     * `func` will happen synchronously after subscription, but that can be changed
     * with proper {@link Scheduler} provided as optional third parameter. Scheduler
     * can also control when values from callback will be emitted by Observable.
     * To find out more, check out documentation for {@link bindCallback}, where
     * Scheduler works exactly the same.
     *
     * As in {@link bindCallback}, context (`this` property) of input function will be set to context
     * of returned function, when it is called.
     *
     * After Observable emits value, it will complete immediately. This means
     * even if `func` calls callback again, values from second and consecutive
     * calls will never appear on the stream. If you need to handle functions
     * that call callbacks multiple times, check out {@link fromEvent} or
     * {@link fromEventPattern} instead.
     *
     * Note that `bindNodeCallback` can be used in non-Node.js environments as well.
     * "Node.js-style" callbacks are just a convention, so if you write for
     * browsers or any other environment and API you use implements that callback style,
     * `bindNodeCallback` can be safely used on that API functions as well.
     *
     * Remember that Error object passed to callback does not have to be an instance
     * of JavaScript built-in `Error` object. In fact, it does not even have to an object.
     * Error parameter of callback function is interpreted as "present", when value
     * of that parameter is truthy. It could be, for example, non-zero number, non-empty
     * string or boolean `true`. In all of these cases resulting Observable would error
     * with that value. This means usually regular style callbacks will fail very often when
     * `bindNodeCallback` is used. If your Observable errors much more often then you
     * would expect, check if callback really is called in Node.js-style and, if not,
     * switch to {@link bindCallback} instead.
     *
     * Note that even if error parameter is technically present in callback, but its value
     * is falsy, it still won't appear in array emitted by Observable or in selector function.
     *
     *
     * @example <caption>Read a file from the filesystem and get the data as an Observable</caption>
     * import * as fs from 'fs';
     * var readFileAsObservable = Rx.Observable.bindNodeCallback(fs.readFile);
     * var result = readFileAsObservable('./roadNames.txt', 'utf8');
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     *
     * @example <caption>Use on function calling callback with multiple arguments</caption>
     * someFunction((err, a, b) => {
     *   console.log(err); // null
     *   console.log(a); // 5
     *   console.log(b); // "some string"
     * });
     * var boundSomeFunction = Rx.Observable.bindNodeCallback(someFunction);
     * boundSomeFunction()
     * .subscribe(value => {
     *   console.log(value); // [5, "some string"]
     * });
     *
     *
     * @example <caption>Use with selector function</caption>
     * someFunction((err, a, b) => {
     *   console.log(err); // undefined
     *   console.log(a); // "abc"
     *   console.log(b); // "DEF"
     * });
     * var boundSomeFunction = Rx.Observable.bindNodeCallback(someFunction, (a, b) => a + b);
     * boundSomeFunction()
     * .subscribe(value => {
     *   console.log(value); // "abcDEF"
     * });
     *
     *
     * @example <caption>Use on function calling callback in regular style</caption>
     * someFunction(a => {
     *   console.log(a); // 5
     * });
     * var boundSomeFunction = Rx.Observable.bindNodeCallback(someFunction);
     * boundSomeFunction()
     * .subscribe(
     *   value => {}             // never gets called
     *   err => console.log(err) // 5
     *);
     *
     *
     * @see {@link bindCallback}
     * @see {@link from}
     * @see {@link fromPromise}
     *
     * @param {function} func Function with a Node.js-style callback as the last parameter.
     * @param {function} [selector] A function which takes the arguments from the
     * callback and maps those to a value to emit on the output Observable.
     * @param {Scheduler} [scheduler] The scheduler on which to schedule the
     * callbacks.
     * @return {function(...params: *): Observable} A function which returns the
     * Observable that delivers the same values the Node.js callback would
     * deliver.
     * @static true
     * @name bindNodeCallback
     * @owner Observable
     */
    BoundNodeCallbackObservable.create = function (func, selector, scheduler) {
        if (selector === void 0) { selector = undefined; }
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            return new BoundNodeCallbackObservable(func, selector, args, this, scheduler);
        };
    };
    BoundNodeCallbackObservable.prototype._subscribe = function (subscriber) {
        var callbackFunc = this.callbackFunc;
        var args = this.args;
        var scheduler = this.scheduler;
        var subject = this.subject;
        if (!scheduler) {
            if (!subject) {
                subject = this.subject = new AsyncSubject_1.AsyncSubject();
                var handler = function handlerFn() {
                    var innerArgs = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        innerArgs[_i - 0] = arguments[_i];
                    }
                    var source = handlerFn.source;
                    var selector = source.selector, subject = source.subject;
                    var err = innerArgs.shift();
                    if (err) {
                        subject.error(err);
                    }
                    else if (selector) {
                        var result_1 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);
                        if (result_1 === errorObject_1.errorObject) {
                            subject.error(errorObject_1.errorObject.e);
                        }
                        else {
                            subject.next(result_1);
                            subject.complete();
                        }
                    }
                    else {
                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
                        subject.complete();
                    }
                };
                // use named function instance to avoid closure.
                handler.source = this;
                var result = tryCatch_1.tryCatch(callbackFunc).apply(this.context, args.concat(handler));
                if (result === errorObject_1.errorObject) {
                    subject.error(errorObject_1.errorObject.e);
                }
            }
            return subject.subscribe(subscriber);
        }
        else {
            return scheduler.schedule(dispatch, 0, { source: this, subscriber: subscriber, context: this.context });
        }
    };
    return BoundNodeCallbackObservable;
}(Observable_1.Observable));
exports.BoundNodeCallbackObservable = BoundNodeCallbackObservable;
function dispatch(state) {
    var self = this;
    var source = state.source, subscriber = state.subscriber, context = state.context;
    // XXX: cast to `any` to access to the private field in `source`.
    var _a = source, callbackFunc = _a.callbackFunc, args = _a.args, scheduler = _a.scheduler;
    var subject = source.subject;
    if (!subject) {
        subject = source.subject = new AsyncSubject_1.AsyncSubject();
        var handler = function handlerFn() {
            var innerArgs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                innerArgs[_i - 0] = arguments[_i];
            }
            var source = handlerFn.source;
            var selector = source.selector, subject = source.subject;
            var err = innerArgs.shift();
            if (err) {
                self.add(scheduler.schedule(dispatchError, 0, { err: err, subject: subject }));
            }
            else if (selector) {
                var result_2 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);
                if (result_2 === errorObject_1.errorObject) {
                    self.add(scheduler.schedule(dispatchError, 0, { err: errorObject_1.errorObject.e, subject: subject }));
                }
                else {
                    self.add(scheduler.schedule(dispatchNext, 0, { value: result_2, subject: subject }));
                }
            }
            else {
                var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
                self.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));
            }
        };
        // use named function to pass values in without closure
        handler.source = source;
        var result = tryCatch_1.tryCatch(callbackFunc).apply(context, args.concat(handler));
        if (result === errorObject_1.errorObject) {
            self.add(scheduler.schedule(dispatchError, 0, { err: errorObject_1.errorObject.e, subject: subject }));
        }
    }
    self.add(subject.subscribe(subscriber));
}
function dispatchNext(arg) {
    var value = arg.value, subject = arg.subject;
    subject.next(value);
    subject.complete();
}
function dispatchError(arg) {
    var err = arg.err, subject = arg.subject;
    subject.error(err);
}
//# sourceMappingURL=BoundNodeCallbackObservable.js.map

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(0);
var subscribeToResult_1 = __webpack_require__(3);
var OuterSubscriber_1 = __webpack_require__(2);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var DeferObservable = (function (_super) {
    __extends(DeferObservable, _super);
    function DeferObservable(observableFactory) {
        _super.call(this);
        this.observableFactory = observableFactory;
    }
    /**
     * Creates an Observable that, on subscribe, calls an Observable factory to
     * make an Observable for each new Observer.
     *
     * <span class="informal">Creates the Observable lazily, that is, only when it
     * is subscribed.
     * </span>
     *
     * <img src="./img/defer.png" width="100%">
     *
     * `defer` allows you to create the Observable only when the Observer
     * subscribes, and create a fresh Observable for each Observer. It waits until
     * an Observer subscribes to it, and then it generates an Observable,
     * typically with an Observable factory function. It does this afresh for each
     * subscriber, so although each subscriber may think it is subscribing to the
     * same Observable, in fact each subscriber gets its own individual
     * Observable.
     *
     * @example <caption>Subscribe to either an Observable of clicks or an Observable of interval, at random</caption>
     * var clicksOrInterval = Rx.Observable.defer(function () {
     *   if (Math.random() > 0.5) {
     *     return Rx.Observable.fromEvent(document, 'click');
     *   } else {
     *     return Rx.Observable.interval(1000);
     *   }
     * });
     * clicksOrInterval.subscribe(x => console.log(x));
     *
     * // Results in the following behavior:
     * // If the result of Math.random() is greater than 0.5 it will listen
     * // for clicks anywhere on the "document"; when document is clicked it
     * // will log a MouseEvent object to the console. If the result is less
     * // than 0.5 it will emit ascending numbers, one every second(1000ms).
     *
     * @see {@link create}
     *
     * @param {function(): SubscribableOrPromise} observableFactory The Observable
     * factory function to invoke for each Observer that subscribes to the output
     * Observable. May also return a Promise, which will be converted on the fly
     * to an Observable.
     * @return {Observable} An Observable whose Observers' subscriptions trigger
     * an invocation of the given Observable factory function.
     * @static true
     * @name defer
     * @owner Observable
     */
    DeferObservable.create = function (observableFactory) {
        return new DeferObservable(observableFactory);
    };
    DeferObservable.prototype._subscribe = function (subscriber) {
        return new DeferSubscriber(subscriber, this.observableFactory);
    };
    return DeferObservable;
}(Observable_1.Observable));
exports.DeferObservable = DeferObservable;
var DeferSubscriber = (function (_super) {
    __extends(DeferSubscriber, _super);
    function DeferSubscriber(destination, factory) {
        _super.call(this, destination);
        this.factory = factory;
        this.tryDefer();
    }
    DeferSubscriber.prototype.tryDefer = function () {
        try {
            this._callFactory();
        }
        catch (err) {
            this._error(err);
        }
    };
    DeferSubscriber.prototype._callFactory = function () {
        var result = this.factory();
        if (result) {
            this.add(subscribeToResult_1.subscribeToResult(this, result));
        }
    };
    return DeferSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=DeferObservable.js.map

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(0);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ErrorObservable = (function (_super) {
    __extends(ErrorObservable, _super);
    function ErrorObservable(error, scheduler) {
        _super.call(this);
        this.error = error;
        this.scheduler = scheduler;
    }
    /**
     * Creates an Observable that emits no items to the Observer and immediately
     * emits an error notification.
     *
     * <span class="informal">Just emits 'error', and nothing else.
     * </span>
     *
     * <img src="./img/throw.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the error notification. It can be used for composing with other
     * Observables, such as in a {@link mergeMap}.
     *
     * @example <caption>Emit the number 7, then emit an error.</caption>
     * var result = Rx.Observable.throw(new Error('oops!')).startWith(7);
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     * @example <caption>Map and flatten numbers to the sequence 'a', 'b', 'c', but throw an error for 13</caption>
     * var interval = Rx.Observable.interval(1000);
     * var result = interval.mergeMap(x =>
     *   x === 13 ?
     *     Rx.Observable.throw('Thirteens are bad') :
     *     Rx.Observable.of('a', 'b', 'c')
     * );
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     * @see {@link create}
     * @see {@link empty}
     * @see {@link never}
     * @see {@link of}
     *
     * @param {any} error The particular Error to pass to the error notification.
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emission of the error notification.
     * @return {Observable} An error Observable: emits only the error notification
     * using the given error argument.
     * @static true
     * @name throw
     * @owner Observable
     */
    ErrorObservable.create = function (error, scheduler) {
        return new ErrorObservable(error, scheduler);
    };
    ErrorObservable.dispatch = function (arg) {
        var error = arg.error, subscriber = arg.subscriber;
        subscriber.error(error);
    };
    ErrorObservable.prototype._subscribe = function (subscriber) {
        var error = this.error;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(ErrorObservable.dispatch, 0, {
                error: error, subscriber: subscriber
            });
        }
        else {
            subscriber.error(error);
        }
    };
    return ErrorObservable;
}(Observable_1.Observable));
exports.ErrorObservable = ErrorObservable;
//# sourceMappingURL=ErrorObservable.js.map

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(0);
var EmptyObservable_1 = __webpack_require__(13);
var isArray_1 = __webpack_require__(11);
var subscribeToResult_1 = __webpack_require__(3);
var OuterSubscriber_1 = __webpack_require__(2);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ForkJoinObservable = (function (_super) {
    __extends(ForkJoinObservable, _super);
    function ForkJoinObservable(sources, resultSelector) {
        _super.call(this);
        this.sources = sources;
        this.resultSelector = resultSelector;
    }
    /* tslint:enable:max-line-length */
    /**
     * @param sources
     * @return {any}
     * @static true
     * @name forkJoin
     * @owner Observable
     */
    ForkJoinObservable.create = function () {
        var sources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            sources[_i - 0] = arguments[_i];
        }
        if (sources === null || arguments.length === 0) {
            return new EmptyObservable_1.EmptyObservable();
        }
        var resultSelector = null;
        if (typeof sources[sources.length - 1] === 'function') {
            resultSelector = sources.pop();
        }
        // if the first and only other argument besides the resultSelector is an array
        // assume it's been called with `forkJoin([obs1, obs2, obs3], resultSelector)`
        if (sources.length === 1 && isArray_1.isArray(sources[0])) {
            sources = sources[0];
        }
        if (sources.length === 0) {
            return new EmptyObservable_1.EmptyObservable();
        }
        return new ForkJoinObservable(sources, resultSelector);
    };
    ForkJoinObservable.prototype._subscribe = function (subscriber) {
        return new ForkJoinSubscriber(subscriber, this.sources, this.resultSelector);
    };
    return ForkJoinObservable;
}(Observable_1.Observable));
exports.ForkJoinObservable = ForkJoinObservable;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ForkJoinSubscriber = (function (_super) {
    __extends(ForkJoinSubscriber, _super);
    function ForkJoinSubscriber(destination, sources, resultSelector) {
        _super.call(this, destination);
        this.sources = sources;
        this.resultSelector = resultSelector;
        this.completed = 0;
        this.haveValues = 0;
        var len = sources.length;
        this.total = len;
        this.values = new Array(len);
        for (var i = 0; i < len; i++) {
            var source = sources[i];
            var innerSubscription = subscribeToResult_1.subscribeToResult(this, source, null, i);
            if (innerSubscription) {
                innerSubscription.outerIndex = i;
                this.add(innerSubscription);
            }
        }
    }
    ForkJoinSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values[outerIndex] = innerValue;
        if (!innerSub._hasValue) {
            innerSub._hasValue = true;
            this.haveValues++;
        }
    };
    ForkJoinSubscriber.prototype.notifyComplete = function (innerSub) {
        var destination = this.destination;
        var _a = this, haveValues = _a.haveValues, resultSelector = _a.resultSelector, values = _a.values;
        var len = values.length;
        if (!innerSub._hasValue) {
            destination.complete();
            return;
        }
        this.completed++;
        if (this.completed !== len) {
            return;
        }
        if (haveValues === len) {
            var value = resultSelector ? resultSelector.apply(this, values) : values;
            destination.next(value);
        }
        destination.complete();
    };
    return ForkJoinSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=ForkJoinObservable.js.map

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(0);
var tryCatch_1 = __webpack_require__(8);
var isFunction_1 = __webpack_require__(27);
var errorObject_1 = __webpack_require__(6);
var Subscription_1 = __webpack_require__(4);
var toString = Object.prototype.toString;
function isNodeStyleEventEmitter(sourceObj) {
    return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
}
function isJQueryStyleEventEmitter(sourceObj) {
    return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
}
function isNodeList(sourceObj) {
    return !!sourceObj && toString.call(sourceObj) === '[object NodeList]';
}
function isHTMLCollection(sourceObj) {
    return !!sourceObj && toString.call(sourceObj) === '[object HTMLCollection]';
}
function isEventTarget(sourceObj) {
    return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var FromEventObservable = (function (_super) {
    __extends(FromEventObservable, _super);
    function FromEventObservable(sourceObj, eventName, selector, options) {
        _super.call(this);
        this.sourceObj = sourceObj;
        this.eventName = eventName;
        this.selector = selector;
        this.options = options;
    }
    /* tslint:enable:max-line-length */
    /**
     * Creates an Observable that emits events of a specific type coming from the
     * given event target.
     *
     * <span class="informal">Creates an Observable from DOM events, or Node
     * EventEmitter events or others.</span>
     *
     * <img src="./img/fromEvent.png" width="100%">
     *
     * Creates an Observable by attaching an event listener to an "event target",
     * which may be an object with `addEventListener` and `removeEventListener`,
     * a Node.js EventEmitter, a jQuery style EventEmitter, a NodeList from the
     * DOM, or an HTMLCollection from the DOM. The event handler is attached when
     * the output Observable is subscribed, and removed when the Subscription is
     * unsubscribed.
     *
     * @example <caption>Emits clicks happening on the DOM document</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * clicks.subscribe(x => console.log(x));
     *
     * // Results in:
     * // MouseEvent object logged to console everytime a click
     * // occurs on the document.
     *
     * @see {@link from}
     * @see {@link fromEventPattern}
     *
     * @param {EventTargetLike} target The DOMElement, event target, Node.js
     * EventEmitter, NodeList or HTMLCollection to attach the event handler to.
     * @param {string} eventName The event name of interest, being emitted by the
     * `target`.
     * @param {EventListenerOptions} [options] Options to pass through to addEventListener
     * @param {SelectorMethodSignature<T>} [selector] An optional function to
     * post-process results. It takes the arguments from the event handler and
     * should return a single value.
     * @return {Observable<T>}
     * @static true
     * @name fromEvent
     * @owner Observable
     */
    FromEventObservable.create = function (target, eventName, options, selector) {
        if (isFunction_1.isFunction(options)) {
            selector = options;
            options = undefined;
        }
        return new FromEventObservable(target, eventName, selector, options);
    };
    FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber, options) {
        var unsubscribe;
        if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {
            for (var i = 0, len = sourceObj.length; i < len; i++) {
                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
            }
        }
        else if (isEventTarget(sourceObj)) {
            var source_1 = sourceObj;
            sourceObj.addEventListener(eventName, handler, options);
            unsubscribe = function () { return source_1.removeEventListener(eventName, handler); };
        }
        else if (isJQueryStyleEventEmitter(sourceObj)) {
            var source_2 = sourceObj;
            sourceObj.on(eventName, handler);
            unsubscribe = function () { return source_2.off(eventName, handler); };
        }
        else if (isNodeStyleEventEmitter(sourceObj)) {
            var source_3 = sourceObj;
            sourceObj.addListener(eventName, handler);
            unsubscribe = function () { return source_3.removeListener(eventName, handler); };
        }
        else {
            throw new TypeError('Invalid event target');
        }
        subscriber.add(new Subscription_1.Subscription(unsubscribe));
    };
    FromEventObservable.prototype._subscribe = function (subscriber) {
        var sourceObj = this.sourceObj;
        var eventName = this.eventName;
        var options = this.options;
        var selector = this.selector;
        var handler = selector ? function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var result = tryCatch_1.tryCatch(selector).apply(void 0, args);
            if (result === errorObject_1.errorObject) {
                subscriber.error(errorObject_1.errorObject.e);
            }
            else {
                subscriber.next(result);
            }
        } : function (e) { return subscriber.next(e); };
        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber, options);
    };
    return FromEventObservable;
}(Observable_1.Observable));
exports.FromEventObservable = FromEventObservable;
//# sourceMappingURL=FromEventObservable.js.map

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isFunction_1 = __webpack_require__(27);
var Observable_1 = __webpack_require__(0);
var Subscription_1 = __webpack_require__(4);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var FromEventPatternObservable = (function (_super) {
    __extends(FromEventPatternObservable, _super);
    function FromEventPatternObservable(addHandler, removeHandler, selector) {
        _super.call(this);
        this.addHandler = addHandler;
        this.removeHandler = removeHandler;
        this.selector = selector;
    }
    /**
     * Creates an Observable from an API based on addHandler/removeHandler
     * functions.
     *
     * <span class="informal">Converts any addHandler/removeHandler API to an
     * Observable.</span>
     *
     * <img src="./img/fromEventPattern.png" width="100%">
     *
     * Creates an Observable by using the `addHandler` and `removeHandler`
     * functions to add and remove the handlers, with an optional selector
     * function to project the event arguments to a result. The `addHandler` is
     * called when the output Observable is subscribed, and `removeHandler` is
     * called when the Subscription is unsubscribed.
     *
     * @example <caption>Emits clicks happening on the DOM document</caption>
     * function addClickHandler(handler) {
     *   document.addEventListener('click', handler);
     * }
     *
     * function removeClickHandler(handler) {
     *   document.removeEventListener('click', handler);
     * }
     *
     * var clicks = Rx.Observable.fromEventPattern(
     *   addClickHandler,
     *   removeClickHandler
     * );
     * clicks.subscribe(x => console.log(x));
     *
     * @see {@link from}
     * @see {@link fromEvent}
     *
     * @param {function(handler: Function): any} addHandler A function that takes
     * a `handler` function as argument and attaches it somehow to the actual
     * source of events.
     * @param {function(handler: Function, signal?: any): void} [removeHandler] An optional function that
     * takes a `handler` function as argument and removes it in case it was
     * previously attached using `addHandler`. if addHandler returns signal to teardown when remove,
     * removeHandler function will forward it.
     * @param {function(...args: any): T} [selector] An optional function to
     * post-process results. It takes the arguments from the event handler and
     * should return a single value.
     * @return {Observable<T>}
     * @static true
     * @name fromEventPattern
     * @owner Observable
     */
    FromEventPatternObservable.create = function (addHandler, removeHandler, selector) {
        return new FromEventPatternObservable(addHandler, removeHandler, selector);
    };
    FromEventPatternObservable.prototype._subscribe = function (subscriber) {
        var _this = this;
        var removeHandler = this.removeHandler;
        var handler = !!this.selector ? function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            _this._callSelector(subscriber, args);
        } : function (e) { subscriber.next(e); };
        var retValue = this._callAddHandler(handler, subscriber);
        if (!isFunction_1.isFunction(removeHandler)) {
            return;
        }
        subscriber.add(new Subscription_1.Subscription(function () {
            //TODO: determine whether or not to forward to error handler
            removeHandler(handler, retValue);
        }));
    };
    FromEventPatternObservable.prototype._callSelector = function (subscriber, args) {
        try {
            var result = this.selector.apply(this, args);
            subscriber.next(result);
        }
        catch (e) {
            subscriber.error(e);
        }
    };
    FromEventPatternObservable.prototype._callAddHandler = function (handler, errorSubscriber) {
        try {
            return this.addHandler(handler) || null;
        }
        catch (e) {
            errorSubscriber.error(e);
        }
    };
    return FromEventPatternObservable;
}(Observable_1.Observable));
exports.FromEventPatternObservable = FromEventPatternObservable;
//# sourceMappingURL=FromEventPatternObservable.js.map

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(0);
var isScheduler_1 = __webpack_require__(12);
var selfSelector = function (value) { return value; };
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var GenerateObservable = (function (_super) {
    __extends(GenerateObservable, _super);
    function GenerateObservable(initialState, condition, iterate, resultSelector, scheduler) {
        _super.call(this);
        this.initialState = initialState;
        this.condition = condition;
        this.iterate = iterate;
        this.resultSelector = resultSelector;
        this.scheduler = scheduler;
    }
    GenerateObservable.create = function (initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {
        if (arguments.length == 1) {
            return new GenerateObservable(initialStateOrOptions.initialState, initialStateOrOptions.condition, initialStateOrOptions.iterate, initialStateOrOptions.resultSelector || selfSelector, initialStateOrOptions.scheduler);
        }
        if (resultSelectorOrObservable === undefined || isScheduler_1.isScheduler(resultSelectorOrObservable)) {
            return new GenerateObservable(initialStateOrOptions, condition, iterate, selfSelector, resultSelectorOrObservable);
        }
        return new GenerateObservable(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler);
    };
    GenerateObservable.prototype._subscribe = function (subscriber) {
        var state = this.initialState;
        if (this.scheduler) {
            return this.scheduler.schedule(GenerateObservable.dispatch, 0, {
                subscriber: subscriber,
                iterate: this.iterate,
                condition: this.condition,
                resultSelector: this.resultSelector,
                state: state });
        }
        var _a = this, condition = _a.condition, resultSelector = _a.resultSelector, iterate = _a.iterate;
        do {
            if (condition) {
                var conditionResult = void 0;
                try {
                    conditionResult = condition(state);
                }
                catch (err) {
                    subscriber.error(err);
                    return;
                }
                if (!conditionResult) {
                    subscriber.complete();
                    break;
                }
            }
            var value = void 0;
            try {
                value = resultSelector(state);
            }
            catch (err) {
                subscriber.error(err);
                return;
            }
            subscriber.next(value);
            if (subscriber.closed) {
                break;
            }
            try {
                state = iterate(state);
            }
            catch (err) {
                subscriber.error(err);
                return;
            }
        } while (true);
    };
    GenerateObservable.dispatch = function (state) {
        var subscriber = state.subscriber, condition = state.condition;
        if (subscriber.closed) {
            return;
        }
        if (state.needIterate) {
            try {
                state.state = state.iterate(state.state);
            }
            catch (err) {
                subscriber.error(err);
                return;
            }
        }
        else {
            state.needIterate = true;
        }
        if (condition) {
            var conditionResult = void 0;
            try {
                conditionResult = condition(state.state);
            }
            catch (err) {
                subscriber.error(err);
                return;
            }
            if (!conditionResult) {
                subscriber.complete();
                return;
            }
            if (subscriber.closed) {
                return;
            }
        }
        var value;
        try {
            value = state.resultSelector(state.state);
        }
        catch (err) {
            subscriber.error(err);
            return;
        }
        if (subscriber.closed) {
            return;
        }
        subscriber.next(value);
        if (subscriber.closed) {
            return;
        }
        return this.schedule(state);
    };
    return GenerateObservable;
}(Observable_1.Observable));
exports.GenerateObservable = GenerateObservable;
//# sourceMappingURL=GenerateObservable.js.map

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(0);
var subscribeToResult_1 = __webpack_require__(3);
var OuterSubscriber_1 = __webpack_require__(2);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var IfObservable = (function (_super) {
    __extends(IfObservable, _super);
    function IfObservable(condition, thenSource, elseSource) {
        _super.call(this);
        this.condition = condition;
        this.thenSource = thenSource;
        this.elseSource = elseSource;
    }
    IfObservable.create = function (condition, thenSource, elseSource) {
        return new IfObservable(condition, thenSource, elseSource);
    };
    IfObservable.prototype._subscribe = function (subscriber) {
        var _a = this, condition = _a.condition, thenSource = _a.thenSource, elseSource = _a.elseSource;
        return new IfSubscriber(subscriber, condition, thenSource, elseSource);
    };
    return IfObservable;
}(Observable_1.Observable));
exports.IfObservable = IfObservable;
var IfSubscriber = (function (_super) {
    __extends(IfSubscriber, _super);
    function IfSubscriber(destination, condition, thenSource, elseSource) {
        _super.call(this, destination);
        this.condition = condition;
        this.thenSource = thenSource;
        this.elseSource = elseSource;
        this.tryIf();
    }
    IfSubscriber.prototype.tryIf = function () {
        var _a = this, condition = _a.condition, thenSource = _a.thenSource, elseSource = _a.elseSource;
        var result;
        try {
            result = condition();
            var source = result ? thenSource : elseSource;
            if (source) {
                this.add(subscribeToResult_1.subscribeToResult(this, source));
            }
            else {
                this._complete();
            }
        }
        catch (err) {
            this._error(err);
        }
    };
    return IfSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=IfObservable.js.map

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isNumeric_1 = __webpack_require__(28);
var Observable_1 = __webpack_require__(0);
var async_1 = __webpack_require__(9);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var IntervalObservable = (function (_super) {
    __extends(IntervalObservable, _super);
    function IntervalObservable(period, scheduler) {
        if (period === void 0) { period = 0; }
        if (scheduler === void 0) { scheduler = async_1.async; }
        _super.call(this);
        this.period = period;
        this.scheduler = scheduler;
        if (!isNumeric_1.isNumeric(period) || period < 0) {
            this.period = 0;
        }
        if (!scheduler || typeof scheduler.schedule !== 'function') {
            this.scheduler = async_1.async;
        }
    }
    /**
     * Creates an Observable that emits sequential numbers every specified
     * interval of time, on a specified IScheduler.
     *
     * <span class="informal">Emits incremental numbers periodically in time.
     * </span>
     *
     * <img src="./img/interval.png" width="100%">
     *
     * `interval` returns an Observable that emits an infinite sequence of
     * ascending integers, with a constant interval of time of your choosing
     * between those emissions. The first emission is not sent immediately, but
     * only after the first period has passed. By default, this operator uses the
     * `async` IScheduler to provide a notion of time, but you may pass any
     * IScheduler to it.
     *
     * @example <caption>Emits ascending numbers, one every second (1000ms)</caption>
     * var numbers = Rx.Observable.interval(1000);
     * numbers.subscribe(x => console.log(x));
     *
     * @see {@link timer}
     * @see {@link delay}
     *
     * @param {number} [period=0] The interval size in milliseconds (by default)
     * or the time unit determined by the scheduler's clock.
     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling
     * the emission of values, and providing a notion of "time".
     * @return {Observable} An Observable that emits a sequential number each time
     * interval.
     * @static true
     * @name interval
     * @owner Observable
     */
    IntervalObservable.create = function (period, scheduler) {
        if (period === void 0) { period = 0; }
        if (scheduler === void 0) { scheduler = async_1.async; }
        return new IntervalObservable(period, scheduler);
    };
    IntervalObservable.dispatch = function (state) {
        var index = state.index, subscriber = state.subscriber, period = state.period;
        subscriber.next(index);
        if (subscriber.closed) {
            return;
        }
        state.index += 1;
        this.schedule(state, period);
    };
    IntervalObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var period = this.period;
        var scheduler = this.scheduler;
        subscriber.add(scheduler.schedule(IntervalObservable.dispatch, period, {
            index: index, subscriber: subscriber, period: period
        }));
    };
    return IntervalObservable;
}(Observable_1.Observable));
exports.IntervalObservable = IntervalObservable;
//# sourceMappingURL=IntervalObservable.js.map

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var root_1 = __webpack_require__(7);
var Observable_1 = __webpack_require__(0);
var iterator_1 = __webpack_require__(18);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var IteratorObservable = (function (_super) {
    __extends(IteratorObservable, _super);
    function IteratorObservable(iterator, scheduler) {
        _super.call(this);
        this.scheduler = scheduler;
        if (iterator == null) {
            throw new Error('iterator cannot be null.');
        }
        this.iterator = getIterator(iterator);
    }
    IteratorObservable.create = function (iterator, scheduler) {
        return new IteratorObservable(iterator, scheduler);
    };
    IteratorObservable.dispatch = function (state) {
        var index = state.index, hasError = state.hasError, iterator = state.iterator, subscriber = state.subscriber;
        if (hasError) {
            subscriber.error(state.error);
            return;
        }
        var result = iterator.next();
        if (result.done) {
            subscriber.complete();
            return;
        }
        subscriber.next(result.value);
        state.index = index + 1;
        if (subscriber.closed) {
            if (typeof iterator.return === 'function') {
                iterator.return();
            }
            return;
        }
        this.schedule(state);
    };
    IteratorObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var _a = this, iterator = _a.iterator, scheduler = _a.scheduler;
        if (scheduler) {
            return scheduler.schedule(IteratorObservable.dispatch, 0, {
                index: index, iterator: iterator, subscriber: subscriber
            });
        }
        else {
            do {
                var result = iterator.next();
                if (result.done) {
                    subscriber.complete();
                    break;
                }
                else {
                    subscriber.next(result.value);
                }
                if (subscriber.closed) {
                    if (typeof iterator.return === 'function') {
                        iterator.return();
                    }
                    break;
                }
            } while (true);
        }
    };
    return IteratorObservable;
}(Observable_1.Observable));
exports.IteratorObservable = IteratorObservable;
var StringIterator = (function () {
    function StringIterator(str, idx, len) {
        if (idx === void 0) { idx = 0; }
        if (len === void 0) { len = str.length; }
        this.str = str;
        this.idx = idx;
        this.len = len;
    }
    StringIterator.prototype[iterator_1.$$iterator] = function () { return (this); };
    StringIterator.prototype.next = function () {
        return this.idx < this.len ? {
            done: false,
            value: this.str.charAt(this.idx++)
        } : {
            done: true,
            value: undefined
        };
    };
    return StringIterator;
}());
var ArrayIterator = (function () {
    function ArrayIterator(arr, idx, len) {
        if (idx === void 0) { idx = 0; }
        if (len === void 0) { len = toLength(arr); }
        this.arr = arr;
        this.idx = idx;
        this.len = len;
    }
    ArrayIterator.prototype[iterator_1.$$iterator] = function () { return this; };
    ArrayIterator.prototype.next = function () {
        return this.idx < this.len ? {
            done: false,
            value: this.arr[this.idx++]
        } : {
            done: true,
            value: undefined
        };
    };
    return ArrayIterator;
}());
function getIterator(obj) {
    var i = obj[iterator_1.$$iterator];
    if (!i && typeof obj === 'string') {
        return new StringIterator(obj);
    }
    if (!i && obj.length !== undefined) {
        return new ArrayIterator(obj);
    }
    if (!i) {
        throw new TypeError('object is not iterable');
    }
    return obj[iterator_1.$$iterator]();
}
var maxSafeInteger = Math.pow(2, 53) - 1;
function toLength(o) {
    var len = +o.length;
    if (isNaN(len)) {
        return 0;
    }
    if (len === 0 || !numberIsFinite(len)) {
        return len;
    }
    len = sign(len) * Math.floor(Math.abs(len));
    if (len <= 0) {
        return 0;
    }
    if (len > maxSafeInteger) {
        return maxSafeInteger;
    }
    return len;
}
function numberIsFinite(value) {
    return typeof value === 'number' && root_1.root.isFinite(value);
}
function sign(value) {
    var valueAsNumber = +value;
    if (valueAsNumber === 0) {
        return valueAsNumber;
    }
    if (isNaN(valueAsNumber)) {
        return valueAsNumber;
    }
    return valueAsNumber < 0 ? -1 : 1;
}
//# sourceMappingURL=IteratorObservable.js.map

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(0);
var noop_1 = __webpack_require__(66);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var NeverObservable = (function (_super) {
    __extends(NeverObservable, _super);
    function NeverObservable() {
        _super.call(this);
    }
    /**
     * Creates an Observable that emits no items to the Observer.
     *
     * <span class="informal">An Observable that never emits anything.</span>
     *
     * <img src="./img/never.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that emits
     * neither values nor errors nor the completion notification. It can be used
     * for testing purposes or for composing with other Observables. Please not
     * that by never emitting a complete notification, this Observable keeps the
     * subscription from being disposed automatically. Subscriptions need to be
     * manually disposed.
     *
     * @example <caption>Emit the number 7, then never emit anything else (not even complete).</caption>
     * function info() {
     *   console.log('Will not be called');
     * }
     * var result = Rx.Observable.never().startWith(7);
     * result.subscribe(x => console.log(x), info, info);
     *
     * @see {@link create}
     * @see {@link empty}
     * @see {@link of}
     * @see {@link throw}
     *
     * @return {Observable} A "never" Observable: never emits anything.
     * @static true
     * @name never
     * @owner Observable
     */
    NeverObservable.create = function () {
        return new NeverObservable();
    };
    NeverObservable.prototype._subscribe = function (subscriber) {
        noop_1.noop();
    };
    return NeverObservable;
}(Observable_1.Observable));
exports.NeverObservable = NeverObservable;
//# sourceMappingURL=NeverObservable.js.map

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(0);
function dispatch(state) {
    var obj = state.obj, keys = state.keys, length = state.length, index = state.index, subscriber = state.subscriber;
    if (index === length) {
        subscriber.complete();
        return;
    }
    var key = keys[index];
    subscriber.next([key, obj[key]]);
    state.index = index + 1;
    this.schedule(state);
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var PairsObservable = (function (_super) {
    __extends(PairsObservable, _super);
    function PairsObservable(obj, scheduler) {
        _super.call(this);
        this.obj = obj;
        this.scheduler = scheduler;
        this.keys = Object.keys(obj);
    }
    /**
     * Convert an object into an observable sequence of [key, value] pairs
     * using an optional IScheduler to enumerate the object.
     *
     * @example <caption>Converts a javascript object to an Observable</caption>
     * var obj = {
     *   foo: 42,
     *   bar: 56,
     *   baz: 78
     * };
     *
     * var source = Rx.Observable.pairs(obj);
     *
     * var subscription = source.subscribe(
     *   function (x) {
     *     console.log('Next: %s', x);
     *   },
     *   function (err) {
     *     console.log('Error: %s', err);
     *   },
     *   function () {
     *     console.log('Completed');
     *   });
     *
     * @param {Object} obj The object to inspect and turn into an
     * Observable sequence.
     * @param {Scheduler} [scheduler] An optional IScheduler to run the
     * enumeration of the input sequence on.
     * @returns {(Observable<Array<string | T>>)} An observable sequence of
     * [key, value] pairs from the object.
     */
    PairsObservable.create = function (obj, scheduler) {
        return new PairsObservable(obj, scheduler);
    };
    PairsObservable.prototype._subscribe = function (subscriber) {
        var _a = this, keys = _a.keys, scheduler = _a.scheduler;
        var length = keys.length;
        if (scheduler) {
            return scheduler.schedule(dispatch, 0, {
                obj: this.obj, keys: keys, length: length, index: 0, subscriber: subscriber
            });
        }
        else {
            for (var idx = 0; idx < length; idx++) {
                var key = keys[idx];
                subscriber.next([key, this.obj[key]]);
            }
            subscriber.complete();
        }
    };
    return PairsObservable;
}(Observable_1.Observable));
exports.PairsObservable = PairsObservable;
//# sourceMappingURL=PairsObservable.js.map

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(0);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var RangeObservable = (function (_super) {
    __extends(RangeObservable, _super);
    function RangeObservable(start, count, scheduler) {
        _super.call(this);
        this.start = start;
        this._count = count;
        this.scheduler = scheduler;
    }
    /**
     * Creates an Observable that emits a sequence of numbers within a specified
     * range.
     *
     * <span class="informal">Emits a sequence of numbers in a range.</span>
     *
     * <img src="./img/range.png" width="100%">
     *
     * `range` operator emits a range of sequential integers, in order, where you
     * select the `start` of the range and its `length`. By default, uses no
     * IScheduler and just delivers the notifications synchronously, but may use
     * an optional IScheduler to regulate those deliveries.
     *
     * @example <caption>Emits the numbers 1 to 10</caption>
     * var numbers = Rx.Observable.range(1, 10);
     * numbers.subscribe(x => console.log(x));
     *
     * @see {@link timer}
     * @see {@link interval}
     *
     * @param {number} [start=0] The value of the first integer in the sequence.
     * @param {number} [count=0] The number of sequential integers to generate.
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emissions of the notifications.
     * @return {Observable} An Observable of numbers that emits a finite range of
     * sequential integers.
     * @static true
     * @name range
     * @owner Observable
     */
    RangeObservable.create = function (start, count, scheduler) {
        if (start === void 0) { start = 0; }
        if (count === void 0) { count = 0; }
        return new RangeObservable(start, count, scheduler);
    };
    RangeObservable.dispatch = function (state) {
        var start = state.start, index = state.index, count = state.count, subscriber = state.subscriber;
        if (index >= count) {
            subscriber.complete();
            return;
        }
        subscriber.next(start);
        if (subscriber.closed) {
            return;
        }
        state.index = index + 1;
        state.start = start + 1;
        this.schedule(state);
    };
    RangeObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var start = this.start;
        var count = this._count;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(RangeObservable.dispatch, 0, {
                index: index, count: count, start: start, subscriber: subscriber
            });
        }
        else {
            do {
                if (index++ >= count) {
                    subscriber.complete();
                    break;
                }
                subscriber.next(start++);
                if (subscriber.closed) {
                    break;
                }
            } while (true);
        }
    };
    return RangeObservable;
}(Observable_1.Observable));
exports.RangeObservable = RangeObservable;
//# sourceMappingURL=RangeObservable.js.map

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(0);
var asap_1 = __webpack_require__(56);
var isNumeric_1 = __webpack_require__(28);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var SubscribeOnObservable = (function (_super) {
    __extends(SubscribeOnObservable, _super);
    function SubscribeOnObservable(source, delayTime, scheduler) {
        if (delayTime === void 0) { delayTime = 0; }
        if (scheduler === void 0) { scheduler = asap_1.asap; }
        _super.call(this);
        this.source = source;
        this.delayTime = delayTime;
        this.scheduler = scheduler;
        if (!isNumeric_1.isNumeric(delayTime) || delayTime < 0) {
            this.delayTime = 0;
        }
        if (!scheduler || typeof scheduler.schedule !== 'function') {
            this.scheduler = asap_1.asap;
        }
    }
    SubscribeOnObservable.create = function (source, delay, scheduler) {
        if (delay === void 0) { delay = 0; }
        if (scheduler === void 0) { scheduler = asap_1.asap; }
        return new SubscribeOnObservable(source, delay, scheduler);
    };
    SubscribeOnObservable.dispatch = function (arg) {
        var source = arg.source, subscriber = arg.subscriber;
        return this.add(source.subscribe(subscriber));
    };
    SubscribeOnObservable.prototype._subscribe = function (subscriber) {
        var delay = this.delayTime;
        var source = this.source;
        var scheduler = this.scheduler;
        return scheduler.schedule(SubscribeOnObservable.dispatch, delay, {
            source: source, subscriber: subscriber
        });
    };
    return SubscribeOnObservable;
}(Observable_1.Observable));
exports.SubscribeOnObservable = SubscribeOnObservable;
//# sourceMappingURL=SubscribeOnObservable.js.map

/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isNumeric_1 = __webpack_require__(28);
var Observable_1 = __webpack_require__(0);
var async_1 = __webpack_require__(9);
var isScheduler_1 = __webpack_require__(12);
var isDate_1 = __webpack_require__(26);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var TimerObservable = (function (_super) {
    __extends(TimerObservable, _super);
    function TimerObservable(dueTime, period, scheduler) {
        if (dueTime === void 0) { dueTime = 0; }
        _super.call(this);
        this.period = -1;
        this.dueTime = 0;
        if (isNumeric_1.isNumeric(period)) {
            this.period = Number(period) < 1 && 1 || Number(period);
        }
        else if (isScheduler_1.isScheduler(period)) {
            scheduler = period;
        }
        if (!isScheduler_1.isScheduler(scheduler)) {
            scheduler = async_1.async;
        }
        this.scheduler = scheduler;
        this.dueTime = isDate_1.isDate(dueTime) ?
            (+dueTime - this.scheduler.now()) :
            dueTime;
    }
    /**
     * Creates an Observable that starts emitting after an `initialDelay` and
     * emits ever increasing numbers after each `period` of time thereafter.
     *
     * <span class="informal">Its like {@link interval}, but you can specify when
     * should the emissions start.</span>
     *
     * <img src="./img/timer.png" width="100%">
     *
     * `timer` returns an Observable that emits an infinite sequence of ascending
     * integers, with a constant interval of time, `period` of your choosing
     * between those emissions. The first emission happens after the specified
     * `initialDelay`. The initial delay may be a {@link Date}. By default, this
     * operator uses the `async` IScheduler to provide a notion of time, but you
     * may pass any IScheduler to it. If `period` is not specified, the output
     * Observable emits only one value, `0`. Otherwise, it emits an infinite
     * sequence.
     *
     * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>
     * var numbers = Rx.Observable.timer(3000, 1000);
     * numbers.subscribe(x => console.log(x));
     *
     * @example <caption>Emits one number after five seconds</caption>
     * var numbers = Rx.Observable.timer(5000);
     * numbers.subscribe(x => console.log(x));
     *
     * @see {@link interval}
     * @see {@link delay}
     *
     * @param {number|Date} initialDelay The initial delay time to wait before
     * emitting the first value of `0`.
     * @param {number} [period] The period of time between emissions of the
     * subsequent numbers.
     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling
     * the emission of values, and providing a notion of "time".
     * @return {Observable} An Observable that emits a `0` after the
     * `initialDelay` and ever increasing numbers after each `period` of time
     * thereafter.
     * @static true
     * @name timer
     * @owner Observable
     */
    TimerObservable.create = function (initialDelay, period, scheduler) {
        if (initialDelay === void 0) { initialDelay = 0; }
        return new TimerObservable(initialDelay, period, scheduler);
    };
    TimerObservable.dispatch = function (state) {
        var index = state.index, period = state.period, subscriber = state.subscriber;
        var action = this;
        subscriber.next(index);
        if (subscriber.closed) {
            return;
        }
        else if (period === -1) {
            return subscriber.complete();
        }
        state.index = index + 1;
        action.schedule(state, period);
    };
    TimerObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var _a = this, period = _a.period, dueTime = _a.dueTime, scheduler = _a.scheduler;
        return scheduler.schedule(TimerObservable.dispatch, dueTime, {
            index: index, period: period, subscriber: subscriber
        });
    };
    return TimerObservable;
}(Observable_1.Observable));
exports.TimerObservable = TimerObservable;
//# sourceMappingURL=TimerObservable.js.map

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(0);
var subscribeToResult_1 = __webpack_require__(3);
var OuterSubscriber_1 = __webpack_require__(2);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var UsingObservable = (function (_super) {
    __extends(UsingObservable, _super);
    function UsingObservable(resourceFactory, observableFactory) {
        _super.call(this);
        this.resourceFactory = resourceFactory;
        this.observableFactory = observableFactory;
    }
    UsingObservable.create = function (resourceFactory, observableFactory) {
        return new UsingObservable(resourceFactory, observableFactory);
    };
    UsingObservable.prototype._subscribe = function (subscriber) {
        var _a = this, resourceFactory = _a.resourceFactory, observableFactory = _a.observableFactory;
        var resource;
        try {
            resource = resourceFactory();
            return new UsingSubscriber(subscriber, resource, observableFactory);
        }
        catch (err) {
            subscriber.error(err);
        }
    };
    return UsingObservable;
}(Observable_1.Observable));
exports.UsingObservable = UsingObservable;
var UsingSubscriber = (function (_super) {
    __extends(UsingSubscriber, _super);
    function UsingSubscriber(destination, resource, observableFactory) {
        _super.call(this, destination);
        this.resource = resource;
        this.observableFactory = observableFactory;
        destination.add(resource);
        this.tryUse();
    }
    UsingSubscriber.prototype.tryUse = function () {
        try {
            var source = this.observableFactory.call(this, this.resource);
            if (source) {
                this.add(subscribeToResult_1.subscribeToResult(this, source));
            }
        }
        catch (err) {
            this._error(err);
        }
    };
    return UsingSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=UsingObservable.js.map

/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var BoundCallbackObservable_1 = __webpack_require__(209);
exports.bindCallback = BoundCallbackObservable_1.BoundCallbackObservable.create;
//# sourceMappingURL=bindCallback.js.map

/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var BoundNodeCallbackObservable_1 = __webpack_require__(210);
exports.bindNodeCallback = BoundNodeCallbackObservable_1.BoundNodeCallbackObservable.create;
//# sourceMappingURL=bindNodeCallback.js.map

/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isScheduler_1 = __webpack_require__(12);
var isArray_1 = __webpack_require__(11);
var ArrayObservable_1 = __webpack_require__(10);
var combineLatest_1 = __webpack_require__(31);
/* tslint:enable:max-line-length */
/**
 * Combines multiple Observables to create an Observable whose values are
 * calculated from the latest values of each of its input Observables.
 *
 * <span class="informal">Whenever any input Observable emits a value, it
 * computes a formula using the latest values from all the inputs, then emits
 * the output of that formula.</span>
 *
 * <img src="./img/combineLatest.png" width="100%">
 *
 * `combineLatest` combines the values from all the Observables passed as
 * arguments. This is done by subscribing to each Observable in order and,
 * whenever any Observable emits, collecting an array of the most recent
 * values from each Observable. So if you pass `n` Observables to operator,
 * returned Observable will always emit an array of `n` values, in order
 * corresponding to order of passed Observables (value from the first Observable
 * on the first place and so on).
 *
 * Static version of `combineLatest` accepts either an array of Observables
 * or each Observable can be put directly as an argument. Note that array of
 * Observables is good choice, if you don't know beforehand how many Observables
 * you will combine. Passing empty array will result in Observable that
 * completes immediately.
 *
 * To ensure output array has always the same length, `combineLatest` will
 * actually wait for all input Observables to emit at least once,
 * before it starts emitting results. This means if some Observable emits
 * values before other Observables started emitting, all that values but last
 * will be lost. On the other hand, is some Observable does not emit value but
 * completes, resulting Observable will complete at the same moment without
 * emitting anything, since it will be now impossible to include value from
 * completed Observable in resulting array. Also, if some input Observable does
 * not emit any value and never completes, `combineLatest` will also never emit
 * and never complete, since, again, it will wait for all streams to emit some
 * value.
 *
 * If at least one Observable was passed to `combineLatest` and all passed Observables
 * emitted something, resulting Observable will complete when all combined
 * streams complete. So even if some Observable completes, result of
 * `combineLatest` will still emit values when other Observables do. In case
 * of completed Observable, its value from now on will always be the last
 * emitted value. On the other hand, if any Observable errors, `combineLatest`
 * will error immediately as well, and all other Observables will be unsubscribed.
 *
 * `combineLatest` accepts as optional parameter `project` function, which takes
 * as arguments all values that would normally be emitted by resulting Observable.
 * `project` can return any kind of value, which will be then emitted by Observable
 * instead of default array. Note that `project` does not take as argument that array
 * of values, but values themselves. That means default `project` can be imagined
 * as function that takes all its arguments and puts them into an array.
 *
 *
 * @example <caption>Combine two timer Observables</caption>
 * const firstTimer = Rx.Observable.timer(0, 1000); // emit 0, 1, 2... after every second, starting from now
 * const secondTimer = Rx.Observable.timer(500, 1000); // emit 0, 1, 2... after every second, starting 0,5s from now
 * const combinedTimers = Rx.Observable.combineLatest(firstTimer, secondTimer);
 * combinedTimers.subscribe(value => console.log(value));
 * // Logs
 * // [0, 0] after 0.5s
 * // [1, 0] after 1s
 * // [1, 1] after 1.5s
 * // [2, 1] after 2s
 *
 *
 * @example <caption>Combine an array of Observables</caption>
 * const observables = [1, 5, 10].map(
 *   n => Rx.Observable.of(n).delay(n * 1000).startWith(0) // emit 0 and then emit n after n seconds
 * );
 * const combined = Rx.Observable.combineLatest(observables);
 * combined.subscribe(value => console.log(value));
 * // Logs
 * // [0, 0, 0] immediately
 * // [1, 0, 0] after 1s
 * // [1, 5, 0] after 5s
 * // [1, 5, 10] after 10s
 *
 *
 * @example <caption>Use project function to dynamically calculate the Body-Mass Index</caption>
 * var weight = Rx.Observable.of(70, 72, 76, 79, 75);
 * var height = Rx.Observable.of(1.76, 1.77, 1.78);
 * var bmi = Rx.Observable.combineLatest(weight, height, (w, h) => w / (h * h));
 * bmi.subscribe(x => console.log('BMI is ' + x));
 *
 * // With output to console:
 * // BMI is 24.212293388429753
 * // BMI is 23.93948099205209
 * // BMI is 23.671253629592222
 *
 *
 * @see {@link combineAll}
 * @see {@link merge}
 * @see {@link withLatestFrom}
 *
 * @param {ObservableInput} observable1 An input Observable to combine with other Observables.
 * @param {ObservableInput} observable2 An input Observable to combine with other Observables.
 * More than one input Observables may be given as arguments
 * or an array of Observables may be given as the first argument.
 * @param {function} [project] An optional function to project the values from
 * the combined latest values into a new value on the output Observable.
 * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to
 * each input Observable.
 * @return {Observable} An Observable of projected values from the most recent
 * values from each input Observable, or an array of the most recent values from
 * each input Observable.
 * @static true
 * @name combineLatest
 * @owner Observable
 */
function combineLatest() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var project = null;
    var scheduler = null;
    if (isScheduler_1.isScheduler(observables[observables.length - 1])) {
        scheduler = observables.pop();
    }
    if (typeof observables[observables.length - 1] === 'function') {
        project = observables.pop();
    }
    // if the first and only other argument besides the resultSelector is an array
    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`
    if (observables.length === 1 && isArray_1.isArray(observables[0])) {
        observables = observables[0];
    }
    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new combineLatest_1.CombineLatestOperator(project));
}
exports.combineLatest = combineLatest;
//# sourceMappingURL=combineLatest.js.map

/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var concat_1 = __webpack_require__(32);
exports.concat = concat_1.concatStatic;
//# sourceMappingURL=concat.js.map

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var DeferObservable_1 = __webpack_require__(211);
exports.defer = DeferObservable_1.DeferObservable.create;
//# sourceMappingURL=defer.js.map

/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = __webpack_require__(5);
var Subscriber_1 = __webpack_require__(1);
var Observable_1 = __webpack_require__(0);
var Subscription_1 = __webpack_require__(4);
var root_1 = __webpack_require__(7);
var ReplaySubject_1 = __webpack_require__(29);
var tryCatch_1 = __webpack_require__(8);
var errorObject_1 = __webpack_require__(6);
var assign_1 = __webpack_require__(350);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var WebSocketSubject = (function (_super) {
    __extends(WebSocketSubject, _super);
    function WebSocketSubject(urlConfigOrSource, destination) {
        if (urlConfigOrSource instanceof Observable_1.Observable) {
            _super.call(this, destination, urlConfigOrSource);
        }
        else {
            _super.call(this);
            this.WebSocketCtor = root_1.root.WebSocket;
            this._output = new Subject_1.Subject();
            if (typeof urlConfigOrSource === 'string') {
                this.url = urlConfigOrSource;
            }
            else {
                // WARNING: config object could override important members here.
                assign_1.assign(this, urlConfigOrSource);
            }
            if (!this.WebSocketCtor) {
                throw new Error('no WebSocket constructor can be found');
            }
            this.destination = new ReplaySubject_1.ReplaySubject();
        }
    }
    WebSocketSubject.prototype.resultSelector = function (e) {
        return JSON.parse(e.data);
    };
    /**
     * Wrapper around the w3c-compatible WebSocket object provided by the browser.
     *
     * @example <caption>Wraps browser WebSocket</caption>
     *
     * let subject = Observable.webSocket('ws://localhost:8081');
     * subject.subscribe(
     *    (msg) => console.log('message received: ' + msg),
     *    (err) => console.log(err),
     *    () => console.log('complete')
     *  );
     * subject.next(JSON.stringify({ op: 'hello' }));
     *
     * @example <caption>Wraps WebSocket from nodejs-websocket (using node.js)</caption>
     *
     * import { w3cwebsocket } from 'websocket';
     *
     * let socket = new WebSocketSubject({
     *   url: 'ws://localhost:8081',
     *   WebSocketCtor: w3cwebsocket
     * });
     *
     * let subject = Observable.webSocket('ws://localhost:8081');
     * subject.subscribe(
     *    (msg) => console.log('message received: ' + msg),
     *    (err) => console.log(err),
     *    () => console.log('complete')
     *  );
     * subject.next(JSON.stringify({ op: 'hello' }));
     *
     * @param {string | WebSocketSubjectConfig} urlConfigOrSource the source of the websocket as an url or a structure defining the websocket object
     * @return {WebSocketSubject}
     * @static true
     * @name webSocket
     * @owner Observable
     */
    WebSocketSubject.create = function (urlConfigOrSource) {
        return new WebSocketSubject(urlConfigOrSource);
    };
    WebSocketSubject.prototype.lift = function (operator) {
        var sock = new WebSocketSubject(this, this.destination);
        sock.operator = operator;
        return sock;
    };
    WebSocketSubject.prototype._resetState = function () {
        this.socket = null;
        if (!this.source) {
            this.destination = new ReplaySubject_1.ReplaySubject();
        }
        this._output = new Subject_1.Subject();
    };
    // TODO: factor this out to be a proper Operator/Subscriber implementation and eliminate closures
    WebSocketSubject.prototype.multiplex = function (subMsg, unsubMsg, messageFilter) {
        var self = this;
        return new Observable_1.Observable(function (observer) {
            var result = tryCatch_1.tryCatch(subMsg)();
            if (result === errorObject_1.errorObject) {
                observer.error(errorObject_1.errorObject.e);
            }
            else {
                self.next(result);
            }
            var subscription = self.subscribe(function (x) {
                var result = tryCatch_1.tryCatch(messageFilter)(x);
                if (result === errorObject_1.errorObject) {
                    observer.error(errorObject_1.errorObject.e);
                }
                else if (result) {
                    observer.next(x);
                }
            }, function (err) { return observer.error(err); }, function () { return observer.complete(); });
            return function () {
                var result = tryCatch_1.tryCatch(unsubMsg)();
                if (result === errorObject_1.errorObject) {
                    observer.error(errorObject_1.errorObject.e);
                }
                else {
                    self.next(result);
                }
                subscription.unsubscribe();
            };
        });
    };
    WebSocketSubject.prototype._connectSocket = function () {
        var _this = this;
        var WebSocketCtor = this.WebSocketCtor;
        var observer = this._output;
        var socket = null;
        try {
            socket = this.protocol ?
                new WebSocketCtor(this.url, this.protocol) :
                new WebSocketCtor(this.url);
            this.socket = socket;
            if (this.binaryType) {
                this.socket.binaryType = this.binaryType;
            }
        }
        catch (e) {
            observer.error(e);
            return;
        }
        var subscription = new Subscription_1.Subscription(function () {
            _this.socket = null;
            if (socket && socket.readyState === 1) {
                socket.close();
            }
        });
        socket.onopen = function (e) {
            var openObserver = _this.openObserver;
            if (openObserver) {
                openObserver.next(e);
            }
            var queue = _this.destination;
            _this.destination = Subscriber_1.Subscriber.create(function (x) { return socket.readyState === 1 && socket.send(x); }, function (e) {
                var closingObserver = _this.closingObserver;
                if (closingObserver) {
                    closingObserver.next(undefined);
                }
                if (e && e.code) {
                    socket.close(e.code, e.reason);
                }
                else {
                    observer.error(new TypeError('WebSocketSubject.error must be called with an object with an error code, ' +
                        'and an optional reason: { code: number, reason: string }'));
                }
                _this._resetState();
            }, function () {
                var closingObserver = _this.closingObserver;
                if (closingObserver) {
                    closingObserver.next(undefined);
                }
                socket.close();
                _this._resetState();
            });
            if (queue && queue instanceof ReplaySubject_1.ReplaySubject) {
                subscription.add(queue.subscribe(_this.destination));
            }
        };
        socket.onerror = function (e) {
            _this._resetState();
            observer.error(e);
        };
        socket.onclose = function (e) {
            _this._resetState();
            var closeObserver = _this.closeObserver;
            if (closeObserver) {
                closeObserver.next(e);
            }
            if (e.wasClean) {
                observer.complete();
            }
            else {
                observer.error(e);
            }
        };
        socket.onmessage = function (e) {
            var result = tryCatch_1.tryCatch(_this.resultSelector)(e);
            if (result === errorObject_1.errorObject) {
                observer.error(errorObject_1.errorObject.e);
            }
            else {
                observer.next(result);
            }
        };
    };
    WebSocketSubject.prototype._subscribe = function (subscriber) {
        var _this = this;
        var source = this.source;
        if (source) {
            return source.subscribe(subscriber);
        }
        if (!this.socket) {
            this._connectSocket();
        }
        var subscription = new Subscription_1.Subscription();
        subscription.add(this._output.subscribe(subscriber));
        subscription.add(function () {
            var socket = _this.socket;
            if (_this._output.observers.length === 0) {
                if (socket && socket.readyState === 1) {
                    socket.close();
                }
                _this._resetState();
            }
        });
        return subscription;
    };
    WebSocketSubject.prototype.unsubscribe = function () {
        var _a = this, source = _a.source, socket = _a.socket;
        if (socket && socket.readyState === 1) {
            socket.close();
            this._resetState();
        }
        _super.prototype.unsubscribe.call(this);
        if (!source) {
            this.destination = new ReplaySubject_1.ReplaySubject();
        }
    };
    return WebSocketSubject;
}(Subject_1.AnonymousSubject));
exports.WebSocketSubject = WebSocketSubject;
//# sourceMappingURL=WebSocketSubject.js.map

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var AjaxObservable_1 = __webpack_require__(44);
exports.ajax = AjaxObservable_1.AjaxObservable.create;
//# sourceMappingURL=ajax.js.map

/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var WebSocketSubject_1 = __webpack_require__(231);
exports.webSocket = WebSocketSubject_1.WebSocketSubject.create;
//# sourceMappingURL=webSocket.js.map

/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var EmptyObservable_1 = __webpack_require__(13);
exports.empty = EmptyObservable_1.EmptyObservable.create;
//# sourceMappingURL=empty.js.map

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ForkJoinObservable_1 = __webpack_require__(213);
exports.forkJoin = ForkJoinObservable_1.ForkJoinObservable.create;
//# sourceMappingURL=forkJoin.js.map

/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var FromObservable_1 = __webpack_require__(42);
exports.from = FromObservable_1.FromObservable.create;
//# sourceMappingURL=from.js.map

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var FromEventObservable_1 = __webpack_require__(214);
exports.fromEvent = FromEventObservable_1.FromEventObservable.create;
//# sourceMappingURL=fromEvent.js.map

/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var FromEventPatternObservable_1 = __webpack_require__(215);
exports.fromEventPattern = FromEventPatternObservable_1.FromEventPatternObservable.create;
//# sourceMappingURL=fromEventPattern.js.map

/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var PromiseObservable_1 = __webpack_require__(43);
exports.fromPromise = PromiseObservable_1.PromiseObservable.create;
//# sourceMappingURL=fromPromise.js.map

/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var IfObservable_1 = __webpack_require__(217);
exports._if = IfObservable_1.IfObservable.create;
//# sourceMappingURL=if.js.map

/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var IntervalObservable_1 = __webpack_require__(218);
exports.interval = IntervalObservable_1.IntervalObservable.create;
//# sourceMappingURL=interval.js.map

/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var merge_1 = __webpack_require__(48);
exports.merge = merge_1.mergeStatic;
//# sourceMappingURL=merge.js.map

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var NeverObservable_1 = __webpack_require__(220);
exports.never = NeverObservable_1.NeverObservable.create;
//# sourceMappingURL=never.js.map

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayObservable_1 = __webpack_require__(10);
exports.of = ArrayObservable_1.ArrayObservable.of;
//# sourceMappingURL=of.js.map

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var PairsObservable_1 = __webpack_require__(221);
exports.pairs = PairsObservable_1.PairsObservable.create;
//# sourceMappingURL=pairs.js.map

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var RangeObservable_1 = __webpack_require__(222);
exports.range = RangeObservable_1.RangeObservable.create;
//# sourceMappingURL=range.js.map

/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ErrorObservable_1 = __webpack_require__(212);
exports._throw = ErrorObservable_1.ErrorObservable.create;
//# sourceMappingURL=throw.js.map

/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var TimerObservable_1 = __webpack_require__(224);
exports.timer = TimerObservable_1.TimerObservable.create;
//# sourceMappingURL=timer.js.map

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var UsingObservable_1 = __webpack_require__(225);
exports.using = UsingObservable_1.UsingObservable.create;
//# sourceMappingURL=using.js.map

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var zip_1 = __webpack_require__(36);
exports.zip = zip_1.zipStatic;
//# sourceMappingURL=zip.js.map

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var tryCatch_1 = __webpack_require__(8);
var errorObject_1 = __webpack_require__(6);
var OuterSubscriber_1 = __webpack_require__(2);
var subscribeToResult_1 = __webpack_require__(3);
/**
 * Ignores source values for a duration determined by another Observable, then
 * emits the most recent value from the source Observable, then repeats this
 * process.
 *
 * <span class="informal">It's like {@link auditTime}, but the silencing
 * duration is determined by a second Observable.</span>
 *
 * <img src="./img/audit.png" width="100%">
 *
 * `audit` is similar to `throttle`, but emits the last value from the silenced
 * time window, instead of the first value. `audit` emits the most recent value
 * from the source Observable on the output Observable as soon as its internal
 * timer becomes disabled, and ignores source values while the timer is enabled.
 * Initially, the timer is disabled. As soon as the first source value arrives,
 * the timer is enabled by calling the `durationSelector` function with the
 * source value, which returns the "duration" Observable. When the duration
 * Observable emits a value or completes, the timer is disabled, then the most
 * recent source value is emitted on the output Observable, and this process
 * repeats for the next source value.
 *
 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.audit(ev => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounce}
 * @see {@link delayWhen}
 * @see {@link sample}
 * @see {@link throttle}
 *
 * @param {function(value: T): SubscribableOrPromise} durationSelector A function
 * that receives a value from the source Observable, for computing the silencing
 * duration, returned as an Observable or a Promise.
 * @return {Observable<T>} An Observable that performs rate-limiting of
 * emissions from the source Observable.
 * @method audit
 * @owner Observable
 */
function audit(durationSelector) {
    return this.lift(new AuditOperator(durationSelector));
}
exports.audit = audit;
var AuditOperator = (function () {
    function AuditOperator(durationSelector) {
        this.durationSelector = durationSelector;
    }
    AuditOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));
    };
    return AuditOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AuditSubscriber = (function (_super) {
    __extends(AuditSubscriber, _super);
    function AuditSubscriber(destination, durationSelector) {
        _super.call(this, destination);
        this.durationSelector = durationSelector;
        this.hasValue = false;
    }
    AuditSubscriber.prototype._next = function (value) {
        this.value = value;
        this.hasValue = true;
        if (!this.throttled) {
            var duration = tryCatch_1.tryCatch(this.durationSelector)(value);
            if (duration === errorObject_1.errorObject) {
                this.destination.error(errorObject_1.errorObject.e);
            }
            else {
                this.add(this.throttled = subscribeToResult_1.subscribeToResult(this, duration));
            }
        }
    };
    AuditSubscriber.prototype.clearThrottle = function () {
        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;
        if (throttled) {
            this.remove(throttled);
            this.throttled = null;
            throttled.unsubscribe();
        }
        if (hasValue) {
            this.value = null;
            this.hasValue = false;
            this.destination.next(value);
        }
    };
    AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
        this.clearThrottle();
    };
    AuditSubscriber.prototype.notifyComplete = function () {
        this.clearThrottle();
    };
    return AuditSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=audit.js.map

/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var async_1 = __webpack_require__(9);
var Subscriber_1 = __webpack_require__(1);
/**
 * Ignores source values for `duration` milliseconds, then emits the most recent
 * value from the source Observable, then repeats this process.
 *
 * <span class="informal">When it sees a source values, it ignores that plus
 * the next ones for `duration` milliseconds, and then it emits the most recent
 * value from the source.</span>
 *
 * <img src="./img/auditTime.png" width="100%">
 *
 * `auditTime` is similar to `throttleTime`, but emits the last value from the
 * silenced time window, instead of the first value. `auditTime` emits the most
 * recent value from the source Observable on the output Observable as soon as
 * its internal timer becomes disabled, and ignores source values while the
 * timer is enabled. Initially, the timer is disabled. As soon as the first
 * source value arrives, the timer is enabled. After `duration` milliseconds (or
 * the time unit determined internally by the optional `scheduler`) has passed,
 * the timer is disabled, then the most recent source value is emitted on the
 * output Observable, and this process repeats for the next source value.
 * Optionally takes a {@link IScheduler} for managing timers.
 *
 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.auditTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link audit}
 * @see {@link debounceTime}
 * @see {@link delay}
 * @see {@link sampleTime}
 * @see {@link throttleTime}
 *
 * @param {number} duration Time to wait before emitting the most recent source
 * value, measured in milliseconds or the time unit determined internally
 * by the optional `scheduler`.
 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
 * managing the timers that handle the rate-limiting behavior.
 * @return {Observable<T>} An Observable that performs rate-limiting of
 * emissions from the source Observable.
 * @method auditTime
 * @owner Observable
 */
function auditTime(duration, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return this.lift(new AuditTimeOperator(duration, scheduler));
}
exports.auditTime = auditTime;
var AuditTimeOperator = (function () {
    function AuditTimeOperator(duration, scheduler) {
        this.duration = duration;
        this.scheduler = scheduler;
    }
    AuditTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new AuditTimeSubscriber(subscriber, this.duration, this.scheduler));
    };
    return AuditTimeOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AuditTimeSubscriber = (function (_super) {
    __extends(AuditTimeSubscriber, _super);
    function AuditTimeSubscriber(destination, duration, scheduler) {
        _super.call(this, destination);
        this.duration = duration;
        this.scheduler = scheduler;
        this.hasValue = false;
    }
    AuditTimeSubscriber.prototype._next = function (value) {
        this.value = value;
        this.hasValue = true;
        if (!this.throttled) {
            this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, this));
        }
    };
    AuditTimeSubscriber.prototype.clearThrottle = function () {
        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;
        if (throttled) {
            this.remove(throttled);
            this.throttled = null;
            throttled.unsubscribe();
        }
        if (hasValue) {
            this.value = null;
            this.hasValue = false;
            this.destination.next(value);
        }
    };
    return AuditTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchNext(subscriber) {
    subscriber.clearThrottle();
}
//# sourceMappingURL=auditTime.js.map

/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(2);
var subscribeToResult_1 = __webpack_require__(3);
/**
 * Buffers the source Observable values until `closingNotifier` emits.
 *
 * <span class="informal">Collects values from the past as an array, and emits
 * that array only when another Observable emits.</span>
 *
 * <img src="./img/buffer.png" width="100%">
 *
 * Buffers the incoming Observable values until the given `closingNotifier`
 * Observable emits a value, at which point it emits the buffer on the output
 * Observable and starts a new buffer internally, awaiting the next time
 * `closingNotifier` emits.
 *
 * @example <caption>On every click, emit array of most recent interval events</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var interval = Rx.Observable.interval(1000);
 * var buffered = interval.buffer(clicks);
 * buffered.subscribe(x => console.log(x));
 *
 * @see {@link bufferCount}
 * @see {@link bufferTime}
 * @see {@link bufferToggle}
 * @see {@link bufferWhen}
 * @see {@link window}
 *
 * @param {Observable<any>} closingNotifier An Observable that signals the
 * buffer to be emitted on the output Observable.
 * @return {Observable<T[]>} An Observable of buffers, which are arrays of
 * values.
 * @method buffer
 * @owner Observable
 */
function buffer(closingNotifier) {
    return this.lift(new BufferOperator(closingNotifier));
}
exports.buffer = buffer;
var BufferOperator = (function () {
    function BufferOperator(closingNotifier) {
        this.closingNotifier = closingNotifier;
    }
    BufferOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));
    };
    return BufferOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var BufferSubscriber = (function (_super) {
    __extends(BufferSubscriber, _super);
    function BufferSubscriber(destination, closingNotifier) {
        _super.call(this, destination);
        this.buffer = [];
        this.add(subscribeToResult_1.subscribeToResult(this, closingNotifier));
    }
    BufferSubscriber.prototype._next = function (value) {
        this.buffer.push(value);
    };
    BufferSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var buffer = this.buffer;
        this.buffer = [];
        this.destination.next(buffer);
    };
    return BufferSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=buffer.js.map

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(1);
/**
 * Buffers the source Observable values until the size hits the maximum
 * `bufferSize` given.
 *
 * <span class="informal">Collects values from the past as an array, and emits
 * that array only when its size reaches `bufferSize`.</span>
 *
 * <img src="./img/bufferCount.png" width="100%">
 *
 * Buffers a number of values from the source Observable by `bufferSize` then
 * emits the buffer and clears it, and starts a new buffer each
 * `startBufferEvery` values. If `startBufferEvery` is not provided or is
 * `null`, then new buffers are started immediately at the start of the source
 * and when each buffer closes and is emitted.
 *
 * @example <caption>Emit the last two click events as an array</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var buffered = clicks.bufferCount(2);
 * buffered.subscribe(x => console.log(x));
 *
 * @example <caption>On every click, emit the last two click events as an array</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var buffered = clicks.bufferCount(2, 1);
 * buffered.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferTime}
 * @see {@link bufferToggle}
 * @see {@link bufferWhen}
 * @see {@link pairwise}
 * @see {@link windowCount}
 *
 * @param {number} bufferSize The maximum size of the buffer emitted.
 * @param {number} [startBufferEvery] Interval at which to start a new buffer.
 * For example if `startBufferEvery` is `2`, then a new buffer will be started
 * on every other value from the source. A new buffer is started at the
 * beginning of the source by default.
 * @return {Observable<T[]>} An Observable of arrays of buffered values.
 * @method bufferCount
 * @owner Observable
 */
function bufferCount(bufferSize, startBufferEvery) {
    if (startBufferEvery === void 0) { startBufferEvery = null; }
    return this.lift(new BufferCountOperator(bufferSize, startBufferEvery));
}
exports.bufferCount = bufferCount;
var BufferCountOperator = (function () {
    function BufferCountOperator(bufferSize, startBufferEvery) {
        this.bufferSize = bufferSize;
        this.startBufferEvery = startBufferEvery;
    }
    BufferCountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferCountSubscriber(subscriber, this.bufferSize, this.startBufferEvery));
    };
    return BufferCountOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var BufferCountSubscriber = (function (_super) {
    __extends(BufferCountSubscriber, _super);
    function BufferCountSubscriber(destination, bufferSize, startBufferEvery) {
        _super.call(this, destination);
        this.bufferSize = bufferSize;
        this.startBufferEvery = startBufferEvery;
        this.buffers = [];
        this.count = 0;
    }
    BufferCountSubscriber.prototype._next = function (value) {
        var count = this.count++;
        var _a = this, destination = _a.destination, bufferSize = _a.bufferSize, startBufferEvery = _a.startBufferEvery, buffers = _a.buffers;
        var startOn = (startBufferEvery == null) ? bufferSize : startBufferEvery;
        if (count % startOn === 0) {
            buffers.push([]);
        }
        for (var i = buffers.length; i--;) {
            var buffer = buffers[i];
            buffer.push(value);
            if (buffer.length === bufferSize) {
                buffers.splice(i, 1);
                destination.next(buffer);
            }
        }
    };
    BufferCountSubscriber.prototype._complete = function () {
        var destination = this.destination;
        var buffers = this.buffers;
        while (buffers.length > 0) {
            var buffer = buffers.shift();
            if (buffer.length > 0) {
                destination.next(buffer);
            }
        }
        _super.prototype._complete.call(this);
    };
    return BufferCountSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=bufferCount.js.map

/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var async_1 = __webpack_require__(9);
var Subscriber_1 = __webpack_require__(1);
var isScheduler_1 = __webpack_require__(12);
/* tslint:enable:max-line-length */
/**
 * Buffers the source Observable values for a specific time period.
 *
 * <span class="informal">Collects values from the past as an array, and emits
 * those arrays periodically in time.</span>
 *
 * <img src="./img/bufferTime.png" width="100%">
 *
 * Buffers values from the source for a specific time duration `bufferTimeSpan`.
 * Unless the optional argument `bufferCreationInterval` is given, it emits and
 * resets the buffer every `bufferTimeSpan` milliseconds. If
 * `bufferCreationInterval` is given, this operator opens the buffer every
 * `bufferCreationInterval` milliseconds and closes (emits and resets) the
 * buffer every `bufferTimeSpan` milliseconds. When the optional argument
 * `maxBufferSize` is specified, the buffer will be closed either after
 * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.
 *
 * @example <caption>Every second, emit an array of the recent click events</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var buffered = clicks.bufferTime(1000);
 * buffered.subscribe(x => console.log(x));
 *
 * @example <caption>Every 5 seconds, emit the click events from the next 2 seconds</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var buffered = clicks.bufferTime(2000, 5000);
 * buffered.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferCount}
 * @see {@link bufferToggle}
 * @see {@link bufferWhen}
 * @see {@link windowTime}
 *
 * @param {number} bufferTimeSpan The amount of time to fill each buffer array.
 * @param {number} [bufferCreationInterval] The interval at which to start new
 * buffers.
 * @param {number} [maxBufferSize] The maximum buffer size.
 * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the
 * intervals that determine buffer boundaries.
 * @return {Observable<T[]>} An observable of arrays of buffered values.
 * @method bufferTime
 * @owner Observable
 */
function bufferTime(bufferTimeSpan) {
    var length = arguments.length;
    var scheduler = async_1.async;
    if (isScheduler_1.isScheduler(arguments[arguments.length - 1])) {
        scheduler = arguments[arguments.length - 1];
        length--;
    }
    var bufferCreationInterval = null;
    if (length >= 2) {
        bufferCreationInterval = arguments[1];
    }
    var maxBufferSize = Number.POSITIVE_INFINITY;
    if (length >= 3) {
        maxBufferSize = arguments[2];
    }
    return this.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));
}
exports.bufferTime = bufferTime;
var BufferTimeOperator = (function () {
    function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        this.bufferTimeSpan = bufferTimeSpan;
        this.bufferCreationInterval = bufferCreationInterval;
        this.maxBufferSize = maxBufferSize;
        this.scheduler = scheduler;
    }
    BufferTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
    };
    return BufferTimeOperator;
}());
var Context = (function () {
    function Context() {
        this.buffer = [];
    }
    return Context;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var BufferTimeSubscriber = (function (_super) {
    __extends(BufferTimeSubscriber, _super);
    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        _super.call(this, destination);
        this.bufferTimeSpan = bufferTimeSpan;
        this.bufferCreationInterval = bufferCreationInterval;
        this.maxBufferSize = maxBufferSize;
        this.scheduler = scheduler;
        this.contexts = [];
        var context = this.openContext();
        this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;
        if (this.timespanOnly) {
            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };
            this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
        else {
            var closeState = { subscriber: this, context: context };
            var creationState = { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: this, scheduler: scheduler };
            this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));
            this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
        }
    }
    BufferTimeSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        var len = contexts.length;
        var filledBufferContext;
        for (var i = 0; i < len; i++) {
            var context = contexts[i];
            var buffer = context.buffer;
            buffer.push(value);
            if (buffer.length == this.maxBufferSize) {
                filledBufferContext = context;
            }
        }
        if (filledBufferContext) {
            this.onBufferFull(filledBufferContext);
        }
    };
    BufferTimeSubscriber.prototype._error = function (err) {
        this.contexts.length = 0;
        _super.prototype._error.call(this, err);
    };
    BufferTimeSubscriber.prototype._complete = function () {
        var _a = this, contexts = _a.contexts, destination = _a.destination;
        while (contexts.length > 0) {
            var context = contexts.shift();
            destination.next(context.buffer);
        }
        _super.prototype._complete.call(this);
    };
    BufferTimeSubscriber.prototype._unsubscribe = function () {
        this.contexts = null;
    };
    BufferTimeSubscriber.prototype.onBufferFull = function (context) {
        this.closeContext(context);
        var closeAction = context.closeAction;
        closeAction.unsubscribe();
        this.remove(closeAction);
        if (!this.closed && this.timespanOnly) {
            context = this.openContext();
            var bufferTimeSpan = this.bufferTimeSpan;
            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };
            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
    };
    BufferTimeSubscriber.prototype.openContext = function () {
        var context = new Context();
        this.contexts.push(context);
        return context;
    };
    BufferTimeSubscriber.prototype.closeContext = function (context) {
        this.destination.next(context.buffer);
        var contexts = this.contexts;
        var spliceIndex = contexts ? contexts.indexOf(context) : -1;
        if (spliceIndex >= 0) {
            contexts.splice(contexts.indexOf(context), 1);
        }
    };
    return BufferTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchBufferTimeSpanOnly(state) {
    var subscriber = state.subscriber;
    var prevContext = state.context;
    if (prevContext) {
        subscriber.closeContext(prevContext);
    }
    if (!subscriber.closed) {
        state.context = subscriber.openContext();
        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);
    }
}
function dispatchBufferCreation(state) {
    var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;
    var context = subscriber.openContext();
    var action = this;
    if (!subscriber.closed) {
        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, context: context }));
        action.schedule(state, bufferCreationInterval);
    }
}
function dispatchBufferClose(arg) {
    var subscriber = arg.subscriber, context = arg.context;
    subscriber.closeContext(context);
}
//# sourceMappingURL=bufferTime.js.map

/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1 = __webpack_require__(4);
var subscribeToResult_1 = __webpack_require__(3);
var OuterSubscriber_1 = __webpack_require__(2);
/**
 * Buffers the source Observable values starting from an emission from
 * `openings` and ending when the output of `closingSelector` emits.
 *
 * <span class="informal">Collects values from the past as an array. Starts
 * collecting only when `opening` emits, and calls the `closingSelector`
 * function to get an Observable that tells when to close the buffer.</span>
 *
 * <img src="./img/bufferToggle.png" width="100%">
 *
 * Buffers values from the source by opening the buffer via signals from an
 * Observable provided to `openings`, and closing and sending the buffers when
 * a Subscribable or Promise returned by the `closingSelector` function emits.
 *
 * @example <caption>Every other second, emit the click events from the next 500ms</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var openings = Rx.Observable.interval(1000);
 * var buffered = clicks.bufferToggle(openings, i =>
 *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()
 * );
 * buffered.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferCount}
 * @see {@link bufferTime}
 * @see {@link bufferWhen}
 * @see {@link windowToggle}
 *
 * @param {SubscribableOrPromise<O>} openings A Subscribable or Promise of notifications to start new
 * buffers.
 * @param {function(value: O): SubscribableOrPromise} closingSelector A function that takes
 * the value emitted by the `openings` observable and returns a Subscribable or Promise,
 * which, when it emits, signals that the associated buffer should be emitted
 * and cleared.
 * @return {Observable<T[]>} An observable of arrays of buffered values.
 * @method bufferToggle
 * @owner Observable
 */
function bufferToggle(openings, closingSelector) {
    return this.lift(new BufferToggleOperator(openings, closingSelector));
}
exports.bufferToggle = bufferToggle;
var BufferToggleOperator = (function () {
    function BufferToggleOperator(openings, closingSelector) {
        this.openings = openings;
        this.closingSelector = closingSelector;
    }
    BufferToggleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));
    };
    return BufferToggleOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var BufferToggleSubscriber = (function (_super) {
    __extends(BufferToggleSubscriber, _super);
    function BufferToggleSubscriber(destination, openings, closingSelector) {
        _super.call(this, destination);
        this.openings = openings;
        this.closingSelector = closingSelector;
        this.contexts = [];
        this.add(subscribeToResult_1.subscribeToResult(this, openings));
    }
    BufferToggleSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        var len = contexts.length;
        for (var i = 0; i < len; i++) {
            contexts[i].buffer.push(value);
        }
    };
    BufferToggleSubscriber.prototype._error = function (err) {
        var contexts = this.contexts;
        while (contexts.length > 0) {
            var context = contexts.shift();
            context.subscription.unsubscribe();
            context.buffer = null;
            context.subscription = null;
        }
        this.contexts = null;
        _super.prototype._error.call(this, err);
    };
    BufferToggleSubscriber.prototype._complete = function () {
        var contexts = this.contexts;
        while (contexts.length > 0) {
            var context = contexts.shift();
            this.destination.next(context.buffer);
            context.subscription.unsubscribe();
            context.buffer = null;
            context.subscription = null;
        }
        this.contexts = null;
        _super.prototype._complete.call(this);
    };
    BufferToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
    };
    BufferToggleSubscriber.prototype.notifyComplete = function (innerSub) {
        this.closeBuffer(innerSub.context);
    };
    BufferToggleSubscriber.prototype.openBuffer = function (value) {
        try {
            var closingSelector = this.closingSelector;
            var closingNotifier = closingSelector.call(this, value);
            if (closingNotifier) {
                this.trySubscribe(closingNotifier);
            }
        }
        catch (err) {
            this._error(err);
        }
    };
    BufferToggleSubscriber.prototype.closeBuffer = function (context) {
        var contexts = this.contexts;
        if (contexts && context) {
            var buffer = context.buffer, subscription = context.subscription;
            this.destination.next(buffer);
            contexts.splice(contexts.indexOf(context), 1);
            this.remove(subscription);
            subscription.unsubscribe();
        }
    };
    BufferToggleSubscriber.prototype.trySubscribe = function (closingNotifier) {
        var contexts = this.contexts;
        var buffer = [];
        var subscription = new Subscription_1.Subscription();
        var context = { buffer: buffer, subscription: subscription };
        contexts.push(context);
        var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);
        if (!innerSubscription || innerSubscription.closed) {
            this.closeBuffer(context);
        }
        else {
            innerSubscription.context = context;
            this.add(innerSubscription);
            subscription.add(innerSubscription);
        }
    };
    return BufferToggleSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=bufferToggle.js.map

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1 = __webpack_require__(4);
var tryCatch_1 = __webpack_require__(8);
var errorObject_1 = __webpack_require__(6);
var OuterSubscriber_1 = __webpack_require__(2);
var subscribeToResult_1 = __webpack_require__(3);
/**
 * Buffers the source Observable values, using a factory function of closing
 * Observables to determine when to close, emit, and reset the buffer.
 *
 * <span class="informal">Collects values from the past as an array. When it
 * starts collecting values, it calls a function that returns an Observable that
 * tells when to close the buffer and restart collecting.</span>
 *
 * <img src="./img/bufferWhen.png" width="100%">
 *
 * Opens a buffer immediately, then closes the buffer when the observable
 * returned by calling `closingSelector` function emits a value. When it closes
 * the buffer, it immediately opens a new buffer and repeats the process.
 *
 * @example <caption>Emit an array of the last clicks every [1-5] random seconds</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var buffered = clicks.bufferWhen(() =>
 *   Rx.Observable.interval(1000 + Math.random() * 4000)
 * );
 * buffered.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferCount}
 * @see {@link bufferTime}
 * @see {@link bufferToggle}
 * @see {@link windowWhen}
 *
 * @param {function(): Observable} closingSelector A function that takes no
 * arguments and returns an Observable that signals buffer closure.
 * @return {Observable<T[]>} An observable of arrays of buffered values.
 * @method bufferWhen
 * @owner Observable
 */
function bufferWhen(closingSelector) {
    return this.lift(new BufferWhenOperator(closingSelector));
}
exports.bufferWhen = bufferWhen;
var BufferWhenOperator = (function () {
    function BufferWhenOperator(closingSelector) {
        this.closingSelector = closingSelector;
    }
    BufferWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));
    };
    return BufferWhenOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var BufferWhenSubscriber = (function (_super) {
    __extends(BufferWhenSubscriber, _super);
    function BufferWhenSubscriber(destination, closingSelector) {
        _super.call(this, destination);
        this.closingSelector = closingSelector;
        this.subscribing = false;
        this.openBuffer();
    }
    BufferWhenSubscriber.prototype._next = function (value) {
        this.buffer.push(value);
    };
    BufferWhenSubscriber.prototype._complete = function () {
        var buffer = this.buffer;
        if (buffer) {
            this.destination.next(buffer);
        }
        _super.prototype._complete.call(this);
    };
    BufferWhenSubscriber.prototype._unsubscribe = function () {
        this.buffer = null;
        this.subscribing = false;
    };
    BufferWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openBuffer();
    };
    BufferWhenSubscriber.prototype.notifyComplete = function () {
        if (this.subscribing) {
            this.complete();
        }
        else {
            this.openBuffer();
        }
    };
    BufferWhenSubscriber.prototype.openBuffer = function () {
        var closingSubscription = this.closingSubscription;
        if (closingSubscription) {
            this.remove(closingSubscription);
            closingSubscription.unsubscribe();
        }
        var buffer = this.buffer;
        if (this.buffer) {
            this.destination.next(buffer);
        }
        this.buffer = [];
        var closingNotifier = tryCatch_1.tryCatch(this.closingSelector)();
        if (closingNotifier === errorObject_1.errorObject) {
            this.error(errorObject_1.errorObject.e);
        }
        else {
            closingSubscription = new Subscription_1.Subscription();
            this.closingSubscription = closingSubscription;
            this.add(closingSubscription);
            this.subscribing = true;
            closingSubscription.add(subscribeToResult_1.subscribeToResult(this, closingNotifier));
            this.subscribing = false;
        }
    };
    return BufferWhenSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=bufferWhen.js.map

/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(2);
var subscribeToResult_1 = __webpack_require__(3);
/**
 * Catches errors on the observable to be handled by returning a new observable or throwing an error.
 *
 * <img src="./img/catch.png" width="100%">
 *
 * @example <caption>Continues with a different Observable when there's an error</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 * 	   if (n == 4) {
 * 	     throw 'four!';
 *     }
 *	   return n;
 *   })
 *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))
 *   .subscribe(x => console.log(x));
 *   // 1, 2, 3, I, II, III, IV, V
 *
 * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 * 	   if (n === 4) {
 * 	     throw 'four!';
 *     }
 * 	   return n;
 *   })
 *   .catch((err, caught) => caught)
 *   .take(30)
 *   .subscribe(x => console.log(x));
 *   // 1, 2, 3, 1, 2, 3, ...
 *
 * @example <caption>Throws a new error when the source Observable throws an error</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 *     if (n == 4) {
 *       throw 'four!';
 *     }
 *     return n;
 *   })
 *   .catch(err => {
 *     throw 'error in source. Details: ' + err;
 *   })
 *   .subscribe(
 *     x => console.log(x),
 *     err => console.log(err)
 *   );
 *   // 1, 2, 3, error in source. Details: four!
 *
 * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which
 *  is the source observable, in case you'd like to "retry" that observable by returning it again. Whatever observable
 *  is returned by the `selector` will be used to continue the observable chain.
 * @return {Observable} An observable that originates from either the source or the observable returned by the
 *  catch `selector` function.
 * @method catch
 * @name catch
 * @owner Observable
 */
function _catch(selector) {
    var operator = new CatchOperator(selector);
    var caught = this.lift(operator);
    return (operator.caught = caught);
}
exports._catch = _catch;
var CatchOperator = (function () {
    function CatchOperator(selector) {
        this.selector = selector;
    }
    CatchOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
    };
    return CatchOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var CatchSubscriber = (function (_super) {
    __extends(CatchSubscriber, _super);
    function CatchSubscriber(destination, selector, caught) {
        _super.call(this, destination);
        this.selector = selector;
        this.caught = caught;
    }
    // NOTE: overriding `error` instead of `_error` because we don't want
    // to have this flag this subscriber as `isStopped`. We can mimic the
    // behavior of the RetrySubscriber (from the `retry` operator), where
    // we unsubscribe from our source chain, reset our Subscriber flags,
    // then subscribe to the selector result.
    CatchSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var result = void 0;
            try {
                result = this.selector(err, this.caught);
            }
            catch (err2) {
                _super.prototype.error.call(this, err2);
                return;
            }
            this._unsubscribeAndRecycle();
            this.add(subscribeToResult_1.subscribeToResult(this, result));
        }
    };
    return CatchSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=catch.js.map

/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var combineLatest_1 = __webpack_require__(31);
/**
 * Converts a higher-order Observable into a first-order Observable by waiting
 * for the outer Observable to complete, then applying {@link combineLatest}.
 *
 * <span class="informal">Flattens an Observable-of-Observables by applying
 * {@link combineLatest} when the Observable-of-Observables completes.</span>
 *
 * <img src="./img/combineAll.png" width="100%">
 *
 * Takes an Observable of Observables, and collects all Observables from it.
 * Once the outer Observable completes, it subscribes to all collected
 * Observables and combines their values using the {@link combineLatest}
 * strategy, such that:
 * - Every time an inner Observable emits, the output Observable emits.
 * - When the returned observable emits, it emits all of the latest values by:
 *   - If a `project` function is provided, it is called with each recent value
 *     from each inner Observable in whatever order they arrived, and the result
 *     of the `project` function is what is emitted by the output Observable.
 *   - If there is no `project` function, an array of all of the most recent
 *     values is emitted by the output Observable.
 *
 * @example <caption>Map two click events to a finite interval Observable, then apply combineAll</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map(ev =>
 *   Rx.Observable.interval(Math.random()*2000).take(3)
 * ).take(2);
 * var result = higherOrder.combineAll();
 * result.subscribe(x => console.log(x));
 *
 * @see {@link combineLatest}
 * @see {@link mergeAll}
 *
 * @param {function} [project] An optional function to map the most recent
 * values from each inner Observable into a new result. Takes each of the most
 * recent values from each collected inner Observable as arguments, in order.
 * @return {Observable} An Observable of projected results or arrays of recent
 * values.
 * @method combineAll
 * @owner Observable
 */
function combineAll(project) {
    return this.lift(new combineLatest_1.CombineLatestOperator(project));
}
exports.combineAll = combineAll;
//# sourceMappingURL=combineAll.js.map

/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var mergeAll_1 = __webpack_require__(20);
/* tslint:enable:max-line-length */
/**
 * Converts a higher-order Observable into a first-order Observable by
 * concatenating the inner Observables in order.
 *
 * <span class="informal">Flattens an Observable-of-Observables by putting one
 * inner Observable after the other.</span>
 *
 * <img src="./img/concatAll.png" width="100%">
 *
 * Joins every Observable emitted by the source (a higher-order Observable), in
 * a serial fashion. It subscribes to each inner Observable only after the
 * previous inner Observable has completed, and merges all of their values into
 * the returned observable.
 *
 * __Warning:__ If the source Observable emits Observables quickly and
 * endlessly, and the inner Observables it emits generally complete slower than
 * the source emits, you can run into memory issues as the incoming Observables
 * collect in an unbounded buffer.
 *
 * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set
 * to `1`.
 *
 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));
 * var firstOrder = higherOrder.concatAll();
 * firstOrder.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // (results are not concurrent)
 * // For every click on the "document" it will emit values 0 to 3 spaced
 * // on a 1000ms interval
 * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
 *
 * @see {@link combineAll}
 * @see {@link concat}
 * @see {@link concatMap}
 * @see {@link concatMapTo}
 * @see {@link exhaust}
 * @see {@link mergeAll}
 * @see {@link switch}
 * @see {@link zipAll}
 *
 * @return {Observable} An Observable emitting values from all the inner
 * Observables concatenated.
 * @method concatAll
 * @owner Observable
 */
function concatAll() {
    return this.lift(new mergeAll_1.MergeAllOperator(1));
}
exports.concatAll = concatAll;
//# sourceMappingURL=concatAll.js.map

/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var mergeMap_1 = __webpack_require__(49);
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable, in a serialized fashion waiting for each one to complete before
 * merging the next.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link concatAll}.</span>
 *
 * <img src="./img/concatMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. Each new inner Observable is
 * concatenated with the previous inner Observable.
 *
 * __Warning:__ if source values arrive endlessly and faster than their
 * corresponding inner Observables can complete, it will result in memory issues
 * as inner Observables amass in an unbounded buffer waiting for their turn to
 * be subscribed to.
 *
 * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set
 * to `1`.
 *
 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));
 * result.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // (results are not concurrent)
 * // For every click on the "document" it will emit values 0 to 3 spaced
 * // on a 1000ms interval
 * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
 *
 * @see {@link concat}
 * @see {@link concatAll}
 * @see {@link concatMapTo}
 * @see {@link exhaustMap}
 * @see {@link mergeMap}
 * @see {@link switchMap}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An observable of values merged from the projected
 * Observables as they were subscribed to, one at a time. Optionally, these
 * values may have been projected from a passed `projectResult` argument.
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and taking values from each projected inner
 * Observable sequentially.
 * @method concatMap
 * @owner Observable
 */
function concatMap(project, resultSelector) {
    return this.lift(new mergeMap_1.MergeMapOperator(project, resultSelector, 1));
}
exports.concatMap = concatMap;
//# sourceMappingURL=concatMap.js.map

/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var mergeMapTo_1 = __webpack_require__(50);
/* tslint:enable:max-line-length */
/**
 * Projects each source value to the same Observable which is merged multiple
 * times in a serialized fashion on the output Observable.
 *
 * <span class="informal">It's like {@link concatMap}, but maps each value
 * always to the same inner Observable.</span>
 *
 * <img src="./img/concatMapTo.png" width="100%">
 *
 * Maps each source value to the given Observable `innerObservable` regardless
 * of the source value, and then flattens those resulting Observables into one
 * single Observable, which is the output Observable. Each new `innerObservable`
 * instance emitted on the output Observable is concatenated with the previous
 * `innerObservable` instance.
 *
 * __Warning:__ if source values arrive endlessly and faster than their
 * corresponding inner Observables can complete, it will result in memory issues
 * as inner Observables amass in an unbounded buffer waiting for their turn to
 * be subscribed to.
 *
 * Note: `concatMapTo` is equivalent to `mergeMapTo` with concurrency parameter
 * set to `1`.
 *
 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.concatMapTo(Rx.Observable.interval(1000).take(4));
 * result.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // (results are not concurrent)
 * // For every click on the "document" it will emit values 0 to 3 spaced
 * // on a 1000ms interval
 * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
 *
 * @see {@link concat}
 * @see {@link concatAll}
 * @see {@link concatMap}
 * @see {@link mergeMapTo}
 * @see {@link switchMapTo}
 *
 * @param {ObservableInput} innerObservable An Observable to replace each value from
 * the source Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An observable of values merged together by joining the
 * passed observable with itself, one after the other, for each value emitted
 * from the source.
 * @method concatMapTo
 * @owner Observable
 */
function concatMapTo(innerObservable, resultSelector) {
    return this.lift(new mergeMapTo_1.MergeMapToOperator(innerObservable, resultSelector, 1));
}
exports.concatMapTo = concatMapTo;
//# sourceMappingURL=concatMapTo.js.map

/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(1);
/**
 * Counts the number of emissions on the source and emits that number when the
 * source completes.
 *
 * <span class="informal">Tells how many values were emitted, when the source
 * completes.</span>
 *
 * <img src="./img/count.png" width="100%">
 *
 * `count` transforms an Observable that emits values into an Observable that
 * emits a single value that represents the number of values emitted by the
 * source Observable. If the source Observable terminates with an error, `count`
 * will pass this error notification along without emitting a value first. If
 * the source Observable does not terminate at all, `count` will neither emit
 * a value nor terminate. This operator takes an optional `predicate` function
 * as argument, in which case the output emission will represent the number of
 * source values that matched `true` with the `predicate`.
 *
 * @example <caption>Counts how many seconds have passed before the first click happened</caption>
 * var seconds = Rx.Observable.interval(1000);
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var secondsBeforeClick = seconds.takeUntil(clicks);
 * var result = secondsBeforeClick.count();
 * result.subscribe(x => console.log(x));
 *
 * @example <caption>Counts how many odd numbers are there between 1 and 7</caption>
 * var numbers = Rx.Observable.range(1, 7);
 * var result = numbers.count(i => i % 2 === 1);
 * result.subscribe(x => console.log(x));
 *
 * // Results in:
 * // 4
 *
 * @see {@link max}
 * @see {@link min}
 * @see {@link reduce}
 *
 * @param {function(value: T, i: number, source: Observable<T>): boolean} [predicate] A
 * boolean function to select what values are to be counted. It is provided with
 * arguments of:
 * - `value`: the value from the source Observable.
 * - `index`: the (zero-based) "index" of the value from the source Observable.
 * - `source`: the source Observable instance itself.
 * @return {Observable} An Observable of one number that represents the count as
 * described above.
 * @method count
 * @owner Observable
 */
function count(predicate) {
    return this.lift(new CountOperator(predicate, this));
}
exports.count = count;
var CountOperator = (function () {
    function CountOperator(predicate, source) {
        this.predicate = predicate;
        this.source = source;
    }
    CountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));
    };
    return CountOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var CountSubscriber = (function (_super) {
    __extends(CountSubscriber, _super);
    function CountSubscriber(destination, predicate, source) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.source = source;
        this.count = 0;
        this.index = 0;
    }
    CountSubscriber.prototype._next = function (value) {
        if (this.predicate) {
            this._tryPredicate(value);
        }
        else {
            this.count++;
        }
    };
    CountSubscriber.prototype._tryPredicate = function (value) {
        var result;
        try {
            result = this.predicate(value, this.index++, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.count++;
        }
    };
    CountSubscriber.prototype._complete = function () {
        this.destination.next(this.count);
        this.destination.complete();
    };
    return CountSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=count.js.map

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(2);
var subscribeToResult_1 = __webpack_require__(3);
/**
 * Emits a value from the source Observable only after a particular time span
 * determined by another Observable has passed without another source emission.
 *
 * <span class="informal">It's like {@link debounceTime}, but the time span of
 * emission silence is determined by a second Observable.</span>
 *
 * <img src="./img/debounce.png" width="100%">
 *
 * `debounce` delays values emitted by the source Observable, but drops previous
 * pending delayed emissions if a new value arrives on the source Observable.
 * This operator keeps track of the most recent value from the source
 * Observable, and spawns a duration Observable by calling the
 * `durationSelector` function. The value is emitted only when the duration
 * Observable emits a value or completes, and if no other value was emitted on
 * the source Observable since the duration Observable was spawned. If a new
 * value appears before the duration Observable emits, the previous value will
 * be dropped and will not be emitted on the output Observable.
 *
 * Like {@link debounceTime}, this is a rate-limiting operator, and also a
 * delay-like operator since output emissions do not necessarily occur at the
 * same time as they did on the source Observable.
 *
 * @example <caption>Emit the most recent click after a burst of clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.debounce(() => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link audit}
 * @see {@link debounceTime}
 * @see {@link delayWhen}
 * @see {@link throttle}
 *
 * @param {function(value: T): SubscribableOrPromise} durationSelector A function
 * that receives a value from the source Observable, for computing the timeout
 * duration for each source value, returned as an Observable or a Promise.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by the specified duration Observable returned by
 * `durationSelector`, and may drop some values if they occur too frequently.
 * @method debounce
 * @owner Observable
 */
function debounce(durationSelector) {
    return this.lift(new DebounceOperator(durationSelector));
}
exports.debounce = debounce;
var DebounceOperator = (function () {
    function DebounceOperator(durationSelector) {
        this.durationSelector = durationSelector;
    }
    DebounceOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));
    };
    return DebounceOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DebounceSubscriber = (function (_super) {
    __extends(DebounceSubscriber, _super);
    function DebounceSubscriber(destination, durationSelector) {
        _super.call(this, destination);
        this.durationSelector = durationSelector;
        this.hasValue = false;
        this.durationSubscription = null;
    }
    DebounceSubscriber.prototype._next = function (value) {
        try {
            var result = this.durationSelector.call(this, value);
            if (result) {
                this._tryNext(value, result);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    DebounceSubscriber.prototype._complete = function () {
        this.emitValue();
        this.destination.complete();
    };
    DebounceSubscriber.prototype._tryNext = function (value, duration) {
        var subscription = this.durationSubscription;
        this.value = value;
        this.hasValue = true;
        if (subscription) {
            subscription.unsubscribe();
            this.remove(subscription);
        }
        subscription = subscribeToResult_1.subscribeToResult(this, duration);
        if (!subscription.closed) {
            this.add(this.durationSubscription = subscription);
        }
    };
    DebounceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.emitValue();
    };
    DebounceSubscriber.prototype.notifyComplete = function () {
        this.emitValue();
    };
    DebounceSubscriber.prototype.emitValue = function () {
        if (this.hasValue) {
            var value = this.value;
            var subscription = this.durationSubscription;
            if (subscription) {
                this.durationSubscription = null;
                subscription.unsubscribe();
                this.remove(subscription);
            }
            this.value = null;
            this.hasValue = false;
            _super.prototype._next.call(this, value);
        }
    };
    return DebounceSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=debounce.js.map

/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(1);
var async_1 = __webpack_require__(9);
/**
 * Emits a value from the source Observable only after a particular time span
 * has passed without another source emission.
 *
 * <span class="informal">It's like {@link delay}, but passes only the most
 * recent value from each burst of emissions.</span>
 *
 * <img src="./img/debounceTime.png" width="100%">
 *
 * `debounceTime` delays values emitted by the source Observable, but drops
 * previous pending delayed emissions if a new value arrives on the source
 * Observable. This operator keeps track of the most recent value from the
 * source Observable, and emits that only when `dueTime` enough time has passed
 * without any other value appearing on the source Observable. If a new value
 * appears before `dueTime` silence occurs, the previous value will be dropped
 * and will not be emitted on the output Observable.
 *
 * This is a rate-limiting operator, because it is impossible for more than one
 * value to be emitted in any time window of duration `dueTime`, but it is also
 * a delay-like operator since output emissions do not occur at the same time as
 * they did on the source Observable. Optionally takes a {@link IScheduler} for
 * managing timers.
 *
 * @example <caption>Emit the most recent click after a burst of clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.debounceTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounce}
 * @see {@link delay}
 * @see {@link sampleTime}
 * @see {@link throttleTime}
 *
 * @param {number} dueTime The timeout duration in milliseconds (or the time
 * unit determined internally by the optional `scheduler`) for the window of
 * time required to wait for emission silence before emitting the most recent
 * source value.
 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
 * managing the timers that handle the timeout for each value.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by the specified `dueTime`, and may drop some values if they occur
 * too frequently.
 * @method debounceTime
 * @owner Observable
 */
function debounceTime(dueTime, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return this.lift(new DebounceTimeOperator(dueTime, scheduler));
}
exports.debounceTime = debounceTime;
var DebounceTimeOperator = (function () {
    function DebounceTimeOperator(dueTime, scheduler) {
        this.dueTime = dueTime;
        this.scheduler = scheduler;
    }
    DebounceTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
    };
    return DebounceTimeOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DebounceTimeSubscriber = (function (_super) {
    __extends(DebounceTimeSubscriber, _super);
    function DebounceTimeSubscriber(destination, dueTime, scheduler) {
        _super.call(this, destination);
        this.dueTime = dueTime;
        this.scheduler = scheduler;
        this.debouncedSubscription = null;
        this.lastValue = null;
        this.hasValue = false;
    }
    DebounceTimeSubscriber.prototype._next = function (value) {
        this.clearDebounce();
        this.lastValue = value;
        this.hasValue = true;
        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));
    };
    DebounceTimeSubscriber.prototype._complete = function () {
        this.debouncedNext();
        this.destination.complete();
    };
    DebounceTimeSubscriber.prototype.debouncedNext = function () {
        this.clearDebounce();
        if (this.hasValue) {
            this.destination.next(this.lastValue);
            this.lastValue = null;
            this.hasValue = false;
        }
    };
    DebounceTimeSubscriber.prototype.clearDebounce = function () {
        var debouncedSubscription = this.debouncedSubscription;
        if (debouncedSubscription !== null) {
            this.remove(debouncedSubscription);
            debouncedSubscription.unsubscribe();
            this.debouncedSubscription = null;
        }
    };
    return DebounceTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchNext(subscriber) {
    subscriber.debouncedNext();
}
//# sourceMappingURL=debounceTime.js.map

/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(1);
/* tslint:enable:max-line-length */
/**
 * Emits a given value if the source Observable completes without emitting any
 * `next` value, otherwise mirrors the source Observable.
 *
 * <span class="informal">If the source Observable turns out to be empty, then
 * this operator will emit a default value.</span>
 *
 * <img src="./img/defaultIfEmpty.png" width="100%">
 *
 * `defaultIfEmpty` emits the values emitted by the source Observable or a
 * specified default value if the source Observable is empty (completes without
 * having emitted any `next` value).
 *
 * @example <caption>If no clicks happen in 5 seconds, then emit "no clicks"</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var clicksBeforeFive = clicks.takeUntil(Rx.Observable.interval(5000));
 * var result = clicksBeforeFive.defaultIfEmpty('no clicks');
 * result.subscribe(x => console.log(x));
 *
 * @see {@link empty}
 * @see {@link last}
 *
 * @param {any} [defaultValue=null] The default value used if the source
 * Observable is empty.
 * @return {Observable} An Observable that emits either the specified
 * `defaultValue` if the source Observable emits no items, or the values emitted
 * by the source Observable.
 * @method defaultIfEmpty
 * @owner Observable
 */
function defaultIfEmpty(defaultValue) {
    if (defaultValue === void 0) { defaultValue = null; }
    return this.lift(new DefaultIfEmptyOperator(defaultValue));
}
exports.defaultIfEmpty = defaultIfEmpty;
var DefaultIfEmptyOperator = (function () {
    function DefaultIfEmptyOperator(defaultValue) {
        this.defaultValue = defaultValue;
    }
    DefaultIfEmptyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
    };
    return DefaultIfEmptyOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DefaultIfEmptySubscriber = (function (_super) {
    __extends(DefaultIfEmptySubscriber, _super);
    function DefaultIfEmptySubscriber(destination, defaultValue) {
        _super.call(this, destination);
        this.defaultValue = defaultValue;
        this.isEmpty = true;
    }
    DefaultIfEmptySubscriber.prototype._next = function (value) {
        this.isEmpty = false;
        this.destination.next(value);
    };
    DefaultIfEmptySubscriber.prototype._complete = function () {
        if (this.isEmpty) {
            this.destination.next(this.defaultValue);
        }
        this.destination.complete();
    };
    return DefaultIfEmptySubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=defaultIfEmpty.js.map

/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var async_1 = __webpack_require__(9);
var isDate_1 = __webpack_require__(26);
var Subscriber_1 = __webpack_require__(1);
var Notification_1 = __webpack_require__(15);
/**
 * Delays the emission of items from the source Observable by a given timeout or
 * until a given Date.
 *
 * <span class="informal">Time shifts each item by some specified amount of
 * milliseconds.</span>
 *
 * <img src="./img/delay.png" width="100%">
 *
 * If the delay argument is a Number, this operator time shifts the source
 * Observable by that amount of time expressed in milliseconds. The relative
 * time intervals between the values are preserved.
 *
 * If the delay argument is a Date, this operator time shifts the start of the
 * Observable execution until the given date occurs.
 *
 * @example <caption>Delay each click by one second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var delayedClicks = clicks.delay(1000); // each click emitted after 1 second
 * delayedClicks.subscribe(x => console.log(x));
 *
 * @example <caption>Delay all clicks until a future date happens</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var date = new Date('March 15, 2050 12:00:00'); // in the future
 * var delayedClicks = clicks.delay(date); // click emitted only after that date
 * delayedClicks.subscribe(x => console.log(x));
 *
 * @see {@link debounceTime}
 * @see {@link delayWhen}
 *
 * @param {number|Date} delay The delay duration in milliseconds (a `number`) or
 * a `Date` until which the emission of the source items is delayed.
 * @param {Scheduler} [scheduler=async] The IScheduler to use for
 * managing the timers that handle the time-shift for each item.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by the specified timeout or Date.
 * @method delay
 * @owner Observable
 */
function delay(delay, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    var absoluteDelay = isDate_1.isDate(delay);
    var delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(delay);
    return this.lift(new DelayOperator(delayFor, scheduler));
}
exports.delay = delay;
var DelayOperator = (function () {
    function DelayOperator(delay, scheduler) {
        this.delay = delay;
        this.scheduler = scheduler;
    }
    DelayOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
    };
    return DelayOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DelaySubscriber = (function (_super) {
    __extends(DelaySubscriber, _super);
    function DelaySubscriber(destination, delay, scheduler) {
        _super.call(this, destination);
        this.delay = delay;
        this.scheduler = scheduler;
        this.queue = [];
        this.active = false;
        this.errored = false;
    }
    DelaySubscriber.dispatch = function (state) {
        var source = state.source;
        var queue = source.queue;
        var scheduler = state.scheduler;
        var destination = state.destination;
        while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {
            queue.shift().notification.observe(destination);
        }
        if (queue.length > 0) {
            var delay_1 = Math.max(0, queue[0].time - scheduler.now());
            this.schedule(state, delay_1);
        }
        else {
            source.active = false;
        }
    };
    DelaySubscriber.prototype._schedule = function (scheduler) {
        this.active = true;
        this.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
            source: this, destination: this.destination, scheduler: scheduler
        }));
    };
    DelaySubscriber.prototype.scheduleNotification = function (notification) {
        if (this.errored === true) {
            return;
        }
        var scheduler = this.scheduler;
        var message = new DelayMessage(scheduler.now() + this.delay, notification);
        this.queue.push(message);
        if (this.active === false) {
            this._schedule(scheduler);
        }
    };
    DelaySubscriber.prototype._next = function (value) {
        this.scheduleNotification(Notification_1.Notification.createNext(value));
    };
    DelaySubscriber.prototype._error = function (err) {
        this.errored = true;
        this.queue = [];
        this.destination.error(err);
    };
    DelaySubscriber.prototype._complete = function () {
        this.scheduleNotification(Notification_1.Notification.createComplete());
    };
    return DelaySubscriber;
}(Subscriber_1.Subscriber));
var DelayMessage = (function () {
    function DelayMessage(time, notification) {
        this.time = time;
        this.notification = notification;
    }
    return DelayMessage;
}());
//# sourceMappingURL=delay.js.map

/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(1);
var Observable_1 = __webpack_require__(0);
var OuterSubscriber_1 = __webpack_require__(2);
var subscribeToResult_1 = __webpack_require__(3);
/**
 * Delays the emission of items from the source Observable by a given time span
 * determined by the emissions of another Observable.
 *
 * <span class="informal">It's like {@link delay}, but the time span of the
 * delay duration is determined by a second Observable.</span>
 *
 * <img src="./img/delayWhen.png" width="100%">
 *
 * `delayWhen` time shifts each emitted value from the source Observable by a
 * time span determined by another Observable. When the source emits a value,
 * the `delayDurationSelector` function is called with the source value as
 * argument, and should return an Observable, called the "duration" Observable.
 * The source value is emitted on the output Observable only when the duration
 * Observable emits a value or completes.
 *
 * Optionally, `delayWhen` takes a second argument, `subscriptionDelay`, which
 * is an Observable. When `subscriptionDelay` emits its first value or
 * completes, the source Observable is subscribed to and starts behaving like
 * described in the previous paragraph. If `subscriptionDelay` is not provided,
 * `delayWhen` will subscribe to the source Observable as soon as the output
 * Observable is subscribed.
 *
 * @example <caption>Delay each click by a random amount of time, between 0 and 5 seconds</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var delayedClicks = clicks.delayWhen(event =>
 *   Rx.Observable.interval(Math.random() * 5000)
 * );
 * delayedClicks.subscribe(x => console.log(x));
 *
 * @see {@link debounce}
 * @see {@link delay}
 *
 * @param {function(value: T): Observable} delayDurationSelector A function that
 * returns an Observable for each value emitted by the source Observable, which
 * is then used to delay the emission of that item on the output Observable
 * until the Observable returned from this function emits a value.
 * @param {Observable} subscriptionDelay An Observable that triggers the
 * subscription to the source Observable once it emits any value.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by an amount of time specified by the Observable returned by
 * `delayDurationSelector`.
 * @method delayWhen
 * @owner Observable
 */
function delayWhen(delayDurationSelector, subscriptionDelay) {
    if (subscriptionDelay) {
        return new SubscriptionDelayObservable(this, subscriptionDelay)
            .lift(new DelayWhenOperator(delayDurationSelector));
    }
    return this.lift(new DelayWhenOperator(delayDurationSelector));
}
exports.delayWhen = delayWhen;
var DelayWhenOperator = (function () {
    function DelayWhenOperator(delayDurationSelector) {
        this.delayDurationSelector = delayDurationSelector;
    }
    DelayWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));
    };
    return DelayWhenOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DelayWhenSubscriber = (function (_super) {
    __extends(DelayWhenSubscriber, _super);
    function DelayWhenSubscriber(destination, delayDurationSelector) {
        _super.call(this, destination);
        this.delayDurationSelector = delayDurationSelector;
        this.completed = false;
        this.delayNotifierSubscriptions = [];
        this.values = [];
    }
    DelayWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(outerValue);
        this.removeSubscription(innerSub);
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {
        var value = this.removeSubscription(innerSub);
        if (value) {
            this.destination.next(value);
        }
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype._next = function (value) {
        try {
            var delayNotifier = this.delayDurationSelector(value);
            if (delayNotifier) {
                this.tryDelay(delayNotifier, value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    DelayWhenSubscriber.prototype._complete = function () {
        this.completed = true;
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype.removeSubscription = function (subscription) {
        subscription.unsubscribe();
        var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);
        var value = null;
        if (subscriptionIdx !== -1) {
            value = this.values[subscriptionIdx];
            this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
            this.values.splice(subscriptionIdx, 1);
        }
        return value;
    };
    DelayWhenSubscriber.prototype.tryDelay = function (delayNotifier, value) {
        var notifierSubscription = subscribeToResult_1.subscribeToResult(this, delayNotifier, value);
        this.add(notifierSubscription);
        this.delayNotifierSubscriptions.push(notifierSubscription);
        this.values.push(value);
    };
    DelayWhenSubscriber.prototype.tryComplete = function () {
        if (this.completed && this.delayNotifierSubscriptions.length === 0) {
            this.destination.complete();
        }
    };
    return DelayWhenSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SubscriptionDelayObservable = (function (_super) {
    __extends(SubscriptionDelayObservable, _super);
    function SubscriptionDelayObservable(source, subscriptionDelay) {
        _super.call(this);
        this.source = source;
        this.subscriptionDelay = subscriptionDelay;
    }
    SubscriptionDelayObservable.prototype._subscribe = function (subscriber) {
        this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
    };
    return SubscriptionDelayObservable;
}(Observable_1.Observable));
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SubscriptionDelaySubscriber = (function (_super) {
    __extends(SubscriptionDelaySubscriber, _super);
    function SubscriptionDelaySubscriber(parent, source) {
        _super.call(this);
        this.parent = parent;
        this.source = source;
        this.sourceSubscribed = false;
    }
    SubscriptionDelaySubscriber.prototype._next = function (unused) {
        this.subscribeToSource();
    };
    SubscriptionDelaySubscriber.prototype._error = function (err) {
        this.unsubscribe();
        this.parent.error(err);
    };
    SubscriptionDelaySubscriber.prototype._complete = function () {
        this.subscribeToSource();
    };
    SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {
        if (!this.sourceSubscribed) {
            this.sourceSubscribed = true;
            this.unsubscribe();
            this.source.subscribe(this.parent);
        }
    };
    return SubscriptionDelaySubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=delayWhen.js.map

/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(1);
/**
 * Converts an Observable of {@link Notification} objects into the emissions
 * that they represent.
 *
 * <span class="informal">Unwraps {@link Notification} objects as actual `next`,
 * `error` and `complete` emissions. The opposite of {@link materialize}.</span>
 *
 * <img src="./img/dematerialize.png" width="100%">
 *
 * `dematerialize` is assumed to operate an Observable that only emits
 * {@link Notification} objects as `next` emissions, and does not emit any
 * `error`. Such Observable is the output of a `materialize` operation. Those
 * notifications are then unwrapped using the metadata they contain, and emitted
 * as `next`, `error`, and `complete` on the output Observable.
 *
 * Use this operator in conjunction with {@link materialize}.
 *
 * @example <caption>Convert an Observable of Notifications to an actual Observable</caption>
 * var notifA = new Rx.Notification('N', 'A');
 * var notifB = new Rx.Notification('N', 'B');
 * var notifE = new Rx.Notification('E', void 0,
 *   new TypeError('x.toUpperCase is not a function')
 * );
 * var materialized = Rx.Observable.of(notifA, notifB, notifE);
 * var upperCase = materialized.dematerialize();
 * upperCase.subscribe(x => console.log(x), e => console.error(e));
 *
 * // Results in:
 * // A
 * // B
 * // TypeError: x.toUpperCase is not a function
 *
 * @see {@link Notification}
 * @see {@link materialize}
 *
 * @return {Observable} An Observable that emits items and notifications
 * embedded in Notification objects emitted by the source Observable.
 * @method dematerialize
 * @owner Observable
 */
function dematerialize() {
    return this.lift(new DeMaterializeOperator());
}
exports.dematerialize = dematerialize;
var DeMaterializeOperator = (function () {
    function DeMaterializeOperator() {
    }
    DeMaterializeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DeMaterializeSubscriber(subscriber));
    };
    return DeMaterializeOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DeMaterializeSubscriber = (function (_super) {
    __extends(DeMaterializeSubscriber, _super);
    function DeMaterializeSubscriber(destination) {
        _super.call(this, destination);
    }
    DeMaterializeSubscriber.prototype._next = function (value) {
        value.observe(this.destination);
    };
    return DeMaterializeSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=dematerialize.js.map

/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(2);
var subscribeToResult_1 = __webpack_require__(3);
var Set_1 = __webpack_require__(349);
/**
 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.
 *
 * If a keySelector function is provided, then it will project each value from the source observable into a new value that it will
 * check for equality with previously projected values. If a keySelector function is not provided, it will use each value from the
 * source observable directly with an equality check against previous values.
 *
 * In JavaScript runtimes that support `Set`, this operator will use a `Set` to improve performance of the distinct value checking.
 *
 * In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the
 * hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct`
 * use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so
 * that the internal `Set` can be "flushed", basically clearing it of values.
 *
 * @example <caption>A simple example with numbers</caption>
 * Observable.of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1)
 *   .distinct()
 *   .subscribe(x => console.log(x)); // 1, 2, 3, 4
 *
 * @example <caption>An example using a keySelector function</caption>
 * interface Person {
 *    age: number,
 *    name: string
 * }
 *
 * Observable.of<Person>(
 *     { age: 4, name: 'Foo'},
 *     { age: 7, name: 'Bar'},
 *     { age: 5, name: 'Foo'})
 *     .distinct((p: Person) => p.name)
 *     .subscribe(x => console.log(x));
 *
 * // displays:
 * // { age: 4, name: 'Foo' }
 * // { age: 7, name: 'Bar' }
 *
 * @see {@link distinctUntilChanged}
 * @see {@link distinctUntilKeyChanged}
 *
 * @param {function} [keySelector] Optional function to select which value you want to check as distinct.
 * @param {Observable} [flushes] Optional Observable for flushing the internal HashSet of the operator.
 * @return {Observable} An Observable that emits items from the source Observable with distinct values.
 * @method distinct
 * @owner Observable
 */
function distinct(keySelector, flushes) {
    return this.lift(new DistinctOperator(keySelector, flushes));
}
exports.distinct = distinct;
var DistinctOperator = (function () {
    function DistinctOperator(keySelector, flushes) {
        this.keySelector = keySelector;
        this.flushes = flushes;
    }
    DistinctOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));
    };
    return DistinctOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DistinctSubscriber = (function (_super) {
    __extends(DistinctSubscriber, _super);
    function DistinctSubscriber(destination, keySelector, flushes) {
        _super.call(this, destination);
        this.keySelector = keySelector;
        this.values = new Set_1.Set();
        if (flushes) {
            this.add(subscribeToResult_1.subscribeToResult(this, flushes));
        }
    }
    DistinctSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values.clear();
    };
    DistinctSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    DistinctSubscriber.prototype._next = function (value) {
        if (this.keySelector) {
            this._useKeySelector(value);
        }
        else {
            this._finalizeNext(value, value);
        }
    };
    DistinctSubscriber.prototype._useKeySelector = function (value) {
        var key;
        var destination = this.destination;
        try {
            key = this.keySelector(value);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        this._finalizeNext(key, value);
    };
    DistinctSubscriber.prototype._finalizeNext = function (key, value) {
        var values = this.values;
        if (!values.has(key)) {
            values.add(key);
            this.destination.next(value);
        }
    };
    return DistinctSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.DistinctSubscriber = DistinctSubscriber;
//# sourceMappingURL=distinct.js.map

/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var distinctUntilChanged_1 = __webpack_require__(45);
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item,
 * using a property accessed by using the key provided to check if the two items are distinct.
 *
 * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
 *
 * If a comparator function is not provided, an equality check is used by default.
 *
 * @example <caption>An example comparing the name of persons</caption>
 *
 *  interface Person {
 *     age: number,
 *     name: string
 *  }
 *
 * Observable.of<Person>(
 *     { age: 4, name: 'Foo'},
 *     { age: 7, name: 'Bar'},
 *     { age: 5, name: 'Foo'},
 *     { age: 6, name: 'Foo'})
 *     .distinctUntilKeyChanged('name')
 *     .subscribe(x => console.log(x));
 *
 * // displays:
 * // { age: 4, name: 'Foo' }
 * // { age: 7, name: 'Bar' }
 * // { age: 5, name: 'Foo' }
 *
 * @example <caption>An example comparing the first letters of the name</caption>
 *
 * interface Person {
 *     age: number,
 *     name: string
 *  }
 *
 * Observable.of<Person>(
 *     { age: 4, name: 'Foo1'},
 *     { age: 7, name: 'Bar'},
 *     { age: 5, name: 'Foo2'},
 *     { age: 6, name: 'Foo3'})
 *     .distinctUntilKeyChanged('name', (x: string, y: string) => x.substring(0, 3) === y.substring(0, 3))
 *     .subscribe(x => console.log(x));
 *
 * // displays:
 * // { age: 4, name: 'Foo1' }
 * // { age: 7, name: 'Bar' }
 * // { age: 5, name: 'Foo2' }
 *
 * @see {@link distinct}
 * @see {@link distinctUntilChanged}
 *
 * @param {string} key String key for object property lookup on each item.
 * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.
 * @return {Observable} An Observable that emits items from the source Observable with distinct values based on the key specified.
 * @method distinctUntilKeyChanged
 * @owner Observable
 */
function distinctUntilKeyChanged(key, compare) {
    return distinctUntilChanged_1.distinctUntilChanged.call(this, function (x, y) {
        if (compare) {
            return compare(x[key], y[key]);
        }
        return x[key] === y[key];
    });
}
exports.distinctUntilKeyChanged = distinctUntilKeyChanged;
//# sourceMappingURL=distinctUntilKeyChanged.js.map

/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(1);
/* tslint:enable:max-line-length */
/**
 * Perform a side effect for every emission on the source Observable, but return
 * an Observable that is identical to the source.
 *
 * <span class="informal">Intercepts each emission on the source and runs a
 * function, but returns an output which is identical to the source.</span>
 *
 * <img src="./img/do.png" width="100%">
 *
 * Returns a mirrored Observable of the source Observable, but modified so that
 * the provided Observer is called to perform a side effect for every value,
 * error, and completion emitted by the source. Any errors that are thrown in
 * the aforementioned Observer or handlers are safely sent down the error path
 * of the output Observable.
 *
 * This operator is useful for debugging your Observables for the correct values
 * or performing other side effects.
 *
 * Note: this is different to a `subscribe` on the Observable. If the Observable
 * returned by `do` is not subscribed, the side effects specified by the
 * Observer will never happen. `do` therefore simply spies on existing
 * execution, it does not trigger an execution to happen like `subscribe` does.
 *
 * @example <caption>Map every every click to the clientX position of that click, while also logging the click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks
 *   .do(ev => console.log(ev))
 *   .map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link map}
 * @see {@link subscribe}
 *
 * @param {Observer|function} [nextOrObserver] A normal Observer object or a
 * callback for `next`.
 * @param {function} [error] Callback for errors in the source.
 * @param {function} [complete] Callback for the completion of the source.
 * @return {Observable} An Observable identical to the source, but runs the
 * specified Observer or callback(s) for each item.
 * @method do
 * @name do
 * @owner Observable
 */
function _do(nextOrObserver, error, complete) {
    return this.lift(new DoOperator(nextOrObserver, error, complete));
}
exports._do = _do;
var DoOperator = (function () {
    function DoOperator(nextOrObserver, error, complete) {
        this.nextOrObserver = nextOrObserver;
        this.error = error;
        this.complete = complete;
    }
    DoOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
    };
    return DoOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DoSubscriber = (function (_super) {
    __extends(DoSubscriber, _super);
    function DoSubscriber(destination, nextOrObserver, error, complete) {
        _super.call(this, destination);
        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);
        safeSubscriber.syncErrorThrowable = true;
        this.add(safeSubscriber);
        this.safeSubscriber = safeSubscriber;
    }
    DoSubscriber.prototype._next = function (value) {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.next(value);
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        }
        else {
            this.destination.next(value);
        }
    };
    DoSubscriber.prototype._error = function (err) {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.error(err);
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        }
        else {
            this.destination.error(err);
        }
    };
    DoSubscriber.prototype._complete = function () {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.complete();
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        }
        else {
            this.destination.complete();
        }
    };
    return DoSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=do.js.map

/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(1);
var ArgumentOutOfRangeError_1 = __webpack_require__(23);
/**
 * Emits the single value at the specified `index` in a sequence of emissions
 * from the source Observable.
 *
 * <span class="informal">Emits only the i-th value, then completes.</span>
 *
 * <img src="./img/elementAt.png" width="100%">
 *
 * `elementAt` returns an Observable that emits the item at the specified
 * `index` in the source Observable, or a default value if that `index` is out
 * of range and the `default` argument is provided. If the `default` argument is
 * not given and the `index` is out of range, the output Observable will emit an
 * `ArgumentOutOfRangeError` error.
 *
 * @example <caption>Emit only the third click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.elementAt(2);
 * result.subscribe(x => console.log(x));
 *
 * // Results in:
 * // click 1 = nothing
 * // click 2 = nothing
 * // click 3 = MouseEvent object logged to console
 *
 * @see {@link first}
 * @see {@link last}
 * @see {@link skip}
 * @see {@link single}
 * @see {@link take}
 *
 * @throws {ArgumentOutOfRangeError} When using `elementAt(i)`, it delivers an
 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0` or the
 * Observable has completed before emitting the i-th `next` notification.
 *
 * @param {number} index Is the number `i` for the i-th source emission that has
 * happened since the subscription, starting from the number `0`.
 * @param {T} [defaultValue] The default value returned for missing indices.
 * @return {Observable} An Observable that emits a single item, if it is found.
 * Otherwise, will emit the default value if given. If not, then emits an error.
 * @method elementAt
 * @owner Observable
 */
function elementAt(index, defaultValue) {
    return this.lift(new ElementAtOperator(index, defaultValue));
}
exports.elementAt = elementAt;
var ElementAtOperator = (function () {
    function ElementAtOperator(index, defaultValue) {
        this.index = index;
        this.defaultValue = defaultValue;
        if (index < 0) {
            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
        }
    }
    ElementAtOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ElementAtSubscriber(subscriber, this.index, this.defaultValue));
    };
    return ElementAtOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ElementAtSubscriber = (function (_super) {
    __extends(ElementAtSubscriber, _super);
    function ElementAtSubscriber(destination, index, defaultValue) {
        _super.call(this, destination);
        this.index = index;
        this.defaultValue = defaultValue;
    }
    ElementAtSubscriber.prototype._next = function (x) {
        if (this.index-- === 0) {
            this.destination.next(x);
            this.destination.complete();
        }
    };
    ElementAtSubscriber.prototype._complete = function () {
        var destination = this.destination;
        if (this.index >= 0) {
            if (typeof this.defaultValue !== 'undefined') {
                destination.next(this.defaultValue);
            }
            else {
                destination.error(new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError);
            }
        }
        destination.complete();
    };
    return ElementAtSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=elementAt.js.map

/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(1);
/**
 * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.
 *
 * @example <caption>A simple example emitting true if all elements are less than 5, false otherwise</caption>
 *  Observable.of(1, 2, 3, 4, 5, 6)
 *     .every(x => x < 5)
 *     .subscribe(x => console.log(x)); // -> false
 *
 * @param {function} predicate A function for determining if an item meets a specified condition.
 * @param {any} [thisArg] Optional object to use for `this` in the callback.
 * @return {Observable} An Observable of booleans that determines if all items of the source Observable meet the condition specified.
 * @method every
 * @owner Observable
 */
function every(predicate, thisArg) {
    return this.lift(new EveryOperator(predicate, thisArg, this));
}
exports.every = every;
var EveryOperator = (function () {
    function EveryOperator(predicate, thisArg, source) {
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.source = source;
    }
    EveryOperator.prototype.call = function (observer, source) {
        return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));
    };
    return EveryOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var EverySubscriber = (function (_super) {
    __extends(EverySubscriber, _super);
    function EverySubscriber(destination, predicate, thisArg, source) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.source = source;
        this.index = 0;
        this.thisArg = thisArg || this;
    }
    EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {
        this.destination.next(everyValueMatch);
        this.destination.complete();
    };
    EverySubscriber.prototype._next = function (value) {
        var result = false;
        try {
            result = this.predicate.call(this.thisArg, value, this.index++, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (!result) {
            this.notifyComplete(false);
        }
    };
    EverySubscriber.prototype._complete = function () {
        this.notifyComplete(true);
    };
    return EverySubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=every.js.map

/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(2);
var subscribeToResult_1 = __webpack_require__(3);
/**
 * Converts a higher-order Observable into a first-order Observable by dropping
 * inner Observables while the previous inner Observable has not yet completed.
 *
 * <span class="informal">Flattens an Observable-of-Observables by dropping the
 * next inner Observables while the current inner is still executing.</span>
 *
 * <img src="./img/exhaust.png" width="100%">
 *
 * `exhaust` subscribes to an Observable that emits Observables, also known as a
 * higher-order Observable. Each time it observes one of these emitted inner
 * Observables, the output Observable begins emitting the items emitted by that
 * inner Observable. So far, it behaves like {@link mergeAll}. However,
 * `exhaust` ignores every new inner Observable if the previous Observable has
 * not yet completed. Once that one completes, it will accept and flatten the
 * next inner Observable and repeat this process.
 *
 * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
 * var result = higherOrder.exhaust();
 * result.subscribe(x => console.log(x));
 *
 * @see {@link combineAll}
 * @see {@link concatAll}
 * @see {@link switch}
 * @see {@link mergeAll}
 * @see {@link exhaustMap}
 * @see {@link zipAll}
 *
 * @return {Observable} An Observable that takes a source of Observables and propagates the first observable
 * exclusively until it completes before subscribing to the next.
 * @method exhaust
 * @owner Observable
 */
function exhaust() {
    return this.lift(new SwitchFirstOperator());
}
exports.exhaust = exhaust;
var SwitchFirstOperator = (function () {
    function SwitchFirstOperator() {
    }
    SwitchFirstOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchFirstSubscriber(subscriber));
    };
    return SwitchFirstOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchFirstSubscriber = (function (_super) {
    __extends(SwitchFirstSubscriber, _super);
    function SwitchFirstSubscriber(destination) {
        _super.call(this, destination);
        this.hasCompleted = false;
        this.hasSubscription = false;
    }
    SwitchFirstSubscriber.prototype._next = function (value) {
        if (!this.hasSubscription) {
            this.hasSubscription = true;
            this.add(subscribeToResult_1.subscribeToResult(this, value));
        }
    };
    SwitchFirstSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
            this.destination.complete();
        }
    };
    SwitchFirstSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.hasSubscription = false;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };
    return SwitchFirstSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=exhaust.js.map

/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(2);
var subscribeToResult_1 = __webpack_require__(3);
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable only if the previous projected Observable has completed.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link exhaust}.</span>
 *
 * <img src="./img/exhaustMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. When it projects a source value to
 * an Observable, the output Observable begins emitting the items emitted by
 * that projected Observable. However, `exhaustMap` ignores every new projected
 * Observable if the previous projected Observable has not yet completed. Once
 * that one completes, it will accept and flatten the next projected Observable
 * and repeat this process.
 *
 * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.exhaustMap((ev) => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMap}
 * @see {@link exhaust}
 * @see {@link mergeMap}
 * @see {@link switchMap}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable containing projected Observables
 * of each item of the source, ignoring projected Observables that start before
 * their preceding Observable has completed.
 * @method exhaustMap
 * @owner Observable
 */
function exhaustMap(project, resultSelector) {
    return this.lift(new SwitchFirstMapOperator(project, resultSelector));
}
exports.exhaustMap = exhaustMap;
var SwitchFirstMapOperator = (function () {
    function SwitchFirstMapOperator(project, resultSelector) {
        this.project = project;
        this.resultSelector = resultSelector;
    }
    SwitchFirstMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchFirstMapSubscriber(subscriber, this.project, this.resultSelector));
    };
    return SwitchFirstMapOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchFirstMapSubscriber = (function (_super) {
    __extends(SwitchFirstMapSubscriber, _super);
    function SwitchFirstMapSubscriber(destination, project, resultSelector) {
        _super.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.hasSubscription = false;
        this.hasCompleted = false;
        this.index = 0;
    }
    SwitchFirstMapSubscriber.prototype._next = function (value) {
        if (!this.hasSubscription) {
            this.tryNext(value);
        }
    };
    SwitchFirstMapSubscriber.prototype.tryNext = function (value) {
        var index = this.index++;
        var destination = this.destination;
        try {
            var result = this.project(value, index);
            this.hasSubscription = true;
            this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));
        }
        catch (err) {
            destination.error(err);
        }
    };
    SwitchFirstMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
            this.destination.complete();
        }
    };
    SwitchFirstMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
        if (resultSelector) {
            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);
        }
        else {
            destination.next(innerValue);
        }
    };
    SwitchFirstMapSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {
        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
        try {
            var result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);
            destination.next(result);
        }
        catch (err) {
            destination.error(err);
        }
    };
    SwitchFirstMapSubscriber.prototype.notifyError = function (err) {
        this.destination.error(err);
    };
    SwitchFirstMapSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.hasSubscription = false;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };
    return SwitchFirstMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=exhaustMap.js.map

/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var tryCatch_1 = __webpack_require__(8);
var errorObject_1 = __webpack_require__(6);
var OuterSubscriber_1 = __webpack_require__(2);
var subscribeToResult_1 = __webpack_require__(3);
/* tslint:enable:max-line-length */
/**
 * Recursively projects each source value to an Observable which is merged in
 * the output Observable.
 *
 * <span class="informal">It's similar to {@link mergeMap}, but applies the
 * projection function to every source value as well as every output value.
 * It's recursive.</span>
 *
 * <img src="./img/expand.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an Observable, and then merging those resulting Observables and
 * emitting the results of this merger. *Expand* will re-emit on the output
 * Observable every source value. Then, each output value is given to the
 * `project` function which returns an inner Observable to be merged on the
 * output Observable. Those output values resulting from the projection are also
 * given to the `project` function to produce new output values. This is how
 * *expand* behaves recursively.
 *
 * @example <caption>Start emitting the powers of two on every click, at most 10 of them</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var powersOfTwo = clicks
 *   .mapTo(1)
 *   .expand(x => Rx.Observable.of(2 * x).delay(1000))
 *   .take(10);
 * powersOfTwo.subscribe(x => console.log(x));
 *
 * @see {@link mergeMap}
 * @see {@link mergeScan}
 *
 * @param {function(value: T, index: number) => Observable} project A function
 * that, when applied to an item emitted by the source or the output Observable,
 * returns an Observable.
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to
 * each projected inner Observable.
 * @return {Observable} An Observable that emits the source values and also
 * result of applying the projection function to each value emitted on the
 * output Observable and and merging the results of the Observables obtained
 * from this transformation.
 * @method expand
 * @owner Observable
 */
function expand(project, concurrent, scheduler) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    if (scheduler === void 0) { scheduler = undefined; }
    concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;
    return this.lift(new ExpandOperator(project, concurrent, scheduler));
}
exports.expand = expand;
var ExpandOperator = (function () {
    function ExpandOperator(project, concurrent, scheduler) {
        this.project = project;
        this.concurrent = concurrent;
        this.scheduler = scheduler;
    }
    ExpandOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));
    };
    return ExpandOperator;
}());
exports.ExpandOperator = ExpandOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ExpandSubscriber = (function (_super) {
    __extends(ExpandSubscriber, _super);
    function ExpandSubscriber(destination, project, concurrent, scheduler) {
        _super.call(this, destination);
        this.project = project;
        this.concurrent = concurrent;
        this.scheduler = scheduler;
        this.index = 0;
        this.active = 0;
        this.hasCompleted = false;
        if (concurrent < Number.POSITIVE_INFINITY) {
            this.buffer = [];
        }
    }
    ExpandSubscriber.dispatch = function (arg) {
        var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;
        subscriber.subscribeToProjection(result, value, index);
    };
    ExpandSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        if (destination.closed) {
            this._complete();
            return;
        }
        var index = this.index++;
        if (this.active < this.concurrent) {
            destination.next(value);
            var result = tryCatch_1.tryCatch(this.project)(value, index);
            if (result === errorObject_1.errorObject) {
                destination.error(errorObject_1.errorObject.e);
            }
            else if (!this.scheduler) {
                this.subscribeToProjection(result, value, index);
            }
            else {
                var state = { subscriber: this, result: result, value: value, index: index };
                this.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));
            }
        }
        else {
            this.buffer.push(value);
        }
    };
    ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {
        this.active++;
        this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));
    };
    ExpandSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
    };
    ExpandSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this._next(innerValue);
    };
    ExpandSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer && buffer.length > 0) {
            this._next(buffer.shift());
        }
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
    };
    return ExpandSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.ExpandSubscriber = ExpandSubscriber;
//# sourceMappingURL=expand.js.map

/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(1);
var Subscription_1 = __webpack_require__(4);
/**
 * Returns an Observable that mirrors the source Observable, but will call a specified function when
 * the source terminates on complete or error.
 * @param {function} callback Function to be called when source terminates.
 * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.
 * @method finally
 * @owner Observable
 */
function _finally(callback) {
    return this.lift(new FinallyOperator(callback));
}
exports._finally = _finally;
var FinallyOperator = (function () {
    function FinallyOperator(callback) {
        this.callback = callback;
    }
    FinallyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FinallySubscriber(subscriber, this.callback));
    };
    return FinallyOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FinallySubscriber = (function (_super) {
    __extends(FinallySubscriber, _super);
    function FinallySubscriber(destination, callback) {
        _super.call(this, destination);
        this.add(new Subscription_1.Subscription(callback));
    }
    return FinallySubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=finally.js.map

/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var find_1 = __webpack_require__(47);
/**
 * Emits only the index of the first value emitted by the source Observable that
 * meets some condition.
 *
 * <span class="informal">It's like {@link find}, but emits the index of the
 * found value, not the value itself.</span>
 *
 * <img src="./img/findIndex.png" width="100%">
 *
 * `findIndex` searches for the first item in the source Observable that matches
 * the specified condition embodied by the `predicate`, and returns the
 * (zero-based) index of the first occurrence in the source. Unlike
 * {@link first}, the `predicate` is required in `findIndex`, and does not emit
 * an error if a valid value is not found.
 *
 * @example <caption>Emit the index of first click that happens on a DIV element</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.findIndex(ev => ev.target.tagName === 'DIV');
 * result.subscribe(x => console.log(x));
 *
 * @see {@link filter}
 * @see {@link find}
 * @see {@link first}
 * @see {@link take}
 *
 * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate
 * A function called with each item to test for condition matching.
 * @param {any} [thisArg] An optional argument to determine the value of `this`
 * in the `predicate` function.
 * @return {Observable} An Observable of the index of the first item that
 * matches the condition.
 * @method find
 * @owner Observable
 */
function findIndex(predicate, thisArg) {
    return this.lift(new find_1.FindValueOperator(predicate, this, true, thisArg));
}
exports.findIndex = findIndex;
//# sourceMappingURL=findIndex.js.map

/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(1);
var EmptyError_1 = __webpack_require__(24);
/**
 * Emits only the first value (or the first value that meets some condition)
 * emitted by the source Observable.
 *
 * <span class="informal">Emits only the first value. Or emits only the first
 * value that passes some test.</span>
 *
 * <img src="./img/first.png" width="100%">
 *
 * If called with no arguments, `first` emits the first value of the source
 * Observable, then completes. If called with a `predicate` function, `first`
 * emits the first value of the source that matches the specified condition. It
 * may also take a `resultSelector` function to produce the output value from
 * the input value, and a `defaultValue` to emit in case the source completes
 * before it is able to emit a valid value. Throws an error if `defaultValue`
 * was not provided and a matching element is not found.
 *
 * @example <caption>Emit only the first click that happens on the DOM</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.first();
 * result.subscribe(x => console.log(x));
 *
 * @example <caption>Emits the first click that happens on a DIV</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.first(ev => ev.target.tagName === 'DIV');
 * result.subscribe(x => console.log(x));
 *
 * @see {@link filter}
 * @see {@link find}
 * @see {@link take}
 *
 * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
 * callback if the Observable completes before any `next` notification was sent.
 *
 * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]
 * An optional function called with each item to test for condition matching.
 * @param {function(value: T, index: number): R} [resultSelector] A function to
 * produce the value on the output Observable based on the values
 * and the indices of the source Observable. The arguments passed to this
 * function are:
 * - `value`: the value that was emitted on the source.
 * - `index`: the "index" of the value from the source.
 * @param {R} [defaultValue] The default value emitted in case no valid value
 * was found on the source.
 * @return {Observable<T|R>} An Observable of the first item that matches the
 * condition.
 * @method first
 * @owner Observable
 */
function first(predicate, resultSelector, defaultValue) {
    return this.lift(new FirstOperator(predicate, resultSelector, defaultValue, this));
}
exports.first = first;
var FirstOperator = (function () {
    function FirstOperator(predicate, resultSelector, defaultValue, source) {
        this.predicate = predicate;
        this.resultSelector = resultSelector;
        this.defaultValue = defaultValue;
        this.source = source;
    }
    FirstOperator.prototype.call = function (observer, source) {
        return source.subscribe(new FirstSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));
    };
    return FirstOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FirstSubscriber = (function (_super) {
    __extends(FirstSubscriber, _super);
    function FirstSubscriber(destination, predicate, resultSelector, defaultValue, source) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.resultSelector = resultSelector;
        this.defaultValue = defaultValue;
        this.source = source;
        this.index = 0;
        this.hasCompleted = false;
        this._emitted = false;
    }
    FirstSubscriber.prototype._next = function (value) {
        var index = this.index++;
        if (this.predicate) {
            this._tryPredicate(value, index);
        }
        else {
            this._emit(value, index);
        }
    };
    FirstSubscriber.prototype._tryPredicate = function (value, index) {
        var result;
        try {
            result = this.predicate(value, index, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this._emit(value, index);
        }
    };
    FirstSubscriber.prototype._emit = function (value, index) {
        if (this.resultSelector) {
            this._tryResultSelector(value, index);
            return;
        }
        this._emitFinal(value);
    };
    FirstSubscriber.prototype._tryResultSelector = function (value, index) {
        var result;
        try {
            result = this.resultSelector(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this._emitFinal(result);
    };
    FirstSubscriber.prototype._emitFinal = function (value) {
        var destination = this.destination;
        if (!this._emitted) {
            this._emitted = true;
            destination.next(value);
            destination.complete();
            this.hasCompleted = true;
        }
    };
    FirstSubscriber.prototype._complete = function () {
        var destination = this.destination;
        if (!this.hasCompleted && typeof this.defaultValue !== 'undefined') {
            destination.next(this.defaultValue);
            destination.complete();
        }
        else if (!this.hasCompleted) {
            destination.error(new EmptyError_1.EmptyError);
        }
    };
    return FirstSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=first.js.map

/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(1);
var Subscription_1 = __webpack_require__(4);
var Observable_1 = __webpack_require__(0);
var Subject_1 = __webpack_require__(5);
var Map_1 = __webpack_require__(347);
var FastMap_1 = __webpack_require__(345);
/* tslint:enable:max-line-length */
/**
 * Groups the items emitted by an Observable according to a specified criterion,
 * and emits these grouped items as `GroupedObservables`, one
 * {@link GroupedObservable} per group.
 *
 * <img src="./img/groupBy.png" width="100%">
 *
 * @param {function(value: T): K} keySelector A function that extracts the key
 * for each item.
 * @param {function(value: T): R} [elementSelector] A function that extracts the
 * return element for each item.
 * @param {function(grouped: GroupedObservable<K,R>): Observable<any>} [durationSelector]
 * A function that returns an Observable to determine how long each group should
 * exist.
 * @return {Observable<GroupedObservable<K,R>>} An Observable that emits
 * GroupedObservables, each of which corresponds to a unique key value and each
 * of which emits those items from the source Observable that share that key
 * value.
 * @method groupBy
 * @owner Observable
 */
function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {
    return this.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
}
exports.groupBy = groupBy;
var GroupByOperator = (function () {
    function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {
        this.keySelector = keySelector;
        this.elementSelector = elementSelector;
        this.durationSelector = durationSelector;
        this.subjectSelector = subjectSelector;
    }
    GroupByOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
    };
    return GroupByOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var GroupBySubscriber = (function (_super) {
    __extends(GroupBySubscriber, _super);
    function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
        _super.call(this, destination);
        this.keySelector = keySelector;
        this.elementSelector = elementSelector;
        this.durationSelector = durationSelector;
        this.subjectSelector = subjectSelector;
        this.groups = null;
        this.attemptedToUnsubscribe = false;
        this.count = 0;
    }
    GroupBySubscriber.prototype._next = function (value) {
        var key;
        try {
            key = this.keySelector(value);
        }
        catch (err) {
            this.error(err);
            return;
        }
        this._group(value, key);
    };
    GroupBySubscriber.prototype._group = function (value, key) {
        var groups = this.groups;
        if (!groups) {
            groups = this.groups = typeof key === 'string' ? new FastMap_1.FastMap() : new Map_1.Map();
        }
        var group = groups.get(key);
        var element;
        if (this.elementSelector) {
            try {
                element = this.elementSelector(value);
            }
            catch (err) {
                this.error(err);
            }
        }
        else {
            element = value;
        }
        if (!group) {
            group = this.subjectSelector ? this.subjectSelector() : new Subject_1.Subject();
            groups.set(key, group);
            var groupedObservable = new GroupedObservable(key, group, this);
            this.destination.next(groupedObservable);
            if (this.durationSelector) {
                var duration = void 0;
                try {
                    duration = this.durationSelector(new GroupedObservable(key, group));
                }
                catch (err) {
                    this.error(err);
                    return;
                }
                this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
            }
        }
        if (!group.closed) {
            group.next(element);
        }
    };
    GroupBySubscriber.prototype._error = function (err) {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.error(err);
            });
            groups.clear();
        }
        this.destination.error(err);
    };
    GroupBySubscriber.prototype._complete = function () {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.complete();
            });
            groups.clear();
        }
        this.destination.complete();
    };
    GroupBySubscriber.prototype.removeGroup = function (key) {
        this.groups.delete(key);
    };
    GroupBySubscriber.prototype.unsubscribe = function () {
        if (!this.closed) {
            this.attemptedToUnsubscribe = true;
            if (this.count === 0) {
                _super.prototype.unsubscribe.call(this);
            }
        }
    };
    return GroupBySubscriber;
}(Subscriber_1.Subscriber));
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var GroupDurationSubscriber = (function (_super) {
    __extends(GroupDurationSubscriber, _super);
    function GroupDurationSubscriber(key, group, parent) {
        _super.call(this);
        this.key = key;
        this.group = group;
        this.parent = parent;
    }
    GroupDurationSubscriber.prototype._next = function (value) {
        this._complete();
    };
    GroupDurationSubscriber.prototype._error = function (err) {
        var group = this.group;
        if (!group.closed) {
            group.error(err);
        }
        this.parent.removeGroup(this.key);
    };
    GroupDurationSubscriber.prototype._complete = function () {
        var group = this.group;
        if (!group.closed) {
            group.complete();
        }
        this.parent.removeGroup(this.key);
    };
    return GroupDurationSubscriber;
}(Subscriber_1.Subscriber));
/**
 * An Observable representing values belonging to the same group represented by
 * a common key. The values emitted by a GroupedObservable come from the source
 * Observable. The common key is available as the field `key` on a
 * GroupedObservable instance.
 *
 * @class GroupedObservable<K, T>
 */
var GroupedObservable = (function (_super) {
    __extends(GroupedObservable, _super);
    function GroupedObservable(key, groupSubject, refCountSubscription) {
        _super.call(this);
        this.key = key;
        this.groupSubject = groupSubject;
        this.refCountSubscription = refCountSubscription;
    }
    GroupedObservable.prototype._subscribe = function (subscriber) {
        var subscription = new Subscription_1.Subscription();
        var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;
        if (refCountSubscription && !refCountSubscription.closed) {
            subscription.add(new InnerRefCountSubscription(refCountSubscription));
        }
        subscription.add(groupSubject.subscribe(subscriber));
        return subscription;
    };
    return GroupedObservable;
}(Observable_1.Observable));
exports.GroupedObservable = GroupedObservable;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var InnerRefCountSubscription = (function (_super) {
    __extends(InnerRefCountSubscription, _super);
    function InnerRefCountSubscription(parent) {
        _super.call(this);
        this.parent = parent;
        parent.count++;
    }
    InnerRefCountSubscription.prototype.unsubscribe = function () {
        var parent = this.parent;
        if (!parent.closed && !this.closed) {
            _super.prototype.unsubscribe.call(this);
            parent.count -= 1;
            if (parent.count === 0 && parent.attemptedToUnsubscribe) {
                parent.unsubscribe();
            }
        }
    };
    return InnerRefCountSubscription;
}(Subscription_1.Subscription));
//# sourceMappingURL=groupBy.js.map

/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(1);
var noop_1 = __webpack_require__(66);
/**
 * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.
 *
 * <img src="./img/ignoreElements.png" width="100%">
 *
 * @return {Observable} An empty Observable that only calls `complete`
 * or `error`, based on which one is called by the source Observable.
 * @method ignoreElements
 * @owner Observable
 */
function ignoreElements() {
    return this.lift(new IgnoreElementsOperator());
}
exports.ignoreElements = ignoreElements;
;
var IgnoreElementsOperator = (function () {
    function IgnoreElementsOperator() {
    }
    IgnoreElementsOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new IgnoreElementsSubscriber(subscriber));
    };
    return IgnoreElementsOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var IgnoreElementsSubscriber = (function (_super) {
    __extends(IgnoreElementsSubscriber, _super);
    function IgnoreElementsSubscriber() {
        _super.apply(this, arguments);
    }
    IgnoreElementsSubscriber.prototype._next = function (unused) {
        noop_1.noop();
    };
    return IgnoreElementsSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=ignoreElements.js.map

/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(1);
/**
 * If the source Observable is empty it returns an Observable that emits true, otherwise it emits false.
 *
 * <img src="./img/isEmpty.png" width="100%">
 *
 * @return {Observable} An Observable that emits a Boolean.
 * @method isEmpty
 * @owner Observable
 */
function isEmpty() {
    return this.lift(new IsEmptyOperator());
}
exports.isEmpty = isEmpty;
var IsEmptyOperator = (function () {
    function IsEmptyOperator() {
    }
    IsEmptyOperator.prototype.call = function (observer, source) {
        return source.subscribe(new IsEmptySubscriber(observer));
    };
    return IsEmptyOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var IsEmptySubscriber = (function (_super) {
    __extends(IsEmptySubscriber, _super);
    function IsEmptySubscriber(destination) {
        _super.call(this, destination);
    }
    IsEmptySubscriber.prototype.notifyComplete = function (isEmpty) {
        var destination = this.destination;
        destination.next(isEmpty);
        destination.complete();
    };
    IsEmptySubscriber.prototype._next = function (value) {
        this.notifyComplete(false);
    };
    IsEmptySubscriber.prototype._complete = function () {
        this.notifyComplete(true);
    };
    return IsEmptySubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=isEmpty.js.map

/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(1);
var EmptyError_1 = __webpack_require__(24);
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits only the last item emitted by the source Observable.
 * It optionally takes a predicate function as a parameter, in which case, rather than emitting
 * the last item from the source Observable, the resulting Observable will emit the last item
 * from the source Observable that satisfies the predicate.
 *
 * <img src="./img/last.png" width="100%">
 *
 * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
 * callback if the Observable completes before any `next` notification was sent.
 * @param {function} predicate - The condition any source emitted item has to satisfy.
 * @return {Observable} An Observable that emits only the last item satisfying the given condition
 * from the source, or an NoSuchElementException if no such items are emitted.
 * @throws - Throws if no items that match the predicate are emitted by the source Observable.
 * @method last
 * @owner Observable
 */
function last(predicate, resultSelector, defaultValue) {
    return this.lift(new LastOperator(predicate, resultSelector, defaultValue, this));
}
exports.last = last;
var LastOperator = (function () {
    function LastOperator(predicate, resultSelector, defaultValue, source) {
        this.predicate = predicate;
        this.resultSelector = resultSelector;
        this.defaultValue = defaultValue;
        this.source = source;
    }
    LastOperator.prototype.call = function (observer, source) {
        return source.subscribe(new LastSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));
    };
    return LastOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var LastSubscriber = (function (_super) {
    __extends(LastSubscriber, _super);
    function LastSubscriber(destination, predicate, resultSelector, defaultValue, source) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.resultSelector = resultSelector;
        this.defaultValue = defaultValue;
        this.source = source;
        this.hasValue = false;
        this.index = 0;
        if (typeof defaultValue !== 'undefined') {
            this.lastValue = defaultValue;
            this.hasValue = true;
        }
    }
    LastSubscriber.prototype._next = function (value) {
        var index = this.index++;
        if (this.predicate) {
            this._tryPredicate(value, index);
        }
        else {
            if (this.resultSelector) {
                this._tryResultSelector(value, index);
                return;
            }
            this.lastValue = value;
            this.hasValue = true;
        }
    };
    LastSubscriber.prototype._tryPredicate = function (value, index) {
        var result;
        try {
            result = this.predicate(value, index, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            if (this.resultSelector) {
                this._tryResultSelector(value, index);
                return;
            }
            this.lastValue = value;
            this.hasValue = true;
        }
    };
    LastSubscriber.prototype._tryResultSelector = function (value, index) {
        var result;
        try {
            result = this.resultSelector(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.lastValue = result;
        this.hasValue = true;
    };
    LastSubscriber.prototype._complete = function () {
        var destination = this.destination;
        if (this.hasValue) {
            destination.next(this.lastValue);
            destination.complete();
        }
        else {
            destination.error(new EmptyError_1.EmptyError);
        }
    };
    return LastSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=last.js.map

/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @param func
 * @return {Observable<R>}
 * @method let
 * @owner Observable
 */
function letProto(func) {
    return func(this);
}
exports.letProto = letProto;
//# sourceMappingURL=let.js.map

/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(1);
/**
 * Emits the given constant value on the output Observable every time the source
 * Observable emits a value.
 *
 * <span class="informal">Like {@link map}, but it maps every source value to
 * the same output value every time.</span>
 *
 * <img src="./img/mapTo.png" width="100%">
 *
 * Takes a constant `value` as argument, and emits that whenever the source
 * Observable emits a value. In other words, ignores the actual source value,
 * and simply uses the emission moment to know when to emit the given `value`.
 *
 * @example <caption>Map every every click to the string 'Hi'</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var greetings = clicks.mapTo('Hi');
 * greetings.subscribe(x => console.log(x));
 *
 * @see {@link map}
 *
 * @param {any} value The value to map each source value to.
 * @return {Observable} An Observable that emits the given `value` every time
 * the source Observable emits something.
 * @method mapTo
 * @owner Observable
 */
function mapTo(value) {
    return this.lift(new MapToOperator(value));
}
exports.mapTo = mapTo;
var MapToOperator = (function () {
    function MapToOperator(value) {
        this.value = value;
    }
    MapToOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapToSubscriber(subscriber, this.value));
    };
    return MapToOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MapToSubscriber = (function (_super) {
    __extends(MapToSubscriber, _super);
    function MapToSubscriber(destination, value) {
        _super.call(this, destination);
        this.value = value;
    }
    MapToSubscriber.prototype._next = function (x) {
        this.destination.next(this.value);
    };
    return MapToSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=mapTo.js.map

/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(1);
var Notification_1 = __webpack_require__(15);
/**
 * Represents all of the notifications from the source Observable as `next`
 * emissions marked with their original types within {@link Notification}
 * objects.
 *
 * <span class="informal">Wraps `next`, `error` and `complete` emissions in
 * {@link Notification} objects, emitted as `next` on the output Observable.
 * </span>
 *
 * <img src="./img/materialize.png" width="100%">
 *
 * `materialize` returns an Observable that emits a `next` notification for each
 * `next`, `error`, or `complete` emission of the source Observable. When the
 * source Observable emits `complete`, the output Observable will emit `next` as
 * a Notification of type "complete", and then it will emit `complete` as well.
 * When the source Observable emits `error`, the output will emit `next` as a
 * Notification of type "error", and then `complete`.
 *
 * This operator is useful for producing metadata of the source Observable, to
 * be consumed as `next` emissions. Use it in conjunction with
 * {@link dematerialize}.
 *
 * @example <caption>Convert a faulty Observable to an Observable of Notifications</caption>
 * var letters = Rx.Observable.of('a', 'b', 13, 'd');
 * var upperCase = letters.map(x => x.toUpperCase());
 * var materialized = upperCase.materialize();
 * materialized.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // - Notification {kind: "N", value: "A", error: undefined, hasValue: true}
 * // - Notification {kind: "N", value: "B", error: undefined, hasValue: true}
 * // - Notification {kind: "E", value: undefined, error: TypeError:
 * //   x.toUpperCase is not a function at MapSubscriber.letters.map.x
 * //   [as project] (http://1, hasValue: false}
 *
 * @see {@link Notification}
 * @see {@link dematerialize}
 *
 * @return {Observable<Notification<T>>} An Observable that emits
 * {@link Notification} objects that wrap the original emissions from the source
 * Observable with metadata.
 * @method materialize
 * @owner Observable
 */
function materialize() {
    return this.lift(new MaterializeOperator());
}
exports.materialize = materialize;
var MaterializeOperator = (function () {
    function MaterializeOperator() {
    }
    MaterializeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MaterializeSubscriber(subscriber));
    };
    return MaterializeOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MaterializeSubscriber = (function (_super) {
    __extends(MaterializeSubscriber, _super);
    function MaterializeSubscriber(destination) {
        _super.call(this, destination);
    }
    MaterializeSubscriber.prototype._next = function (value) {
        this.destination.next(Notification_1.Notification.createNext(value));
    };
    MaterializeSubscriber.prototype._error = function (err) {
        var destination = this.destination;
        destination.next(Notification_1.Notification.createError(err));
        destination.complete();
    };
    MaterializeSubscriber.prototype._complete = function () {
        var destination = this.destination;
        destination.next(Notification_1.Notification.createComplete());
        destination.complete();
    };
    return MaterializeSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=materialize.js.map

/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var reduce_1 = __webpack_require__(35);
/**
 * The Max operator operates on an Observable that emits numbers (or items that can be compared with a provided function),
 * and when source Observable completes it emits a single item: the item with the largest value.
 *
 * <img src="./img/max.png" width="100%">
 *
 * @example <caption>Get the maximal value of a series of numbers</caption>
 * Rx.Observable.of(5, 4, 7, 2, 8)
 *   .max()
 *   .subscribe(x => console.log(x)); // -> 8
 *
 * @example <caption>Use a comparer function to get the maximal item</caption>
 * interface Person {
 *   age: number,
 *   name: string
 * }
 * Observable.of<Person>({age: 7, name: 'Foo'},
 *                       {age: 5, name: 'Bar'},
 *                       {age: 9, name: 'Beer'})
 *           .max<Person>((a: Person, b: Person) => a.age < b.age ? -1 : 1)
 *           .subscribe((x: Person) => console.log(x.name)); // -> 'Beer'
 * }
 *
 * @see {@link min}
 *
 * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the
 * value of two items.
 * @return {Observable} An Observable that emits item with the largest value.
 * @method max
 * @owner Observable
 */
function max(comparer) {
    var max = (typeof comparer === 'function')
        ? function (x, y) { return comparer(x, y) > 0 ? x : y; }
        : function (x, y) { return x > y ? x : y; };
    return this.lift(new reduce_1.ReduceOperator(max));
}
exports.max = max;
//# sourceMappingURL=max.js.map

/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var tryCatch_1 = __webpack_require__(8);
var errorObject_1 = __webpack_require__(6);
var subscribeToResult_1 = __webpack_require__(3);
var OuterSubscriber_1 = __webpack_require__(2);
/**
 * Applies an accumulator function over the source Observable where the
 * accumulator function itself returns an Observable, then each intermediate
 * Observable returned is merged into the output Observable.
 *
 * <span class="informal">It's like {@link scan}, but the Observables returned
 * by the accumulator are merged into the outer Observable.</span>
 *
 * @example <caption>Count the number of click events</caption>
 * const click$ = Rx.Observable.fromEvent(document, 'click');
 * const one$ = click$.mapTo(1);
 * const seed = 0;
 * const count$ = one$.mergeScan((acc, one) => Rx.Observable.of(acc + one), seed);
 * count$.subscribe(x => console.log(x));
 *
 * // Results:
 * 1
 * 2
 * 3
 * 4
 * // ...and so on for each click
 *
 * @param {function(acc: R, value: T): Observable<R>} accumulator
 * The accumulator function called on each source value.
 * @param seed The initial accumulation value.
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of
 * input Observables being subscribed to concurrently.
 * @return {Observable<R>} An observable of the accumulated values.
 * @method mergeScan
 * @owner Observable
 */
function mergeScan(accumulator, seed, concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    return this.lift(new MergeScanOperator(accumulator, seed, concurrent));
}
exports.mergeScan = mergeScan;
var MergeScanOperator = (function () {
    function MergeScanOperator(accumulator, seed, concurrent) {
        this.accumulator = accumulator;
        this.seed = seed;
        this.concurrent = concurrent;
    }
    MergeScanOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));
    };
    return MergeScanOperator;
}());
exports.MergeScanOperator = MergeScanOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MergeScanSubscriber = (function (_super) {
    __extends(MergeScanSubscriber, _super);
    function MergeScanSubscriber(destination, accumulator, acc, concurrent) {
        _super.call(this, destination);
        this.accumulator = accumulator;
        this.acc = acc;
        this.concurrent = concurrent;
        this.hasValue = false;
        this.hasCompleted = false;
        this.buffer = [];
        this.active = 0;
        this.index = 0;
    }
    MergeScanSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            var index = this.index++;
            var ish = tryCatch_1.tryCatch(this.accumulator)(this.acc, value);
            var destination = this.destination;
            if (ish === errorObject_1.errorObject) {
                destination.error(errorObject_1.errorObject.e);
            }
            else {
                this.active++;
                this._innerSub(ish, value, index);
            }
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeScanSubscriber.prototype._innerSub = function (ish, value, index) {
        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));
    };
    MergeScanSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            if (this.hasValue === false) {
                this.destination.next(this.acc);
            }
            this.destination.complete();
        }
    };
    MergeScanSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var destination = this.destination;
        this.acc = innerValue;
        this.hasValue = true;
        destination.next(innerValue);
    };
    MergeScanSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            if (this.hasValue === false) {
                this.destination.next(this.acc);
            }
            this.destination.complete();
        }
    };
    return MergeScanSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.MergeScanSubscriber = MergeScanSubscriber;
//# sourceMappingURL=mergeScan.js.map

/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var reduce_1 = __webpack_require__(35);
/**
 * The Min operator operates on an Observable that emits numbers (or items that can be compared with a provided function),
 * and when source Observable completes it emits a single item: the item with the smallest value.
 *
 * <img src="./img/min.png" width="100%">
 *
 * @example <caption>Get the minimal value of a series of numbers</caption>
 * Rx.Observable.of(5, 4, 7, 2, 8)
 *   .min()
 *   .subscribe(x => console.log(x)); // -> 2
 *
 * @example <caption>Use a comparer function to get the minimal item</caption>
 * interface Person {
 *   age: number,
 *   name: string
 * }
 * Observable.of<Person>({age: 7, name: 'Foo'},
 *                       {age: 5, name: 'Bar'},
 *                       {age: 9, name: 'Beer'})
 *           .min<Person>( (a: Person, b: Person) => a.age < b.age ? -1 : 1)
 *           .subscribe((x: Person) => console.log(x.name)); // -> 'Bar'
 * }
 *
 * @see {@link max}
 *
 * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the
 * value of two items.
 * @return {Observable<R>} An Observable that emits item with the smallest value.
 * @method min
 * @owner Observable
 */
function min(comparer) {
    var min = (typeof comparer === 'function')
        ? function (x, y) { return comparer(x, y) < 0 ? x : y; }
        : function (x, y) { return x < y ? x : y; };
    return this.lift(new reduce_1.ReduceOperator(min));
}
exports.min = min;
//# sourceMappingURL=min.js.map

/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(1);
/**
 * Groups pairs of consecutive emissions together and emits them as an array of
 * two values.
 *
 * <span class="informal">Puts the current value and previous value together as
 * an array, and emits that.</span>
 *
 * <img src="./img/pairwise.png" width="100%">
 *
 * The Nth emission from the source Observable will cause the output Observable
 * to emit an array [(N-1)th, Nth] of the previous and the current value, as a
 * pair. For this reason, `pairwise` emits on the second and subsequent
 * emissions from the source Observable, but not on the first emission, because
 * there is no previous value in that case.
 *
 * @example <caption>On every click (starting from the second), emit the relative distance to the previous click</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var pairs = clicks.pairwise();
 * var distance = pairs.map(pair => {
 *   var x0 = pair[0].clientX;
 *   var y0 = pair[0].clientY;
 *   var x1 = pair[1].clientX;
 *   var y1 = pair[1].clientY;
 *   return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));
 * });
 * distance.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferCount}
 *
 * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of
 * consecutive values from the source Observable.
 * @method pairwise
 * @owner Observable
 */
function pairwise() {
    return this.lift(new PairwiseOperator());
}
exports.pairwise = pairwise;
var PairwiseOperator = (function () {
    function PairwiseOperator() {
    }
    PairwiseOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new PairwiseSubscriber(subscriber));
    };
    return PairwiseOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var PairwiseSubscriber = (function (_super) {
    __extends(PairwiseSubscriber, _super);
    function PairwiseSubscriber(destination) {
        _super.call(this, destination);
        this.hasPrev = false;
    }
    PairwiseSubscriber.prototype._next = function (value) {
        if (this.hasPrev) {
            this.destination.next([this.prev, value]);
        }
        else {
            this.hasPrev = true;
        }
        this.prev = value;
    };
    return PairwiseSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=pairwise.js.map

/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var not_1 = __webpack_require__(351);
var filter_1 = __webpack_require__(46);
/**
 * Splits the source Observable into two, one with values that satisfy a
 * predicate, and another with values that don't satisfy the predicate.
 *
 * <span class="informal">It's like {@link filter}, but returns two Observables:
 * one like the output of {@link filter}, and the other with values that did not
 * pass the condition.</span>
 *
 * <img src="./img/partition.png" width="100%">
 *
 * `partition` outputs an array with two Observables that partition the values
 * from the source Observable through the given `predicate` function. The first
 * Observable in that array emits source values for which the predicate argument
 * returns true. The second Observable emits source values for which the
 * predicate returns false. The first behaves like {@link filter} and the second
 * behaves like {@link filter} with the predicate negated.
 *
 * @example <caption>Partition click events into those on DIV elements and those elsewhere</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var parts = clicks.partition(ev => ev.target.tagName === 'DIV');
 * var clicksOnDivs = parts[0];
 * var clicksElsewhere = parts[1];
 * clicksOnDivs.subscribe(x => console.log('DIV clicked: ', x));
 * clicksElsewhere.subscribe(x => console.log('Other clicked: ', x));
 *
 * @see {@link filter}
 *
 * @param {function(value: T, index: number): boolean} predicate A function that
 * evaluates each value emitted by the source Observable. If it returns `true`,
 * the value is emitted on the first Observable in the returned array, if
 * `false` the value is emitted on the second Observable in the array. The
 * `index` parameter is the number `i` for the i-th source emission that has
 * happened since the subscription, starting from the number `0`.
 * @param {any} [thisArg] An optional argument to determine the value of `this`
 * in the `predicate` function.
 * @return {[Observable<T>, Observable<T>]} An array with two Observables: one
 * with values that passed the predicate, and another with values that did not
 * pass the predicate.
 * @method partition
 * @owner Observable
 */
function partition(predicate, thisArg) {
    return [
        filter_1.filter.call(this, predicate, thisArg),
        filter_1.filter.call(this, not_1.not(predicate, thisArg))
    ];
}
exports.partition = partition;
//# sourceMappingURL=partition.js.map

/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var map_1 = __webpack_require__(33);
/**
 * Maps each source value (an object) to its specified nested property.
 *
 * <span class="informal">Like {@link map}, but meant only for picking one of
 * the nested properties of every emitted object.</span>
 *
 * <img src="./img/pluck.png" width="100%">
 *
 * Given a list of strings describing a path to an object property, retrieves
 * the value of a specified nested property from all values in the source
 * Observable. If a property can't be resolved, it will return `undefined` for
 * that value.
 *
 * @example <caption>Map every every click to the tagName of the clicked target element</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var tagNames = clicks.pluck('target', 'tagName');
 * tagNames.subscribe(x => console.log(x));
 *
 * @see {@link map}
 *
 * @param {...string} properties The nested properties to pluck from each source
 * value (an object).
 * @return {Observable} A new Observable of property values from the source values.
 * @method pluck
 * @owner Observable
 */
function pluck() {
    var properties = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        properties[_i - 0] = arguments[_i];
    }
    var length = properties.length;
    if (length === 0) {
        throw new Error('list of properties cannot be empty.');
    }
    return map_1.map.call(this, plucker(properties, length));
}
exports.pluck = pluck;
function plucker(props, length) {
    var mapper = function (x) {
        var currentProp = x;
        for (var i = 0; i < length; i++) {
            var p = currentProp[props[i]];
            if (typeof p !== 'undefined') {
                currentProp = p;
            }
            else {
                return undefined;
            }
        }
        return currentProp;
    };
    return mapper;
}
//# sourceMappingURL=pluck.js.map

/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Subject_1 = __webpack_require__(5);
var multicast_1 = __webpack_require__(14);
/* tslint:enable:max-line-length */
/**
 * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called
 * before it begins emitting items to those Observers that have subscribed to it.
 *
 * <img src="./img/publish.png" width="100%">
 *
 * @param {Function} [selector] - Optional selector function which can use the multicasted source sequence as many times
 * as needed, without causing multiple subscriptions to the source sequence.
 * Subscribers to the given source will receive all notifications of the source from the time of the subscription on.
 * @return A ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.
 * @method publish
 * @owner Observable
 */
function publish(selector) {
    return selector ? multicast_1.multicast.call(this, function () { return new Subject_1.Subject(); }, selector) :
        multicast_1.multicast.call(this, new Subject_1.Subject());
}
exports.publish = publish;
//# sourceMappingURL=publish.js.map

/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var BehaviorSubject_1 = __webpack_require__(38);
var multicast_1 = __webpack_require__(14);
/**
 * @param value
 * @return {ConnectableObservable<T>}
 * @method publishBehavior
 * @owner Observable
 */
function publishBehavior(value) {
    return multicast_1.multicast.call(this, new BehaviorSubject_1.BehaviorSubject(value));
}
exports.publishBehavior = publishBehavior;
//# sourceMappingURL=publishBehavior.js.map

/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var AsyncSubject_1 = __webpack_require__(19);
var multicast_1 = __webpack_require__(14);
/**
 * @return {ConnectableObservable<T>}
 * @method publishLast
 * @owner Observable
 */
function publishLast() {
    return multicast_1.multicast.call(this, new AsyncSubject_1.AsyncSubject());
}
exports.publishLast = publishLast;
//# sourceMappingURL=publishLast.js.map

/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ReplaySubject_1 = __webpack_require__(29);
var multicast_1 = __webpack_require__(14);
/**
 * @param bufferSize
 * @param windowTime
 * @param scheduler
 * @return {ConnectableObservable<T>}
 * @method publishReplay
 * @owner Observable
 */
function publishReplay(bufferSize, windowTime, scheduler) {
    if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }
    if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }
    return multicast_1.multicast.call(this, new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler));
}
exports.publishReplay = publishReplay;
//# sourceMappingURL=publishReplay.js.map

/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(1);
var EmptyObservable_1 = __webpack_require__(13);
/**
 * Returns an Observable that repeats the stream of items emitted by the source Observable at most count times.
 *
 * <img src="./img/repeat.png" width="100%">
 *
 * @param {number} [count] The number of times the source Observable items are repeated, a count of 0 will yield
 * an empty Observable.
 * @return {Observable} An Observable that repeats the stream of items emitted by the source Observable at most
 * count times.
 * @method repeat
 * @owner Observable
 */
function repeat(count) {
    if (count === void 0) { count = -1; }
    if (count === 0) {
        return new EmptyObservable_1.EmptyObservable();
    }
    else if (count < 0) {
        return this.lift(new RepeatOperator(-1, this));
    }
    else {
        return this.lift(new RepeatOperator(count - 1, this));
    }
}
exports.repeat = repeat;
var RepeatOperator = (function () {
    function RepeatOperator(count, source) {
        this.count = count;
        this.source = source;
    }
    RepeatOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
    };
    return RepeatOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var RepeatSubscriber = (function (_super) {
    __extends(RepeatSubscriber, _super);
    function RepeatSubscriber(destination, count, source) {
        _super.call(this, destination);
        this.count = count;
        this.source = source;
    }
    RepeatSubscriber.prototype.complete = function () {
        if (!this.isStopped) {
            var _a = this, source = _a.source, count = _a.count;
            if (count === 0) {
                return _super.prototype.complete.call(this);
            }
            else if (count > -1) {
                this.count = count - 1;
            }
            source.subscribe(this._unsubscribeAndRecycle());
        }
    };
    return RepeatSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=repeat.js.map

/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = __webpack_require__(5);
var tryCatch_1 = __webpack_require__(8);
var errorObject_1 = __webpack_require__(6);
var OuterSubscriber_1 = __webpack_require__(2);
var subscribeToResult_1 = __webpack_require__(3);
/**
 * Returns an Observable that mirrors the source Observable with the exception of a `complete`. If the source
 * Observable calls `complete`, this method will emit to the Observable returned from `notifier`. If that Observable
 * calls `complete` or `error`, then this method will call `complete` or `error` on the child subscription. Otherwise
 * this method will resubscribe to the source Observable.
 *
 * <img src="./img/repeatWhen.png" width="100%">
 *
 * @param {function(notifications: Observable): Observable} notifier - Receives an Observable of notifications with
 * which a user can `complete` or `error`, aborting the repetition.
 * @return {Observable} The source Observable modified with repeat logic.
 * @method repeatWhen
 * @owner Observable
 */
function repeatWhen(notifier) {
    return this.lift(new RepeatWhenOperator(notifier));
}
exports.repeatWhen = repeatWhen;
var RepeatWhenOperator = (function () {
    function RepeatWhenOperator(notifier) {
        this.notifier = notifier;
    }
    RepeatWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));
    };
    return RepeatWhenOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var RepeatWhenSubscriber = (function (_super) {
    __extends(RepeatWhenSubscriber, _super);
    function RepeatWhenSubscriber(destination, notifier, source) {
        _super.call(this, destination);
        this.notifier = notifier;
        this.source = source;
        this.sourceIsBeingSubscribedTo = true;
    }
    RepeatWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.sourceIsBeingSubscribedTo = true;
        this.source.subscribe(this);
    };
    RepeatWhenSubscriber.prototype.notifyComplete = function (innerSub) {
        if (this.sourceIsBeingSubscribedTo === false) {
            return _super.prototype.complete.call(this);
        }
    };
    RepeatWhenSubscriber.prototype.complete = function () {
        this.sourceIsBeingSubscribedTo = false;
        if (!this.isStopped) {
            if (!this.retries) {
                this.subscribeToRetries();
            }
            else if (this.retriesSubscription.closed) {
                return _super.prototype.complete.call(this);
            }
            this._unsubscribeAndRecycle();
            this.notifications.next();
        }
    };
    RepeatWhenSubscriber.prototype._unsubscribe = function () {
        var _a = this, notifications = _a.notifications, retriesSubscription = _a.retriesSubscription;
        if (notifications) {
            notifications.unsubscribe();
            this.notifications = null;
        }
        if (retriesSubscription) {
            retriesSubscription.unsubscribe();
            this.retriesSubscription = null;
        }
        this.retries = null;
    };
    RepeatWhenSubscriber.prototype._unsubscribeAndRecycle = function () {
        var _a = this, notifications = _a.notifications, retries = _a.retries, retriesSubscription = _a.retriesSubscription;
        this.notifications = null;
        this.retries = null;
        this.retriesSubscription = null;
        _super.prototype._unsubscribeAndRecycle.call(this);
        this.notifications = notifications;
        this.retries = retries;
        this.retriesSubscription = retriesSubscription;
        return this;
    };
    RepeatWhenSubscriber.prototype.subscribeToRetries = function () {
        this.notifications = new Subject_1.Subject();
        var retries = tryCatch_1.tryCatch(this.notifier)(this.notifications);
        if (retries === errorObject_1.errorObject) {
            return _super.prototype.complete.call(this);
        }
        this.retries = retries;
        this.retriesSubscription = subscribeToResult_1.subscribeToResult(this, retries);
    };
    return RepeatWhenSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=repeatWhen.js.map

/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(1);
/**
 * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable
 * calls `error`, this method will resubscribe to the source Observable for a maximum of `count` resubscriptions (given
 * as a number parameter) rather than propagating the `error` call.
 *
 * <img src="./img/retry.png" width="100%">
 *
 * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted
 * during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second
 * time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications
 * would be: [1, 2, 1, 2, 3, 4, 5, `complete`].
 * @param {number} count - Number of retry attempts before failing.
 * @return {Observable} The source Observable modified with the retry logic.
 * @method retry
 * @owner Observable
 */
function retry(count) {
    if (count === void 0) { count = -1; }
    return this.lift(new RetryOperator(count, this));
}
exports.retry = retry;
var RetryOperator = (function () {
    function RetryOperator(count, source) {
        this.count = count;
        this.source = source;
    }
    RetryOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
    };
    return RetryOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var RetrySubscriber = (function (_super) {
    __extends(RetrySubscriber, _super);
    function RetrySubscriber(destination, count, source) {
        _super.call(this, destination);
        this.count = count;
        this.source = source;
    }
    RetrySubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _a = this, source = _a.source, count = _a.count;
            if (count === 0) {
                return _super.prototype.error.call(this, err);
            }
            else if (count > -1) {
                this.count = count - 1;
            }
            source.subscribe(this._unsubscribeAndRecycle());
        }
    };
    return RetrySubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=retry.js.map

/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = __webpack_require__(5);
var tryCatch_1 = __webpack_require__(8);
var errorObject_1 = __webpack_require__(6);
var OuterSubscriber_1 = __webpack_require__(2);
var subscribeToResult_1 = __webpack_require__(3);
/**
 * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable
 * calls `error`, this method will emit the Throwable that caused the error to the Observable returned from `notifier`.
 * If that Observable calls `complete` or `error` then this method will call `complete` or `error` on the child
 * subscription. Otherwise this method will resubscribe to the source Observable.
 *
 * <img src="./img/retryWhen.png" width="100%">
 *
 * @param {function(errors: Observable): Observable} notifier - Receives an Observable of notifications with which a
 * user can `complete` or `error`, aborting the retry.
 * @return {Observable} The source Observable modified with retry logic.
 * @method retryWhen
 * @owner Observable
 */
function retryWhen(notifier) {
    return this.lift(new RetryWhenOperator(notifier, this));
}
exports.retryWhen = retryWhen;
var RetryWhenOperator = (function () {
    function RetryWhenOperator(notifier, source) {
        this.notifier = notifier;
        this.source = source;
    }
    RetryWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));
    };
    return RetryWhenOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var RetryWhenSubscriber = (function (_super) {
    __extends(RetryWhenSubscriber, _super);
    function RetryWhenSubscriber(destination, notifier, source) {
        _super.call(this, destination);
        this.notifier = notifier;
        this.source = source;
    }
    RetryWhenSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var errors = this.errors;
            var retries = this.retries;
            var retriesSubscription = this.retriesSubscription;
            if (!retries) {
                errors = new Subject_1.Subject();
                retries = tryCatch_1.tryCatch(this.notifier)(errors);
                if (retries === errorObject_1.errorObject) {
                    return _super.prototype.error.call(this, errorObject_1.errorObject.e);
                }
                retriesSubscription = subscribeToResult_1.subscribeToResult(this, retries);
            }
            else {
                this.errors = null;
                this.retriesSubscription = null;
            }
            this._unsubscribeAndRecycle();
            this.errors = errors;
            this.retries = retries;
            this.retriesSubscription = retriesSubscription;
            errors.next(err);
        }
    };
    RetryWhenSubscriber.prototype._unsubscribe = function () {
        var _a = this, errors = _a.errors, retriesSubscription = _a.retriesSubscription;
        if (errors) {
            errors.unsubscribe();
            this.errors = null;
        }
        if (retriesSubscription) {
            retriesSubscription.unsubscribe();
            this.retriesSubscription = null;
        }
        this.retries = null;
    };
    RetryWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _a = this, errors = _a.errors, retries = _a.retries, retriesSubscription = _a.retriesSubscription;
        this.errors = null;
        this.retries = null;
        this.retriesSubscription = null;
        this._unsubscribeAndRecycle();
        this.errors = errors;
        this.retries = retries;
        this.retriesSubscription = retriesSubscription;
        this.source.subscribe(this);
    };
    return RetryWhenSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=retryWhen.js.map

/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(2);
var subscribeToResult_1 = __webpack_require__(3);
/**
 * Emits the most recently emitted value from the source Observable whenever
 * another Observable, the `notifier`, emits.
 *
 * <span class="informal">It's like {@link sampleTime}, but samples whenever
 * the `notifier` Observable emits something.</span>
 *
 * <img src="./img/sample.png" width="100%">
 *
 * Whenever the `notifier` Observable emits a value or completes, `sample`
 * looks at the source Observable and emits whichever value it has most recently
 * emitted since the previous sampling, unless the source has not emitted
 * anything since the previous sampling. The `notifier` is subscribed to as soon
 * as the output Observable is subscribed.
 *
 * @example <caption>On every click, sample the most recent "seconds" timer</caption>
 * var seconds = Rx.Observable.interval(1000);
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = seconds.sample(clicks);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link audit}
 * @see {@link debounce}
 * @see {@link sampleTime}
 * @see {@link throttle}
 *
 * @param {Observable<any>} notifier The Observable to use for sampling the
 * source Observable.
 * @return {Observable<T>} An Observable that emits the results of sampling the
 * values emitted by the source Observable whenever the notifier Observable
 * emits value or completes.
 * @method sample
 * @owner Observable
 */
function sample(notifier) {
    return this.lift(new SampleOperator(notifier));
}
exports.sample = sample;
var SampleOperator = (function () {
    function SampleOperator(notifier) {
        this.notifier = notifier;
    }
    SampleOperator.prototype.call = function (subscriber, source) {
        var sampleSubscriber = new SampleSubscriber(subscriber);
        var subscription = source.subscribe(sampleSubscriber);
        subscription.add(subscribeToResult_1.subscribeToResult(sampleSubscriber, this.notifier));
        return subscription;
    };
    return SampleOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SampleSubscriber = (function (_super) {
    __extends(SampleSubscriber, _super);
    function SampleSubscriber() {
        _super.apply(this, arguments);
        this.hasValue = false;
    }
    SampleSubscriber.prototype._next = function (value) {
        this.value = value;
        this.hasValue = true;
    };
    SampleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.emitValue();
    };
    SampleSubscriber.prototype.notifyComplete = function () {
        this.emitValue();
    };
    SampleSubscriber.prototype.emitValue = function () {
        if (this.hasValue) {
            this.hasValue = false;
            this.destination.next(this.value);
        }
    };
    return SampleSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=sample.js.map

/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(1);
var async_1 = __webpack_require__(9);
/**
 * Emits the most recently emitted value from the source Observable within
 * periodic time intervals.
 *
 * <span class="informal">Samples the source Observable at periodic time
 * intervals, emitting what it samples.</span>
 *
 * <img src="./img/sampleTime.png" width="100%">
 *
 * `sampleTime` periodically looks at the source Observable and emits whichever
 * value it has most recently emitted since the previous sampling, unless the
 * source has not emitted anything since the previous sampling. The sampling
 * happens periodically in time every `period` milliseconds (or the time unit
 * defined by the optional `scheduler` argument). The sampling starts as soon as
 * the output Observable is subscribed.
 *
 * @example <caption>Every second, emit the most recent click at most once</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.sampleTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounceTime}
 * @see {@link delay}
 * @see {@link sample}
 * @see {@link throttleTime}
 *
 * @param {number} period The sampling period expressed in milliseconds or the
 * time unit determined internally by the optional `scheduler`.
 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
 * managing the timers that handle the sampling.
 * @return {Observable<T>} An Observable that emits the results of sampling the
 * values emitted by the source Observable at the specified time interval.
 * @method sampleTime
 * @owner Observable
 */
function sampleTime(period, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return this.lift(new SampleTimeOperator(period, scheduler));
}
exports.sampleTime = sampleTime;
var SampleTimeOperator = (function () {
    function SampleTimeOperator(period, scheduler) {
        this.period = period;
        this.scheduler = scheduler;
    }
    SampleTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));
    };
    return SampleTimeOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SampleTimeSubscriber = (function (_super) {
    __extends(SampleTimeSubscriber, _super);
    function SampleTimeSubscriber(destination, period, scheduler) {
        _super.call(this, destination);
        this.period = period;
        this.scheduler = scheduler;
        this.hasValue = false;
        this.add(scheduler.schedule(dispatchNotification, period, { subscriber: this, period: period }));
    }
    SampleTimeSubscriber.prototype._next = function (value) {
        this.lastValue = value;
        this.hasValue = true;
    };
    SampleTimeSubscriber.prototype.notifyNext = function () {
        if (this.hasValue) {
            this.hasValue = false;
            this.destination.next(this.lastValue);
        }
    };
    return SampleTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchNotification(state) {
    var subscriber = state.subscriber, period = state.period;
    subscriber.notifyNext();
    this.schedule(state, period);
}
//# sourceMappingURL=sampleTime.js.map

/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(1);
/* tslint:enable:max-line-length */
/**
 * Applies an accumulator function over the source Observable, and returns each
 * intermediate result, with an optional seed value.
 *
 * <span class="informal">It's like {@link reduce}, but emits the current
 * accumulation whenever the source emits a value.</span>
 *
 * <img src="./img/scan.png" width="100%">
 *
 * Combines together all values emitted on the source, using an accumulator
 * function that knows how to join a new source value into the accumulation from
 * the past. Is similar to {@link reduce}, but emits the intermediate
 * accumulations.
 *
 * Returns an Observable that applies a specified `accumulator` function to each
 * item emitted by the source Observable. If a `seed` value is specified, then
 * that value will be used as the initial value for the accumulator. If no seed
 * value is specified, the first item of the source is used as the seed.
 *
 * @example <caption>Count the number of click events</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var ones = clicks.mapTo(1);
 * var seed = 0;
 * var count = ones.scan((acc, one) => acc + one, seed);
 * count.subscribe(x => console.log(x));
 *
 * @see {@link expand}
 * @see {@link mergeScan}
 * @see {@link reduce}
 *
 * @param {function(acc: R, value: T, index: number): R} accumulator
 * The accumulator function called on each source value.
 * @param {T|R} [seed] The initial accumulation value.
 * @return {Observable<R>} An observable of the accumulated values.
 * @method scan
 * @owner Observable
 */
function scan(accumulator, seed) {
    var hasSeed = false;
    // providing a seed of `undefined` *should* be valid and trigger
    // hasSeed! so don't use `seed !== undefined` checks!
    // For this reason, we have to check it here at the original call site
    // otherwise inside Operator/Subscriber we won't know if `undefined`
    // means they didn't provide anything or if they literally provided `undefined`
    if (arguments.length >= 2) {
        hasSeed = true;
    }
    return this.lift(new ScanOperator(accumulator, seed, hasSeed));
}
exports.scan = scan;
var ScanOperator = (function () {
    function ScanOperator(accumulator, seed, hasSeed) {
        if (hasSeed === void 0) { hasSeed = false; }
        this.accumulator = accumulator;
        this.seed = seed;
        this.hasSeed = hasSeed;
    }
    ScanOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
    };
    return ScanOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ScanSubscriber = (function (_super) {
    __extends(ScanSubscriber, _super);
    function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
        _super.call(this, destination);
        this.accumulator = accumulator;
        this._seed = _seed;
        this.hasSeed = hasSeed;
        this.index = 0;
    }
    Object.defineProperty(ScanSubscriber.prototype, "seed", {
        get: function () {
            return this._seed;
        },
        set: function (value) {
            this.hasSeed = true;
            this._seed = value;
        },
        enumerable: true,
        configurable: true
    });
    ScanSubscriber.prototype._next = function (value) {
        if (!this.hasSeed) {
            this.seed = value;
            this.destination.next(value);
        }
        else {
            return this._tryNext(value);
        }
    };
    ScanSubscriber.prototype._tryNext = function (value) {
        var index = this.index++;
        var result;
        try {
            result = this.accumulator(this.seed, value, index);
        }
        catch (err) {
            this.destination.error(err);
        }
        this.seed = result;
        this.destination.next(result);
    };
    return ScanSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=scan.js.map

/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(1);
var tryCatch_1 = __webpack_require__(8);
var errorObject_1 = __webpack_require__(6);
/**
 * Compares all values of two observables in sequence using an optional comparor function
 * and returns an observable of a single boolean value representing whether or not the two sequences
 * are equal.
 *
 * <span class="informal">Checks to see of all values emitted by both observables are equal, in order.</span>
 *
 * <img src="./img/sequenceEqual.png" width="100%">
 *
 * `sequenceEqual` subscribes to two observables and buffers incoming values from each observable. Whenever either
 * observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom
 * up; If any value pair doesn't match, the returned observable will emit `false` and complete. If one of the
 * observables completes, the operator will wait for the other observable to complete; If the other
 * observable emits before completing, the returned observable will emit `false` and complete. If one observable never
 * completes or emits after the other complets, the returned observable will never complete.
 *
 * @example <caption>figure out if the Konami code matches</caption>
 * var code = Rx.Observable.from([
 *  "ArrowUp",
 *  "ArrowUp",
 *  "ArrowDown",
 *  "ArrowDown",
 *  "ArrowLeft",
 *  "ArrowRight",
 *  "ArrowLeft",
 *  "ArrowRight",
 *  "KeyB",
 *  "KeyA",
 *  "Enter" // no start key, clearly.
 * ]);
 *
 * var keys = Rx.Observable.fromEvent(document, 'keyup')
 *  .map(e => e.code);
 * var matches = keys.bufferCount(11, 1)
 *  .mergeMap(
 *    last11 =>
 *      Rx.Observable.from(last11)
 *        .sequenceEqual(code)
 *   );
 * matches.subscribe(matched => console.log('Successful cheat at Contra? ', matched));
 *
 * @see {@link combineLatest}
 * @see {@link zip}
 * @see {@link withLatestFrom}
 *
 * @param {Observable} compareTo The observable sequence to compare the source sequence to.
 * @param {function} [comparor] An optional function to compare each value pair
 * @return {Observable} An Observable of a single boolean value representing whether or not
 * the values emitted by both observables were equal in sequence.
 * @method sequenceEqual
 * @owner Observable
 */
function sequenceEqual(compareTo, comparor) {
    return this.lift(new SequenceEqualOperator(compareTo, comparor));
}
exports.sequenceEqual = sequenceEqual;
var SequenceEqualOperator = (function () {
    function SequenceEqualOperator(compareTo, comparor) {
        this.compareTo = compareTo;
        this.comparor = comparor;
    }
    SequenceEqualOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparor));
    };
    return SequenceEqualOperator;
}());
exports.SequenceEqualOperator = SequenceEqualOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SequenceEqualSubscriber = (function (_super) {
    __extends(SequenceEqualSubscriber, _super);
    function SequenceEqualSubscriber(destination, compareTo, comparor) {
        _super.call(this, destination);
        this.compareTo = compareTo;
        this.comparor = comparor;
        this._a = [];
        this._b = [];
        this._oneComplete = false;
        this.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, this)));
    }
    SequenceEqualSubscriber.prototype._next = function (value) {
        if (this._oneComplete && this._b.length === 0) {
            this.emit(false);
        }
        else {
            this._a.push(value);
            this.checkValues();
        }
    };
    SequenceEqualSubscriber.prototype._complete = function () {
        if (this._oneComplete) {
            this.emit(this._a.length === 0 && this._b.length === 0);
        }
        else {
            this._oneComplete = true;
        }
    };
    SequenceEqualSubscriber.prototype.checkValues = function () {
        var _c = this, _a = _c._a, _b = _c._b, comparor = _c.comparor;
        while (_a.length > 0 && _b.length > 0) {
            var a = _a.shift();
            var b = _b.shift();
            var areEqual = false;
            if (comparor) {
                areEqual = tryCatch_1.tryCatch(comparor)(a, b);
                if (areEqual === errorObject_1.errorObject) {
                    this.destination.error(errorObject_1.errorObject.e);
                }
            }
            else {
                areEqual = a === b;
            }
            if (!areEqual) {
                this.emit(false);
            }
        }
    };
    SequenceEqualSubscriber.prototype.emit = function (value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
    };
    SequenceEqualSubscriber.prototype.nextB = function (value) {
        if (this._oneComplete && this._a.length === 0) {
            this.emit(false);
        }
        else {
            this._b.push(value);
            this.checkValues();
        }
    };
    return SequenceEqualSubscriber;
}(Subscriber_1.Subscriber));
exports.SequenceEqualSubscriber = SequenceEqualSubscriber;
var SequenceEqualCompareToSubscriber = (function (_super) {
    __extends(SequenceEqualCompareToSubscriber, _super);
    function SequenceEqualCompareToSubscriber(destination, parent) {
        _super.call(this, destination);
        this.parent = parent;
    }
    SequenceEqualCompareToSubscriber.prototype._next = function (value) {
        this.parent.nextB(value);
    };
    SequenceEqualCompareToSubscriber.prototype._error = function (err) {
        this.parent.error(err);
    };
    SequenceEqualCompareToSubscriber.prototype._complete = function () {
        this.parent._complete();
    };
    return SequenceEqualCompareToSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=sequenceEqual.js.map

/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var multicast_1 = __webpack_require__(14);
var Subject_1 = __webpack_require__(5);
function shareSubjectFactory() {
    return new Subject_1.Subject();
}
/**
 * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one
 * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will
 * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.
 * This is an alias for .publish().refCount().
 *
 * <img src="./img/share.png" width="100%">
 *
 * @return {Observable<T>} An Observable that upon connection causes the source Observable to emit items to its Observers.
 * @method share
 * @owner Observable
 */
function share() {
    return multicast_1.multicast.call(this, shareSubjectFactory).refCount();
}
exports.share = share;
;
//# sourceMappingURL=share.js.map

/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(1);
var EmptyError_1 = __webpack_require__(24);
/**
 * Returns an Observable that emits the single item emitted by the source Observable that matches a specified
 * predicate, if that Observable emits one such item. If the source Observable emits more than one such item or no
 * such items, notify of an IllegalArgumentException or NoSuchElementException respectively.
 *
 * <img src="./img/single.png" width="100%">
 *
 * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
 * callback if the Observable completes before any `next` notification was sent.
 * @param {Function} predicate - A predicate function to evaluate items emitted by the source Observable.
 * @return {Observable<T>} An Observable that emits the single item emitted by the source Observable that matches
 * the predicate.
 .
 * @method single
 * @owner Observable
 */
function single(predicate) {
    return this.lift(new SingleOperator(predicate, this));
}
exports.single = single;
var SingleOperator = (function () {
    function SingleOperator(predicate, source) {
        this.predicate = predicate;
        this.source = source;
    }
    SingleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));
    };
    return SingleOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SingleSubscriber = (function (_super) {
    __extends(SingleSubscriber, _super);
    function SingleSubscriber(destination, predicate, source) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.source = source;
        this.seenValue = false;
        this.index = 0;
    }
    SingleSubscriber.prototype.applySingleValue = function (value) {
        if (this.seenValue) {
            this.destination.error('Sequence contains more than one element');
        }
        else {
            this.seenValue = true;
            this.singleValue = value;
        }
    };
    SingleSubscriber.prototype._next = function (value) {
        var index = this.index++;
        if (this.predicate) {
            this.tryNext(value, index);
        }
        else {
            this.applySingleValue(value);
        }
    };
    SingleSubscriber.prototype.tryNext = function (value, index) {
        try {
            if (this.predicate(value, index, this.source)) {
                this.applySingleValue(value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    SingleSubscriber.prototype._complete = function () {
        var destination = this.destination;
        if (this.index > 0) {
            destination.next(this.seenValue ? this.singleValue : undefined);
            destination.complete();
        }
        else {
            destination.error(new EmptyError_1.EmptyError);
        }
    };
    return SingleSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=single.js.map

/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(1);
/**
 * Returns an Observable that skips the first `count` items emitted by the source Observable.
 *
 * <img src="./img/skip.png" width="100%">
 *
 * @param {Number} count - The number of times, items emitted by source Observable should be skipped.
 * @return {Observable} An Observable that skips values emitted by the source Observable.
 *
 * @method skip
 * @owner Observable
 */
function skip(count) {
    return this.lift(new SkipOperator(count));
}
exports.skip = skip;
var SkipOperator = (function () {
    function SkipOperator(total) {
        this.total = total;
    }
    SkipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipSubscriber(subscriber, this.total));
    };
    return SkipOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SkipSubscriber = (function (_super) {
    __extends(SkipSubscriber, _super);
    function SkipSubscriber(destination, total) {
        _super.call(this, destination);
        this.total = total;
        this.count = 0;
    }
    SkipSubscriber.prototype._next = function (x) {
        if (++this.count > this.total) {
            this.destination.next(x);
        }
    };
    return SkipSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=skip.js.map

/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(2);
var subscribeToResult_1 = __webpack_require__(3);
/**
 * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.
 *
 * <img src="./img/skipUntil.png" width="100%">
 *
 * @param {Observable} notifier - The second Observable that has to emit an item before the source Observable's elements begin to
 * be mirrored by the resulting Observable.
 * @return {Observable<T>} An Observable that skips items from the source Observable until the second Observable emits
 * an item, then emits the remaining items.
 * @method skipUntil
 * @owner Observable
 */
function skipUntil(notifier) {
    return this.lift(new SkipUntilOperator(notifier));
}
exports.skipUntil = skipUntil;
var SkipUntilOperator = (function () {
    function SkipUntilOperator(notifier) {
        this.notifier = notifier;
    }
    SkipUntilOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipUntilSubscriber(subscriber, this.notifier));
    };
    return SkipUntilOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SkipUntilSubscriber = (function (_super) {
    __extends(SkipUntilSubscriber, _super);
    function SkipUntilSubscriber(destination, notifier) {
        _super.call(this, destination);
        this.hasValue = false;
        this.isInnerStopped = false;
        this.add(subscribeToResult_1.subscribeToResult(this, notifier));
    }
    SkipUntilSubscriber.prototype._next = function (value) {
        if (this.hasValue) {
            _super.prototype._next.call(this, value);
        }
    };
    SkipUntilSubscriber.prototype._complete = function () {
        if (this.isInnerStopped) {
            _super.prototype._complete.call(this);
        }
        else {
            this.unsubscribe();
        }
    };
    SkipUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.hasValue = true;
    };
    SkipUntilSubscriber.prototype.notifyComplete = function () {
        this.isInnerStopped = true;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    return SkipUntilSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=skipUntil.js.map

/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(1);
/**
 * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds
 * true, but emits all further source items as soon as the condition becomes false.
 *
 * <img src="./img/skipWhile.png" width="100%">
 *
 * @param {Function} predicate - A function to test each item emitted from the source Observable.
 * @return {Observable<T>} An Observable that begins emitting items emitted by the source Observable when the
 * specified predicate becomes false.
 * @method skipWhile
 * @owner Observable
 */
function skipWhile(predicate) {
    return this.lift(new SkipWhileOperator(predicate));
}
exports.skipWhile = skipWhile;
var SkipWhileOperator = (function () {
    function SkipWhileOperator(predicate) {
        this.predicate = predicate;
    }
    SkipWhileOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
    };
    return SkipWhileOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SkipWhileSubscriber = (function (_super) {
    __extends(SkipWhileSubscriber, _super);
    function SkipWhileSubscriber(destination, predicate) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.skipping = true;
        this.index = 0;
    }
    SkipWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        if (this.skipping) {
            this.tryCallPredicate(value);
        }
        if (!this.skipping) {
            destination.next(value);
        }
    };
    SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {
        try {
            var result = this.predicate(value, this.index++);
            this.skipping = Boolean(result);
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    return SkipWhileSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=skipWhile.js.map

/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayObservable_1 = __webpack_require__(10);
var ScalarObservable_1 = __webpack_require__(30);
var EmptyObservable_1 = __webpack_require__(13);
var concat_1 = __webpack_require__(32);
var isScheduler_1 = __webpack_require__(12);
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits the items you specify as arguments before it begins to emit
 * items emitted by the source Observable.
 *
 * <img src="./img/startWith.png" width="100%">
 *
 * @param {...T} values - Items you want the modified Observable to emit first.
 * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling
 * the emissions of the `next` notifications.
 * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items
 * emitted by the source Observable.
 * @method startWith
 * @owner Observable
 */
function startWith() {
    var array = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        array[_i - 0] = arguments[_i];
    }
    var scheduler = array[array.length - 1];
    if (isScheduler_1.isScheduler(scheduler)) {
        array.pop();
    }
    else {
        scheduler = null;
    }
    var len = array.length;
    if (len === 1) {
        return concat_1.concatStatic(new ScalarObservable_1.ScalarObservable(array[0], scheduler), this);
    }
    else if (len > 1) {
        return concat_1.concatStatic(new ArrayObservable_1.ArrayObservable(array, scheduler), this);
    }
    else {
        return concat_1.concatStatic(new EmptyObservable_1.EmptyObservable(scheduler), this);
    }
}
exports.startWith = startWith;
//# sourceMappingURL=startWith.js.map

/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var SubscribeOnObservable_1 = __webpack_require__(223);
/**
 * Asynchronously subscribes Observers to this Observable on the specified IScheduler.
 *
 * <img src="./img/subscribeOn.png" width="100%">
 *
 * @param {Scheduler} scheduler - The IScheduler to perform subscription actions on.
 * @return {Observable<T>} The source Observable modified so that its subscriptions happen on the specified IScheduler.
 .
 * @method subscribeOn
 * @owner Observable
 */
function subscribeOn(scheduler, delay) {
    if (delay === void 0) { delay = 0; }
    return this.lift(new SubscribeOnOperator(scheduler, delay));
}
exports.subscribeOn = subscribeOn;
var SubscribeOnOperator = (function () {
    function SubscribeOnOperator(scheduler, delay) {
        this.scheduler = scheduler;
        this.delay = delay;
    }
    SubscribeOnOperator.prototype.call = function (subscriber, source) {
        return new SubscribeOnObservable_1.SubscribeOnObservable(source, this.delay, this.scheduler).subscribe(subscriber);
    };
    return SubscribeOnOperator;
}());
//# sourceMappingURL=subscribeOn.js.map

/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(2);
var subscribeToResult_1 = __webpack_require__(3);
/**
 * Converts a higher-order Observable into a first-order Observable by
 * subscribing to only the most recently emitted of those inner Observables.
 *
 * <span class="informal">Flattens an Observable-of-Observables by dropping the
 * previous inner Observable once a new one appears.</span>
 *
 * <img src="./img/switch.png" width="100%">
 *
 * `switch` subscribes to an Observable that emits Observables, also known as a
 * higher-order Observable. Each time it observes one of these emitted inner
 * Observables, the output Observable subscribes to the inner Observable and
 * begins emitting the items emitted by that. So far, it behaves
 * like {@link mergeAll}. However, when a new inner Observable is emitted,
 * `switch` unsubscribes from the earlier-emitted inner Observable and
 * subscribes to the new inner Observable and begins emitting items from it. It
 * continues to behave like this for subsequent inner Observables.
 *
 * @example <caption>Rerun an interval Observable on every click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * // Each click event is mapped to an Observable that ticks every second
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
 * var switched = higherOrder.switch();
 * // The outcome is that `switched` is essentially a timer that restarts
 * // on every click. The interval Observables from older clicks do not merge
 * // with the current interval Observable.
 * switched.subscribe(x => console.log(x));
 *
 * @see {@link combineAll}
 * @see {@link concatAll}
 * @see {@link exhaust}
 * @see {@link mergeAll}
 * @see {@link switchMap}
 * @see {@link switchMapTo}
 * @see {@link zipAll}
 *
 * @return {Observable<T>} An Observable that emits the items emitted by the
 * Observable most recently emitted by the source Observable.
 * @method switch
 * @name switch
 * @owner Observable
 */
function _switch() {
    return this.lift(new SwitchOperator());
}
exports._switch = _switch;
var SwitchOperator = (function () {
    function SwitchOperator() {
    }
    SwitchOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchSubscriber(subscriber));
    };
    return SwitchOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchSubscriber = (function (_super) {
    __extends(SwitchSubscriber, _super);
    function SwitchSubscriber(destination) {
        _super.call(this, destination);
        this.active = 0;
        this.hasCompleted = false;
    }
    SwitchSubscriber.prototype._next = function (value) {
        this.unsubscribeInner();
        this.active++;
        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, value));
    };
    SwitchSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0) {
            this.destination.complete();
        }
    };
    SwitchSubscriber.prototype.unsubscribeInner = function () {
        this.active = this.active > 0 ? this.active - 1 : 0;
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
            this.remove(innerSubscription);
        }
    };
    SwitchSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    SwitchSubscriber.prototype.notifyError = function (err) {
        this.destination.error(err);
    };
    SwitchSubscriber.prototype.notifyComplete = function () {
        this.unsubscribeInner();
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
    };
    return SwitchSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=switch.js.map

/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(2);
var subscribeToResult_1 = __webpack_require__(3);
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable, emitting values only from the most recently projected Observable.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link switch}.</span>
 *
 * <img src="./img/switchMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. Each time it observes one of these
 * inner Observables, the output Observable begins emitting the items emitted by
 * that inner Observable. When a new inner Observable is emitted, `switchMap`
 * stops emitting items from the earlier-emitted inner Observable and begins
 * emitting items from the new one. It continues to behave like this for
 * subsequent inner Observables.
 *
 * @example <caption>Rerun an interval Observable on every click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMap}
 * @see {@link exhaustMap}
 * @see {@link mergeMap}
 * @see {@link switch}
 * @see {@link switchMapTo}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and taking only the values from the most recently
 * projected inner Observable.
 * @method switchMap
 * @owner Observable
 */
function switchMap(project, resultSelector) {
    return this.lift(new SwitchMapOperator(project, resultSelector));
}
exports.switchMap = switchMap;
var SwitchMapOperator = (function () {
    function SwitchMapOperator(project, resultSelector) {
        this.project = project;
        this.resultSelector = resultSelector;
    }
    SwitchMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));
    };
    return SwitchMapOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchMapSubscriber = (function (_super) {
    __extends(SwitchMapSubscriber, _super);
    function SwitchMapSubscriber(destination, project, resultSelector) {
        _super.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.index = 0;
    }
    SwitchMapSubscriber.prototype._next = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (error) {
            this.destination.error(error);
            return;
        }
        this._innerSub(result, value, index);
    };
    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
        }
        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, value, index));
    };
    SwitchMapSubscriber.prototype._complete = function () {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype._unsubscribe = function () {
        this.innerSubscription = null;
    };
    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.innerSubscription = null;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (this.resultSelector) {
            this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);
        }
        else {
            this.destination.next(innerValue);
        }
    };
    SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
        var result;
        try {
            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return SwitchMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=switchMap.js.map

/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(2);
var subscribeToResult_1 = __webpack_require__(3);
/* tslint:enable:max-line-length */
/**
 * Projects each source value to the same Observable which is flattened multiple
 * times with {@link switch} in the output Observable.
 *
 * <span class="informal">It's like {@link switchMap}, but maps each value
 * always to the same inner Observable.</span>
 *
 * <img src="./img/switchMapTo.png" width="100%">
 *
 * Maps each source value to the given Observable `innerObservable` regardless
 * of the source value, and then flattens those resulting Observables into one
 * single Observable, which is the output Observable. The output Observables
 * emits values only from the most recently emitted instance of
 * `innerObservable`.
 *
 * @example <caption>Rerun an interval Observable on every click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.switchMapTo(Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMapTo}
 * @see {@link switch}
 * @see {@link switchMap}
 * @see {@link mergeMapTo}
 *
 * @param {ObservableInput} innerObservable An Observable to replace each value from
 * the source Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable that emits items from the given
 * `innerObservable` (and optionally transformed through `resultSelector`) every
 * time a value is emitted on the source Observable, and taking only the values
 * from the most recently projected inner Observable.
 * @method switchMapTo
 * @owner Observable
 */
function switchMapTo(innerObservable, resultSelector) {
    return this.lift(new SwitchMapToOperator(innerObservable, resultSelector));
}
exports.switchMapTo = switchMapTo;
var SwitchMapToOperator = (function () {
    function SwitchMapToOperator(observable, resultSelector) {
        this.observable = observable;
        this.resultSelector = resultSelector;
    }
    SwitchMapToOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchMapToSubscriber(subscriber, this.observable, this.resultSelector));
    };
    return SwitchMapToOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchMapToSubscriber = (function (_super) {
    __extends(SwitchMapToSubscriber, _super);
    function SwitchMapToSubscriber(destination, inner, resultSelector) {
        _super.call(this, destination);
        this.inner = inner;
        this.resultSelector = resultSelector;
        this.index = 0;
    }
    SwitchMapToSubscriber.prototype._next = function (value) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
        }
        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, this.inner, value, this.index++));
    };
    SwitchMapToSubscriber.prototype._complete = function () {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapToSubscriber.prototype._unsubscribe = function () {
        this.innerSubscription = null;
    };
    SwitchMapToSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.innerSubscription = null;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
        if (resultSelector) {
            this.tryResultSelector(outerValue, innerValue, outerIndex, innerIndex);
        }
        else {
            destination.next(innerValue);
        }
    };
    SwitchMapToSubscriber.prototype.tryResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {
        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
        var result;
        try {
            result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        destination.next(result);
    };
    return SwitchMapToSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=switchMapTo.js.map

/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(1);
var ArgumentOutOfRangeError_1 = __webpack_require__(23);
var EmptyObservable_1 = __webpack_require__(13);
/**
 * Emits only the first `count` values emitted by the source Observable.
 *
 * <span class="informal">Takes the first `count` values from the source, then
 * completes.</span>
 *
 * <img src="./img/take.png" width="100%">
 *
 * `take` returns an Observable that emits only the first `count` values emitted
 * by the source Observable. If the source emits fewer than `count` values then
 * all of its values are emitted. After that, it completes, regardless if the
 * source completes.
 *
 * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>
 * var interval = Rx.Observable.interval(1000);
 * var five = interval.take(5);
 * five.subscribe(x => console.log(x));
 *
 * @see {@link takeLast}
 * @see {@link takeUntil}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an
 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.
 *
 * @param {number} count The maximum number of `next` values to emit.
 * @return {Observable<T>} An Observable that emits only the first `count`
 * values emitted by the source Observable, or all of the values from the source
 * if the source emits fewer than `count` values.
 * @method take
 * @owner Observable
 */
function take(count) {
    if (count === 0) {
        return new EmptyObservable_1.EmptyObservable();
    }
    else {
        return this.lift(new TakeOperator(count));
    }
}
exports.take = take;
var TakeOperator = (function () {
    function TakeOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
        }
    }
    TakeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeSubscriber(subscriber, this.total));
    };
    return TakeOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeSubscriber = (function (_super) {
    __extends(TakeSubscriber, _super);
    function TakeSubscriber(destination, total) {
        _super.call(this, destination);
        this.total = total;
        this.count = 0;
    }
    TakeSubscriber.prototype._next = function (value) {
        var total = this.total;
        var count = ++this.count;
        if (count <= total) {
            this.destination.next(value);
            if (count === total) {
                this.destination.complete();
                this.unsubscribe();
            }
        }
    };
    return TakeSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=take.js.map

/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(1);
var ArgumentOutOfRangeError_1 = __webpack_require__(23);
var EmptyObservable_1 = __webpack_require__(13);
/**
 * Emits only the last `count` values emitted by the source Observable.
 *
 * <span class="informal">Remembers the latest `count` values, then emits those
 * only when the source completes.</span>
 *
 * <img src="./img/takeLast.png" width="100%">
 *
 * `takeLast` returns an Observable that emits at most the last `count` values
 * emitted by the source Observable. If the source emits fewer than `count`
 * values then all of its values are emitted. This operator must wait until the
 * `complete` notification emission from the source in order to emit the `next`
 * values on the output Observable, because otherwise it is impossible to know
 * whether or not more values will be emitted on the source. For this reason,
 * all values are emitted synchronously, followed by the complete notification.
 *
 * @example <caption>Take the last 3 values of an Observable with many values</caption>
 * var many = Rx.Observable.range(1, 100);
 * var lastThree = many.takeLast(3);
 * lastThree.subscribe(x => console.log(x));
 *
 * @see {@link take}
 * @see {@link takeUntil}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @throws {ArgumentOutOfRangeError} When using `takeLast(i)`, it delivers an
 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.
 *
 * @param {number} count The maximum number of values to emit from the end of
 * the sequence of values emitted by the source Observable.
 * @return {Observable<T>} An Observable that emits at most the last count
 * values emitted by the source Observable.
 * @method takeLast
 * @owner Observable
 */
function takeLast(count) {
    if (count === 0) {
        return new EmptyObservable_1.EmptyObservable();
    }
    else {
        return this.lift(new TakeLastOperator(count));
    }
}
exports.takeLast = takeLast;
var TakeLastOperator = (function () {
    function TakeLastOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
        }
    }
    TakeLastOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
    };
    return TakeLastOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeLastSubscriber = (function (_super) {
    __extends(TakeLastSubscriber, _super);
    function TakeLastSubscriber(destination, total) {
        _super.call(this, destination);
        this.total = total;
        this.ring = new Array();
        this.count = 0;
    }
    TakeLastSubscriber.prototype._next = function (value) {
        var ring = this.ring;
        var total = this.total;
        var count = this.count++;
        if (ring.length < total) {
            ring.push(value);
        }
        else {
            var index = count % total;
            ring[index] = value;
        }
    };
    TakeLastSubscriber.prototype._complete = function () {
        var destination = this.destination;
        var count = this.count;
        if (count > 0) {
            var total = this.count >= this.total ? this.total : this.count;
            var ring = this.ring;
            for (var i = 0; i < total; i++) {
                var idx = (count++) % total;
                destination.next(ring[idx]);
            }
        }
        destination.complete();
    };
    return TakeLastSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=takeLast.js.map

/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(2);
var subscribeToResult_1 = __webpack_require__(3);
/**
 * Emits the values emitted by the source Observable until a `notifier`
 * Observable emits a value.
 *
 * <span class="informal">Lets values pass until a second Observable,
 * `notifier`, emits something. Then, it completes.</span>
 *
 * <img src="./img/takeUntil.png" width="100%">
 *
 * `takeUntil` subscribes and begins mirroring the source Observable. It also
 * monitors a second Observable, `notifier` that you provide. If the `notifier`
 * emits a value or a complete notification, the output Observable stops
 * mirroring the source Observable and completes.
 *
 * @example <caption>Tick every second until the first click happens</caption>
 * var interval = Rx.Observable.interval(1000);
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = interval.takeUntil(clicks);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link take}
 * @see {@link takeLast}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @param {Observable} notifier The Observable whose first emitted value will
 * cause the output Observable of `takeUntil` to stop emitting values from the
 * source Observable.
 * @return {Observable<T>} An Observable that emits the values from the source
 * Observable until such time as `notifier` emits its first value.
 * @method takeUntil
 * @owner Observable
 */
function takeUntil(notifier) {
    return this.lift(new TakeUntilOperator(notifier));
}
exports.takeUntil = takeUntil;
var TakeUntilOperator = (function () {
    function TakeUntilOperator(notifier) {
        this.notifier = notifier;
    }
    TakeUntilOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeUntilSubscriber(subscriber, this.notifier));
    };
    return TakeUntilOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeUntilSubscriber = (function (_super) {
    __extends(TakeUntilSubscriber, _super);
    function TakeUntilSubscriber(destination, notifier) {
        _super.call(this, destination);
        this.notifier = notifier;
        this.add(subscribeToResult_1.subscribeToResult(this, notifier));
    }
    TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.complete();
    };
    TakeUntilSubscriber.prototype.notifyComplete = function () {
        // noop
    };
    return TakeUntilSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=takeUntil.js.map

/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(1);
/**
 * Emits values emitted by the source Observable so long as each value satisfies
 * the given `predicate`, and then completes as soon as this `predicate` is not
 * satisfied.
 *
 * <span class="informal">Takes values from the source only while they pass the
 * condition given. When the first value does not satisfy, it completes.</span>
 *
 * <img src="./img/takeWhile.png" width="100%">
 *
 * `takeWhile` subscribes and begins mirroring the source Observable. Each value
 * emitted on the source is given to the `predicate` function which returns a
 * boolean, representing a condition to be satisfied by the source values. The
 * output Observable emits the source values until such time as the `predicate`
 * returns false, at which point `takeWhile` stops mirroring the source
 * Observable and completes the output Observable.
 *
 * @example <caption>Emit click events only while the clientX property is greater than 200</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.takeWhile(ev => ev.clientX > 200);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link take}
 * @see {@link takeLast}
 * @see {@link takeUntil}
 * @see {@link skip}
 *
 * @param {function(value: T, index: number): boolean} predicate A function that
 * evaluates a value emitted by the source Observable and returns a boolean.
 * Also takes the (zero-based) index as the second argument.
 * @return {Observable<T>} An Observable that emits the values from the source
 * Observable so long as each value satisfies the condition defined by the
 * `predicate`, then completes.
 * @method takeWhile
 * @owner Observable
 */
function takeWhile(predicate) {
    return this.lift(new TakeWhileOperator(predicate));
}
exports.takeWhile = takeWhile;
var TakeWhileOperator = (function () {
    function TakeWhileOperator(predicate) {
        this.predicate = predicate;
    }
    TakeWhileOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate));
    };
    return TakeWhileOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeWhileSubscriber = (function (_super) {
    __extends(TakeWhileSubscriber, _super);
    function TakeWhileSubscriber(destination, predicate) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.index = 0;
    }
    TakeWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        var result;
        try {
            result = this.predicate(value, this.index++);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        this.nextOrComplete(value, result);
    };
    TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {
        var destination = this.destination;
        if (Boolean(predicateResult)) {
            destination.next(value);
        }
        else {
            destination.complete();
        }
    };
    return TakeWhileSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=takeWhile.js.map

/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(2);
var subscribeToResult_1 = __webpack_require__(3);
/**
 * Emits a value from the source Observable, then ignores subsequent source
 * values for a duration determined by another Observable, then repeats this
 * process.
 *
 * <span class="informal">It's like {@link throttleTime}, but the silencing
 * duration is determined by a second Observable.</span>
 *
 * <img src="./img/throttle.png" width="100%">
 *
 * `throttle` emits the source Observable values on the output Observable
 * when its internal timer is disabled, and ignores source values when the timer
 * is enabled. Initially, the timer is disabled. As soon as the first source
 * value arrives, it is forwarded to the output Observable, and then the timer
 * is enabled by calling the `durationSelector` function with the source value,
 * which returns the "duration" Observable. When the duration Observable emits a
 * value or completes, the timer is disabled, and this process repeats for the
 * next source value.
 *
 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.throttle(ev => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link audit}
 * @see {@link debounce}
 * @see {@link delayWhen}
 * @see {@link sample}
 * @see {@link throttleTime}
 *
 * @param {function(value: T): SubscribableOrPromise} durationSelector A function
 * that receives a value from the source Observable, for computing the silencing
 * duration for each source value, returned as an Observable or a Promise.
 * @return {Observable<T>} An Observable that performs the throttle operation to
 * limit the rate of emissions from the source.
 * @method throttle
 * @owner Observable
 */
function throttle(durationSelector) {
    return this.lift(new ThrottleOperator(durationSelector));
}
exports.throttle = throttle;
var ThrottleOperator = (function () {
    function ThrottleOperator(durationSelector) {
        this.durationSelector = durationSelector;
    }
    ThrottleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector));
    };
    return ThrottleOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ThrottleSubscriber = (function (_super) {
    __extends(ThrottleSubscriber, _super);
    function ThrottleSubscriber(destination, durationSelector) {
        _super.call(this, destination);
        this.destination = destination;
        this.durationSelector = durationSelector;
    }
    ThrottleSubscriber.prototype._next = function (value) {
        if (!this.throttled) {
            this.tryDurationSelector(value);
        }
    };
    ThrottleSubscriber.prototype.tryDurationSelector = function (value) {
        var duration = null;
        try {
            duration = this.durationSelector(value);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.emitAndThrottle(value, duration);
    };
    ThrottleSubscriber.prototype.emitAndThrottle = function (value, duration) {
        this.add(this.throttled = subscribeToResult_1.subscribeToResult(this, duration));
        this.destination.next(value);
    };
    ThrottleSubscriber.prototype._unsubscribe = function () {
        var throttled = this.throttled;
        if (throttled) {
            this.remove(throttled);
            this.throttled = null;
            throttled.unsubscribe();
        }
    };
    ThrottleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this._unsubscribe();
    };
    ThrottleSubscriber.prototype.notifyComplete = function () {
        this._unsubscribe();
    };
    return ThrottleSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=throttle.js.map

/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(1);
var async_1 = __webpack_require__(9);
/**
 * Emits a value from the source Observable, then ignores subsequent source
 * values for `duration` milliseconds, then repeats this process.
 *
 * <span class="informal">Lets a value pass, then ignores source values for the
 * next `duration` milliseconds.</span>
 *
 * <img src="./img/throttleTime.png" width="100%">
 *
 * `throttleTime` emits the source Observable values on the output Observable
 * when its internal timer is disabled, and ignores source values when the timer
 * is enabled. Initially, the timer is disabled. As soon as the first source
 * value arrives, it is forwarded to the output Observable, and then the timer
 * is enabled. After `duration` milliseconds (or the time unit determined
 * internally by the optional `scheduler`) has passed, the timer is disabled,
 * and this process repeats for the next source value. Optionally takes a
 * {@link IScheduler} for managing timers.
 *
 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.throttleTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounceTime}
 * @see {@link delay}
 * @see {@link sampleTime}
 * @see {@link throttle}
 *
 * @param {number} duration Time to wait before emitting another value after
 * emitting the last value, measured in milliseconds or the time unit determined
 * internally by the optional `scheduler`.
 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
 * managing the timers that handle the sampling.
 * @return {Observable<T>} An Observable that performs the throttle operation to
 * limit the rate of emissions from the source.
 * @method throttleTime
 * @owner Observable
 */
function throttleTime(duration, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return this.lift(new ThrottleTimeOperator(duration, scheduler));
}
exports.throttleTime = throttleTime;
var ThrottleTimeOperator = (function () {
    function ThrottleTimeOperator(duration, scheduler) {
        this.duration = duration;
        this.scheduler = scheduler;
    }
    ThrottleTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler));
    };
    return ThrottleTimeOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ThrottleTimeSubscriber = (function (_super) {
    __extends(ThrottleTimeSubscriber, _super);
    function ThrottleTimeSubscriber(destination, duration, scheduler) {
        _super.call(this, destination);
        this.duration = duration;
        this.scheduler = scheduler;
    }
    ThrottleTimeSubscriber.prototype._next = function (value) {
        if (!this.throttled) {
            this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this }));
            this.destination.next(value);
        }
    };
    ThrottleTimeSubscriber.prototype.clearThrottle = function () {
        var throttled = this.throttled;
        if (throttled) {
            throttled.unsubscribe();
            this.remove(throttled);
            this.throttled = null;
        }
    };
    return ThrottleTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchNext(arg) {
    var subscriber = arg.subscriber;
    subscriber.clearThrottle();
}
//# sourceMappingURL=throttleTime.js.map

/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var async_1 = __webpack_require__(9);
var isDate_1 = __webpack_require__(26);
var Subscriber_1 = __webpack_require__(1);
var TimeoutError_1 = __webpack_require__(60);
/**
 * @param {number} due
 * @param {Scheduler} [scheduler]
 * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
 * @method timeout
 * @owner Observable
 */
function timeout(due, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    var absoluteTimeout = isDate_1.isDate(due);
    var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);
    return this.lift(new TimeoutOperator(waitFor, absoluteTimeout, scheduler, new TimeoutError_1.TimeoutError()));
}
exports.timeout = timeout;
var TimeoutOperator = (function () {
    function TimeoutOperator(waitFor, absoluteTimeout, scheduler, errorInstance) {
        this.waitFor = waitFor;
        this.absoluteTimeout = absoluteTimeout;
        this.scheduler = scheduler;
        this.errorInstance = errorInstance;
    }
    TimeoutOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TimeoutSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.scheduler, this.errorInstance));
    };
    return TimeoutOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TimeoutSubscriber = (function (_super) {
    __extends(TimeoutSubscriber, _super);
    function TimeoutSubscriber(destination, absoluteTimeout, waitFor, scheduler, errorInstance) {
        _super.call(this, destination);
        this.absoluteTimeout = absoluteTimeout;
        this.waitFor = waitFor;
        this.scheduler = scheduler;
        this.errorInstance = errorInstance;
        this.index = 0;
        this._previousIndex = 0;
        this._hasCompleted = false;
        this.scheduleTimeout();
    }
    Object.defineProperty(TimeoutSubscriber.prototype, "previousIndex", {
        get: function () {
            return this._previousIndex;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeoutSubscriber.prototype, "hasCompleted", {
        get: function () {
            return this._hasCompleted;
        },
        enumerable: true,
        configurable: true
    });
    TimeoutSubscriber.dispatchTimeout = function (state) {
        var source = state.subscriber;
        var currentIndex = state.index;
        if (!source.hasCompleted && source.previousIndex === currentIndex) {
            source.notifyTimeout();
        }
    };
    TimeoutSubscriber.prototype.scheduleTimeout = function () {
        var currentIndex = this.index;
        this.scheduler.schedule(TimeoutSubscriber.dispatchTimeout, this.waitFor, { subscriber: this, index: currentIndex });
        this.index++;
        this._previousIndex = currentIndex;
    };
    TimeoutSubscriber.prototype._next = function (value) {
        this.destination.next(value);
        if (!this.absoluteTimeout) {
            this.scheduleTimeout();
        }
    };
    TimeoutSubscriber.prototype._error = function (err) {
        this.destination.error(err);
        this._hasCompleted = true;
    };
    TimeoutSubscriber.prototype._complete = function () {
        this.destination.complete();
        this._hasCompleted = true;
    };
    TimeoutSubscriber.prototype.notifyTimeout = function () {
        this.error(this.errorInstance);
    };
    return TimeoutSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=timeout.js.map

/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var async_1 = __webpack_require__(9);
var isDate_1 = __webpack_require__(26);
var OuterSubscriber_1 = __webpack_require__(2);
var subscribeToResult_1 = __webpack_require__(3);
/* tslint:enable:max-line-length */
/**
 * @param due
 * @param withObservable
 * @param scheduler
 * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
 * @method timeoutWith
 * @owner Observable
 */
function timeoutWith(due, withObservable, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    var absoluteTimeout = isDate_1.isDate(due);
    var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);
    return this.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
}
exports.timeoutWith = timeoutWith;
var TimeoutWithOperator = (function () {
    function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {
        this.waitFor = waitFor;
        this.absoluteTimeout = absoluteTimeout;
        this.withObservable = withObservable;
        this.scheduler = scheduler;
    }
    TimeoutWithOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
    };
    return TimeoutWithOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TimeoutWithSubscriber = (function (_super) {
    __extends(TimeoutWithSubscriber, _super);
    function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
        _super.call(this);
        this.destination = destination;
        this.absoluteTimeout = absoluteTimeout;
        this.waitFor = waitFor;
        this.withObservable = withObservable;
        this.scheduler = scheduler;
        this.timeoutSubscription = undefined;
        this.index = 0;
        this._previousIndex = 0;
        this._hasCompleted = false;
        destination.add(this);
        this.scheduleTimeout();
    }
    Object.defineProperty(TimeoutWithSubscriber.prototype, "previousIndex", {
        get: function () {
            return this._previousIndex;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeoutWithSubscriber.prototype, "hasCompleted", {
        get: function () {
            return this._hasCompleted;
        },
        enumerable: true,
        configurable: true
    });
    TimeoutWithSubscriber.dispatchTimeout = function (state) {
        var source = state.subscriber;
        var currentIndex = state.index;
        if (!source.hasCompleted && source.previousIndex === currentIndex) {
            source.handleTimeout();
        }
    };
    TimeoutWithSubscriber.prototype.scheduleTimeout = function () {
        var currentIndex = this.index;
        var timeoutState = { subscriber: this, index: currentIndex };
        this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, timeoutState);
        this.index++;
        this._previousIndex = currentIndex;
    };
    TimeoutWithSubscriber.prototype._next = function (value) {
        this.destination.next(value);
        if (!this.absoluteTimeout) {
            this.scheduleTimeout();
        }
    };
    TimeoutWithSubscriber.prototype._error = function (err) {
        this.destination.error(err);
        this._hasCompleted = true;
    };
    TimeoutWithSubscriber.prototype._complete = function () {
        this.destination.complete();
        this._hasCompleted = true;
    };
    TimeoutWithSubscriber.prototype.handleTimeout = function () {
        if (!this.closed) {
            var withObservable = this.withObservable;
            this.unsubscribe();
            this.destination.add(this.timeoutSubscription = subscribeToResult_1.subscribeToResult(this, withObservable));
        }
    };
    return TimeoutWithSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=timeoutWith.js.map

/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(1);
/**
 * @return {Observable<any[]>|WebSocketSubject<T>|Observable<T>}
 * @method toArray
 * @owner Observable
 */
function toArray() {
    return this.lift(new ToArrayOperator());
}
exports.toArray = toArray;
var ToArrayOperator = (function () {
    function ToArrayOperator() {
    }
    ToArrayOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ToArraySubscriber(subscriber));
    };
    return ToArrayOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ToArraySubscriber = (function (_super) {
    __extends(ToArraySubscriber, _super);
    function ToArraySubscriber(destination) {
        _super.call(this, destination);
        this.array = [];
    }
    ToArraySubscriber.prototype._next = function (x) {
        this.array.push(x);
    };
    ToArraySubscriber.prototype._complete = function () {
        this.destination.next(this.array);
        this.destination.complete();
    };
    return ToArraySubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=toArray.js.map

/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var root_1 = __webpack_require__(7);
/* tslint:enable:max-line-length */
/**
 * Converts an Observable sequence to a ES2015 compliant promise.
 *
 * @example
 * // Using normal ES2015
 * let source = Rx.Observable
 *   .just(42)
 *   .toPromise();
 *
 * source.then((value) => console.log('Value: %s', value));
 * // => Value: 42
 *
 * // Rejected Promise
 * // Using normal ES2015
 * let source = Rx.Observable
 *   .throw(new Error('woops'))
 *   .toPromise();
 *
 * source
 *   .then((value) => console.log('Value: %s', value))
 *   .catch((err) => console.log('Error: %s', err));
 * // => Error: Error: woops
 *
 * // Setting via the config
 * Rx.config.Promise = RSVP.Promise;
 *
 * let source = Rx.Observable
 *   .of(42)
 *   .toPromise();
 *
 * source.then((value) => console.log('Value: %s', value));
 * // => Value: 42
 *
 * // Setting via the method
 * let source = Rx.Observable
 *   .just(42)
 *   .toPromise(RSVP.Promise);
 *
 * source.then((value) => console.log('Value: %s', value));
 * // => Value: 42
 *
 * @param PromiseCtor promise The constructor of the promise. If not provided,
 * it will look for a constructor first in Rx.config.Promise then fall back to
 * the native Promise constructor if available.
 * @return {Promise<T>} An ES2015 compatible promise with the last value from
 * the observable sequence.
 * @method toPromise
 * @owner Observable
 */
function toPromise(PromiseCtor) {
    var _this = this;
    if (!PromiseCtor) {
        if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
            PromiseCtor = root_1.root.Rx.config.Promise;
        }
        else if (root_1.root.Promise) {
            PromiseCtor = root_1.root.Promise;
        }
    }
    if (!PromiseCtor) {
        throw new Error('no Promise impl found');
    }
    return new PromiseCtor(function (resolve, reject) {
        var value;
        _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
    });
}
exports.toPromise = toPromise;
//# sourceMappingURL=toPromise.js.map

/***/ }),
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = __webpack_require__(5);
var OuterSubscriber_1 = __webpack_require__(2);
var subscribeToResult_1 = __webpack_require__(3);
/**
 * Branch out the source Observable values as a nested Observable whenever
 * `windowBoundaries` emits.
 *
 * <span class="informal">It's like {@link buffer}, but emits a nested Observable
 * instead of an array.</span>
 *
 * <img src="./img/window.png" width="100%">
 *
 * Returns an Observable that emits windows of items it collects from the source
 * Observable. The output Observable emits connected, non-overlapping
 * windows. It emits the current window and opens a new one whenever the
 * Observable `windowBoundaries` emits an item. Because each window is an
 * Observable, the output is a higher-order Observable.
 *
 * @example <caption>In every window of 1 second each, emit at most 2 click events</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var interval = Rx.Observable.interval(1000);
 * var result = clicks.window(interval)
 *   .map(win => win.take(2)) // each window has at most 2 emissions
 *   .mergeAll(); // flatten the Observable-of-Observables
 * result.subscribe(x => console.log(x));
 *
 * @see {@link windowCount}
 * @see {@link windowTime}
 * @see {@link windowToggle}
 * @see {@link windowWhen}
 * @see {@link buffer}
 *
 * @param {Observable<any>} windowBoundaries An Observable that completes the
 * previous window and starts a new window.
 * @return {Observable<Observable<T>>} An Observable of windows, which are
 * Observables emitting values of the source Observable.
 * @method window
 * @owner Observable
 */
function window(windowBoundaries) {
    return this.lift(new WindowOperator(windowBoundaries));
}
exports.window = window;
var WindowOperator = (function () {
    function WindowOperator(windowBoundaries) {
        this.windowBoundaries = windowBoundaries;
    }
    WindowOperator.prototype.call = function (subscriber, source) {
        var windowSubscriber = new WindowSubscriber(subscriber);
        var sourceSubscription = source.subscribe(windowSubscriber);
        if (!sourceSubscription.closed) {
            windowSubscriber.add(subscribeToResult_1.subscribeToResult(windowSubscriber, this.windowBoundaries));
        }
        return sourceSubscription;
    };
    return WindowOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WindowSubscriber = (function (_super) {
    __extends(WindowSubscriber, _super);
    function WindowSubscriber(destination) {
        _super.call(this, destination);
        this.window = new Subject_1.Subject();
        destination.next(this.window);
    }
    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openWindow();
    };
    WindowSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
        this._complete();
    };
    WindowSubscriber.prototype._next = function (value) {
        this.window.next(value);
    };
    WindowSubscriber.prototype._error = function (err) {
        this.window.error(err);
        this.destination.error(err);
    };
    WindowSubscriber.prototype._complete = function () {
        this.window.complete();
        this.destination.complete();
    };
    WindowSubscriber.prototype._unsubscribe = function () {
        this.window = null;
    };
    WindowSubscriber.prototype.openWindow = function () {
        var prevWindow = this.window;
        if (prevWindow) {
            prevWindow.complete();
        }
        var destination = this.destination;
        var newWindow = this.window = new Subject_1.Subject();
        destination.next(newWindow);
    };
    return WindowSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=window.js.map

/***/ }),
/* 327 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(1);
var Subject_1 = __webpack_require__(5);
/**
 * Branch out the source Observable values as a nested Observable with each
 * nested Observable emitting at most `windowSize` values.
 *
 * <span class="informal">It's like {@link bufferCount}, but emits a nested
 * Observable instead of an array.</span>
 *
 * <img src="./img/windowCount.png" width="100%">
 *
 * Returns an Observable that emits windows of items it collects from the source
 * Observable. The output Observable emits windows every `startWindowEvery`
 * items, each containing no more than `windowSize` items. When the source
 * Observable completes or encounters an error, the output Observable emits
 * the current window and propagates the notification from the source
 * Observable. If `startWindowEvery` is not provided, then new windows are
 * started immediately at the start of the source and when each window completes
 * with size `windowSize`.
 *
 * @example <caption>Ignore every 3rd click event, starting from the first one</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.windowCount(3)
 *   .map(win => win.skip(1)) // skip first of every 3 clicks
 *   .mergeAll(); // flatten the Observable-of-Observables
 * result.subscribe(x => console.log(x));
 *
 * @example <caption>Ignore every 3rd click event, starting from the third one</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.windowCount(2, 3)
 *   .mergeAll(); // flatten the Observable-of-Observables
 * result.subscribe(x => console.log(x));
 *
 * @see {@link window}
 * @see {@link windowTime}
 * @see {@link windowToggle}
 * @see {@link windowWhen}
 * @see {@link bufferCount}
 *
 * @param {number} windowSize The maximum number of values emitted by each
 * window.
 * @param {number} [startWindowEvery] Interval at which to start a new window.
 * For example if `startWindowEvery` is `2`, then a new window will be started
 * on every other value from the source. A new window is started at the
 * beginning of the source by default.
 * @return {Observable<Observable<T>>} An Observable of windows, which in turn
 * are Observable of values.
 * @method windowCount
 * @owner Observable
 */
function windowCount(windowSize, startWindowEvery) {
    if (startWindowEvery === void 0) { startWindowEvery = 0; }
    return this.lift(new WindowCountOperator(windowSize, startWindowEvery));
}
exports.windowCount = windowCount;
var WindowCountOperator = (function () {
    function WindowCountOperator(windowSize, startWindowEvery) {
        this.windowSize = windowSize;
        this.startWindowEvery = startWindowEvery;
    }
    WindowCountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));
    };
    return WindowCountOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WindowCountSubscriber = (function (_super) {
    __extends(WindowCountSubscriber, _super);
    function WindowCountSubscriber(destination, windowSize, startWindowEvery) {
        _super.call(this, destination);
        this.destination = destination;
        this.windowSize = windowSize;
        this.startWindowEvery = startWindowEvery;
        this.windows = [new Subject_1.Subject()];
        this.count = 0;
        destination.next(this.windows[0]);
    }
    WindowCountSubscriber.prototype._next = function (value) {
        var startWindowEvery = (this.startWindowEvery > 0) ? this.startWindowEvery : this.windowSize;
        var destination = this.destination;
        var windowSize = this.windowSize;
        var windows = this.windows;
        var len = windows.length;
        for (var i = 0; i < len && !this.closed; i++) {
            windows[i].next(value);
        }
        var c = this.count - windowSize + 1;
        if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {
            windows.shift().complete();
        }
        if (++this.count % startWindowEvery === 0 && !this.closed) {
            var window_1 = new Subject_1.Subject();
            windows.push(window_1);
            destination.next(window_1);
        }
    };
    WindowCountSubscriber.prototype._error = function (err) {
        var windows = this.windows;
        if (windows) {
            while (windows.length > 0 && !this.closed) {
                windows.shift().error(err);
            }
        }
        this.destination.error(err);
    };
    WindowCountSubscriber.prototype._complete = function () {
        var windows = this.windows;
        if (windows) {
            while (windows.length > 0 && !this.closed) {
                windows.shift().complete();
            }
        }
        this.destination.complete();
    };
    WindowCountSubscriber.prototype._unsubscribe = function () {
        this.count = 0;
        this.windows = null;
    };
    return WindowCountSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=windowCount.js.map

/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = __webpack_require__(5);
var async_1 = __webpack_require__(9);
var Subscriber_1 = __webpack_require__(1);
var isNumeric_1 = __webpack_require__(28);
var isScheduler_1 = __webpack_require__(12);
function windowTime(windowTimeSpan) {
    var scheduler = async_1.async;
    var windowCreationInterval = null;
    var maxWindowSize = Number.POSITIVE_INFINITY;
    if (isScheduler_1.isScheduler(arguments[3])) {
        scheduler = arguments[3];
    }
    if (isScheduler_1.isScheduler(arguments[2])) {
        scheduler = arguments[2];
    }
    else if (isNumeric_1.isNumeric(arguments[2])) {
        maxWindowSize = arguments[2];
    }
    if (isScheduler_1.isScheduler(arguments[1])) {
        scheduler = arguments[1];
    }
    else if (isNumeric_1.isNumeric(arguments[1])) {
        windowCreationInterval = arguments[1];
    }
    return this.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));
}
exports.windowTime = windowTime;
var WindowTimeOperator = (function () {
    function WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        this.windowTimeSpan = windowTimeSpan;
        this.windowCreationInterval = windowCreationInterval;
        this.maxWindowSize = maxWindowSize;
        this.scheduler = scheduler;
    }
    WindowTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
    };
    return WindowTimeOperator;
}());
var CountedSubject = (function (_super) {
    __extends(CountedSubject, _super);
    function CountedSubject() {
        _super.apply(this, arguments);
        this._numberOfNextedValues = 0;
    }
    CountedSubject.prototype.next = function (value) {
        this._numberOfNextedValues++;
        _super.prototype.next.call(this, value);
    };
    Object.defineProperty(CountedSubject.prototype, "numberOfNextedValues", {
        get: function () {
            return this._numberOfNextedValues;
        },
        enumerable: true,
        configurable: true
    });
    return CountedSubject;
}(Subject_1.Subject));
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WindowTimeSubscriber = (function (_super) {
    __extends(WindowTimeSubscriber, _super);
    function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        _super.call(this, destination);
        this.destination = destination;
        this.windowTimeSpan = windowTimeSpan;
        this.windowCreationInterval = windowCreationInterval;
        this.maxWindowSize = maxWindowSize;
        this.scheduler = scheduler;
        this.windows = [];
        var window = this.openWindow();
        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
            var closeState = { subscriber: this, window: window, context: null };
            var creationState = { windowTimeSpan: windowTimeSpan, windowCreationInterval: windowCreationInterval, subscriber: this, scheduler: scheduler };
            this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));
            this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
        }
        else {
            var timeSpanOnlyState = { subscriber: this, window: window, windowTimeSpan: windowTimeSpan };
            this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
        }
    }
    WindowTimeSubscriber.prototype._next = function (value) {
        var windows = this.windows;
        var len = windows.length;
        for (var i = 0; i < len; i++) {
            var window_1 = windows[i];
            if (!window_1.closed) {
                window_1.next(value);
                if (window_1.numberOfNextedValues >= this.maxWindowSize) {
                    this.closeWindow(window_1);
                }
            }
        }
    };
    WindowTimeSubscriber.prototype._error = function (err) {
        var windows = this.windows;
        while (windows.length > 0) {
            windows.shift().error(err);
        }
        this.destination.error(err);
    };
    WindowTimeSubscriber.prototype._complete = function () {
        var windows = this.windows;
        while (windows.length > 0) {
            var window_2 = windows.shift();
            if (!window_2.closed) {
                window_2.complete();
            }
        }
        this.destination.complete();
    };
    WindowTimeSubscriber.prototype.openWindow = function () {
        var window = new CountedSubject();
        this.windows.push(window);
        var destination = this.destination;
        destination.next(window);
        return window;
    };
    WindowTimeSubscriber.prototype.closeWindow = function (window) {
        window.complete();
        var windows = this.windows;
        windows.splice(windows.indexOf(window), 1);
    };
    return WindowTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchWindowTimeSpanOnly(state) {
    var subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan, window = state.window;
    if (window) {
        subscriber.closeWindow(window);
    }
    state.window = subscriber.openWindow();
    this.schedule(state, windowTimeSpan);
}
function dispatchWindowCreation(state) {
    var windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval;
    var window = subscriber.openWindow();
    var action = this;
    var context = { action: action, subscription: null };
    var timeSpanState = { subscriber: subscriber, window: window, context: context };
    context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
    action.add(context.subscription);
    action.schedule(state, windowCreationInterval);
}
function dispatchWindowClose(state) {
    var subscriber = state.subscriber, window = state.window, context = state.context;
    if (context && context.action && context.subscription) {
        context.action.remove(context.subscription);
    }
    subscriber.closeWindow(window);
}
//# sourceMappingURL=windowTime.js.map

/***/ }),
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = __webpack_require__(5);
var Subscription_1 = __webpack_require__(4);
var tryCatch_1 = __webpack_require__(8);
var errorObject_1 = __webpack_require__(6);
var OuterSubscriber_1 = __webpack_require__(2);
var subscribeToResult_1 = __webpack_require__(3);
/**
 * Branch out the source Observable values as a nested Observable starting from
 * an emission from `openings` and ending when the output of `closingSelector`
 * emits.
 *
 * <span class="informal">It's like {@link bufferToggle}, but emits a nested
 * Observable instead of an array.</span>
 *
 * <img src="./img/windowToggle.png" width="100%">
 *
 * Returns an Observable that emits windows of items it collects from the source
 * Observable. The output Observable emits windows that contain those items
 * emitted by the source Observable between the time when the `openings`
 * Observable emits an item and when the Observable returned by
 * `closingSelector` emits an item.
 *
 * @example <caption>Every other second, emit the click events from the next 500ms</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var openings = Rx.Observable.interval(1000);
 * var result = clicks.windowToggle(openings, i =>
 *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()
 * ).mergeAll();
 * result.subscribe(x => console.log(x));
 *
 * @see {@link window}
 * @see {@link windowCount}
 * @see {@link windowTime}
 * @see {@link windowWhen}
 * @see {@link bufferToggle}
 *
 * @param {Observable<O>} openings An observable of notifications to start new
 * windows.
 * @param {function(value: O): Observable} closingSelector A function that takes
 * the value emitted by the `openings` observable and returns an Observable,
 * which, when it emits (either `next` or `complete`), signals that the
 * associated window should complete.
 * @return {Observable<Observable<T>>} An observable of windows, which in turn
 * are Observables.
 * @method windowToggle
 * @owner Observable
 */
function windowToggle(openings, closingSelector) {
    return this.lift(new WindowToggleOperator(openings, closingSelector));
}
exports.windowToggle = windowToggle;
var WindowToggleOperator = (function () {
    function WindowToggleOperator(openings, closingSelector) {
        this.openings = openings;
        this.closingSelector = closingSelector;
    }
    WindowToggleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));
    };
    return WindowToggleOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WindowToggleSubscriber = (function (_super) {
    __extends(WindowToggleSubscriber, _super);
    function WindowToggleSubscriber(destination, openings, closingSelector) {
        _super.call(this, destination);
        this.openings = openings;
        this.closingSelector = closingSelector;
        this.contexts = [];
        this.add(this.openSubscription = subscribeToResult_1.subscribeToResult(this, openings, openings));
    }
    WindowToggleSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        if (contexts) {
            var len = contexts.length;
            for (var i = 0; i < len; i++) {
                contexts[i].window.next(value);
            }
        }
    };
    WindowToggleSubscriber.prototype._error = function (err) {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context = contexts[index];
                context.window.error(err);
                context.subscription.unsubscribe();
            }
        }
        _super.prototype._error.call(this, err);
    };
    WindowToggleSubscriber.prototype._complete = function () {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context = contexts[index];
                context.window.complete();
                context.subscription.unsubscribe();
            }
        }
        _super.prototype._complete.call(this);
    };
    WindowToggleSubscriber.prototype._unsubscribe = function () {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context = contexts[index];
                context.window.unsubscribe();
                context.subscription.unsubscribe();
            }
        }
    };
    WindowToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (outerValue === this.openings) {
            var closingSelector = this.closingSelector;
            var closingNotifier = tryCatch_1.tryCatch(closingSelector)(innerValue);
            if (closingNotifier === errorObject_1.errorObject) {
                return this.error(errorObject_1.errorObject.e);
            }
            else {
                var window_1 = new Subject_1.Subject();
                var subscription = new Subscription_1.Subscription();
                var context = { window: window_1, subscription: subscription };
                this.contexts.push(context);
                var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);
                if (innerSubscription.closed) {
                    this.closeWindow(this.contexts.length - 1);
                }
                else {
                    innerSubscription.context = context;
                    subscription.add(innerSubscription);
                }
                this.destination.next(window_1);
            }
        }
        else {
            this.closeWindow(this.contexts.indexOf(outerValue));
        }
    };
    WindowToggleSubscriber.prototype.notifyError = function (err) {
        this.error(err);
    };
    WindowToggleSubscriber.prototype.notifyComplete = function (inner) {
        if (inner !== this.openSubscription) {
            this.closeWindow(this.contexts.indexOf(inner.context));
        }
    };
    WindowToggleSubscriber.prototype.closeWindow = function (index) {
        if (index === -1) {
            return;
        }
        var contexts = this.contexts;
        var context = contexts[index];
        var window = context.window, subscription = context.subscription;
        contexts.splice(index, 1);
        window.complete();
        subscription.unsubscribe();
    };
    return WindowToggleSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=windowToggle.js.map

/***/ }),
/* 330 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = __webpack_require__(5);
var tryCatch_1 = __webpack_require__(8);
var errorObject_1 = __webpack_require__(6);
var OuterSubscriber_1 = __webpack_require__(2);
var subscribeToResult_1 = __webpack_require__(3);
/**
 * Branch out the source Observable values as a nested Observable using a
 * factory function of closing Observables to determine when to start a new
 * window.
 *
 * <span class="informal">It's like {@link bufferWhen}, but emits a nested
 * Observable instead of an array.</span>
 *
 * <img src="./img/windowWhen.png" width="100%">
 *
 * Returns an Observable that emits windows of items it collects from the source
 * Observable. The output Observable emits connected, non-overlapping windows.
 * It emits the current window and opens a new one whenever the Observable
 * produced by the specified `closingSelector` function emits an item. The first
 * window is opened immediately when subscribing to the output Observable.
 *
 * @example <caption>Emit only the first two clicks events in every window of [1-5] random seconds</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks
 *   .windowWhen(() => Rx.Observable.interval(1000 + Math.random() * 4000))
 *   .map(win => win.take(2)) // each window has at most 2 emissions
 *   .mergeAll(); // flatten the Observable-of-Observables
 * result.subscribe(x => console.log(x));
 *
 * @see {@link window}
 * @see {@link windowCount}
 * @see {@link windowTime}
 * @see {@link windowToggle}
 * @see {@link bufferWhen}
 *
 * @param {function(): Observable} closingSelector A function that takes no
 * arguments and returns an Observable that signals (on either `next` or
 * `complete`) when to close the previous window and start a new one.
 * @return {Observable<Observable<T>>} An observable of windows, which in turn
 * are Observables.
 * @method windowWhen
 * @owner Observable
 */
function windowWhen(closingSelector) {
    return this.lift(new WindowOperator(closingSelector));
}
exports.windowWhen = windowWhen;
var WindowOperator = (function () {
    function WindowOperator(closingSelector) {
        this.closingSelector = closingSelector;
    }
    WindowOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowSubscriber(subscriber, this.closingSelector));
    };
    return WindowOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WindowSubscriber = (function (_super) {
    __extends(WindowSubscriber, _super);
    function WindowSubscriber(destination, closingSelector) {
        _super.call(this, destination);
        this.destination = destination;
        this.closingSelector = closingSelector;
        this.openWindow();
    }
    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openWindow(innerSub);
    };
    WindowSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
        this.openWindow(innerSub);
    };
    WindowSubscriber.prototype._next = function (value) {
        this.window.next(value);
    };
    WindowSubscriber.prototype._error = function (err) {
        this.window.error(err);
        this.destination.error(err);
        this.unsubscribeClosingNotification();
    };
    WindowSubscriber.prototype._complete = function () {
        this.window.complete();
        this.destination.complete();
        this.unsubscribeClosingNotification();
    };
    WindowSubscriber.prototype.unsubscribeClosingNotification = function () {
        if (this.closingNotification) {
            this.closingNotification.unsubscribe();
        }
    };
    WindowSubscriber.prototype.openWindow = function (innerSub) {
        if (innerSub === void 0) { innerSub = null; }
        if (innerSub) {
            this.remove(innerSub);
            innerSub.unsubscribe();
        }
        var prevWindow = this.window;
        if (prevWindow) {
            prevWindow.complete();
        }
        var window = this.window = new Subject_1.Subject();
        this.destination.next(window);
        var closingNotifier = tryCatch_1.tryCatch(this.closingSelector)();
        if (closingNotifier === errorObject_1.errorObject) {
            var err = errorObject_1.errorObject.e;
            this.destination.error(err);
            this.window.error(err);
        }
        else {
            this.add(this.closingNotification = subscribeToResult_1.subscribeToResult(this, closingNotifier));
        }
    };
    return WindowSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=windowWhen.js.map

/***/ }),
/* 331 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(2);
var subscribeToResult_1 = __webpack_require__(3);
/* tslint:enable:max-line-length */
/**
 * Combines the source Observable with other Observables to create an Observable
 * whose values are calculated from the latest values of each, only when the
 * source emits.
 *
 * <span class="informal">Whenever the source Observable emits a value, it
 * computes a formula using that value plus the latest values from other input
 * Observables, then emits the output of that formula.</span>
 *
 * <img src="./img/withLatestFrom.png" width="100%">
 *
 * `withLatestFrom` combines each value from the source Observable (the
 * instance) with the latest values from the other input Observables only when
 * the source emits a value, optionally using a `project` function to determine
 * the value to be emitted on the output Observable. All input Observables must
 * emit at least one value before the output Observable will emit a value.
 *
 * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var timer = Rx.Observable.interval(1000);
 * var result = clicks.withLatestFrom(timer);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link combineLatest}
 *
 * @param {ObservableInput} other An input Observable to combine with the source
 * Observable. More than one input Observables may be given as argument.
 * @param {Function} [project] Projection function for combining values
 * together. Receives all values in order of the Observables passed, where the
 * first parameter is a value from the source Observable. (e.g.
 * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not
 * passed, arrays will be emitted on the output Observable.
 * @return {Observable} An Observable of projected values from the most recent
 * values from each input Observable, or an array of the most recent values from
 * each input Observable.
 * @method withLatestFrom
 * @owner Observable
 */
function withLatestFrom() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i - 0] = arguments[_i];
    }
    var project;
    if (typeof args[args.length - 1] === 'function') {
        project = args.pop();
    }
    var observables = args;
    return this.lift(new WithLatestFromOperator(observables, project));
}
exports.withLatestFrom = withLatestFrom;
var WithLatestFromOperator = (function () {
    function WithLatestFromOperator(observables, project) {
        this.observables = observables;
        this.project = project;
    }
    WithLatestFromOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
    };
    return WithLatestFromOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WithLatestFromSubscriber = (function (_super) {
    __extends(WithLatestFromSubscriber, _super);
    function WithLatestFromSubscriber(destination, observables, project) {
        _super.call(this, destination);
        this.observables = observables;
        this.project = project;
        this.toRespond = [];
        var len = observables.length;
        this.values = new Array(len);
        for (var i = 0; i < len; i++) {
            this.toRespond.push(i);
        }
        for (var i = 0; i < len; i++) {
            var observable = observables[i];
            this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));
        }
    }
    WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values[outerIndex] = innerValue;
        var toRespond = this.toRespond;
        if (toRespond.length > 0) {
            var found = toRespond.indexOf(outerIndex);
            if (found !== -1) {
                toRespond.splice(found, 1);
            }
        }
    };
    WithLatestFromSubscriber.prototype.notifyComplete = function () {
        // noop
    };
    WithLatestFromSubscriber.prototype._next = function (value) {
        if (this.toRespond.length === 0) {
            var args = [value].concat(this.values);
            if (this.project) {
                this._tryProject(args);
            }
            else {
                this.destination.next(args);
            }
        }
    };
    WithLatestFromSubscriber.prototype._tryProject = function (args) {
        var result;
        try {
            result = this.project.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return WithLatestFromSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=withLatestFrom.js.map

/***/ }),
/* 332 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var zip_1 = __webpack_require__(36);
/**
 * @param project
 * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
 * @method zipAll
 * @owner Observable
 */
function zipAll(project) {
    return this.lift(new zip_1.ZipOperator(project));
}
exports.zipAll = zipAll;
//# sourceMappingURL=zipAll.js.map

/***/ }),
/* 333 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1 = __webpack_require__(4);
/**
 * A unit of work to be executed in a {@link Scheduler}. An action is typically
 * created from within a Scheduler and an RxJS user does not need to concern
 * themselves about creating and manipulating an Action.
 *
 * ```ts
 * class Action<T> extends Subscription {
 *   new (scheduler: Scheduler, work: (state?: T) => void);
 *   schedule(state?: T, delay: number = 0): Subscription;
 * }
 * ```
 *
 * @class Action<T>
 */
var Action = (function (_super) {
    __extends(Action, _super);
    function Action(scheduler, work) {
        _super.call(this);
    }
    /**
     * Schedules this action on its parent Scheduler for execution. May be passed
     * some context object, `state`. May happen at some point in the future,
     * according to the `delay` parameter, if specified.
     * @param {T} [state] Some contextual data that the `work` function uses when
     * called by the Scheduler.
     * @param {number} [delay] Time to wait before executing the work, where the
     * time unit is implicit and defined by the Scheduler.
     * @return {void}
     */
    Action.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        return this;
    };
    return Action;
}(Subscription_1.Subscription));
exports.Action = Action;
//# sourceMappingURL=Action.js.map

/***/ }),
/* 334 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var AsyncAction_1 = __webpack_require__(16);
var AnimationFrame_1 = __webpack_require__(344);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AnimationFrameAction = (function (_super) {
    __extends(AnimationFrameAction, _super);
    function AnimationFrameAction(scheduler, work) {
        _super.call(this, scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
    }
    AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        // If delay is greater than 0, request as an async action.
        if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        // Push the action to the end of the scheduler queue.
        scheduler.actions.push(this);
        // If an animation frame has already been requested, don't request another
        // one. If an animation frame hasn't been requested yet, request one. Return
        // the current animation frame request id.
        return scheduler.scheduled || (scheduler.scheduled = AnimationFrame_1.AnimationFrame.requestAnimationFrame(scheduler.flush.bind(scheduler, null)));
    };
    AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        // If delay exists and is greater than 0, or if the delay is null (the
        // action wasn't rescheduled) but was originally scheduled as an async
        // action, then recycle as an async action.
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        // If the scheduler queue is empty, cancel the requested animation frame and
        // set the scheduled flag to undefined so the next AnimationFrameAction will
        // request its own.
        if (scheduler.actions.length === 0) {
            AnimationFrame_1.AnimationFrame.cancelAnimationFrame(id);
            scheduler.scheduled = undefined;
        }
        // Return undefined so the action knows to request a new async id if it's rescheduled.
        return undefined;
    };
    return AnimationFrameAction;
}(AsyncAction_1.AsyncAction));
exports.AnimationFrameAction = AnimationFrameAction;
//# sourceMappingURL=AnimationFrameAction.js.map

/***/ }),
/* 335 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var AsyncScheduler_1 = __webpack_require__(17);
var AnimationFrameScheduler = (function (_super) {
    __extends(AnimationFrameScheduler, _super);
    function AnimationFrameScheduler() {
        _super.apply(this, arguments);
    }
    AnimationFrameScheduler.prototype.flush = function (action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (++index < count && (action = actions.shift()));
        this.active = false;
        if (error) {
            while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AnimationFrameScheduler;
}(AsyncScheduler_1.AsyncScheduler));
exports.AnimationFrameScheduler = AnimationFrameScheduler;
//# sourceMappingURL=AnimationFrameScheduler.js.map

/***/ }),
/* 336 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Immediate_1 = __webpack_require__(346);
var AsyncAction_1 = __webpack_require__(16);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AsapAction = (function (_super) {
    __extends(AsapAction, _super);
    function AsapAction(scheduler, work) {
        _super.call(this, scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
    }
    AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        // If delay is greater than 0, request as an async action.
        if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        // Push the action to the end of the scheduler queue.
        scheduler.actions.push(this);
        // If a microtask has already been scheduled, don't schedule another
        // one. If a microtask hasn't been scheduled yet, schedule one now. Return
        // the current scheduled microtask id.
        return scheduler.scheduled || (scheduler.scheduled = Immediate_1.Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
    };
    AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        // If delay exists and is greater than 0, or if the delay is null (the
        // action wasn't rescheduled) but was originally scheduled as an async
        // action, then recycle as an async action.
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        // If the scheduler queue is empty, cancel the requested microtask and
        // set the scheduled flag to undefined so the next AsapAction will schedule
        // its own.
        if (scheduler.actions.length === 0) {
            Immediate_1.Immediate.clearImmediate(id);
            scheduler.scheduled = undefined;
        }
        // Return undefined so the action knows to request a new async id if it's rescheduled.
        return undefined;
    };
    return AsapAction;
}(AsyncAction_1.AsyncAction));
exports.AsapAction = AsapAction;
//# sourceMappingURL=AsapAction.js.map

/***/ }),
/* 337 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var AsyncScheduler_1 = __webpack_require__(17);
var AsapScheduler = (function (_super) {
    __extends(AsapScheduler, _super);
    function AsapScheduler() {
        _super.apply(this, arguments);
    }
    AsapScheduler.prototype.flush = function (action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (++index < count && (action = actions.shift()));
        this.active = false;
        if (error) {
            while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsapScheduler;
}(AsyncScheduler_1.AsyncScheduler));
exports.AsapScheduler = AsapScheduler;
//# sourceMappingURL=AsapScheduler.js.map

/***/ }),
/* 338 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var AsyncAction_1 = __webpack_require__(16);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var QueueAction = (function (_super) {
    __extends(QueueAction, _super);
    function QueueAction(scheduler, work) {
        _super.call(this, scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
    }
    QueueAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        if (delay > 0) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.delay = delay;
        this.state = state;
        this.scheduler.flush(this);
        return this;
    };
    QueueAction.prototype.execute = function (state, delay) {
        return (delay > 0 || this.closed) ?
            _super.prototype.execute.call(this, state, delay) :
            this._execute(state, delay);
    };
    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        // If delay exists and is greater than 0, or if the delay is null (the
        // action wasn't rescheduled) but was originally scheduled as an async
        // action, then recycle as an async action.
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        // Otherwise flush the scheduler starting with this action.
        return scheduler.flush(this);
    };
    return QueueAction;
}(AsyncAction_1.AsyncAction));
exports.QueueAction = QueueAction;
//# sourceMappingURL=QueueAction.js.map

/***/ }),
/* 339 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var AsyncScheduler_1 = __webpack_require__(17);
var QueueScheduler = (function (_super) {
    __extends(QueueScheduler, _super);
    function QueueScheduler() {
        _super.apply(this, arguments);
    }
    return QueueScheduler;
}(AsyncScheduler_1.AsyncScheduler));
exports.QueueScheduler = QueueScheduler;
//# sourceMappingURL=QueueScheduler.js.map

/***/ }),
/* 340 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var AnimationFrameAction_1 = __webpack_require__(334);
var AnimationFrameScheduler_1 = __webpack_require__(335);
/**
 *
 * Animation Frame Scheduler
 *
 * <span class="informal">Perform task when `window.requestAnimationFrame` would fire</span>
 *
 * When `animationFrame` scheduler is used with delay, it will fall back to {@link async} scheduler
 * behaviour.
 *
 * Without delay, `animationFrame` scheduler can be used to create smooth browser animations.
 * It makes sure scheduled task will happen just before next browser content repaint,
 * thus performing animations as efficiently as possible.
 *
 * @example <caption>Schedule div height animation</caption>
 * const div = document.querySelector('.some-div');
 *
 * Rx.Scheduler.schedule(function(height) {
 *   div.style.height = height + "px";
 *
 *   this.schedule(height + 1);  // `this` references currently executing Action,
 *                               // which we reschedule with new state
 * }, 0, 0);
 *
 * // You will see .some-div element growing in height
 *
 *
 * @static true
 * @name animationFrame
 * @owner Scheduler
 */
exports.animationFrame = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);
//# sourceMappingURL=animationFrame.js.map

/***/ }),
/* 341 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(0);
var Subscription_1 = __webpack_require__(4);
var SubscriptionLoggable_1 = __webpack_require__(59);
var applyMixins_1 = __webpack_require__(62);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ColdObservable = (function (_super) {
    __extends(ColdObservable, _super);
    function ColdObservable(messages, scheduler) {
        _super.call(this, function (subscriber) {
            var observable = this;
            var index = observable.logSubscribedFrame();
            subscriber.add(new Subscription_1.Subscription(function () {
                observable.logUnsubscribedFrame(index);
            }));
            observable.scheduleMessages(subscriber);
            return subscriber;
        });
        this.messages = messages;
        this.subscriptions = [];
        this.scheduler = scheduler;
    }
    ColdObservable.prototype.scheduleMessages = function (subscriber) {
        var messagesLength = this.messages.length;
        for (var i = 0; i < messagesLength; i++) {
            var message = this.messages[i];
            subscriber.add(this.scheduler.schedule(function (_a) {
                var message = _a.message, subscriber = _a.subscriber;
                message.notification.observe(subscriber);
            }, message.frame, { message: message, subscriber: subscriber }));
        }
    };
    return ColdObservable;
}(Observable_1.Observable));
exports.ColdObservable = ColdObservable;
applyMixins_1.applyMixins(ColdObservable, [SubscriptionLoggable_1.SubscriptionLoggable]);
//# sourceMappingURL=ColdObservable.js.map

/***/ }),
/* 342 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = __webpack_require__(5);
var Subscription_1 = __webpack_require__(4);
var SubscriptionLoggable_1 = __webpack_require__(59);
var applyMixins_1 = __webpack_require__(62);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var HotObservable = (function (_super) {
    __extends(HotObservable, _super);
    function HotObservable(messages, scheduler) {
        _super.call(this);
        this.messages = messages;
        this.subscriptions = [];
        this.scheduler = scheduler;
    }
    HotObservable.prototype._subscribe = function (subscriber) {
        var subject = this;
        var index = subject.logSubscribedFrame();
        subscriber.add(new Subscription_1.Subscription(function () {
            subject.logUnsubscribedFrame(index);
        }));
        return _super.prototype._subscribe.call(this, subscriber);
    };
    HotObservable.prototype.setup = function () {
        var subject = this;
        var messagesLength = subject.messages.length;
        /* tslint:disable:no-var-keyword */
        for (var i = 0; i < messagesLength; i++) {
            (function () {
                var message = subject.messages[i];
                /* tslint:enable */
                subject.scheduler.schedule(function () { message.notification.observe(subject); }, message.frame);
            })();
        }
    };
    return HotObservable;
}(Subject_1.Subject));
exports.HotObservable = HotObservable;
applyMixins_1.applyMixins(HotObservable, [SubscriptionLoggable_1.SubscriptionLoggable]);
//# sourceMappingURL=HotObservable.js.map

/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(0);
var Notification_1 = __webpack_require__(15);
var ColdObservable_1 = __webpack_require__(341);
var HotObservable_1 = __webpack_require__(342);
var SubscriptionLog_1 = __webpack_require__(58);
var VirtualTimeScheduler_1 = __webpack_require__(55);
var defaultMaxFrame = 750;
var TestScheduler = (function (_super) {
    __extends(TestScheduler, _super);
    function TestScheduler(assertDeepEqual) {
        _super.call(this, VirtualTimeScheduler_1.VirtualAction, defaultMaxFrame);
        this.assertDeepEqual = assertDeepEqual;
        this.hotObservables = [];
        this.coldObservables = [];
        this.flushTests = [];
    }
    TestScheduler.prototype.createTime = function (marbles) {
        var indexOf = marbles.indexOf('|');
        if (indexOf === -1) {
            throw new Error('marble diagram for time should have a completion marker "|"');
        }
        return indexOf * TestScheduler.frameTimeFactor;
    };
    TestScheduler.prototype.createColdObservable = function (marbles, values, error) {
        if (marbles.indexOf('^') !== -1) {
            throw new Error('cold observable cannot have subscription offset "^"');
        }
        if (marbles.indexOf('!') !== -1) {
            throw new Error('cold observable cannot have unsubscription marker "!"');
        }
        var messages = TestScheduler.parseMarbles(marbles, values, error);
        var cold = new ColdObservable_1.ColdObservable(messages, this);
        this.coldObservables.push(cold);
        return cold;
    };
    TestScheduler.prototype.createHotObservable = function (marbles, values, error) {
        if (marbles.indexOf('!') !== -1) {
            throw new Error('hot observable cannot have unsubscription marker "!"');
        }
        var messages = TestScheduler.parseMarbles(marbles, values, error);
        var subject = new HotObservable_1.HotObservable(messages, this);
        this.hotObservables.push(subject);
        return subject;
    };
    TestScheduler.prototype.materializeInnerObservable = function (observable, outerFrame) {
        var _this = this;
        var messages = [];
        observable.subscribe(function (value) {
            messages.push({ frame: _this.frame - outerFrame, notification: Notification_1.Notification.createNext(value) });
        }, function (err) {
            messages.push({ frame: _this.frame - outerFrame, notification: Notification_1.Notification.createError(err) });
        }, function () {
            messages.push({ frame: _this.frame - outerFrame, notification: Notification_1.Notification.createComplete() });
        });
        return messages;
    };
    TestScheduler.prototype.expectObservable = function (observable, unsubscriptionMarbles) {
        var _this = this;
        if (unsubscriptionMarbles === void 0) { unsubscriptionMarbles = null; }
        var actual = [];
        var flushTest = { actual: actual, ready: false };
        var unsubscriptionFrame = TestScheduler
            .parseMarblesAsSubscriptions(unsubscriptionMarbles).unsubscribedFrame;
        var subscription;
        this.schedule(function () {
            subscription = observable.subscribe(function (x) {
                var value = x;
                // Support Observable-of-Observables
                if (x instanceof Observable_1.Observable) {
                    value = _this.materializeInnerObservable(value, _this.frame);
                }
                actual.push({ frame: _this.frame, notification: Notification_1.Notification.createNext(value) });
            }, function (err) {
                actual.push({ frame: _this.frame, notification: Notification_1.Notification.createError(err) });
            }, function () {
                actual.push({ frame: _this.frame, notification: Notification_1.Notification.createComplete() });
            });
        }, 0);
        if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {
            this.schedule(function () { return subscription.unsubscribe(); }, unsubscriptionFrame);
        }
        this.flushTests.push(flushTest);
        return {
            toBe: function (marbles, values, errorValue) {
                flushTest.ready = true;
                flushTest.expected = TestScheduler.parseMarbles(marbles, values, errorValue, true);
            }
        };
    };
    TestScheduler.prototype.expectSubscriptions = function (actualSubscriptionLogs) {
        var flushTest = { actual: actualSubscriptionLogs, ready: false };
        this.flushTests.push(flushTest);
        return {
            toBe: function (marbles) {
                var marblesArray = (typeof marbles === 'string') ? [marbles] : marbles;
                flushTest.ready = true;
                flushTest.expected = marblesArray.map(function (marbles) {
                    return TestScheduler.parseMarblesAsSubscriptions(marbles);
                });
            }
        };
    };
    TestScheduler.prototype.flush = function () {
        var hotObservables = this.hotObservables;
        while (hotObservables.length > 0) {
            hotObservables.shift().setup();
        }
        _super.prototype.flush.call(this);
        var readyFlushTests = this.flushTests.filter(function (test) { return test.ready; });
        while (readyFlushTests.length > 0) {
            var test = readyFlushTests.shift();
            this.assertDeepEqual(test.actual, test.expected);
        }
    };
    TestScheduler.parseMarblesAsSubscriptions = function (marbles) {
        if (typeof marbles !== 'string') {
            return new SubscriptionLog_1.SubscriptionLog(Number.POSITIVE_INFINITY);
        }
        var len = marbles.length;
        var groupStart = -1;
        var subscriptionFrame = Number.POSITIVE_INFINITY;
        var unsubscriptionFrame = Number.POSITIVE_INFINITY;
        for (var i = 0; i < len; i++) {
            var frame = i * this.frameTimeFactor;
            var c = marbles[i];
            switch (c) {
                case '-':
                case ' ':
                    break;
                case '(':
                    groupStart = frame;
                    break;
                case ')':
                    groupStart = -1;
                    break;
                case '^':
                    if (subscriptionFrame !== Number.POSITIVE_INFINITY) {
                        throw new Error('found a second subscription point \'^\' in a ' +
                            'subscription marble diagram. There can only be one.');
                    }
                    subscriptionFrame = groupStart > -1 ? groupStart : frame;
                    break;
                case '!':
                    if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {
                        throw new Error('found a second subscription point \'^\' in a ' +
                            'subscription marble diagram. There can only be one.');
                    }
                    unsubscriptionFrame = groupStart > -1 ? groupStart : frame;
                    break;
                default:
                    throw new Error('there can only be \'^\' and \'!\' markers in a ' +
                        'subscription marble diagram. Found instead \'' + c + '\'.');
            }
        }
        if (unsubscriptionFrame < 0) {
            return new SubscriptionLog_1.SubscriptionLog(subscriptionFrame);
        }
        else {
            return new SubscriptionLog_1.SubscriptionLog(subscriptionFrame, unsubscriptionFrame);
        }
    };
    TestScheduler.parseMarbles = function (marbles, values, errorValue, materializeInnerObservables) {
        if (materializeInnerObservables === void 0) { materializeInnerObservables = false; }
        if (marbles.indexOf('!') !== -1) {
            throw new Error('conventional marble diagrams cannot have the ' +
                'unsubscription marker "!"');
        }
        var len = marbles.length;
        var testMessages = [];
        var subIndex = marbles.indexOf('^');
        var frameOffset = subIndex === -1 ? 0 : (subIndex * -this.frameTimeFactor);
        var getValue = typeof values !== 'object' ?
            function (x) { return x; } :
            function (x) {
                // Support Observable-of-Observables
                if (materializeInnerObservables && values[x] instanceof ColdObservable_1.ColdObservable) {
                    return values[x].messages;
                }
                return values[x];
            };
        var groupStart = -1;
        for (var i = 0; i < len; i++) {
            var frame = i * this.frameTimeFactor + frameOffset;
            var notification = void 0;
            var c = marbles[i];
            switch (c) {
                case '-':
                case ' ':
                    break;
                case '(':
                    groupStart = frame;
                    break;
                case ')':
                    groupStart = -1;
                    break;
                case '|':
                    notification = Notification_1.Notification.createComplete();
                    break;
                case '^':
                    break;
                case '#':
                    notification = Notification_1.Notification.createError(errorValue || 'error');
                    break;
                default:
                    notification = Notification_1.Notification.createNext(getValue(c));
                    break;
            }
            if (notification) {
                testMessages.push({ frame: groupStart > -1 ? groupStart : frame, notification: notification });
            }
        }
        return testMessages;
    };
    return TestScheduler;
}(VirtualTimeScheduler_1.VirtualTimeScheduler));
exports.TestScheduler = TestScheduler;
//# sourceMappingURL=TestScheduler.js.map

/***/ }),
/* 344 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var root_1 = __webpack_require__(7);
var RequestAnimationFrameDefinition = (function () {
    function RequestAnimationFrameDefinition(root) {
        if (root.requestAnimationFrame) {
            this.cancelAnimationFrame = root.cancelAnimationFrame.bind(root);
            this.requestAnimationFrame = root.requestAnimationFrame.bind(root);
        }
        else if (root.mozRequestAnimationFrame) {
            this.cancelAnimationFrame = root.mozCancelAnimationFrame.bind(root);
            this.requestAnimationFrame = root.mozRequestAnimationFrame.bind(root);
        }
        else if (root.webkitRequestAnimationFrame) {
            this.cancelAnimationFrame = root.webkitCancelAnimationFrame.bind(root);
            this.requestAnimationFrame = root.webkitRequestAnimationFrame.bind(root);
        }
        else if (root.msRequestAnimationFrame) {
            this.cancelAnimationFrame = root.msCancelAnimationFrame.bind(root);
            this.requestAnimationFrame = root.msRequestAnimationFrame.bind(root);
        }
        else if (root.oRequestAnimationFrame) {
            this.cancelAnimationFrame = root.oCancelAnimationFrame.bind(root);
            this.requestAnimationFrame = root.oRequestAnimationFrame.bind(root);
        }
        else {
            this.cancelAnimationFrame = root.clearTimeout.bind(root);
            this.requestAnimationFrame = function (cb) { return root.setTimeout(cb, 1000 / 60); };
        }
    }
    return RequestAnimationFrameDefinition;
}());
exports.RequestAnimationFrameDefinition = RequestAnimationFrameDefinition;
exports.AnimationFrame = new RequestAnimationFrameDefinition(root_1.root);
//# sourceMappingURL=AnimationFrame.js.map

/***/ }),
/* 345 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var FastMap = (function () {
    function FastMap() {
        this.values = {};
    }
    FastMap.prototype.delete = function (key) {
        this.values[key] = null;
        return true;
    };
    FastMap.prototype.set = function (key, value) {
        this.values[key] = value;
        return this;
    };
    FastMap.prototype.get = function (key) {
        return this.values[key];
    };
    FastMap.prototype.forEach = function (cb, thisArg) {
        var values = this.values;
        for (var key in values) {
            if (values.hasOwnProperty(key) && values[key] !== null) {
                cb.call(thisArg, values[key], key);
            }
        }
    };
    FastMap.prototype.clear = function () {
        this.values = {};
    };
    return FastMap;
}());
exports.FastMap = FastMap;
//# sourceMappingURL=FastMap.js.map

/***/ }),
/* 346 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(clearImmediate, setImmediate) {/**
Some credit for this helper goes to http://github.com/YuzuJS/setImmediate
*/

var root_1 = __webpack_require__(7);
var ImmediateDefinition = (function () {
    function ImmediateDefinition(root) {
        this.root = root;
        if (root.setImmediate && typeof root.setImmediate === 'function') {
            this.setImmediate = root.setImmediate.bind(root);
            this.clearImmediate = root.clearImmediate.bind(root);
        }
        else {
            this.nextHandle = 1;
            this.tasksByHandle = {};
            this.currentlyRunningATask = false;
            // Don't get fooled by e.g. browserify environments.
            if (this.canUseProcessNextTick()) {
                // For Node.js before 0.9
                this.setImmediate = this.createProcessNextTickSetImmediate();
            }
            else if (this.canUsePostMessage()) {
                // For non-IE10 modern browsers
                this.setImmediate = this.createPostMessageSetImmediate();
            }
            else if (this.canUseMessageChannel()) {
                // For web workers, where supported
                this.setImmediate = this.createMessageChannelSetImmediate();
            }
            else if (this.canUseReadyStateChange()) {
                // For IE 68
                this.setImmediate = this.createReadyStateChangeSetImmediate();
            }
            else {
                // For older browsers
                this.setImmediate = this.createSetTimeoutSetImmediate();
            }
            var ci = function clearImmediate(handle) {
                delete clearImmediate.instance.tasksByHandle[handle];
            };
            ci.instance = this;
            this.clearImmediate = ci;
        }
    }
    ImmediateDefinition.prototype.identify = function (o) {
        return this.root.Object.prototype.toString.call(o);
    };
    ImmediateDefinition.prototype.canUseProcessNextTick = function () {
        return this.identify(this.root.process) === '[object process]';
    };
    ImmediateDefinition.prototype.canUseMessageChannel = function () {
        return Boolean(this.root.MessageChannel);
    };
    ImmediateDefinition.prototype.canUseReadyStateChange = function () {
        var document = this.root.document;
        return Boolean(document && 'onreadystatechange' in document.createElement('script'));
    };
    ImmediateDefinition.prototype.canUsePostMessage = function () {
        var root = this.root;
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `root.postMessage` means something completely different and can't be used for this purpose.
        if (root.postMessage && !root.importScripts) {
            var postMessageIsAsynchronous_1 = true;
            var oldOnMessage = root.onmessage;
            root.onmessage = function () {
                postMessageIsAsynchronous_1 = false;
            };
            root.postMessage('', '*');
            root.onmessage = oldOnMessage;
            return postMessageIsAsynchronous_1;
        }
        return false;
    };
    // This function accepts the same arguments as setImmediate, but
    // returns a function that requires no arguments.
    ImmediateDefinition.prototype.partiallyApplied = function (handler) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var fn = function result() {
            var _a = result, handler = _a.handler, args = _a.args;
            if (typeof handler === 'function') {
                handler.apply(undefined, args);
            }
            else {
                (new Function('' + handler))();
            }
        };
        fn.handler = handler;
        fn.args = args;
        return fn;
    };
    ImmediateDefinition.prototype.addFromSetImmediateArguments = function (args) {
        this.tasksByHandle[this.nextHandle] = this.partiallyApplied.apply(undefined, args);
        return this.nextHandle++;
    };
    ImmediateDefinition.prototype.createProcessNextTickSetImmediate = function () {
        var fn = function setImmediate() {
            var instance = setImmediate.instance;
            var handle = instance.addFromSetImmediateArguments(arguments);
            instance.root.process.nextTick(instance.partiallyApplied(instance.runIfPresent, handle));
            return handle;
        };
        fn.instance = this;
        return fn;
    };
    ImmediateDefinition.prototype.createPostMessageSetImmediate = function () {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
        var root = this.root;
        var messagePrefix = 'setImmediate$' + root.Math.random() + '$';
        var onGlobalMessage = function globalMessageHandler(event) {
            var instance = globalMessageHandler.instance;
            if (event.source === root &&
                typeof event.data === 'string' &&
                event.data.indexOf(messagePrefix) === 0) {
                instance.runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };
        onGlobalMessage.instance = this;
        root.addEventListener('message', onGlobalMessage, false);
        var fn = function setImmediate() {
            var _a = setImmediate, messagePrefix = _a.messagePrefix, instance = _a.instance;
            var handle = instance.addFromSetImmediateArguments(arguments);
            instance.root.postMessage(messagePrefix + handle, '*');
            return handle;
        };
        fn.instance = this;
        fn.messagePrefix = messagePrefix;
        return fn;
    };
    ImmediateDefinition.prototype.runIfPresent = function (handle) {
        // From the spec: 'Wait until any invocations of this algorithm started before this one have completed.'
        // So if we're currently running a task, we'll need to delay this invocation.
        if (this.currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // 'too much recursion' error.
            this.root.setTimeout(this.partiallyApplied(this.runIfPresent, handle), 0);
        }
        else {
            var task = this.tasksByHandle[handle];
            if (task) {
                this.currentlyRunningATask = true;
                try {
                    task();
                }
                finally {
                    this.clearImmediate(handle);
                    this.currentlyRunningATask = false;
                }
            }
        }
    };
    ImmediateDefinition.prototype.createMessageChannelSetImmediate = function () {
        var _this = this;
        var channel = new this.root.MessageChannel();
        channel.port1.onmessage = function (event) {
            var handle = event.data;
            _this.runIfPresent(handle);
        };
        var fn = function setImmediate() {
            var _a = setImmediate, channel = _a.channel, instance = _a.instance;
            var handle = instance.addFromSetImmediateArguments(arguments);
            channel.port2.postMessage(handle);
            return handle;
        };
        fn.channel = channel;
        fn.instance = this;
        return fn;
    };
    ImmediateDefinition.prototype.createReadyStateChangeSetImmediate = function () {
        var fn = function setImmediate() {
            var instance = setImmediate.instance;
            var root = instance.root;
            var doc = root.document;
            var html = doc.documentElement;
            var handle = instance.addFromSetImmediateArguments(arguments);
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement('script');
            script.onreadystatechange = function () {
                instance.runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
            return handle;
        };
        fn.instance = this;
        return fn;
    };
    ImmediateDefinition.prototype.createSetTimeoutSetImmediate = function () {
        var fn = function setImmediate() {
            var instance = setImmediate.instance;
            var handle = instance.addFromSetImmediateArguments(arguments);
            instance.root.setTimeout(instance.partiallyApplied(instance.runIfPresent, handle), 0);
            return handle;
        };
        fn.instance = this;
        return fn;
    };
    return ImmediateDefinition;
}());
exports.ImmediateDefinition = ImmediateDefinition;
exports.Immediate = new ImmediateDefinition(root_1.root);
//# sourceMappingURL=Immediate.js.map
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(67).clearImmediate, __webpack_require__(67).setImmediate))

/***/ }),
/* 347 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var root_1 = __webpack_require__(7);
var MapPolyfill_1 = __webpack_require__(348);
exports.Map = root_1.root.Map || (function () { return MapPolyfill_1.MapPolyfill; })();
//# sourceMappingURL=Map.js.map

/***/ }),
/* 348 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var MapPolyfill = (function () {
    function MapPolyfill() {
        this.size = 0;
        this._values = [];
        this._keys = [];
    }
    MapPolyfill.prototype.get = function (key) {
        var i = this._keys.indexOf(key);
        return i === -1 ? undefined : this._values[i];
    };
    MapPolyfill.prototype.set = function (key, value) {
        var i = this._keys.indexOf(key);
        if (i === -1) {
            this._keys.push(key);
            this._values.push(value);
            this.size++;
        }
        else {
            this._values[i] = value;
        }
        return this;
    };
    MapPolyfill.prototype.delete = function (key) {
        var i = this._keys.indexOf(key);
        if (i === -1) {
            return false;
        }
        this._values.splice(i, 1);
        this._keys.splice(i, 1);
        this.size--;
        return true;
    };
    MapPolyfill.prototype.clear = function () {
        this._keys.length = 0;
        this._values.length = 0;
        this.size = 0;
    };
    MapPolyfill.prototype.forEach = function (cb, thisArg) {
        for (var i = 0; i < this.size; i++) {
            cb.call(thisArg, this._values[i], this._keys[i]);
        }
    };
    return MapPolyfill;
}());
exports.MapPolyfill = MapPolyfill;
//# sourceMappingURL=MapPolyfill.js.map

/***/ }),
/* 349 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var root_1 = __webpack_require__(7);
function minimalSetImpl() {
    // THIS IS NOT a full impl of Set, this is just the minimum
    // bits of functionality we need for this library.
    return (function () {
        function MinimalSet() {
            this._values = [];
        }
        MinimalSet.prototype.add = function (value) {
            if (!this.has(value)) {
                this._values.push(value);
            }
        };
        MinimalSet.prototype.has = function (value) {
            return this._values.indexOf(value) !== -1;
        };
        Object.defineProperty(MinimalSet.prototype, "size", {
            get: function () {
                return this._values.length;
            },
            enumerable: true,
            configurable: true
        });
        MinimalSet.prototype.clear = function () {
            this._values.length = 0;
        };
        return MinimalSet;
    }());
}
exports.minimalSetImpl = minimalSetImpl;
exports.Set = root_1.root.Set || minimalSetImpl();
//# sourceMappingURL=Set.js.map

/***/ }),
/* 350 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var root_1 = __webpack_require__(7);
function assignImpl(target) {
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    var len = sources.length;
    for (var i = 0; i < len; i++) {
        var source = sources[i];
        for (var k in source) {
            if (source.hasOwnProperty(k)) {
                target[k] = source[k];
            }
        }
    }
    return target;
}
exports.assignImpl = assignImpl;
;
function getAssign(root) {
    return root.Object.assign || assignImpl;
}
exports.getAssign = getAssign;
exports.assign = getAssign(root_1.root);
//# sourceMappingURL=assign.js.map

/***/ }),
/* 351 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function not(pred, thisArg) {
    function notPred() {
        return !(notPred.pred.apply(notPred.thisArg, arguments));
    }
    notPred.pred = pred;
    notPred.thisArg = thisArg;
    return notPred;
}
exports.not = not;
//# sourceMappingURL=not.js.map

/***/ }),
/* 352 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Subscriber_1 = __webpack_require__(1);
var rxSubscriber_1 = __webpack_require__(22);
var Observer_1 = __webpack_require__(39);
function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
            return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber_1.$$rxSubscriber]) {
            return nextOrObserver[rxSubscriber_1.$$rxSubscriber]();
        }
    }
    if (!nextOrObserver && !error && !complete) {
        return new Subscriber_1.Subscriber(Observer_1.empty);
    }
    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
}
exports.toSubscriber = toSubscriber;
//# sourceMappingURL=toSubscriber.js.map

/***/ }),
/* 353 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(68), __webpack_require__(77)))

/***/ }),
/* 354 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
var stylesInDom = {},
	memoize = function(fn) {
		var memo;
		return function () {
			if (typeof memo === "undefined") memo = fn.apply(this, arguments);
			return memo;
		};
	},
	isOldIE = memoize(function() {
		return /msie [6-9]\b/.test(self.navigator.userAgent.toLowerCase());
	}),
	getHeadElement = memoize(function () {
		return document.head || document.getElementsByTagName("head")[0];
	}),
	singletonElement = null,
	singletonCounter = 0,
	styleElementsInsertedAtTop = [];

module.exports = function(list, options) {
	if(typeof DEBUG !== "undefined" && DEBUG) {
		if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};
	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (typeof options.singleton === "undefined") options.singleton = isOldIE();

	// By default, add <style> tags to the bottom of <head>.
	if (typeof options.insertAt === "undefined") options.insertAt = "bottom";

	var styles = listToStyles(list);
	addStylesToDom(styles, options);

	return function update(newList) {
		var mayRemove = [];
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			domStyle.refs--;
			mayRemove.push(domStyle);
		}
		if(newList) {
			var newStyles = listToStyles(newList);
			addStylesToDom(newStyles, options);
		}
		for(var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];
			if(domStyle.refs === 0) {
				for(var j = 0; j < domStyle.parts.length; j++)
					domStyle.parts[j]();
				delete stylesInDom[domStyle.id];
			}
		}
	};
}

function addStylesToDom(styles, options) {
	for(var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];
		if(domStyle) {
			domStyle.refs++;
			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}
			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];
			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}
			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles(list) {
	var styles = [];
	var newStyles = {};
	for(var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};
		if(!newStyles[id])
			styles.push(newStyles[id] = {id: id, parts: [part]});
		else
			newStyles[id].parts.push(part);
	}
	return styles;
}

function insertStyleElement(options, styleElement) {
	var head = getHeadElement();
	var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
	if (options.insertAt === "top") {
		if(!lastStyleElementInsertedAtTop) {
			head.insertBefore(styleElement, head.firstChild);
		} else if(lastStyleElementInsertedAtTop.nextSibling) {
			head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			head.appendChild(styleElement);
		}
		styleElementsInsertedAtTop.push(styleElement);
	} else if (options.insertAt === "bottom") {
		head.appendChild(styleElement);
	} else {
		throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
	}
}

function removeStyleElement(styleElement) {
	styleElement.parentNode.removeChild(styleElement);
	var idx = styleElementsInsertedAtTop.indexOf(styleElement);
	if(idx >= 0) {
		styleElementsInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement(options) {
	var styleElement = document.createElement("style");
	styleElement.type = "text/css";
	insertStyleElement(options, styleElement);
	return styleElement;
}

function createLinkElement(options) {
	var linkElement = document.createElement("link");
	linkElement.rel = "stylesheet";
	insertStyleElement(options, linkElement);
	return linkElement;
}

function addStyle(obj, options) {
	var styleElement, update, remove;

	if (options.singleton) {
		var styleIndex = singletonCounter++;
		styleElement = singletonElement || (singletonElement = createStyleElement(options));
		update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
		remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
	} else if(obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function") {
		styleElement = createLinkElement(options);
		update = updateLink.bind(null, styleElement);
		remove = function() {
			removeStyleElement(styleElement);
			if(styleElement.href)
				URL.revokeObjectURL(styleElement.href);
		};
	} else {
		styleElement = createStyleElement(options);
		update = applyToTag.bind(null, styleElement);
		remove = function() {
			removeStyleElement(styleElement);
		};
	}

	update(obj);

	return function updateStyle(newObj) {
		if(newObj) {
			if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
				return;
			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;
		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag(styleElement, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (styleElement.styleSheet) {
		styleElement.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = styleElement.childNodes;
		if (childNodes[index]) styleElement.removeChild(childNodes[index]);
		if (childNodes.length) {
			styleElement.insertBefore(cssNode, childNodes[index]);
		} else {
			styleElement.appendChild(cssNode);
		}
	}
}

function applyToTag(styleElement, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		styleElement.setAttribute("media", media)
	}

	if(styleElement.styleSheet) {
		styleElement.styleSheet.cssText = css;
	} else {
		while(styleElement.firstChild) {
			styleElement.removeChild(styleElement.firstChild);
		}
		styleElement.appendChild(document.createTextNode(css));
	}
}

function updateLink(linkElement, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	if(sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = linkElement.href;

	linkElement.href = URL.createObjectURL(blob);

	if(oldSrc)
		URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 355 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__tether__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__tether___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__tether__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__selection_css__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__selection_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__selection_css__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__html2canvas__ = __webpack_require__(70);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__html2canvas___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__html2canvas__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__frames__ = __webpack_require__(69);
// DO NOT import babel polyfil without ensuring that it does not add to the global
// scope of the window. Adding babel polyfil to the customers window does not work if
// it is already present via the customer's app, and will BREAK our plugin completely
// See https://pendo-io.atlassian.net/browse/APP-2873 for more





__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__frames__["a" /* startFrameMessageRouter */])();
__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__frames__["b" /* registerWithFrameMessageRouter */])();

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNzBlYTU1YzJiZDA2NTQzMGNmNjIiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL09ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL1N1YnNjcmliZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL091dGVyU3Vic2NyaWJlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvU3Vic2NyaXB0aW9uLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9TdWJqZWN0LmpzIiwid2VicGFjazovLy8uL34vcnhqcy91dGlsL2Vycm9yT2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vcnhqcy91dGlsL3Jvb3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3V0aWwvdHJ5Q2F0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NjaGVkdWxlci9hc3luYy5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb2JzZXJ2YWJsZS9BcnJheU9ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3V0aWwvaXNBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvdXRpbC9pc1NjaGVkdWxlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb2JzZXJ2YWJsZS9FbXB0eU9ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL211bHRpY2FzdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvTm90aWZpY2F0aW9uLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9zY2hlZHVsZXIvQXN5bmNBY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NjaGVkdWxlci9Bc3luY1NjaGVkdWxlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3ltYm9sL2l0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9Bc3luY1N1YmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL21lcmdlQWxsLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9zeW1ib2wvb2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3ltYm9sL3J4U3Vic2NyaWJlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvdXRpbC9Bcmd1bWVudE91dE9mUmFuZ2VFcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvdXRpbC9FbXB0eUVycm9yLmpzIiwid2VicGFjazovLy8uL34vcnhqcy91dGlsL09iamVjdFVuc3Vic2NyaWJlZEVycm9yLmpzIiwid2VicGFjazovLy8uL34vcnhqcy91dGlsL2lzRGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvdXRpbC9pc0Z1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcnhqcy91dGlsL2lzTnVtZXJpYy5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvUmVwbGF5U3ViamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb2JzZXJ2YWJsZS9TY2FsYXJPYnNlcnZhYmxlLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci9jb21iaW5lTGF0ZXN0LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci9jb25jYXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL21hcC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3Ivb2JzZXJ2ZU9uLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci9yZWR1Y2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL3ppcC5qcyIsIndlYnBhY2s6Ly8vLi9wbHVnaW5zL3NvdXJjZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL0JlaGF2aW9yU3ViamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvT2JzZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL1N1YmplY3RTdWJzY3JpcHRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29ic2VydmFibGUvQ29ubmVjdGFibGVPYnNlcnZhYmxlLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vYnNlcnZhYmxlL0Zyb21PYnNlcnZhYmxlLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vYnNlcnZhYmxlL1Byb21pc2VPYnNlcnZhYmxlLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vYnNlcnZhYmxlL2RvbS9BamF4T2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvZGlzdGluY3RVbnRpbENoYW5nZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL2ZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvZmluZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvbWVyZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL21lcmdlTWFwLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci9tZXJnZU1hcFRvLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci9vbkVycm9yUmVzdW1lTmV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvcmFjZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvdGltZUludGVydmFsLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci90aW1lc3RhbXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NjaGVkdWxlci9WaXJ0dWFsVGltZVNjaGVkdWxlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc2NoZWR1bGVyL2FzYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NjaGVkdWxlci9xdWV1ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvdGVzdGluZy9TdWJzY3JpcHRpb25Mb2cuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3Rlc3RpbmcvU3Vic2NyaXB0aW9uTG9nZ2FibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3V0aWwvVGltZW91dEVycm9yLmpzIiwid2VicGFjazovLy8uL34vcnhqcy91dGlsL1Vuc3Vic2NyaXB0aW9uRXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3V0aWwvYXBwbHlNaXhpbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3V0aWwvaXNBcnJheUxpa2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3V0aWwvaXNPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3V0aWwvaXNQcm9taXNlLmpzIiwid2VicGFjazovLy8uL34vcnhqcy91dGlsL25vb3AuanMiLCJ3ZWJwYWNrOi8vLy4vfi90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vcGx1Z2lucy9mcmFtZXMuanMiLCJ3ZWJwYWNrOi8vLy4vcGx1Z2lucy9odG1sMmNhbnZhcy5qcyIsIndlYnBhY2s6Ly8vLi9wbHVnaW5zL3RldGhlci5qcyIsIndlYnBhY2s6Ly8vLi9wbHVnaW5zL3NlbGVjdGlvbi5jc3M/ZjFiOSIsIndlYnBhY2s6Ly8vLi9wbHVnaW5zL1NvcnRhYmxlLmpzIiwid2VicGFjazovLy8uL3BsdWdpbnMvc2VsZWN0aW9uLmpzIiwid2VicGFjazovLy8uL3BsdWdpbnMvc2VsZWN0aW9uLmNzcyIsIndlYnBhY2s6Ly8vLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwid2VicGFjazovLy8uL34vcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9Jbm5lclN1YnNjcmliZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL1J4LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9TY2hlZHVsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vYnNlcnZhYmxlL2JpbmRDYWxsYmFjay5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29ic2VydmFibGUvYmluZE5vZGVDYWxsYmFjay5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29ic2VydmFibGUvY29tYmluZUxhdGVzdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29ic2VydmFibGUvY29uY2F0LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb2JzZXJ2YWJsZS9kZWZlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29ic2VydmFibGUvZG9tL2FqYXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vYnNlcnZhYmxlL2RvbS93ZWJTb2NrZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vYnNlcnZhYmxlL2VtcHR5LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb2JzZXJ2YWJsZS9mb3JrSm9pbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29ic2VydmFibGUvZnJvbS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29ic2VydmFibGUvZnJvbUV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb2JzZXJ2YWJsZS9mcm9tRXZlbnRQYXR0ZXJuLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb2JzZXJ2YWJsZS9mcm9tUHJvbWlzZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29ic2VydmFibGUvZ2VuZXJhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vYnNlcnZhYmxlL2lmLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb2JzZXJ2YWJsZS9pbnRlcnZhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29ic2VydmFibGUvbWVyZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vYnNlcnZhYmxlL25ldmVyLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb2JzZXJ2YWJsZS9vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29ic2VydmFibGUvb25FcnJvclJlc3VtZU5leHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vYnNlcnZhYmxlL3BhaXJzLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb2JzZXJ2YWJsZS9yYWNlLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb2JzZXJ2YWJsZS9yYW5nZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29ic2VydmFibGUvdGhyb3cuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vYnNlcnZhYmxlL3RpbWVyLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb2JzZXJ2YWJsZS91c2luZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29ic2VydmFibGUvemlwLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3IvYXVkaXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9hdWRpdFRpbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9idWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9idWZmZXJDb3VudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL2J1ZmZlclRpbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9idWZmZXJUb2dnbGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9idWZmZXJXaGVuLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3IvY2F0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9jb21iaW5lQWxsLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3IvY29tYmluZUxhdGVzdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL2NvbmNhdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL2NvbmNhdEFsbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL2NvbmNhdE1hcC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL2NvbmNhdE1hcFRvLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3IvY291bnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9kZWJvdW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL2RlYm91bmNlVGltZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL2RlZmF1bHRJZkVtcHR5LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3IvZGVsYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9kZWxheVdoZW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9kZW1hdGVyaWFsaXplLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3IvZGlzdGluY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9kaXN0aW5jdFVudGlsQ2hhbmdlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL2Rpc3RpbmN0VW50aWxLZXlDaGFuZ2VkLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3IvZG8uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9lbGVtZW50QXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9ldmVyeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL2V4aGF1c3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9leGhhdXN0TWFwLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3IvZXhwYW5kLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3IvZmlsdGVyLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3IvZmluYWxseS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL2ZpbmQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9maW5kSW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9maXJzdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL2dyb3VwQnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9pZ25vcmVFbGVtZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL2lzRW1wdHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9sYXN0LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3IvbGV0LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3IvbWFwLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3IvbWFwVG8uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9tYXRlcmlhbGl6ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL21heC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL21lcmdlLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3IvbWVyZ2VBbGwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9tZXJnZU1hcC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL21lcmdlTWFwVG8uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9tZXJnZVNjYW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9taW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9tdWx0aWNhc3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9vYnNlcnZlT24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9vbkVycm9yUmVzdW1lTmV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL3BhaXJ3aXNlLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3IvcGFydGl0aW9uLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3IvcGx1Y2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9wdWJsaXNoLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3IvcHVibGlzaEJlaGF2aW9yLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3IvcHVibGlzaExhc3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9wdWJsaXNoUmVwbGF5LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3IvcmFjZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL3JlZHVjZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL3JlcGVhdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL3JlcGVhdFdoZW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9yZXRyeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL3JldHJ5V2hlbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL3NhbXBsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL3NhbXBsZVRpbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9zY2FuLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3Ivc2VxdWVuY2VFcXVhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL3NoYXJlLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3Ivc2luZ2xlLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3Ivc2tpcC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL3NraXBVbnRpbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL3NraXBXaGlsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL3N0YXJ0V2l0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL3N1YnNjcmliZU9uLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3Ivc3dpdGNoLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3Ivc3dpdGNoTWFwLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3Ivc3dpdGNoTWFwVG8uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci90YWtlLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3IvdGFrZUxhc3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci90YWtlVW50aWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci90YWtlV2hpbGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci90aHJvdHRsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL3Rocm90dGxlVGltZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL3RpbWVJbnRlcnZhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL3RpbWVvdXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci90aW1lb3V0V2l0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL3RpbWVzdGFtcC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL3RvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci90b1Byb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci93aW5kb3cuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci93aW5kb3dDb3VudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL3dpbmRvd1RpbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci93aW5kb3dUb2dnbGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci93aW5kb3dXaGVuLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3Ivd2l0aExhdGVzdEZyb20uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci96aXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci96aXBBbGwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29ic2VydmFibGUvQXJyYXlMaWtlT2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb2JzZXJ2YWJsZS9Cb3VuZENhbGxiYWNrT2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb2JzZXJ2YWJsZS9Cb3VuZE5vZGVDYWxsYmFja09ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29ic2VydmFibGUvRGVmZXJPYnNlcnZhYmxlLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vYnNlcnZhYmxlL0Vycm9yT2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb2JzZXJ2YWJsZS9Gb3JrSm9pbk9ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29ic2VydmFibGUvRnJvbUV2ZW50T2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb2JzZXJ2YWJsZS9Gcm9tRXZlbnRQYXR0ZXJuT2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb2JzZXJ2YWJsZS9HZW5lcmF0ZU9ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29ic2VydmFibGUvSWZPYnNlcnZhYmxlLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vYnNlcnZhYmxlL0ludGVydmFsT2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb2JzZXJ2YWJsZS9JdGVyYXRvck9ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29ic2VydmFibGUvTmV2ZXJPYnNlcnZhYmxlLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vYnNlcnZhYmxlL1BhaXJzT2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb2JzZXJ2YWJsZS9SYW5nZU9ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29ic2VydmFibGUvU3Vic2NyaWJlT25PYnNlcnZhYmxlLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vYnNlcnZhYmxlL1RpbWVyT2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb2JzZXJ2YWJsZS9Vc2luZ09ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29ic2VydmFibGUvYmluZENhbGxiYWNrLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vYnNlcnZhYmxlL2JpbmROb2RlQ2FsbGJhY2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29ic2VydmFibGUvY29tYmluZUxhdGVzdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb2JzZXJ2YWJsZS9jb25jYXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29ic2VydmFibGUvZGVmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29ic2VydmFibGUvZG9tL1dlYlNvY2tldFN1YmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29ic2VydmFibGUvZG9tL2FqYXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29ic2VydmFibGUvZG9tL3dlYlNvY2tldC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb2JzZXJ2YWJsZS9lbXB0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb2JzZXJ2YWJsZS9mb3JrSm9pbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb2JzZXJ2YWJsZS9mcm9tLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vYnNlcnZhYmxlL2Zyb21FdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb2JzZXJ2YWJsZS9mcm9tRXZlbnRQYXR0ZXJuLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vYnNlcnZhYmxlL2Zyb21Qcm9taXNlLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vYnNlcnZhYmxlL2lmLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vYnNlcnZhYmxlL2ludGVydmFsLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vYnNlcnZhYmxlL21lcmdlLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vYnNlcnZhYmxlL25ldmVyLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vYnNlcnZhYmxlL29mLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vYnNlcnZhYmxlL3BhaXJzLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vYnNlcnZhYmxlL3JhbmdlLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vYnNlcnZhYmxlL3Rocm93LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vYnNlcnZhYmxlL3RpbWVyLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vYnNlcnZhYmxlL3VzaW5nLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vYnNlcnZhYmxlL3ppcC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvYXVkaXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL2F1ZGl0VGltZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvYnVmZmVyLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci9idWZmZXJDb3VudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvYnVmZmVyVGltZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvYnVmZmVyVG9nZ2xlLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci9idWZmZXJXaGVuLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci9jYXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvY29tYmluZUFsbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvY29uY2F0QWxsLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci9jb25jYXRNYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL2NvbmNhdE1hcFRvLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci9jb3VudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvZGVib3VuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL2RlYm91bmNlVGltZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvZGVmYXVsdElmRW1wdHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL2RlbGF5LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci9kZWxheVdoZW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL2RlbWF0ZXJpYWxpemUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL2Rpc3RpbmN0LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci9kaXN0aW5jdFVudGlsS2V5Q2hhbmdlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvZG8uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL2VsZW1lbnRBdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvZXZlcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL2V4aGF1c3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL2V4aGF1c3RNYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL2V4cGFuZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvZmluYWxseS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvZmluZEluZGV4LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci9maXJzdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvZ3JvdXBCeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvaWdub3JlRWxlbWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL2lzRW1wdHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL2xhc3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL2xldC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvbWFwVG8uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL21hdGVyaWFsaXplLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci9tYXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL21lcmdlU2Nhbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvbWluLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci9wYWlyd2lzZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvcGFydGl0aW9uLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci9wbHVjay5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvcHVibGlzaC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvcHVibGlzaEJlaGF2aW9yLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci9wdWJsaXNoTGFzdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvcHVibGlzaFJlcGxheS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvcmVwZWF0LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci9yZXBlYXRXaGVuLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci9yZXRyeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvcmV0cnlXaGVuLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci9zYW1wbGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL3NhbXBsZVRpbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL3NjYW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL3NlcXVlbmNlRXF1YWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL3NoYXJlLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci9zaW5nbGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL3NraXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL3NraXBVbnRpbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3Ivc2tpcFdoaWxlLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci9zdGFydFdpdGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL3N1YnNjcmliZU9uLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci9zd2l0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL3N3aXRjaE1hcC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3Ivc3dpdGNoTWFwVG8uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL3Rha2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL3Rha2VMYXN0LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci90YWtlVW50aWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL3Rha2VXaGlsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvdGhyb3R0bGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL3Rocm90dGxlVGltZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvdGltZW91dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvdGltZW91dFdpdGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL3RvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL3RvUHJvbWlzZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3Ivd2luZG93LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci93aW5kb3dDb3VudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3Ivd2luZG93VGltZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3Ivd2luZG93VG9nZ2xlLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci93aW5kb3dXaGVuLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci93aXRoTGF0ZXN0RnJvbS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvemlwQWxsLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9zY2hlZHVsZXIvQWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9zY2hlZHVsZXIvQW5pbWF0aW9uRnJhbWVBY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NjaGVkdWxlci9BbmltYXRpb25GcmFtZVNjaGVkdWxlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc2NoZWR1bGVyL0FzYXBBY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NjaGVkdWxlci9Bc2FwU2NoZWR1bGVyLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9zY2hlZHVsZXIvUXVldWVBY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NjaGVkdWxlci9RdWV1ZVNjaGVkdWxlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc2NoZWR1bGVyL2FuaW1hdGlvbkZyYW1lLmpzIiwid2VicGFjazovLy8uL34vcnhqcy90ZXN0aW5nL0NvbGRPYnNlcnZhYmxlLmpzIiwid2VicGFjazovLy8uL34vcnhqcy90ZXN0aW5nL0hvdE9ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3Rlc3RpbmcvVGVzdFNjaGVkdWxlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvdXRpbC9BbmltYXRpb25GcmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvdXRpbC9GYXN0TWFwLmpzIiwid2VicGFjazovLy8uL34vcnhqcy91dGlsL0ltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvdXRpbC9NYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3V0aWwvTWFwUG9seWZpbGwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3V0aWwvU2V0LmpzIiwid2VicGFjazovLy8uL34vcnhqcy91dGlsL2Fzc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvdXRpbC9ub3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3V0aWwvdG9TdWJzY3JpYmVyLmpzIiwid2VicGFjazovLy8uL34vc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vcGx1Z2lucy9pbmRleC5qcyJdLCJuYW1lcyI6WyJleHBvcnRzIiwiYWdlbnQiLCJiYWNrZ3JvdW5kIiwiY29udGVudFNjcmlwdCIsImRlc2lnbmVyIiwicGx1Z2luIiwiaXBjUmVuZGVyZXIiLCJ3aW5kb3ciLCJpc0VsZWN0cm9uIiwiaXNUb3AiLCJ0b3AiLCJoYXNQZW5kb0FnZW50IiwicGVuZG8iLCJpc1JlYWR5IiwidHlwZUVxdWFscyIsInR5cGUiLCJldmVudCIsImRhdGEiLCJkZXN0aW5hdGlvbkVxdWFscyIsImRlc3RpbmF0aW9uIiwib3BlblBhbmVsSWZDbG9zZWQiLCJjb250YWluZXIiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwiY2xhc3NMaXN0IiwicmVtb3ZlIiwicmVjZWl2ZUZyYW1lSW5mbyIsImZyYW1lcyIsIm1lc3NhZ2UiLCJmcmFtZSIsImZpbmQiLCJmIiwic291cmNlIiwiT2JqZWN0IiwiYXNzaWduIiwicHVzaCIsImlkIiwibGVuZ3RoIiwic2VuZEZyYW1lSW5mbyIsInVybCIsImxvY2F0aW9uIiwiaHJlZiIsIkVOViIsIkhPU1QiLCJob3N0TG9jYXRpb24iLCJvcmlnaW4iLCJwb3N0TWVzc2FnZSIsInJlYWRQZW5kb0FnZW50U2V0dGluZ3MiLCJtZXNzYWdlT2JqIiwicGF5bG9hZCIsInNlbmQiLCJyZWFkTG9jYXRpb24iLCJmb3J3YXJkVG9GcmFtZXNXaXRoQW5JbnN0YWxsZWRBZ2VudCIsInRvcFdpbmRvdyIsImZpbHRlciIsImZyYW1lSWQiLCJmb3JFYWNoIiwiaGFuZGxlR3VpZGVQcmV2aWV3IiwidG9wRnJhbWUiLCJmb3J3YXJkVG9Db250ZW50U2NyaXB0IiwiZm9yd2FyZFRvRGVzaWduZXIiLCJzZW5kVG9EZXNpZ25lciIsInBvbGxGb3JQZW5kb0FnZW50Iiwic3RhcnRBZ2VudE1lc3NhZ2VMaXN0ZW5lciIsIndhdGNoIiwic2V0VGltZW91dCIsImNvbnRlbnRXaW5kb3ciLCJPYnNlcnZhYmxlIiwiZnJvbUV2ZW50Iiwic3Vic2NyaWJlIiwibWVzc2FnZURpc3BhdGNoZXIiLCJzZWxtbyIsInNlbGVjdGlvbiIsInN0YXJ0RnJhbWVNZXNzYWdlUm91dGVyIiwib24iLCJtZXNzYWdlcyIsInJlZ2lzdGVyV2l0aEZyYW1lTWVzc2FnZVJvdXRlciIsInVuZGVmaW5lZCIsIl9odG1sMmNhbnZhcyIsInByZXZpb3VzRWxlbWVudCIsImNvbXB1dGVkQ1NTIiwiaHRtbDJjYW52YXMiLCJVdGlsIiwibG9nIiwiYSIsImxvZ2dpbmciLCJjb25zb2xlIiwidHJpbVRleHQiLCJpc05hdGl2ZSIsImlucHV0IiwiYXBwbHkiLCJyZXBsYWNlIiwiU3RyaW5nIiwicHJvdG90eXBlIiwidHJpbSIsImFzRmxvYXQiLCJ2IiwicGFyc2VGbG9hdCIsIlRFWFRfU0hBRE9XX1BST1BFUlRZIiwiVEVYVF9TSEFET1dfVkFMVUVTIiwicGFyc2VUZXh0U2hhZG93cyIsInZhbHVlIiwic2hhZG93cyIsIm1hdGNoIiwicmVzdWx0cyIsImkiLCJzIiwiY29sb3IiLCJvZmZzZXRYIiwib2Zmc2V0WSIsImJsdXIiLCJwYXJzZUJhY2tncm91bmRJbWFnZSIsIndoaXRlc3BhY2UiLCJtZXRob2QiLCJkZWZpbml0aW9uIiwicHJlZml4IiwicHJlZml4X2kiLCJibG9jayIsImMiLCJtb2RlIiwibnVtUGFyZW4iLCJxdW90ZSIsImFyZ3MiLCJhcHBlbmRSZXN1bHQiLCJzdWJzdHIiLCJpbmRleE9mIiwidG9Mb3dlckNhc2UiLCJpaSIsIkJvdW5kcyIsImVsZW1lbnQiLCJjbGllbnRSZWN0IiwiYm91bmRzIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiYm90dG9tIiwiaGVpZ2h0IiwibGVmdCIsIndpZHRoIiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJPZmZzZXRCb3VuZHMiLCJwYXJlbnQiLCJvZmZzZXRQYXJlbnQiLCJvZmZzZXRUb3AiLCJvZmZzZXRMZWZ0IiwidG9QWCIsImF0dHJpYnV0ZSIsInJzTGVmdCIsInJ1bnRpbWVTdHlsZSIsInN0eWxlIiwidGVzdCIsImN1cnJlbnRTdHlsZSIsInBpeGVsTGVmdCIsIk1hdGgiLCJyb3VuZCIsImFzSW50IiwidmFsIiwicGFyc2VJbnQiLCJwYXJzZUJhY2tncm91bmRTaXplUG9zaXRpb24iLCJpbmRleCIsInNwbGl0IiwiZ2V0Q1NTIiwiZGVmYXVsdFZpZXciLCJnZXRDb21wdXRlZFN0eWxlIiwiYXJyIiwibWFwIiwicmVzaXplQm91bmRzIiwiY3VycmVudF93aWR0aCIsImN1cnJlbnRfaGVpZ2h0IiwidGFyZ2V0X3dpZHRoIiwidGFyZ2V0X2hlaWdodCIsInN0cmV0Y2hfbW9kZSIsInRhcmdldF9yYXRpbyIsImN1cnJlbnRfcmF0aW8iLCJvdXRwdXRfd2lkdGgiLCJvdXRwdXRfaGVpZ2h0IiwiYmFja2dyb3VuZEJvdW5kc0ZhY3RvcnkiLCJwcm9wIiwiZWwiLCJpbWFnZSIsImltYWdlSW5kZXgiLCJiYWNrZ3JvdW5kU2l6ZSIsImJncG9zaXRpb24iLCJ0b3BQb3MiLCJwZXJjZW50YWdlIiwidG9TdHJpbmciLCJyZXNpemVkIiwiQmFja2dyb3VuZFBvc2l0aW9uIiwicmVzdWx0IiwiQmFja2dyb3VuZFNpemUiLCJFeHRlbmQiLCJvcHRpb25zIiwiZGVmYXVsdHMiLCJrZXkiLCJoYXNPd25Qcm9wZXJ0eSIsIkNoaWxkcmVuIiwiZWxlbSIsImNoaWxkcmVuIiwibm9kZU5hbWUiLCJ0b1VwcGVyQ2FzZSIsImNvbnRlbnREb2N1bWVudCIsImFycmF5IiwicmV0IiwiZmlyc3QiLCJzZWNvbmQiLCJqIiwibCIsImNoaWxkTm9kZXMiLCJleCIsImlzVHJhbnNwYXJlbnQiLCJiYWNrZ3JvdW5kQ29sb3IiLCJGb250IiwiZm9udERhdGEiLCJmb250IiwiZm9udFNpemUiLCJkb2MiLCJjcmVhdGVFbGVtZW50IiwiaW1nIiwic3BhbiIsInNhbXBsZVRleHQiLCJiYXNlbGluZSIsIm1pZGRsZSIsIm1ldHJpY3NPYmoiLCJ2aXNpYmlsaXR5IiwiZm9udEZhbWlseSIsIm1hcmdpbiIsInBhZGRpbmciLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJzcmMiLCJ2ZXJ0aWNhbEFsaWduIiwiY3JlYXRlVGV4dE5vZGUiLCJyZW1vdmVDaGlsZCIsImxpbmVIZWlnaHQiLCJsaW5lV2lkdGgiLCJHZW5lcmF0ZSIsInJlR3JhZGllbnRzIiwicGFyc2VHcmFkaWVudCIsImNzcyIsImdyYWRpZW50IiwibGVuIiwibTEiLCJzdG9wIiwibTIiLCJtMkxlbiIsInN0ZXAiLCJtMyIsInRsIiwidHIiLCJiciIsImJsIiwieDAiLCJ5MCIsIngxIiwieTEiLCJjb2xvclN0b3BzIiwibWF4IiwiY3giLCJjeSIsInJ4IiwicnkiLCJzcXJ0IiwicG93IiwibWluIiwiYWRkU2Nyb2xsU3RvcHMiLCJncmFkIiwiY29sb3JTdG9wIiwiYWRkQ29sb3JTdG9wIiwiZSIsIkdyYWRpZW50IiwiY2FudmFzIiwiY3R4IiwiZ2V0Q29udGV4dCIsImNyZWF0ZUxpbmVhckdyYWRpZW50IiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJjcmVhdGVSYWRpYWxHcmFkaWVudCIsImNhbnZhc1JhZGlhbCIsImN0eFJhZGlhbCIsInJpIiwiZGkiLCJkcmF3SW1hZ2UiLCJMaXN0QWxwaGEiLCJudW1iZXIiLCJ0bXAiLCJtb2R1bHVzIiwiZnJvbUNoYXJDb2RlIiwiTGlzdFJvbWFuIiwicm9tYW5BcnJheSIsImRlY2ltYWwiLCJyb21hbiIsImgyY1JlbmRlckNvbnRleHQiLCJzdG9yYWdlIiwiY2xpcCIsIm5hbWUiLCJhcmd1bWVudHMiLCJ0cmFuc2xhdGUiLCJmaWxsIiwic2F2ZSIsInJlc3RvcmUiLCJjcmVhdGVQYXR0ZXJuIiwiZHJhd1NoYXBlIiwic2hhcGUiLCJtb3ZlVG8iLCJsaW5lVG8iLCJhcmNUbyIsImJlemllckN1cnZlVG8iLCJxdWFkcmF0aWNDdXJ2ZVRvIiwiZmlsbFRleHQiLCJzZXRWYXJpYWJsZSIsInZhcmlhYmxlIiwiUGFyc2UiLCJpbWFnZXMiLCJzY3JvbGwiLCJlbGVtZW50cyIsIm51bURyYXdzIiwib3duZXJEb2N1bWVudCIsInN1cHBvcnQiLCJTdXBwb3J0IiwiaWdub3JlRWxlbWVudHNSZWdFeHAiLCJSZWdFeHAiLCJpZ25vcmVFbGVtZW50cyIsInBzZXVkb0hpZGUiLCJoaWRlUHNldWRvRWxlbWVudHMiLCJpbm5lckhUTUwiLCJkb2N1bWVudFdpZHRoIiwic2Nyb2xsV2lkdGgiLCJkb2N1bWVudEVsZW1lbnQiLCJjbGllbnRXaWR0aCIsImRvY3VtZW50SGVpZ2h0Iiwic2Nyb2xsSGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwiZ2V0Q1NTSW50IiwiaXNOYU4iLCJyZW5kZXJSZWN0IiwieCIsInkiLCJ3IiwiaCIsImJnY29sb3IiLCJjYXBpdGFsaXplIiwibSIsInAxIiwicDIiLCJ0ZXh0VHJhbnNmb3JtIiwidGV4dCIsInRyYW5zZm9ybSIsIm5vTGV0dGVyU3BhY2luZyIsImxldHRlcl9zcGFjaW5nIiwiZHJhd1RleHQiLCJjdXJyZW50VGV4dCIsInNldFRleHRWYXJpYWJsZXMiLCJ0ZXh0X2RlY29yYXRpb24iLCJhbGlnbiIsImJvbGQiLCJmYW1pbHkiLCJzaXplIiwiam9pbiIsInJlbmRlclRleHREZWNvcmF0aW9uIiwibWV0cmljcyIsImNlaWwiLCJnZXRUZXh0Qm91bmRzIiwic3RhdGUiLCJ0ZXh0RGVjb3JhdGlvbiIsImlzTGFzdCIsInJhbmdlQm91bmRzIiwidGV4dFJhbmdlQm91bmRzIiwibm9kZSIsInRleHRPZmZzZXQiLCJub2RlVmFsdWUiLCJuZXdUZXh0Tm9kZSIsInNwbGl0VGV4dCIsInRleHRXcmFwcGVyQm91bmRzIiwidGV4dE5vZGUiLCJyYW5nZSIsImNyZWF0ZVJhbmdlIiwic2V0U3RhcnQiLCJzZXRFbmQiLCJvbGRUZXh0Tm9kZSIsInBhcmVudE5vZGUiLCJ3cmFwRWxlbWVudCIsImJhY2t1cFRleHQiLCJjbG9uZU5vZGUiLCJyZXBsYWNlQ2hpbGQiLCJyZW5kZXJUZXh0Iiwic3RhY2siLCJ0ZXh0QWxpZ24iLCJ0ZXh0TGlzdCIsImxldHRlclJlbmRlcmluZyIsImNoaW5lc2UiLCJ3b3JkIiwidW5zaGlmdCIsInNwbGljZSIsIm1hdHJpeCIsImxpc3RQb3NpdGlvbiIsImJvdW5kRWxlbWVudCIsIm9yaWdpbmFsVHlwZSIsImRpc3BsYXkiLCJsaXN0U3R5bGVUeXBlIiwiaW5zZXJ0QmVmb3JlIiwiZmlyc3RDaGlsZCIsImVsZW1lbnRJbmRleCIsImNvdW50IiwiY2hpbGRzIiwibm9kZVR5cGUiLCJsaXN0SXRlbVRleHQiLCJjdXJyZW50SW5kZXgiLCJyZW5kZXJMaXN0SXRlbSIsImVsQm91bmRzIiwibGlzdEJvdW5kcyIsImxvYWRJbWFnZSIsInN1Y2NlZWRlZCIsImNsaXBCb3VuZHMiLCJkc3QiLCJ4MiIsInkyIiwic2V0WiIsInBhcmVudFN0YWNrIiwibmV3Q29udGV4dCIsImlzUG9zaXRpb25lZCIsImNzc1Bvc2l0aW9uIiwiekluZGV4Iiwib3BhY2l0eSIsImlzRmxvYXRlZCIsImgyY3pDb250ZXh0Iiwib3duU3RhY2tpbmciLCJyZW5kZXJJbWFnZSIsImJvcmRlcnMiLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdUb3AiLCJwYWRkaW5nUmlnaHQiLCJwYWRkaW5nQm90dG9tIiwiZ2V0Qm9yZGVyRGF0YSIsInNpZGUiLCJnZXRCb3JkZXJSYWRpdXNEYXRhIiwiZ2V0Q3VydmVQb2ludHMiLCJrYXBwYSIsInIxIiwicjIiLCJveCIsIm95IiwieG0iLCJ5bSIsInRvcExlZnQiLCJiZXppZXJDdXJ2ZSIsInRvcFJpZ2h0IiwiYm90dG9tUmlnaHQiLCJib3R0b21MZWZ0Iiwic3RhcnQiLCJzdGFydENvbnRyb2wiLCJlbmRDb250cm9sIiwiZW5kIiwibGVycCIsImIiLCJ0Iiwic3ViZGl2aWRlIiwiYWIiLCJiYyIsImNkIiwiYWJiYyIsImJjY2QiLCJkZXN0IiwiY3VydmVUbyIsImJvcmRlckFyZ3MiLCJjdXJ2ZVRvUmV2ZXJzZWQiLCJwYXJzZUNvcm5lciIsInJhZGl1czEiLCJyYWRpdXMyIiwiY29ybmVyMSIsImNvcm5lcjIiLCJkcmF3U2lkZSIsImJvcmRlckRhdGEiLCJvdXRlcjEiLCJpbm5lcjEiLCJvdXRlcjIiLCJpbm5lcjIiLCJjMSIsImMyIiwiYzMiLCJjNCIsImNhbGN1bGF0ZUN1cnZlUG9pbnRzIiwiYm9yZGVyUmFkaXVzIiwidGxoIiwidGx2IiwidHJoIiwidHJ2IiwiYnJoIiwiYnJ2IiwiYmxoIiwiYmx2IiwidG9wV2lkdGgiLCJyaWdodEhlaWdodCIsImJvdHRvbVdpZHRoIiwibGVmdEhlaWdodCIsInRvcExlZnRPdXRlciIsInRvcExlZnRJbm5lciIsInRvcFJpZ2h0T3V0ZXIiLCJ0b3BSaWdodElubmVyIiwiYm90dG9tUmlnaHRPdXRlciIsImJvdHRvbVJpZ2h0SW5uZXIiLCJib3R0b21MZWZ0T3V0ZXIiLCJib3R0b21MZWZ0SW5uZXIiLCJnZXRCb3JkZXJDbGlwIiwiYm9yZGVyUG9pbnRzIiwicmFkaXVzIiwiYmFja2dyb3VuZENsaXAiLCJwYXJzZUJvcmRlcnMiLCJib3JkZXJTaWRlIiwiYngiLCJieSIsImJ3IiwiYmgiLCJjcmVhdGVTaGFwZSIsImJvcmRlciIsInNsaWNlIiwicmVuZGVyQm9yZGVycyIsInJlbmRlckZvcm1WYWx1ZSIsInZhbHVlV3JhcCIsImNzc1Byb3BlcnR5QXJyYXkiLCJ0ZXh0VmFsdWUiLCJwcm9wZXJ0eSIsImJvcmRlckNvbG9yIiwiYm9yZGVyU3R5bGUiLCJwb3NpdGlvbiIsInNlbGVjdGVkSW5kZXgiLCJwbGFjZWhvbGRlciIsIkFycmF5IiwiY2FsbCIsImdldFBzZXVkb0VsZW1lbnQiLCJ3aGljaCIsImVsU3R5bGUiLCJjb250ZW50IiwiaXNJbWFnZSIsImVscHMiLCJjbGFzc05hbWUiLCJrZXlzIiwiaW5kZXhlZFByb3BlcnR5IiwiaW5qZWN0UHNldWRvRWxlbWVudHMiLCJiZWZvcmUiLCJhZnRlciIsInBhcnNlRWxlbWVudCIsInJlbmRlckJhY2tncm91bmRSZXBlYXQiLCJiYWNrZ3JvdW5kUG9zaXRpb24iLCJiYWNrZ3JvdW5kUmVwZWF0U2hhcGUiLCJyZW5kZXJCYWNrZ3JvdW5kQ29sb3IiLCJiYWNrZ3JvdW5kQm91bmRzIiwicmVuZGVyQmFja2dyb3VuZFJlcGVhdGluZyIsImJhY2tncm91bmRSZXBlYXQiLCJyZXNpemVJbWFnZSIsInJlbmRlckJhY2tncm91bmRJbWFnZSIsImJhY2tncm91bmRJbWFnZSIsImJhY2tncm91bmRJbWFnZXMiLCJzZXRPcGFjaXR5IiwicmVtb3ZlUHgiLCJzdHIiLCJ0cmFuc2Zvcm1SZWdFeHAiLCJnZXRUcmFuc2Zvcm0iLCJ0cmFuc2Zvcm1PcmlnaW4iLCJjcmVhdGVTdGFjayIsInVzZU92ZXJmbG93IiwiZ2V0QmFja2dyb3VuZEJvdW5kcyIsImdldEJvdW5kcyIsInJlbmRlckVsZW1lbnQiLCJwc2V1ZG9FbGVtZW50IiwiaWdub3JlQmFja2dyb3VuZCIsImdldEF0dHJpYnV0ZSIsImlzRWxlbWVudFZpc2libGUiLCJoYXNBdHRyaWJ1dGUiLCJwYXJzZUNoaWxkcmVuIiwiRUxFTUVOVF9OT0RFIiwiVEVYVF9OT0RFIiwiaW5pdCIsInRyYW5zcGFyZW50QmFja2dyb3VuZCIsInppbmRleCIsIlByZWxvYWQiLCJudW1Mb2FkZWQiLCJudW1GYWlsZWQiLCJudW1Ub3RhbCIsImNsZWFudXBEb25lIiwicGFnZU9yaWdpbiIsIm1ldGhvZHMiLCJkb21JbWFnZXMiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImltZ0xlbiIsImxpbmsiLCJzdXBwb3J0Q09SUyIsImNyb3NzT3JpZ2luIiwiSW1hZ2UiLCJ0aW1lb3V0VGltZXIiLCJwcm90b2NvbCIsImhvc3QiLCJpc1NhbWVPcmlnaW4iLCJmaXJzdFJ1biIsImNvbXBsZXRlIiwicHJveHlHZXRJbWFnZSIsImltYWdlT2JqIiwiY2FsbGJhY2tfbmFtZSIsInNjcmlwdFVybCIsInByb3h5Iiwic2NyaXB0IiwiY2FsbGJhY2tuYW1lIiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwic3Vic3RyaW5nIiwic2V0SW1hZ2VMb2FkSGFuZGxlcnMiLCJzZXRBdHRyaWJ1dGUiLCJsb2FkUHNldWRvRWxlbWVudCIsImxvYWRCYWNrZ3JvdW5kSW1hZ2VzIiwibG9hZFBzZXVkb0VsZW1lbnRJbWFnZXMiLCJsb2FkR3JhZGllbnRJbWFnZSIsImludmFsaWRCYWNrZ3JvdW5kcyIsImJhY2tncm91bmRfaW1hZ2UiLCJnZXRJbWFnZXMiLCJlbE5vZGVUeXBlIiwib25sb2FkIiwidGltZXIiLCJjbGVhclRpbWVvdXQiLCJvbmVycm9yIiwiYWxsb3dUYWludCIsInVzZUNPUlMiLCJjbGVhbnVwRE9NIiwiY2F1c2UiLCJ0aW1lb3V0IiwiZXhlY0NvbW1hbmQiLCJjbG9zZSIsInJlbmRlcmluZ0RvbmUiLCJSZW5kZXJlciIsInBhcnNlUXVldWUiLCJjcmVhdGVSZW5kZXJRdWV1ZSIsInF1ZXVlIiwicm9vdENvbnRleHQiLCJidWlsZFN0YWNraW5nQ29udGV4dCIsInJvb3ROb2RlIiwiaW5zZXJ0IiwiY29udGV4dCIsInNwZWNpYWxQYXJlbnQiLCJ6aSIsIk51bWJlciIsImNvbnRleHRGb3JDaGlsZHJlbiIsInN0dWIiLCJjaGlsZHJlbkRlc3QiLCJjaGlsZE5vZGUiLCJzb3J0WiIsInNvcnQiLCJub25Qb3NpdGlvbmVkIiwiZmxvYXRlZCIsInBvc2l0aW9uZWQiLCJsaXN0Iiwid2FsayIsImNvbmNhdCIsImdldFJlbmRlcmVyIiwicmVuZGVyZXJOYW1lIiwicmVuZGVyZXIiLCJFcnJvciIsInN1cHBvcnRTVkdSZW5kZXJpbmciLCJ0b0RhdGFVUkwiLCJzdXBwb3J0UmFuZ2VCb3VuZHMiLCJyIiwidGVzdEVsZW1lbnQiLCJyYW5nZUhlaWdodCIsInNlbGVjdE5vZGUiLCJzdmdSZW5kZXJpbmciLCJvcHRzIiwidGFpbnRUZXN0Iiwib25wcmVsb2FkZWQiLCJvbnBhcnNlZCIsIm9ucmVuZGVyZWQiLCJyZW5kZXIiLCJwYXJzZSIsInByZWxvYWQiLCJDYW52YXMiLCJzYWZlSW1hZ2VzIiwidGVzdENhbnZhcyIsInRlc3RjdHgiLCJiZWdpblBhdGgiLCJhcmciLCJjbG9zZVBhdGgiLCJzYWZlSW1hZ2UiLCJpdGVtIiwiZ2V0SW1hZ2VEYXRhIiwicmVuZGVySXRlbSIsInBhcnNlZERhdGEiLCJuZXdDYW52YXMiLCJmc3R5bGUiLCJ6U3RhY2siLCJzdG9yYWdlQ29udGV4dCIsInRleHRCYXNlbGluZSIsInJlY3QiLCJFdmVudGVkIiwiYWRkQ2xhc3MiLCJkZWZlciIsImRlZmVycmVkIiwiZXh0ZW5kIiwiZmx1c2giLCJnZXRDbGFzc05hbWUiLCJnZXRPZmZzZXRQYXJlbnQiLCJnZXRPcmlnaW4iLCJnZXRTY3JvbGxCYXJTaXplIiwiZ2V0U2Nyb2xsUGFyZW50IiwiaGFzQ2xhc3MiLCJyZW1vdmVDbGFzcyIsInNldENsYXNzTmFtZSIsInVuaXF1ZUlkIiwidXBkYXRlQ2xhc3NlcyIsInplcm9Qb3NDYWNoZSIsIl9faGFzUHJvcCIsIl9faW5kZXhPZiIsIl9fc2xpY2UiLCJUZXRoZXIiLCJtb2R1bGVzIiwiZG9tIiwiZ2V0Qm9keSIsInNjcm9sbFBhcmVudCIsIl9yZWYiLCJpc1JlbGF0aXZlIiwiX2Vycm9yIiwiayIsIl90ZXRoZXJaZXJvRWxlbWVudCIsImJveCIsImRvY0VsIiwicmlnaHQiLCJjbGllbnRUb3AiLCJjbGllbnRMZWZ0IiwiaW5uZXIiLCJvdXRlciIsIndpZHRoQ29udGFpbmVkIiwid2lkdGhTY3JvbGwiLCJwb2ludGVyRXZlbnRzIiwib3ZlcmZsb3ciLCJvdXQiLCJvYmoiLCJfaSIsIl9sZW4iLCJjbHMiLCJfcmVzdWx0cyIsImFkZCIsImNvbnRhaW5zIiwiU1ZHQW5pbWF0ZWRTdHJpbmciLCJiYXNlVmFsIiwiYWxsIiwiX2oiLCJfbGVuMSIsImZuIiwicG9wIiwiaGFuZGxlciIsIm9uY2UiLCJfYmFzZSIsImJpbmRpbmdzIiwib2ZmIiwidHJpZ2dlciIsIl9yZWYxIiwiVXRpbHMiLCJNSVJST1JfTFIiLCJNSVJST1JfVEIiLCJPRkZTRVRfTUFQIiwiYWRkT2Zmc2V0IiwiYXR0YWNobWVudFRvT2Zmc2V0IiwiYXV0b1RvRml4ZWRBdHRhY2htZW50IiwiZ2V0T3V0ZXJTaXplIiwiZ2V0U2l6ZSIsIm5vdyIsIm9mZnNldFRvUHgiLCJwYXJzZUF0dGFjaG1lbnQiLCJwYXJzZU9mZnNldCIsInRldGhlcnMiLCJ0cmFuc2Zvcm1LZXkiLCJ3aXRoaW4iLCJfVGV0aGVyIiwiX19iaW5kIiwibWUiLCJkaWZmIiwidGV0aGVyIiwicGVyZm9ybWFuY2UiLCJEYXRlIiwibGFzdENhbGwiLCJsYXN0RHVyYXRpb24iLCJwZW5kaW5nVGltZW91dCIsInRpY2siLCJhZGRFdmVudExpc3RlbmVyIiwiY2VudGVyIiwiYXR0YWNobWVudCIsInJlbGF0aXZlVG9BdHRhY2htZW50IiwiX3JlZjIiLCJvZmZzZXRzIiwib2Zmc2V0IiwibW9kdWxlIiwiaGlzdG9yeSIsInNldE9wdGlvbnMiLCJpbml0aWFsaXplIiwiZ2V0Q2xhc3MiLCJjbGFzc2VzIiwiY2xhc3NQcmVmaXgiLCJ0YXJnZXRPZmZzZXQiLCJ0YXJnZXRBdHRhY2htZW50IiwidGFyZ2V0IiwidGFyZ2V0TW9kaWZpZXIiLCJqcXVlcnkiLCJxdWVyeVNlbGVjdG9yIiwiZGlzYWJsZSIsImVuYWJsZWQiLCJlbmFibGUiLCJnZXRUYXJnZXRCb3VuZHMiLCJmaXRBZGoiLCJoYXNCb3R0b21TY3JvbGwiLCJzY3JvbGxCb3R0b20iLCJzY3JvbGxQZXJjZW50YWdlIiwicGFnZVlPZmZzZXQiLCJwYWdlWE9mZnNldCIsImlubmVySGVpZ2h0IiwiaW5uZXJXaWR0aCIsIm92ZXJmbG93WCIsImJvcmRlclRvcFdpZHRoIiwiYm9yZGVyQm90dG9tV2lkdGgiLCJib3JkZXJMZWZ0V2lkdGgiLCJzY3JvbGxUb3AiLCJjbGVhckNhY2hlIiwiX2NhY2hlIiwiY2FjaGUiLCJnZXR0ZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZGVzdHJveSIsInVwZGF0ZUF0dGFjaENsYXNzZXMiLCJlbGVtZW50QXR0YWNoIiwidGFyZ2V0QXR0YWNoIiwic2lkZXMiLCJfdGhpcyIsIl9hZGRBdHRhY2hDbGFzc2VzIiwiZmx1c2hDaGFuZ2VzIiwiZWxlbWVudFBvcyIsImVsZW1lbnRTdHlsZSIsIm1hbnVhbE9mZnNldCIsIm1hbnVhbFRhcmdldE9mZnNldCIsIm5leHQiLCJvZmZzZXRCb3JkZXIiLCJvZmZzZXRQYXJlbnRTaXplIiwib2Zmc2V0UGFyZW50U3R5bGUiLCJvZmZzZXRQb3NpdGlvbiIsInNjcm9sbExlZnQiLCJzY3JvbGxiYXJTaXplIiwidGFyZ2V0UG9zIiwidGFyZ2V0U2l6ZSIsIl9yZWYzIiwiX3JlZjQiLCJfcmVmNSIsIl9yZWY2IiwibGFzdFNpemUiLCJwYWdlIiwidmlld3BvcnQiLCJwYXJlbnRFbGVtZW50Iiwib3B0aW1pemF0aW9ucyIsIm1vdmVFbGVtZW50IiwibW92ZSIsImVsVmFsIiwiZm91bmQiLCJtb3ZlZCIsInBvaW50Iiwic2FtZSIsInRyYW5zY3JpYmUiLCJ3cml0ZSIsIndyaXRlQ1NTIiwicG9zIiwieFBvcyIsInlQb3MiLCJncHUiLCJ0YWdOYW1lIiwiQk9VTkRTX0ZPUk1BVCIsIk1JUlJPUl9BVFRBQ0giLCJnZXRCb3VuZGluZ1JlY3QiLCJ0byIsIl9hcmciLCJhZGRDbGFzc2VzIiwiYWxsQ2xhc3NlcyIsImNoYW5nZUF0dGFjaFgiLCJjaGFuZ2VBdHRhY2hZIiwiY29uc3RyYWludCIsImVBdHRhY2htZW50Iiwib29iIiwib29iQ2xhc3MiLCJwIiwicGluIiwicGlubmVkIiwicGlubmVkQ2xhc3MiLCJ0QXR0YWNobWVudCIsInRhcmdldEhlaWdodCIsInRhcmdldFdpZHRoIiwiX2siLCJfbCIsIl9sZW4yIiwiX2xlbjMiLCJfbGVuNCIsIl9sZW41IiwiX20iLCJfbiIsIl9yZWY3IiwiX3JlZjgiLCJjb25zdHJhaW50cyIsIm91dE9mQm91bmRzQ2xhc3MiLCJhYnV0dGVkIiwic2hpZnQiLCJzaGlmdExlZnQiLCJzaGlmdFRvcCIsIlNvcnRhYmxlRmFjdG9yeSIsImRyYWdFbCIsImdob3N0RWwiLCJjbG9uZUVsIiwicm9vdEVsIiwibmV4dEVsIiwic2Nyb2xsRWwiLCJzY3JvbGxQYXJlbnRFbCIsImxhc3RFbCIsImxhc3RDU1MiLCJvbGRJbmRleCIsIm5ld0luZGV4IiwiYWN0aXZlR3JvdXAiLCJhdXRvU2Nyb2xsIiwidGFwRXZ0IiwidG91Y2hFdnQiLCJSU1BBQ0UiLCJleHBhbmRvIiwiZ2V0VGltZSIsIndpbiIsInN1cHBvcnREcmFnZ2FibGUiLCJfc2lsZW50IiwiX2Rpc3BhdGNoRXZlbnQiLCJzb3J0YWJsZSIsInRhcmdldEVsIiwiZnJvbUVsIiwic3RhcnRJbmRleCIsImV2dCIsImNyZWF0ZUV2ZW50Iiwib25OYW1lIiwiY2hhckF0IiwiaW5pdEV2ZW50IiwiZnJvbSIsImNsb25lIiwiZGlzcGF0Y2hFdmVudCIsImFicyIsInRvdWNoRHJhZ092ZXJMaXN0ZW5lcnMiLCJfYXV0b1Njcm9sbCIsIl90aHJvdHRsZSIsInNlbnMiLCJzY3JvbGxTZW5zaXRpdml0eSIsInNwZWVkIiwic2Nyb2xsU3BlZWQiLCJjbGllbnRYIiwiY2xpZW50WSIsIndpbldpZHRoIiwid2luSGVpZ2h0IiwidngiLCJ2eSIsImNsZWFySW50ZXJ2YWwiLCJwaWQiLCJzZXRJbnRlcnZhbCIsInNjcm9sbFRvIiwiU29ydGFibGUiLCJfZXh0ZW5kIiwiZ3JvdXAiLCJyYW5kb20iLCJkaXNhYmxlZCIsInN0b3JlIiwiaGFuZGxlIiwiZHJhZ2dhYmxlIiwiZ2hvc3RDbGFzcyIsImlnbm9yZSIsImFuaW1hdGlvbiIsInNldERhdGEiLCJkYXRhVHJhbnNmZXIiLCJ0ZXh0Q29udGVudCIsImRyb3BCdWJibGUiLCJkcmFnb3ZlckJ1YmJsZSIsImRhdGFJZEF0dHIiLCJkZWxheSIsImdyb3VwcyIsInB1dCIsIl9iaW5kIiwiX29uIiwiX29uVGFwU3RhcnQiLCJfb25EcmFnT3ZlciIsImdldCIsImNvbnN0cnVjdG9yIiwidG91Y2giLCJ0b3VjaGVzIiwib3JpZ2luYWxUYXJnZXQiLCJidXR0b24iLCJfY2xvc2VzdCIsIl9pbmRleCIsInByZXZlbnREZWZhdWx0Iiwic29tZSIsImNyaXRlcmlhIiwiX3ByZXBhcmVEcmFnU3RhcnQiLCJkcmFnU3RhcnRGbiIsIm5leHRTaWJsaW5nIiwiX2Rpc2FibGVEZWxheWVkRHJhZyIsIl9maW5kIiwiX2Rpc2FibGVEcmFnZ2FibGUiLCJfdHJpZ2dlckRyYWdTdGFydCIsIl9vbkRyb3AiLCJfZHJhZ1N0YXJ0VGltZXIiLCJfb2ZmIiwiX29uRHJhZ1N0YXJ0IiwiZW1wdHkiLCJnZXRTZWxlY3Rpb24iLCJyZW1vdmVBbGxSYW5nZXMiLCJlcnIiLCJfZHJhZ1N0YXJ0ZWQiLCJfdG9nZ2xlQ2xhc3MiLCJhY3RpdmUiLCJfZW11bGF0ZURyYWdPdmVyIiwiX2NzcyIsImVsZW1lbnRGcm9tUG9pbnQiLCJncm91cE5hbWUiLCJfb25Ub3VjaE1vdmUiLCJkeCIsImR5IiwidHJhbnNsYXRlM2QiLCJ1c2VGYWxsYmFjayIsIl9vZmZVcEV2ZW50cyIsInB1bGwiLCJnaG9zdFJlY3QiLCJtYXJnaW5Ub3AiLCJtYXJnaW5MZWZ0IiwiX2xvb3BJZCIsImVmZmVjdEFsbG93ZWQiLCJkcmFnUmVjdCIsInJldmVydCIsImdyb3VwUHV0IiwiaXNPd25lciIsImNhblNvcnQiLCJzdG9wUHJvcGFnYXRpb24iLCJfY2xvbmVIaWRlIiwiX2dob3N0SW5Cb3R0b20iLCJhbmltYXRlZCIsInRhcmdldFJlY3QiLCJfYW5pbWF0ZSIsImZsb2F0aW5nIiwiY3NzRmxvYXQiLCJpc1dpZGUiLCJpc0xvbmciLCJoYWxmd2F5IiwibmV4dEVsZW1lbnRTaWJsaW5nIiwiX3Vuc2lsZW50IiwicHJldmlvdXNFbGVtZW50U2libGluZyIsInByZXZSZWN0IiwibXMiLCJjdXJyZW50UmVjdCIsImRyYWdTdGFydFRpbWVyIiwiaGFuZGxlRXZlbnQiLCJfZ2xvYmFsRHJhZ092ZXIiLCJ0b0FycmF5Iiwib3JkZXIiLCJuIiwiX2dlbmVyYXRlSWQiLCJpdGVtcyIsInNldCIsImNsb3Nlc3QiLCJzZWxlY3RvciIsIm9wdGlvbiIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJyZW1vdmVBdHRyaWJ1dGUiLCJiaW5kIiwidGFnIiwicmUiLCJkcm9wRWZmZWN0IiwiaXRlcmF0b3IiLCJsYXN0RWxlbWVudENoaWxkIiwic3VtIiwiY2hhckNvZGVBdCIsImNhbGxiYWNrIiwidXRpbHMiLCJpcyIsInRocm90dGxlIiwidG9nZ2xlQ2xhc3MiLCJ2ZXJzaW9uIiwiY3JlYXRlIiwidGVsbE1hc3RlclNoaW0iLCJhdHRhY2hFdmVudCIsIlNpenpsZSIsInNpenpsZSIsInRlbGxNYXN0ZXIiLCJyZWdpc3Rlck1lc3NhZ2VIYW5kbGVyIiwicGxhY2VCYWRnZSIsIl8iLCJzdG9wR3VpZGVzIiwicmVtb3ZlQWxsQmFkZ2VzIiwiREVGQVVMVF9USU1FUl9MRU5HVEgiLCJyZW1vdmVMYXVuY2hlciIsImNyZWF0ZUxhdW5jaGVyIiwiYWRkR3VpZGVUb0xhdW5jaGVyIiwiX2FkZEd1aWRlVG9MYXVuY2hlciIsInVwZGF0ZUxhdW5jaGVyQ29udGVudCIsImdldE9mZnNldFBvc2l0aW9uIiwiZ2V0U2NyZWVuRGltZW5zaW9ucyIsIndoZW5Mb2FkZWRDYWxsIiwiR3VpZGVGYWN0b3J5IiwiR3VpZGVTdGVwIiwibG9hZEd1aWRlQ3NzIiwiYXJlR3VpZGVzRW5hYmxlZCIsInNob3dMYXVuY2hlciIsImhpZGVMYXVuY2hlciIsImdldFZpc2l0b3JJZCIsImV4dHJhY3RFbGVtZW50VHJlZUNvbnRleHQiLCJleHRyYWN0RWxlbWVudFRyZWVDb250ZXh0QmFja0ZpbGwiLCJzZWxlY3RvcnMiLCJwc2V1ZG9zIiwiY3JlYXRlUHNldWRvIiwiYmVoYXZpb3JzIiwiUHJldmlldyIsImZpeGVkVGFyZ2V0Iiwid2FybmluZ1JlYXNvbiIsImNlbnRlckZsb2F0aW5nVG9vbHRpcCIsImlzU2hvd24iLCJzY3JlZW4iLCJndWlkZSIsImZsb29yIiwiY2FuU2hvdyIsImNhblNob3dPblBhZ2UiLCJnZXRDdXJyZW50VXJsIiwiZWxlbWVudFBhdGhSdWxlIiwiYW55IiwiYXBwZW5kVG8iLCJvdmVycmlkZUVsZW1lbnQiLCJyZWFzb24iLCJwYXJlbnRQb3NpdGlvbiIsImVsZW1lbnRQb3NpdGlvbiIsImdldENsaWVudFJlY3QiLCJ2aWV3cG9ydFJlY3QiLCJpbnRlcnNlY3RSZWN0IiwiZXJyb3IiLCJwcmV2U2Nyb2xsUGFyZW50Iiwic2Nyb2xsUmVjdCIsInJlbW92ZU5vZGUiLCJkb21Ob2RlIiwiY2xhc3NuYW1lIiwiZWxlbXMiLCJfcmVtb3ZlQ2xhc3MiLCJfYWRkQ2xhc3MiLCJlbGUiLCJyZWciLCJOQVZJR0FUSU9OX01PREUiLCJTRUxFQ1RJT05fTU9ERSIsIk9WRVJMQVlfTU9ERSIsIl9QRU5ET19URVRIRVJfQ0xBU1NfUFJFRklYIiwiX1BFTkRPX09WRVJMQVlfQ0xBU1MiLCJfUEVORE9fT1ZFUkxBWV9UQVJHRVRfQ0xBU1MiLCJfUEVORE9fVE9PTFRJUF9DTEFTUyIsIl9QRU5ET19UT09MVElQX0NPTlRFTlRfQ0xBU1MiLCJfUEVORE9fU0VMRUNUSU9OX0NMQVNTIiwiX1BFTkRPX1NFTEVDVElPTl9ISUdITElHSFRfQ0xBU1MiLCJfUEVORE9fVEFHR0VEX0NMQVNTIiwiSUdOT1JFX0NMQVNTRVMiLCJoYW5kbGVNb2RlQ2hhbmdlIiwiY3VycmVudE1vZGUiLCJNT0RFUyIsIm1zZyIsInRhZ2dlZEZlYXR1cmVzIiwiVGFnZ2VkRmVhdHVyZXMiLCJ1cGRhdGVUYWdnZWRGZWF0dXJlcyIsInVwZGF0ZSIsImZlYXR1cmVzIiwicGFnZXMiLCJpc1JlYWRPbmx5IiwiaXNJblN0YXRlIiwic2hvd091dGxpbmVzIiwic2hvd092ZXJsYXlzIiwiaGlkZSIsImlzQmFkZ2UiLCJsYXVuY2hNZXRob2QiLCJzaG93QmFkZ2UiLCJpc0luTGF1bmNoZXIiLCJ1cGRhdGVBY3RpdmVHdWlkZXMiLCJndWlkZXMiLCJsYXVuY2hlckd1aWRlcyIsImlzRnVuY3Rpb24iLCJndWlkZVdpZGdldCIsIm9uY2xpY2siLCJsaXN0aW5nIiwib25VcGRhdGUiLCJkaXNwbGFjZWRHdWlkZSIsIm5ld1ByaW9yaXR5IiwiYXR0cmlidXRlcyIsInByaW9yaXR5IiwiZ3VpZGVJZCIsInNlbmRHdWlkZUNzcyIsImRpcnR5RWRpdEd1aWRlIiwiY2xlYXJEaXJ0eUVkaXRzIiwicmVjdDEiLCJyZWN0MiIsImdldFNpdGVUaGVtZSIsInN0eWxlc0Zyb21Ob2RlcyIsIm5vZGVzIiwibG9va3VwVGFibGUiLCJjb21wdXRlZFN0eWxlIiwiZm9udExpc3QiLCJnZXRQcm9wZXJ0eVZhbHVlIiwicmdiMmhleCIsImJ1aWxkVGhlbWVMaXN0Iiwid2hpdGVsaXN0Iiwic3R5bGVzIiwiaW5wdXRSZ2IiLCJyZ2IiLCJoZXgiLCJoZXhEaWdpdHMiLCJlbGVtZW50Q29udGFpbnMiLCJjb250YWluZWUiLCJzZWxmIiwib3ZlcmxheXMiLCJhY3RpdmVQYWdlcyIsIm1heE51bUV2ZW50cyIsImhvdmVyIiwiY2xpY2siLCJzdGFydFdhdGNoaW5nIiwiaW50ZXJ2YWwiLCJyZWZyZXNoIiwic3RvcFdhdGNoaW5nIiwicmVmcmVzaFBvc2l0aW9uIiwiYmF0Y2hTaXplIiwiaXNGZWF0dXJlT25QYWdlIiwiZmVhdHVyZSIsInBhZ2VJZCIsIm51bUV2ZW50cyIsInJhbmsiLCJtYXhpbXVtcyIsIm51bVZpc2l0b3JzIiwibnVtQWNjb3VudHMiLCJjbGVhciIsIm92ZXJsYXkiLCJGZWF0dXJlT3ZlcmxheSIsImhpZGVPdmVybGF5cyIsImhpZGVPdXRsaW5lcyIsInNob3ciLCJoaWRlT3V0bGluZSIsInNob3dPdXRsaW5lIiwidG9vbHRpcCIsIlRvb2x0aXAiLCJ2aXNpYmxlIiwib3V0bGluZWQiLCJlZGl0QnV0dG9uIiwiaGFzT3ZlcmxheSIsImVsZW1lbnRQYXRoUnVsZXMiLCJqaiIsIkVsZW1lbnRPdmVybGF5IiwidGVtcGxhdGUiLCJkaXJ0eSIsIm1heFJhbmsiLCJodWUiLCJhY3RpdmVPdmVybGF5IiwiZmVhdHVyZUlkIiwidG9vbHRpcENvbnRlbnQiLCJvdXRsaW5lQ29sb3IiLCJvcmlnaW5hbE91dGxpbmVDb2xvciIsInN0b3BFdmVudEJ1YmJsaW5nIiwiaGFzTG9jayIsIl9zdGF0ZSIsImFkZExvY2siLCJjbGVhckxvY2siLCJzdCIsInNldFN0YXRlIiwic3RhcnROYXZpZ2F0aW9uTW9kZSIsInN0YXJ0U2VsZWN0aW9uTW9kZSIsInN0YXJ0T3ZlcmxheU1vZGUiLCJmaW5kVGFyZ2V0IiwiaXNQcmV2aWV3aW5nIiwib3ZlcnJpZGVPbkNsaWNrIiwib2xkT25jbGljayIsImZpeE9uQ2xpY2siLCJ1bmhpZ2hsaWdodCIsIm9sZFRhcmdldCIsImRldGVjdElnbm9yZWRFbGVtZW50IiwiZGV0ZWN0TW9kS2V5cyIsInNoaWZ0S2V5IiwiY3RybEtleSIsImFsdEtleSIsImhpZ2hsaWdodCIsImdldFRhcmdldFBhdGgiLCJwYXRoRWxlbXNBcnIiLCJfZ2V0VmFsaWRDbGFzc05hbWVzIiwiaXNCYWRDbGFzcyIsImNsc1N0ciIsInJhd0NsYXNzZXMiLCJ0ZXN0Q3NzU2VsZWN0b3IiLCJjc3NTZWxlY3RvciIsImlzSW52YWxpZCIsInN1Y2Nlc3MiLCJleGVjIiwiYWxsb3dNdWx0aXBsZSIsIklEX0JMQUNLTElTVCIsIl9pc0JsYWNrTGlzdGVkSWQiLCJDc3NTZWxlY3RvckJ1aWxkZXIiLCJwYXRoIiwiY29uanVuY3Rpb24iLCJjdXJyZW50Q29udGV4dCIsInVwIiwicGFyZW50RWxlbSIsImNyZWF0ZVBhdGhOb2RlIiwibWF0Y2hDb3VudCIsImNoYWluIiwicGF0aE5vZGUiLCJiZXN0U2VsZWN0b3IiLCJkb2VzRXhpc3QiLCJudGhDaGlsZCIsImlkU2VsZWN0b3IiLCJlc2NhcGVDc3MiLCJnZXRWYWxpZEF0dHJpYnV0ZXMiLCJhdHRycyIsImF0dHJOYW1lIiwic29ydEJ5IiwicGx1Y2siLCJjaGlsZEluZGV4IiwidHh0IiwiYnVpbGRDb250YWluc1J1bGUiLCJlbGVjdEJlc3RTZWxlY3RvciIsImJlc3RTZWxlY3RvclNvRmFyIiwiSW5maW5pdHkiLCJ3aXRob3V0Iiwic2luZ2xlUXVvdGVJbmRleCIsImRvdWJsZVF1b3RlSW5kZXgiLCJjb21wdXRlQ3NzTWF0Y2giLCJzZWxlY3RvckJ1aWxkZXIiLCJjdXJyZW50RWxlbWVudCIsImV4Y2x1ZGVBbGxUZXh0IiwiZ2V0VGV4dCIsImdldFNlbGVjdGVkRWxlbWVudCIsIm9yaWdDbGFzcyIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJjbGllbnRfY29vcmRzIiwic2NyZWVuX2Nvb3JkcyIsInNjcmVlblgiLCJzY3JlZW5ZIiwiY3NzTWF0Y2giLCJjbGllbnQiLCJpc1ByZXZpZXdFbGVtZW50IiwiZmluZE50aFBhcmVudCIsIm50aCIsImhhbmRsZU1vdmVTZWxlY3Rpb25VcCIsImRpc3RhbmNlIiwicmV0dXJuQ3NzIiwibmF2aWdhdGlvbiIsImVkaXRvckluc3RhbmNlIiwiY3VycmVudFVwbG9hZEluZm8iLCJzaG93R3VpZGVQcmV2aWV3IiwiZ3VpZGVPclN0ZXAiLCJjbG9zZVByZXZpZXciLCJzdGVwcyIsImJhZGdlSW5mbyIsImJhZGdlIiwicHJldmlld2VkR3VpZGUiLCJwcmV2aWV3UG9sbCIsInBvbGxQcmV2aWV3TW9kZSIsInByZXZpZXdHdWlkZSIsImhpZGVDcmVkaXRzIiwiY29uZmlnIiwiaGlkZVBvd2VyZWRCeSIsInNob3duIiwiaXNFZGl0YWJsZSIsInByZXZpZXdHdWlkZVRocmVhZEhhbmRsZSIsImVsbXMiLCJnZXRHdWlkZVByZXZpZXdET00iLCJndWlkZUNvbnRlbnRFbGVtZW50IiwidXBsb2FkIiwiZWRpdFByZXZpZXdDbGlja0ZuIiwiZGV0YWNoRXZlbnQiLCJpbml0RWRpdG9yIiwiZ3VpZGVFbGVtIiwiY29udGVudEVsZW0iLCJ0b29sYmFyRWxlbSIsInVwZGF0ZVVwbG9hZEluZm8iLCJiYXNlUGF0aCIsIlBFTkRPX0NLRURJVE9SX0JBU0VQQVRIIiwiUEVORE9fQ0tFRElUT1IiLCJwbHVnaW5zIiwiZXh0ZXJuYWxzIiwiYWRkRXh0ZXJuYWwiLCJjayIsImlubGluZSIsImN1c3RvbUNvbmZpZyIsInJlbW92ZVBsdWdpbnMiLCJyZW1vdmVCdXR0b25zIiwiZXh0cmFQbHVnaW5zIiwic2ltcGxldXBsb2Fkc19hY2NlcHRlZEV4dGVuc2lvbnMiLCJmaWxlYnJvd3NlckltYWdlVXBsb2FkVXJsIiwicmVtb3ZlRGlhbG9nVGFicyIsImJhc2VGbG9hdFpJbmRleCIsImFsbG93ZWRDb250ZW50Iiwic3RhcnR1cEZvY3VzIiwic2hhcmVkU3BhY2VzIiwidG9vbGJhciIsImV2IiwiZWRpdG9yIiwic2V0UmVhZE9ubHkiLCJlZGl0b3JfaWQiLCJ1aSIsInNwYWNlSWQiLCJleHRyYUZpZWxkcyIsImV4dHJhRGF0YSIsInVwbG9hZFVybCIsImRvd25sb2FkVXJsIiwicHJlcGFyZVVwbG9hZCIsImh0bWwiLCJnZXREYXRhIiwidXBkYXRlR3VpZGVPYmplY3RDb250ZW50Iiwia2lsbEVkaXRvciIsInNpbGVudCIsInN0YXR1cyIsIm5ld0NvbnRlbnQiLCJlYWNoIiwicmVzaXplR3VpZGVQcmV2aWV3IiwicmVzaXplIiwidXBkYXRlQ29udGVudCIsImdldENvbnRlbnQiLCJ1cGRhdGVHdWlkZVdpZGdldCIsInRvZ2dsZUxhdW5jaGVyIiwidXBkYXRlR3VpZGVDc3MiLCJpc1N0cmluZyIsInNlbGVjdEVsZW1lbnQiLCJhdmFpbGFibGUiLCJwcm9taXNlSWQiLCJ0YWtlU25hcHNob3QiLCJjb250ZW50RGl2IiwiZ3VpZGVEaXYiLCJyZXNpemVkQ2FudmFzIiwicmVzaXplZENvbnRleHQiLCJzeCIsInN5IiwiZ3VpZGVXaWR0aCIsImd1aWRlSGVpZ2h0IiwibWF4QmFubmVyV2lkdGgiLCJndWlkZVJhdGlvIiwiZFJhdGlvIiwiZHciLCJkaCIsInN0b3BJZlNlbGVjdGluZyIsImF0dGFjaFRvIiwiZXZlbnRUdXBsZSIsIm5vcm1hbGl6ZWRVcmwiLCJ1c2VDYXB0dXJlIiwib25Mb2FkZWQiLCJhZGRNZXNzYWdlcyIsInBhcnRpYWwiLCJhZGRFdmVudHMiLCJmaW5pc2hJbml0IiwiY2IiLCJzZXR1cFJwYyIsInByZXZpZXdIdG1sIiwicHJldmlld0NzcyIsInN0b3BQcmV2aWV3SHRtbENzcyIsImNoZWNrR3VpZGVzRW5hYmxlZCIsInN0b3BQcmV2aWV3R3VpZGUiLCJsYXN0UHJldmlld2VkR3VpZGUiLCJtc2dDb250ZW50IiwiZXZlbnRzIiwicElkIiwibWFzdGVyQWNrIiwiYWRkRGVmYXVsdENzcyIsImNzc0xpbmsiLCJyZW1vdmVEZWZhdWx0Q3NzIiwicHJldmlldyIsImFkZENzc1RvSHRtbCIsInByZXZpZXdIdG1sQ3NzIiwicG9sbCIsIm5wc1JhdGluZyIsInN1Ym1pdCIsInN1Ym1pdHRlZCIsIm5wc1JhdGluZ1NlbGVjdGVkIiwicmVtb3ZlUHJldmlld0h0bWxDc3MiLCJ4U2Nyb2xsQW10IiwieVNjcm9sbGFtdCIsImxlYWRpbmciLCJvbkd1aWRlQWR2YW5jZWQiLCJvbkd1aWRlRGlzbWlzc2VkIiwib25HdWlkZVByZXZpb3VzIiwiVkVSU0lPTiIsInZpc2l0b3JJZCIsImN1ckd1aWRlQ29udGFpbmVyIiwiYWxsb3dDb250YWlucyJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1EQUEyQyxjQUFjOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkM7Ozs7Ozs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsK0NBQStDLG1HQUFtRyxFQUFFO0FBQ3BKO0FBQ0Esd0M7Ozs7Ozs7QUNoTUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELHNEQUFzRCxFQUFFO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7Ozs7Ozs7O0FDbkx0QztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDJDOzs7Ozs7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYyxVQUFVO0FBQ3hCO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEI7Ozs7Ozs7QUNsT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGFBQWE7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHFCQUFxQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQ0FBbUM7QUFDbEQ7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLEVBQUU7QUFDakI7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsV0FBVztBQUMxQztBQUNBO0FBQ0EsdURBQXVELG9CQUFvQjtBQUMzRTtBQUNBLENBQUM7QUFDRDtBQUNBLHFDOzs7Ozs7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0M7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Qzs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0M7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQzs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUM7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQzs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0M7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Qzs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUM7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Qjs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0M7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQzs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEI7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQzs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0M7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQzs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUM7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQjs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUM7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQzs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUM7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Qzs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0M7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUM7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Qzs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0M7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQzs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUM7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQzs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0M7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQzs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUM7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQzs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0Q7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCOzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQzs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUM7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQzs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0M7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DOzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQzs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUM7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQzs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEM7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQzs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQjs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0I7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Qzs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0I7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQzs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQzs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQzs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUM7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQzs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUM7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQzs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUM7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQzs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkM7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Qzs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0M7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQzs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0M7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQzs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0M7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQzs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUM7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQzs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0M7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQzs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUM7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDOzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQzs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUM7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQzs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUM7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQzs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0M7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQzs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUM7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQzs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUM7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Qzs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0M7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQzs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEM7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQzs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSw4Qzs7Ozs7OztBQ3RJQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx3Qzs7Ozs7OztBQzVEQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNqRjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSw0Qzs7Ozs7OztBQ3ZQQTtBQUNBO0FBQ0E7QUFDQSxnQzs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBLHFDOzs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0EsaUM7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQSxvQzs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBLGdDOzs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0EscUM7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQSw0Qzs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBLHVDOzs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0EsOEI7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQSxvQzs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBLGlDOzs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0EsaUM7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQSw4Qjs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBLGlDOzs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0EsaUM7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQSxpQzs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBLGlDOzs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0EsaUM7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQSwrQjs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxnQkFBZ0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxTQUFTO0FBQ1QsU0FBUztBQUNULFNBQVM7QUFDVCxTQUFTO0FBQ1Q7QUFDQSxXQUFXLDBDQUEwQztBQUNyRDtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGlDOzs7Ozs7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFNBQVM7QUFDVCxTQUFTO0FBQ1QsU0FBUztBQUNULFNBQVM7QUFDVDtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0EsV0FBVyxVQUFVLHdCQUF3QixpQkFBaUI7QUFDOUQ7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwyQkFBMkI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EscUM7Ozs7Ozs7QUN2R0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFNBQVM7QUFDVCxTQUFTO0FBQ1QsU0FBUztBQUNULFNBQVM7QUFDVDtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0M7Ozs7Ozs7QUMzRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxTQUFTO0FBQ1QsU0FBUztBQUNULFNBQVM7QUFDVCxTQUFTO0FBQ1QsU0FBUztBQUNUO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx5QkFBeUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLEtBQUs7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx1Qzs7Ozs7OztBQzFHQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxTQUFTO0FBQ1QsU0FBUztBQUNULFNBQVM7QUFDVCxTQUFTO0FBQ1Q7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsVUFBVTtBQUNyQjtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRywyQ0FBMkM7QUFDako7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQzs7Ozs7OztBQ3RNQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxTQUFTO0FBQ1QsU0FBUztBQUNULFNBQVM7QUFDVCxTQUFTO0FBQ1Q7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQztBQUNBLFdBQVcsMENBQTBDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx3Qzs7Ozs7OztBQ3ZKQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFNBQVM7QUFDVCxTQUFTO0FBQ1QsU0FBUztBQUNULFNBQVM7QUFDVDtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHNDOzs7Ozs7O0FDekhBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUM7Ozs7Ozs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Qsb0JBQW9CO0FBQzVFO0FBQ0E7QUFDQSxJQUFJLG9CQUFvQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsU0FBUztBQUNUO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDOzs7Ozs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFNBQVM7QUFDVCxTQUFTO0FBQ1QsU0FBUztBQUNULFNBQVM7QUFDVCxTQUFTO0FBQ1QsU0FBUztBQUNULFNBQVM7QUFDVDtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUM7Ozs7Ozs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGdCQUFnQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsU0FBUztBQUNULFNBQVM7QUFDVCxTQUFTO0FBQ1QsU0FBUztBQUNULFNBQVM7QUFDVDtBQUNBLFdBQVcsb0RBQW9EO0FBQy9EO0FBQ0E7QUFDQSxXQUFXLG9GQUFvRjtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUM7Ozs7Ozs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsZ0JBQWdCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsU0FBUztBQUNULFNBQVM7QUFDVCxTQUFTO0FBQ1QsU0FBUztBQUNUO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQSxXQUFXLG9GQUFvRjtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Qzs7Ozs7OztBQy9EQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxTQUFTO0FBQ1QsU0FBUztBQUNUO0FBQ0EsV0FBVyw4REFBOEQ7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUM7Ozs7Ozs7QUM5R0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG1CQUFtQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxtQkFBbUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxTQUFTO0FBQ1QsU0FBUztBQUNULFNBQVM7QUFDVDtBQUNBLFdBQVcsMENBQTBDO0FBQ3JEO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsb0M7Ozs7Ozs7QUM5SEE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFlBQVk7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGlCQUFpQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxTQUFTO0FBQ1QsU0FBUztBQUNULFNBQVM7QUFDVCxTQUFTO0FBQ1Q7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVLHdCQUF3QixpQkFBaUI7QUFDOUQ7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDJCQUEyQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0Esd0M7Ozs7Ozs7QUNuSEE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFNBQVM7QUFDVDtBQUNBLFdBQVcsSUFBSTtBQUNmO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxxQkFBcUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsMEM7Ozs7Ozs7QUM1RUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsU0FBUztBQUNUO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMkJBQTJCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUM7Ozs7Ozs7QUN0SUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxZQUFZO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFNBQVM7QUFDVDtBQUNBLFdBQVcsK0JBQStCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QscUM7Ozs7Ozs7QUM3TEE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixtQkFBbUI7QUFDakQ7QUFDQTtBQUNBLG1DQUFtQyxtQkFBbUI7QUFDdEQsc0RBQXNELGtCQUFrQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksbUJBQW1CO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGtCQUFrQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxTQUFTO0FBQ1Q7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx5Qzs7Ozs7OztBQzFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHFCQUFxQjtBQUM3QixRQUFRLHFCQUFxQjtBQUM3QixRQUFRLHFCQUFxQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxPQUFPO0FBQ1A7QUFDQSxTQUFTO0FBQ1QsU0FBUztBQUNUO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsV0FBVztBQUN0QixZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLG9DOzs7Ozs7O0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxxQkFBcUI7QUFDN0IsUUFBUSxxQkFBcUI7QUFDN0IsUUFBUSxxQkFBcUI7QUFDN0IsUUFBUSxxQkFBcUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsT0FBTztBQUNQLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNCQUFzQjtBQUM5QixRQUFRLHFCQUFxQjtBQUM3QixRQUFRLHNCQUFzQjtBQUM5QixRQUFRLHNCQUFzQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxPQUFPO0FBQ1AsT0FBTztBQUNQO0FBQ0EsU0FBUztBQUNULFNBQVM7QUFDVDtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUQ7Ozs7Ozs7QUNyRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxTQUFTO0FBQ1Q7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QjtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDhCOzs7Ozs7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsU0FBUztBQUNULFNBQVM7QUFDVCxTQUFTO0FBQ1QsU0FBUztBQUNUO0FBQ0EsWUFBWSx3QkFBd0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxxQzs7Ozs7OztBQ25HQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLElBQUk7QUFDZixZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxpQzs7Ozs7OztBQ3pFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGVBQWU7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsU0FBUztBQUNULFNBQVM7QUFDVCxTQUFTO0FBQ1QsU0FBUztBQUNULFNBQVM7QUFDVDtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG1DOzs7Ozs7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsY0FBYztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFNBQVM7QUFDVCxTQUFTO0FBQ1QsU0FBUztBQUNUO0FBQ0EsV0FBVyxvREFBb0Q7QUFDL0Q7QUFDQTtBQUNBLFdBQVcsb0ZBQW9GO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsc0M7Ozs7Ozs7QUN6SUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGVBQWU7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxTQUFTO0FBQ1Q7QUFDQSxXQUFXLGdEQUFnRDtBQUMzRDtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHVDQUF1QztBQUN2RSwrQkFBK0IsdUJBQXVCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxrQzs7Ozs7OztBQ3RKQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUM7Ozs7Ozs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFdBQVc7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLFlBQVk7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsU0FBUztBQUNULFNBQVM7QUFDVCxTQUFTO0FBQ1Q7QUFDQSxXQUFXLGtFQUFrRTtBQUM3RTtBQUNBLFdBQVcsSUFBSTtBQUNmO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQzs7Ozs7OztBQ3hDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFNBQVM7QUFDVCxTQUFTO0FBQ1Q7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBLFdBQVcsa0VBQWtFO0FBQzdFO0FBQ0EsV0FBVyxxQ0FBcUM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGlDOzs7Ozs7O0FDdkpBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx3QkFBd0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakM7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQztBQUNBLFdBQVcsMkRBQTJEO0FBQ3RFO0FBQ0E7QUFDQSxZQUFZLG1DQUFtQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxtQzs7Ozs7OztBQzFPQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywwRUFBMEU7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHlDOzs7Ozs7O0FDOU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsdUNBQXVDO0FBQy9GO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsMEM7Ozs7Ozs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxtQzs7Ozs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxxQzs7Ozs7Ozs7QUNoTkE7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGtDQUFrQyxFQUFFO0FBQ25GLCtCOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGVBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSx1Qzs7Ozs7OztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsK0I7Ozs7Ozs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0M7Ozs7Ozs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQjs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0M7Ozs7OztBQ25CQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsc0JBQXNCLEVBQUU7QUFDbEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7O0FDekxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQSxrQkFBa0IsMkJBQTJCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDJCQUEyQjtBQUM1QztBQUNBO0FBQ0EsUUFBUSx1QkFBdUI7QUFDL0I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGdDQUFnQyxzQkFBc0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDs7QUFFQSw2QkFBNkIsbUJBQW1COztBQUVoRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ3JQQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0ZBQUEzUjtBQUNBLHNHQUFBRyxHIiwiZmlsZSI6InBsdWdpbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDM1NSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgNzBlYTU1YzJiZDA2NTQzMGNmNjIiLCJcInVzZSBzdHJpY3RcIjtcbnZhciByb290XzEgPSByZXF1aXJlKCcuL3V0aWwvcm9vdCcpO1xudmFyIHRvU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi91dGlsL3RvU3Vic2NyaWJlcicpO1xudmFyIG9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vc3ltYm9sL29ic2VydmFibGUnKTtcbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiBvZiBhbnkgc2V0IG9mIHZhbHVlcyBvdmVyIGFueSBhbW91bnQgb2YgdGltZS4gVGhpcyB0aGUgbW9zdCBiYXNpYyBidWlsZGluZyBibG9ja1xuICogb2YgUnhKUy5cbiAqXG4gKiBAY2xhc3MgT2JzZXJ2YWJsZTxUPlxuICovXG52YXIgT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3Vic2NyaWJlIHRoZSBmdW5jdGlvbiB0aGF0IGlzICBjYWxsZWQgd2hlbiB0aGUgT2JzZXJ2YWJsZSBpc1xuICAgICAqIGluaXRpYWxseSBzdWJzY3JpYmVkIHRvLiBUaGlzIGZ1bmN0aW9uIGlzIGdpdmVuIGEgU3Vic2NyaWJlciwgdG8gd2hpY2ggbmV3IHZhbHVlc1xuICAgICAqIGNhbiBiZSBgbmV4dGBlZCwgb3IgYW4gYGVycm9yYCBtZXRob2QgY2FuIGJlIGNhbGxlZCB0byByYWlzZSBhbiBlcnJvciwgb3JcbiAgICAgKiBgY29tcGxldGVgIGNhbiBiZSBjYWxsZWQgdG8gbm90aWZ5IG9mIGEgc3VjY2Vzc2Z1bCBjb21wbGV0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE9ic2VydmFibGUoc3Vic2NyaWJlKSB7XG4gICAgICAgIHRoaXMuX2lzU2NhbGFyID0gZmFsc2U7XG4gICAgICAgIGlmIChzdWJzY3JpYmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZSA9IHN1YnNjcmliZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IE9ic2VydmFibGUsIHdpdGggdGhpcyBPYnNlcnZhYmxlIGFzIHRoZSBzb3VyY2UsIGFuZCB0aGUgcGFzc2VkXG4gICAgICogb3BlcmF0b3IgZGVmaW5lZCBhcyB0aGUgbmV3IG9ic2VydmFibGUncyBvcGVyYXRvci5cbiAgICAgKiBAbWV0aG9kIGxpZnRcbiAgICAgKiBAcGFyYW0ge09wZXJhdG9yfSBvcGVyYXRvciB0aGUgb3BlcmF0b3IgZGVmaW5pbmcgdGhlIG9wZXJhdGlvbiB0byB0YWtlIG9uIHRoZSBvYnNlcnZhYmxlXG4gICAgICogQHJldHVybiB7T2JzZXJ2YWJsZX0gYSBuZXcgb2JzZXJ2YWJsZSB3aXRoIHRoZSBPcGVyYXRvciBhcHBsaWVkXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUubGlmdCA9IGZ1bmN0aW9uIChvcGVyYXRvcikge1xuICAgICAgICB2YXIgb2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlKCk7XG4gICAgICAgIG9ic2VydmFibGUuc291cmNlID0gdGhpcztcbiAgICAgICAgb2JzZXJ2YWJsZS5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZTtcbiAgICB9O1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChvYnNlcnZlck9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIHZhciBvcGVyYXRvciA9IHRoaXMub3BlcmF0b3I7XG4gICAgICAgIHZhciBzaW5rID0gdG9TdWJzY3JpYmVyXzEudG9TdWJzY3JpYmVyKG9ic2VydmVyT3JOZXh0LCBlcnJvciwgY29tcGxldGUpO1xuICAgICAgICBpZiAob3BlcmF0b3IpIHtcbiAgICAgICAgICAgIG9wZXJhdG9yLmNhbGwoc2luaywgdGhpcy5zb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2luay5hZGQodGhpcy5fdHJ5U3Vic2NyaWJlKHNpbmspKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2luay5zeW5jRXJyb3JUaHJvd2FibGUpIHtcbiAgICAgICAgICAgIHNpbmsuc3luY0Vycm9yVGhyb3dhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoc2luay5zeW5jRXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBzaW5rLnN5bmNFcnJvclZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaW5rO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3RyeVN1YnNjcmliZSA9IGZ1bmN0aW9uIChzaW5rKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3Vic2NyaWJlKHNpbmspO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHNpbmsuc3luY0Vycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgICAgICAgIHNpbmsuc3luY0Vycm9yVmFsdWUgPSBlcnI7XG4gICAgICAgICAgICBzaW5rLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBtZXRob2QgZm9yRWFjaFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHQgYSBoYW5kbGVyIGZvciBlYWNoIHZhbHVlIGVtaXR0ZWQgYnkgdGhlIG9ic2VydmFibGVcbiAgICAgKiBAcGFyYW0ge1Byb21pc2VDb25zdHJ1Y3Rvcn0gW1Byb21pc2VDdG9yXSBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHVzZWQgdG8gaW5zdGFudGlhdGUgdGhlIFByb21pc2VcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgdGhhdCBlaXRoZXIgcmVzb2x2ZXMgb24gb2JzZXJ2YWJsZSBjb21wbGV0aW9uIG9yXG4gICAgICogIHJlamVjdHMgd2l0aCB0aGUgaGFuZGxlZCBlcnJvclxuICAgICAqL1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAobmV4dCwgUHJvbWlzZUN0b3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFQcm9taXNlQ3Rvcikge1xuICAgICAgICAgICAgaWYgKHJvb3RfMS5yb290LlJ4ICYmIHJvb3RfMS5yb290LlJ4LmNvbmZpZyAmJiByb290XzEucm9vdC5SeC5jb25maWcuUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIFByb21pc2VDdG9yID0gcm9vdF8xLnJvb3QuUnguY29uZmlnLlByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyb290XzEucm9vdC5Qcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgUHJvbWlzZUN0b3IgPSByb290XzEucm9vdC5Qcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghUHJvbWlzZUN0b3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm8gUHJvbWlzZSBpbXBsIGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlQ3RvcihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gX3RoaXMuc3Vic2NyaWJlKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSBzdWJzY3JpcHRpb24sIHRoZW4gd2UgY2FuIHN1cm1pc2VcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG5leHQgaGFuZGxpbmcgaXMgYXN5bmNocm9ub3VzLiBBbnkgZXJyb3JzIHRocm93blxuICAgICAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIGJlIHJlamVjdGVkIGV4cGxpY2l0bHkgYW5kIHVuc3Vic2NyaWJlIG11c3QgYmVcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsbGVkIG1hbnVhbGx5XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBOTyBzdWJzY3JpcHRpb24sIHRoZW4gd2UncmUgZ2V0dGluZyBhIG5leHRlZFxuICAgICAgICAgICAgICAgICAgICAvLyB2YWx1ZSBzeW5jaHJvbm91c2x5IGR1cmluZyBzdWJzY3JpcHRpb24uIFdlIGNhbiBqdXN0IGNhbGwgaXQuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGl0IGVycm9ycywgT2JzZXJ2YWJsZSdzIGBzdWJzY3JpYmVgIHdpbGwgZW5zdXJlIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyB1bnN1YnNjcmlwdGlvbiBsb2dpYyBpcyBjYWxsZWQsIHRoZW4gc3luY2hyb25vdXNseSByZXRocm93IHRoZSBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgLy8gQWZ0ZXIgdGhhdCwgUHJvbWlzZSB3aWxsIHRyYXAgdGhlIGVycm9yIGFuZCBzZW5kIGl0XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvd24gdGhlIHJlamVjdGlvbiBwYXRoLlxuICAgICAgICAgICAgICAgICAgICBuZXh0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCByZWplY3QsIHJlc29sdmUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQW4gaW50ZXJvcCBwb2ludCBkZWZpbmVkIGJ5IHRoZSBlczctb2JzZXJ2YWJsZSBzcGVjIGh0dHBzOi8vZ2l0aHViLmNvbS96ZW5wYXJzaW5nL2VzLW9ic2VydmFibGVcbiAgICAgKiBAbWV0aG9kIFN5bWJvbC5vYnNlcnZhYmxlXG4gICAgICogQHJldHVybiB7T2JzZXJ2YWJsZX0gdGhpcyBpbnN0YW5jZSBvZiB0aGUgb2JzZXJ2YWJsZVxuICAgICAqL1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlW29ic2VydmFibGVfMS4kJG9ic2VydmFibGVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8vIEhBQ0s6IFNpbmNlIFR5cGVTY3JpcHQgaW5oZXJpdHMgc3RhdGljIHByb3BlcnRpZXMgdG9vLCB3ZSBoYXZlIHRvXG4gICAgLy8gZmlnaHQgYWdhaW5zdCBUeXBlU2NyaXB0IGhlcmUgc28gU3ViamVjdCBjYW4gaGF2ZSBhIGRpZmZlcmVudCBzdGF0aWMgY3JlYXRlIHNpZ25hdHVyZVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgY29sZCBPYnNlcnZhYmxlIGJ5IGNhbGxpbmcgdGhlIE9ic2VydmFibGUgY29uc3RydWN0b3JcbiAgICAgKiBAc3RhdGljIHRydWVcbiAgICAgKiBAb3duZXIgT2JzZXJ2YWJsZVxuICAgICAqIEBtZXRob2QgY3JlYXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3Vic2NyaWJlPyB0aGUgc3Vic2NyaWJlciBmdW5jdGlvbiB0byBiZSBwYXNzZWQgdG8gdGhlIE9ic2VydmFibGUgY29uc3RydWN0b3JcbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBhIG5ldyBjb2xkIG9ic2VydmFibGVcbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKHN1YnNjcmliZSk7XG4gICAgfTtcbiAgICByZXR1cm4gT2JzZXJ2YWJsZTtcbn0oKSk7XG5leHBvcnRzLk9ic2VydmFibGUgPSBPYnNlcnZhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T2JzZXJ2YWJsZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9PYnNlcnZhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgaXNGdW5jdGlvbl8xID0gcmVxdWlyZSgnLi91dGlsL2lzRnVuY3Rpb24nKTtcbnZhciBTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4vU3Vic2NyaXB0aW9uJyk7XG52YXIgT2JzZXJ2ZXJfMSA9IHJlcXVpcmUoJy4vT2JzZXJ2ZXInKTtcbnZhciByeFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4vc3ltYm9sL3J4U3Vic2NyaWJlcicpO1xuLyoqXG4gKiBJbXBsZW1lbnRzIHRoZSB7QGxpbmsgT2JzZXJ2ZXJ9IGludGVyZmFjZSBhbmQgZXh0ZW5kcyB0aGVcbiAqIHtAbGluayBTdWJzY3JpcHRpb259IGNsYXNzLiBXaGlsZSB0aGUge0BsaW5rIE9ic2VydmVyfSBpcyB0aGUgcHVibGljIEFQSSBmb3JcbiAqIGNvbnN1bWluZyB0aGUgdmFsdWVzIG9mIGFuIHtAbGluayBPYnNlcnZhYmxlfSwgYWxsIE9ic2VydmVycyBnZXQgY29udmVydGVkIHRvXG4gKiBhIFN1YnNjcmliZXIsIGluIG9yZGVyIHRvIHByb3ZpZGUgU3Vic2NyaXB0aW9uLWxpa2UgY2FwYWJpbGl0aWVzIHN1Y2ggYXNcbiAqIGB1bnN1YnNjcmliZWAuIFN1YnNjcmliZXIgaXMgYSBjb21tb24gdHlwZSBpbiBSeEpTLCBhbmQgY3J1Y2lhbCBmb3JcbiAqIGltcGxlbWVudGluZyBvcGVyYXRvcnMsIGJ1dCBpdCBpcyByYXJlbHkgdXNlZCBhcyBhIHB1YmxpYyBBUEkuXG4gKlxuICogQGNsYXNzIFN1YnNjcmliZXI8VD5cbiAqL1xudmFyIFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JzZXJ2ZXJ8ZnVuY3Rpb24odmFsdWU6IFQpOiB2b2lkfSBbZGVzdGluYXRpb25Pck5leHRdIEEgcGFydGlhbGx5XG4gICAgICogZGVmaW5lZCBPYnNlcnZlciBvciBhIGBuZXh0YCBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGU6ID9hbnkpOiB2b2lkfSBbZXJyb3JdIFRoZSBgZXJyb3JgIGNhbGxiYWNrIG9mIGFuXG4gICAgICogT2JzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpOiB2b2lkfSBbY29tcGxldGVdIFRoZSBgY29tcGxldGVgIGNhbGxiYWNrIG9mIGFuXG4gICAgICogT2JzZXJ2ZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3Vic2NyaWJlcihkZXN0aW5hdGlvbk9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnN5bmNFcnJvclZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5zeW5jRXJyb3JUaHJvd24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zeW5jRXJyb3JUaHJvd2FibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IE9ic2VydmVyXzEuZW1wdHk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgaWYgKCFkZXN0aW5hdGlvbk9yTmV4dCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gT2JzZXJ2ZXJfMS5lbXB0eTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVzdGluYXRpb25Pck5leHQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXN0aW5hdGlvbk9yTmV4dCBpbnN0YW5jZW9mIFN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbk9yTmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uYWRkKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zeW5jRXJyb3JUaHJvd2FibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBTYWZlU3Vic2NyaWJlcih0aGlzLCBkZXN0aW5hdGlvbk9yTmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLnN5bmNFcnJvclRocm93YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBTYWZlU3Vic2NyaWJlcih0aGlzLCBkZXN0aW5hdGlvbk9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZVtyeFN1YnNjcmliZXJfMS4kJHJ4U3Vic2NyaWJlcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuICAgIC8qKlxuICAgICAqIEEgc3RhdGljIGZhY3RvcnkgZm9yIGEgU3Vic2NyaWJlciwgZ2l2ZW4gYSAocG90ZW50aWFsbHkgcGFydGlhbCkgZGVmaW5pdGlvblxuICAgICAqIG9mIGFuIE9ic2VydmVyLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oeDogP1QpOiB2b2lkfSBbbmV4dF0gVGhlIGBuZXh0YCBjYWxsYmFjayBvZiBhbiBPYnNlcnZlci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGU6ID9hbnkpOiB2b2lkfSBbZXJyb3JdIFRoZSBgZXJyb3JgIGNhbGxiYWNrIG9mIGFuXG4gICAgICogT2JzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpOiB2b2lkfSBbY29tcGxldGVdIFRoZSBgY29tcGxldGVgIGNhbGxiYWNrIG9mIGFuXG4gICAgICogT2JzZXJ2ZXIuXG4gICAgICogQHJldHVybiB7U3Vic2NyaWJlcjxUPn0gQSBTdWJzY3JpYmVyIHdyYXBwaW5nIHRoZSAocGFydGlhbGx5IGRlZmluZWQpXG4gICAgICogT2JzZXJ2ZXIgcmVwcmVzZW50ZWQgYnkgdGhlIGdpdmVuIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBTdWJzY3JpYmVyLmNyZWF0ZSA9IGZ1bmN0aW9uIChuZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgdmFyIHN1YnNjcmliZXIgPSBuZXcgU3Vic2NyaWJlcihuZXh0LCBlcnJvciwgY29tcGxldGUpO1xuICAgICAgICBzdWJzY3JpYmVyLnN5bmNFcnJvclRocm93YWJsZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSB7QGxpbmsgT2JzZXJ2ZXJ9IGNhbGxiYWNrIHRvIHJlY2VpdmUgbm90aWZpY2F0aW9ucyBvZiB0eXBlIGBuZXh0YCBmcm9tXG4gICAgICogdGhlIE9ic2VydmFibGUsIHdpdGggYSB2YWx1ZS4gVGhlIE9ic2VydmFibGUgbWF5IGNhbGwgdGhpcyBtZXRob2QgMCBvciBtb3JlXG4gICAgICogdGltZXMuXG4gICAgICogQHBhcmFtIHtUfSBbdmFsdWVdIFRoZSBgbmV4dGAgdmFsdWUuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX25leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUge0BsaW5rIE9ic2VydmVyfSBjYWxsYmFjayB0byByZWNlaXZlIG5vdGlmaWNhdGlvbnMgb2YgdHlwZSBgZXJyb3JgIGZyb21cbiAgICAgKiB0aGUgT2JzZXJ2YWJsZSwgd2l0aCBhbiBhdHRhY2hlZCB7QGxpbmsgRXJyb3J9LiBOb3RpZmllcyB0aGUgT2JzZXJ2ZXIgdGhhdFxuICAgICAqIHRoZSBPYnNlcnZhYmxlIGhhcyBleHBlcmllbmNlZCBhbiBlcnJvciBjb25kaXRpb24uXG4gICAgICogQHBhcmFtIHthbnl9IFtlcnJdIFRoZSBgZXJyb3JgIGV4Y2VwdGlvbi5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUge0BsaW5rIE9ic2VydmVyfSBjYWxsYmFjayB0byByZWNlaXZlIGEgdmFsdWVsZXNzIG5vdGlmaWNhdGlvbiBvZiB0eXBlXG4gICAgICogYGNvbXBsZXRlYCBmcm9tIHRoZSBPYnNlcnZhYmxlLiBOb3RpZmllcyB0aGUgT2JzZXJ2ZXIgdGhhdCB0aGUgT2JzZXJ2YWJsZVxuICAgICAqIGhhcyBmaW5pc2hlZCBzZW5kaW5nIHB1c2gtYmFzZWQgbm90aWZpY2F0aW9ucy5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgIH07XG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmVBbmRSZWN5Y2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBfcGFyZW50ID0gX2EuX3BhcmVudCwgX3BhcmVudHMgPSBfYS5fcGFyZW50cztcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcGFyZW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gX3BhcmVudDtcbiAgICAgICAgdGhpcy5fcGFyZW50cyA9IF9wYXJlbnRzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBTdWJzY3JpYmVyO1xufShTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24pKTtcbmV4cG9ydHMuU3Vic2NyaWJlciA9IFN1YnNjcmliZXI7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFNhZmVTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2FmZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2FmZVN1YnNjcmliZXIoX3BhcmVudFN1YnNjcmliZXIsIG9ic2VydmVyT3JOZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX3BhcmVudFN1YnNjcmliZXIgPSBfcGFyZW50U3Vic2NyaWJlcjtcbiAgICAgICAgdmFyIG5leHQ7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgICAgaWYgKGlzRnVuY3Rpb25fMS5pc0Z1bmN0aW9uKG9ic2VydmVyT3JOZXh0KSkge1xuICAgICAgICAgICAgbmV4dCA9IG9ic2VydmVyT3JOZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9ic2VydmVyT3JOZXh0KSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gb2JzZXJ2ZXJPck5leHQ7XG4gICAgICAgICAgICBuZXh0ID0gb2JzZXJ2ZXJPck5leHQubmV4dDtcbiAgICAgICAgICAgIGVycm9yID0gb2JzZXJ2ZXJPck5leHQuZXJyb3I7XG4gICAgICAgICAgICBjb21wbGV0ZSA9IG9ic2VydmVyT3JOZXh0LmNvbXBsZXRlO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb25fMS5pc0Z1bmN0aW9uKGNvbnRleHQudW5zdWJzY3JpYmUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoY29udGV4dC51bnN1YnNjcmliZS5iaW5kKGNvbnRleHQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRleHQudW5zdWJzY3JpYmUgPSB0aGlzLnVuc3Vic2NyaWJlLmJpbmQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX25leHQgPSBuZXh0O1xuICAgICAgICB0aGlzLl9lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLl9jb21wbGV0ZSA9IGNvbXBsZXRlO1xuICAgIH1cbiAgICBTYWZlU3Vic2NyaWJlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkICYmIHRoaXMuX25leHQpIHtcbiAgICAgICAgICAgIHZhciBfcGFyZW50U3Vic2NyaWJlciA9IHRoaXMuX3BhcmVudFN1YnNjcmliZXI7XG4gICAgICAgICAgICBpZiAoIV9wYXJlbnRTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93YWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX190cnlPclVuc3ViKHRoaXMuX25leHQsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX190cnlPclNldEVycm9yKF9wYXJlbnRTdWJzY3JpYmVyLCB0aGlzLl9uZXh0LCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdmFyIF9wYXJlbnRTdWJzY3JpYmVyID0gdGhpcy5fcGFyZW50U3Vic2NyaWJlcjtcbiAgICAgICAgICAgIGlmICh0aGlzLl9lcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICghX3BhcmVudFN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3dhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX190cnlPclVuc3ViKHRoaXMuX2Vycm9yLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fdHJ5T3JTZXRFcnJvcihfcGFyZW50U3Vic2NyaWJlciwgdGhpcy5fZXJyb3IsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX3BhcmVudFN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3dhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF9wYXJlbnRTdWJzY3JpYmVyLnN5bmNFcnJvclZhbHVlID0gZXJyO1xuICAgICAgICAgICAgICAgIF9wYXJlbnRTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93biA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTYWZlU3Vic2NyaWJlci5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHZhciBfcGFyZW50U3Vic2NyaWJlciA9IHRoaXMuX3BhcmVudFN1YnNjcmliZXI7XG4gICAgICAgICAgICBpZiAodGhpcy5fY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV9wYXJlbnRTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fdHJ5T3JVbnN1Yih0aGlzLl9jb21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX190cnlPclNldEVycm9yKF9wYXJlbnRTdWJzY3JpYmVyLCB0aGlzLl9jb21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5fX3RyeU9yVW5zdWIgPSBmdW5jdGlvbiAoZm4sIHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmbi5jYWxsKHRoaXMuX2NvbnRleHQsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5fX3RyeU9yU2V0RXJyb3IgPSBmdW5jdGlvbiAocGFyZW50LCBmbiwgdmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZuLmNhbGwodGhpcy5fY29udGV4dCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHBhcmVudC5zeW5jRXJyb3JWYWx1ZSA9IGVycjtcbiAgICAgICAgICAgIHBhcmVudC5zeW5jRXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9wYXJlbnRTdWJzY3JpYmVyID0gdGhpcy5fcGFyZW50U3Vic2NyaWJlcjtcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BhcmVudFN1YnNjcmliZXIgPSBudWxsO1xuICAgICAgICBfcGFyZW50U3Vic2NyaWJlci51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFNhZmVTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdWJzY3JpYmVyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL1N1YnNjcmliZXIuanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuL1N1YnNjcmliZXInKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgT3V0ZXJTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoT3V0ZXJTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE91dGVyU3Vic2NyaWJlcigpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIE91dGVyU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoaW5uZXJWYWx1ZSk7XG4gICAgfTtcbiAgICBPdXRlclN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUVycm9yID0gZnVuY3Rpb24gKGVycm9yLCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycm9yKTtcbiAgICB9O1xuICAgIE91dGVyU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIE91dGVyU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbmV4cG9ydHMuT3V0ZXJTdWJzY3JpYmVyID0gT3V0ZXJTdWJzY3JpYmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T3V0ZXJTdWJzY3JpYmVyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL091dGVyU3Vic2NyaWJlci5qc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciByb290XzEgPSByZXF1aXJlKCcuL3Jvb3QnKTtcbnZhciBpc0FycmF5TGlrZV8xID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xudmFyIGlzUHJvbWlzZV8xID0gcmVxdWlyZSgnLi9pc1Byb21pc2UnKTtcbnZhciBpc09iamVjdF8xID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciBpdGVyYXRvcl8xID0gcmVxdWlyZSgnLi4vc3ltYm9sL2l0ZXJhdG9yJyk7XG52YXIgSW5uZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9Jbm5lclN1YnNjcmliZXInKTtcbnZhciBvYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9zeW1ib2wvb2JzZXJ2YWJsZScpO1xuZnVuY3Rpb24gc3Vic2NyaWJlVG9SZXN1bHQob3V0ZXJTdWJzY3JpYmVyLCByZXN1bHQsIG91dGVyVmFsdWUsIG91dGVySW5kZXgpIHtcbiAgICB2YXIgZGVzdGluYXRpb24gPSBuZXcgSW5uZXJTdWJzY3JpYmVyXzEuSW5uZXJTdWJzY3JpYmVyKG91dGVyU3Vic2NyaWJlciwgb3V0ZXJWYWx1ZSwgb3V0ZXJJbmRleCk7XG4gICAgaWYgKGRlc3RpbmF0aW9uLmNsb3NlZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSB7XG4gICAgICAgIGlmIChyZXN1bHQuX2lzU2NhbGFyKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnN1YnNjcmliZShkZXN0aW5hdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNBcnJheUxpa2VfMS5pc0FycmF5TGlrZShyZXN1bHQpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByZXN1bHQubGVuZ3RoOyBpIDwgbGVuICYmICFkZXN0aW5hdGlvbi5jbG9zZWQ7IGkrKykge1xuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dChyZXN1bHRbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVzdGluYXRpb24uY2xvc2VkKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUHJvbWlzZV8xLmlzUHJvbWlzZShyZXN1bHQpKSB7XG4gICAgICAgIHJlc3VsdC50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCFkZXN0aW5hdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBkZXN0aW5hdGlvbi5lcnJvcihlcnIpOyB9KVxuICAgICAgICAgICAgLnRoZW4obnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgLy8gRXNjYXBpbmcgdGhlIFByb21pc2UgdHJhcDogZ2xvYmFsbHkgdGhyb3cgdW5oYW5kbGVkIGVycm9yc1xuICAgICAgICAgICAgcm9vdF8xLnJvb3Quc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHRocm93IGVycjsgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGVzdGluYXRpb247XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0W2l0ZXJhdG9yXzEuJCRpdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gcmVzdWx0W2l0ZXJhdG9yXzEuJCRpdGVyYXRvcl0oKTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoaXRlbS5kb25lKSB7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQoaXRlbS52YWx1ZSk7XG4gICAgICAgICAgICBpZiAoZGVzdGluYXRpb24uY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKHRydWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZXN1bHQgJiYgdHlwZW9mIHJlc3VsdFtvYnNlcnZhYmxlXzEuJCRvYnNlcnZhYmxlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgb2JzID0gcmVzdWx0W29ic2VydmFibGVfMS4kJG9ic2VydmFibGVdKCk7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JzLnN1YnNjcmliZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZGVzdGluYXRpb24uZXJyb3IobmV3IFR5cGVFcnJvcignUHJvdmlkZWQgb2JqZWN0IGRvZXMgbm90IGNvcnJlY3RseSBpbXBsZW1lbnQgU3ltYm9sLm9ic2VydmFibGUnKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gb2JzLnN1YnNjcmliZShuZXcgSW5uZXJTdWJzY3JpYmVyXzEuSW5uZXJTdWJzY3JpYmVyKG91dGVyU3Vic2NyaWJlciwgb3V0ZXJWYWx1ZSwgb3V0ZXJJbmRleCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgdmFsdWUgPSBpc09iamVjdF8xLmlzT2JqZWN0KHJlc3VsdCkgPyAnYW4gaW52YWxpZCBvYmplY3QnIDogXCInXCIgKyByZXN1bHQgKyBcIidcIjtcbiAgICAgICAgdmFyIG1zZyA9IChcIllvdSBwcm92aWRlZCBcIiArIHZhbHVlICsgXCIgd2hlcmUgYSBzdHJlYW0gd2FzIGV4cGVjdGVkLlwiKVxuICAgICAgICAgICAgKyAnIFlvdSBjYW4gcHJvdmlkZSBhbiBPYnNlcnZhYmxlLCBQcm9taXNlLCBBcnJheSwgb3IgSXRlcmFibGUuJztcbiAgICAgICAgZGVzdGluYXRpb24uZXJyb3IobmV3IFR5cGVFcnJvcihtc2cpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5leHBvcnRzLnN1YnNjcmliZVRvUmVzdWx0ID0gc3Vic2NyaWJlVG9SZXN1bHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJzY3JpYmVUb1Jlc3VsdC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy91dGlsL3N1YnNjcmliZVRvUmVzdWx0LmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGlzQXJyYXlfMSA9IHJlcXVpcmUoJy4vdXRpbC9pc0FycmF5Jyk7XG52YXIgaXNPYmplY3RfMSA9IHJlcXVpcmUoJy4vdXRpbC9pc09iamVjdCcpO1xudmFyIGlzRnVuY3Rpb25fMSA9IHJlcXVpcmUoJy4vdXRpbC9pc0Z1bmN0aW9uJyk7XG52YXIgdHJ5Q2F0Y2hfMSA9IHJlcXVpcmUoJy4vdXRpbC90cnlDYXRjaCcpO1xudmFyIGVycm9yT2JqZWN0XzEgPSByZXF1aXJlKCcuL3V0aWwvZXJyb3JPYmplY3QnKTtcbnZhciBVbnN1YnNjcmlwdGlvbkVycm9yXzEgPSByZXF1aXJlKCcuL3V0aWwvVW5zdWJzY3JpcHRpb25FcnJvcicpO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgZGlzcG9zYWJsZSByZXNvdXJjZSwgc3VjaCBhcyB0aGUgZXhlY3V0aW9uIG9mIGFuIE9ic2VydmFibGUuIEFcbiAqIFN1YnNjcmlwdGlvbiBoYXMgb25lIGltcG9ydGFudCBtZXRob2QsIGB1bnN1YnNjcmliZWAsIHRoYXQgdGFrZXMgbm8gYXJndW1lbnRcbiAqIGFuZCBqdXN0IGRpc3Bvc2VzIHRoZSByZXNvdXJjZSBoZWxkIGJ5IHRoZSBzdWJzY3JpcHRpb24uXG4gKlxuICogQWRkaXRpb25hbGx5LCBzdWJzY3JpcHRpb25zIG1heSBiZSBncm91cGVkIHRvZ2V0aGVyIHRocm91Z2ggdGhlIGBhZGQoKWBcbiAqIG1ldGhvZCwgd2hpY2ggd2lsbCBhdHRhY2ggYSBjaGlsZCBTdWJzY3JpcHRpb24gdG8gdGhlIGN1cnJlbnQgU3Vic2NyaXB0aW9uLlxuICogV2hlbiBhIFN1YnNjcmlwdGlvbiBpcyB1bnN1YnNjcmliZWQsIGFsbCBpdHMgY2hpbGRyZW4gKGFuZCBpdHMgZ3JhbmRjaGlsZHJlbilcbiAqIHdpbGwgYmUgdW5zdWJzY3JpYmVkIGFzIHdlbGwuXG4gKlxuICogQGNsYXNzIFN1YnNjcmlwdGlvblxuICovXG52YXIgU3Vic2NyaXB0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IFt1bnN1YnNjcmliZV0gQSBmdW5jdGlvbiBkZXNjcmliaW5nIGhvdyB0b1xuICAgICAqIHBlcmZvcm0gdGhlIGRpc3Bvc2FsIG9mIHJlc291cmNlcyB3aGVuIHRoZSBgdW5zdWJzY3JpYmVgIG1ldGhvZCBpcyBjYWxsZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3Vic2NyaXB0aW9uKHVuc3Vic2NyaWJlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciB0aGlzIFN1YnNjcmlwdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHVuc3Vic2NyaWJlZC5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wYXJlbnRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucyA9IG51bGw7XG4gICAgICAgIGlmICh1bnN1YnNjcmliZSkge1xuICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmUgPSB1bnN1YnNjcmliZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlcyB0aGUgcmVzb3VyY2VzIGhlbGQgYnkgdGhlIHN1YnNjcmlwdGlvbi4gTWF5LCBmb3IgaW5zdGFuY2UsIGNhbmNlbFxuICAgICAqIGFuIG9uZ29pbmcgT2JzZXJ2YWJsZSBleGVjdXRpb24gb3IgY2FuY2VsIGFueSBvdGhlciB0eXBlIG9mIHdvcmsgdGhhdFxuICAgICAqIHN0YXJ0ZWQgd2hlbiB0aGUgU3Vic2NyaXB0aW9uIHdhcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGhhc0Vycm9ycyA9IGZhbHNlO1xuICAgICAgICB2YXIgZXJyb3JzO1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSB0aGlzLCBfcGFyZW50ID0gX2EuX3BhcmVudCwgX3BhcmVudHMgPSBfYS5fcGFyZW50cywgX3Vuc3Vic2NyaWJlID0gX2EuX3Vuc3Vic2NyaWJlLCBfc3Vic2NyaXB0aW9ucyA9IF9hLl9zdWJzY3JpcHRpb25zO1xuICAgICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BhcmVudHMgPSBudWxsO1xuICAgICAgICAvLyBudWxsIG91dCBfc3Vic2NyaXB0aW9ucyBmaXJzdCBzbyBhbnkgY2hpbGQgc3Vic2NyaXB0aW9ucyB0aGF0IGF0dGVtcHRcbiAgICAgICAgLy8gdG8gcmVtb3ZlIHRoZW1zZWx2ZXMgZnJvbSB0aGlzIHN1YnNjcmlwdGlvbiB3aWxsIG5vb3BcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucyA9IG51bGw7XG4gICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICB2YXIgbGVuID0gX3BhcmVudHMgPyBfcGFyZW50cy5sZW5ndGggOiAwO1xuICAgICAgICAvLyBpZiB0aGlzLl9wYXJlbnQgaXMgbnVsbCwgdGhlbiBzbyBpcyB0aGlzLl9wYXJlbnRzLCBhbmQgd2VcbiAgICAgICAgLy8gZG9uJ3QgaGF2ZSB0byByZW1vdmUgb3Vyc2VsdmVzIGZyb20gYW55IHBhcmVudCBzdWJzY3JpcHRpb25zLlxuICAgICAgICB3aGlsZSAoX3BhcmVudCkge1xuICAgICAgICAgICAgX3BhcmVudC5yZW1vdmUodGhpcyk7XG4gICAgICAgICAgICAvLyBpZiB0aGlzLl9wYXJlbnRzIGlzIG51bGwgb3IgaW5kZXggPj0gbGVuLFxuICAgICAgICAgICAgLy8gdGhlbiBfcGFyZW50IGlzIHNldCB0byBudWxsLCBhbmQgdGhlIGxvb3AgZXhpdHNcbiAgICAgICAgICAgIF9wYXJlbnQgPSArK2luZGV4IDwgbGVuICYmIF9wYXJlbnRzW2luZGV4XSB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uXzEuaXNGdW5jdGlvbihfdW5zdWJzY3JpYmUpKSB7XG4gICAgICAgICAgICB2YXIgdHJpYWwgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKF91bnN1YnNjcmliZSkuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGlmICh0cmlhbCA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgICAgIGhhc0Vycm9ycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzIHx8IChlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUgaW5zdGFuY2VvZiBVbnN1YnNjcmlwdGlvbkVycm9yXzEuVW5zdWJzY3JpcHRpb25FcnJvciA/XG4gICAgICAgICAgICAgICAgICAgIGZsYXR0ZW5VbnN1YnNjcmlwdGlvbkVycm9ycyhlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUuZXJyb3JzKSA6IFtlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBcnJheV8xLmlzQXJyYXkoX3N1YnNjcmlwdGlvbnMpKSB7XG4gICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgICAgbGVuID0gX3N1YnNjcmlwdGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ViID0gX3N1YnNjcmlwdGlvbnNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdF8xLmlzT2JqZWN0KHN1YikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyaWFsID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaChzdWIudW5zdWJzY3JpYmUpLmNhbGwoc3ViKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyaWFsID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNFcnJvcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVyciA9IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBVbnN1YnNjcmlwdGlvbkVycm9yXzEuVW5zdWJzY3JpcHRpb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoZmxhdHRlblVuc3Vic2NyaXB0aW9uRXJyb3JzKGVyci5lcnJvcnMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0Vycm9ycykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3Vic2NyaXB0aW9uRXJyb3JfMS5VbnN1YnNjcmlwdGlvbkVycm9yKGVycm9ycyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMgYSB0ZWFyIGRvd24gdG8gYmUgY2FsbGVkIGR1cmluZyB0aGUgdW5zdWJzY3JpYmUoKSBvZiB0aGlzXG4gICAgICogU3Vic2NyaXB0aW9uLlxuICAgICAqXG4gICAgICogSWYgdGhlIHRlYXIgZG93biBiZWluZyBhZGRlZCBpcyBhIHN1YnNjcmlwdGlvbiB0aGF0IGlzIGFscmVhZHlcbiAgICAgKiB1bnN1YnNjcmliZWQsIGlzIHRoZSBzYW1lIHJlZmVyZW5jZSBgYWRkYCBpcyBiZWluZyBjYWxsZWQgb24sIG9yIGlzXG4gICAgICogYFN1YnNjcmlwdGlvbi5FTVBUWWAsIGl0IHdpbGwgbm90IGJlIGFkZGVkLlxuICAgICAqXG4gICAgICogSWYgdGhpcyBzdWJzY3JpcHRpb24gaXMgYWxyZWFkeSBpbiBhbiBgY2xvc2VkYCBzdGF0ZSwgdGhlIHBhc3NlZFxuICAgICAqIHRlYXIgZG93biBsb2dpYyB3aWxsIGJlIGV4ZWN1dGVkIGltbWVkaWF0ZWx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtUZWFyZG93bkxvZ2ljfSB0ZWFyZG93biBUaGUgYWRkaXRpb25hbCBsb2dpYyB0byBleGVjdXRlIG9uXG4gICAgICogdGVhcmRvd24uXG4gICAgICogQHJldHVybiB7U3Vic2NyaXB0aW9ufSBSZXR1cm5zIHRoZSBTdWJzY3JpcHRpb24gdXNlZCBvciBjcmVhdGVkIHRvIGJlXG4gICAgICogYWRkZWQgdG8gdGhlIGlubmVyIHN1YnNjcmlwdGlvbnMgbGlzdC4gVGhpcyBTdWJzY3JpcHRpb24gY2FuIGJlIHVzZWQgd2l0aFxuICAgICAqIGByZW1vdmUoKWAgdG8gcmVtb3ZlIHRoZSBwYXNzZWQgdGVhcmRvd24gbG9naWMgZnJvbSB0aGUgaW5uZXIgc3Vic2NyaXB0aW9uc1xuICAgICAqIGxpc3QuXG4gICAgICovXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodGVhcmRvd24pIHtcbiAgICAgICAgaWYgKCF0ZWFyZG93biB8fCAodGVhcmRvd24gPT09IFN1YnNjcmlwdGlvbi5FTVBUWSkpIHtcbiAgICAgICAgICAgIHJldHVybiBTdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRlYXJkb3duID09PSB0aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGVhcmRvd247XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHRlYXJkb3duKSB7XG4gICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbih0ZWFyZG93bik7XG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24uY2xvc2VkIHx8IHR5cGVvZiBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzdWJzY3JpcHRpb24uX2FkZFBhcmVudCAhPT0gJ2Z1bmN0aW9uJyAvKiBxdWFjayBxdWFjayAqLykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG1wID0gc3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5fc3Vic2NyaXB0aW9ucyA9IFt0bXBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlY29nbml6ZWQgdGVhcmRvd24gJyArIHRlYXJkb3duICsgJyBhZGRlZCB0byBTdWJzY3JpcHRpb24uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbnMgPSB0aGlzLl9zdWJzY3JpcHRpb25zIHx8ICh0aGlzLl9zdWJzY3JpcHRpb25zID0gW10pO1xuICAgICAgICBzdWJzY3JpcHRpb25zLnB1c2goc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgc3Vic2NyaXB0aW9uLl9hZGRQYXJlbnQodGhpcyk7XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgU3Vic2NyaXB0aW9uIGZyb20gdGhlIGludGVybmFsIGxpc3Qgb2Ygc3Vic2NyaXB0aW9ucyB0aGF0IHdpbGxcbiAgICAgKiB1bnN1YnNjcmliZSBkdXJpbmcgdGhlIHVuc3Vic2NyaWJlIHByb2Nlc3Mgb2YgdGhpcyBTdWJzY3JpcHRpb24uXG4gICAgICogQHBhcmFtIHtTdWJzY3JpcHRpb259IHN1YnNjcmlwdGlvbiBUaGUgc3Vic2NyaXB0aW9uIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9ucyA9IHRoaXMuX3N1YnNjcmlwdGlvbnM7XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uSW5kZXggPSBzdWJzY3JpcHRpb25zLmluZGV4T2Yoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb25JbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25zLnNwbGljZShzdWJzY3JpcHRpb25JbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuX2FkZFBhcmVudCA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgX3BhcmVudCA9IF9hLl9wYXJlbnQsIF9wYXJlbnRzID0gX2EuX3BhcmVudHM7XG4gICAgICAgIGlmICghX3BhcmVudCB8fCBfcGFyZW50ID09PSBwYXJlbnQpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBwYXJlbnQsIG9yIHRoZSBuZXcgcGFyZW50IGlzIHRoZSBzYW1lIGFzIHRoZVxuICAgICAgICAgICAgLy8gY3VycmVudCBwYXJlbnQsIHRoZW4gc2V0IHRoaXMuX3BhcmVudCB0byB0aGUgbmV3IHBhcmVudC5cbiAgICAgICAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghX3BhcmVudHMpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYWxyZWFkeSBvbmUgcGFyZW50LCBidXQgbm90IG11bHRpcGxlLCBhbGxvY2F0ZSBhbiBBcnJheSB0b1xuICAgICAgICAgICAgLy8gc3RvcmUgdGhlIHJlc3Qgb2YgdGhlIHBhcmVudCBTdWJzY3JpcHRpb25zLlxuICAgICAgICAgICAgdGhpcy5fcGFyZW50cyA9IFtwYXJlbnRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9wYXJlbnRzLmluZGV4T2YocGFyZW50KSA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgYWRkIHRoZSBuZXcgcGFyZW50IHRvIHRoZSBfcGFyZW50cyBsaXN0IGlmIGl0J3Mgbm90IGFscmVhZHkgdGhlcmUuXG4gICAgICAgICAgICBfcGFyZW50cy5wdXNoKHBhcmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbi5FTVBUWSA9IChmdW5jdGlvbiAoZW1wdHkpIHtcbiAgICAgICAgZW1wdHkuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGVtcHR5O1xuICAgIH0obmV3IFN1YnNjcmlwdGlvbigpKSk7XG4gICAgcmV0dXJuIFN1YnNjcmlwdGlvbjtcbn0oKSk7XG5leHBvcnRzLlN1YnNjcmlwdGlvbiA9IFN1YnNjcmlwdGlvbjtcbmZ1bmN0aW9uIGZsYXR0ZW5VbnN1YnNjcmlwdGlvbkVycm9ycyhlcnJvcnMpIHtcbiAgICByZXR1cm4gZXJyb3JzLnJlZHVjZShmdW5jdGlvbiAoZXJycywgZXJyKSB7IHJldHVybiBlcnJzLmNvbmNhdCgoZXJyIGluc3RhbmNlb2YgVW5zdWJzY3JpcHRpb25FcnJvcl8xLlVuc3Vic2NyaXB0aW9uRXJyb3IpID8gZXJyLmVycm9ycyA6IGVycik7IH0sIFtdKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1YnNjcmlwdGlvbi5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9TdWJzY3JpcHRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL09ic2VydmFibGUnKTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuL1N1YnNjcmliZXInKTtcbnZhciBTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4vU3Vic2NyaXB0aW9uJyk7XG52YXIgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JfMSA9IHJlcXVpcmUoJy4vdXRpbC9PYmplY3RVbnN1YnNjcmliZWRFcnJvcicpO1xudmFyIFN1YmplY3RTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4vU3ViamVjdFN1YnNjcmlwdGlvbicpO1xudmFyIHJ4U3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi9zeW1ib2wvcnhTdWJzY3JpYmVyJyk7XG4vKipcbiAqIEBjbGFzcyBTdWJqZWN0U3Vic2NyaWJlcjxUPlxuICovXG52YXIgU3ViamVjdFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdWJqZWN0U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdWJqZWN0U3Vic2NyaWJlcihkZXN0aW5hdGlvbikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIFN1YmplY3RTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuZXhwb3J0cy5TdWJqZWN0U3Vic2NyaWJlciA9IFN1YmplY3RTdWJzY3JpYmVyO1xuLyoqXG4gKiBAY2xhc3MgU3ViamVjdDxUPlxuICovXG52YXIgU3ViamVjdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN1YmplY3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3ViamVjdCgpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gW107XG4gICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFzRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50aHJvd25FcnJvciA9IG51bGw7XG4gICAgfVxuICAgIFN1YmplY3QucHJvdG90eXBlW3J4U3Vic2NyaWJlcl8xLiQkcnhTdWJzY3JpYmVyXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdWJqZWN0U3Vic2NyaWJlcih0aGlzKTtcbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLmxpZnQgPSBmdW5jdGlvbiAob3BlcmF0b3IpIHtcbiAgICAgICAgdmFyIHN1YmplY3QgPSBuZXcgQW5vbnltb3VzU3ViamVjdCh0aGlzLCB0aGlzKTtcbiAgICAgICAgc3ViamVjdC5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICByZXR1cm4gc3ViamVjdDtcbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JfMS5PYmplY3RVbnN1YnNjcmliZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHZhciBvYnNlcnZlcnMgPSB0aGlzLm9ic2VydmVycztcbiAgICAgICAgICAgIHZhciBsZW4gPSBvYnNlcnZlcnMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGNvcHkgPSBvYnNlcnZlcnMuc2xpY2UoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb3B5W2ldLm5leHQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JfMS5PYmplY3RVbnN1YnNjcmliZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGFzRXJyb3IgPSB0cnVlO1xuICAgICAgICB0aGlzLnRocm93bkVycm9yID0gZXJyO1xuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgIHZhciBvYnNlcnZlcnMgPSB0aGlzLm9ic2VydmVycztcbiAgICAgICAgdmFyIGxlbiA9IG9ic2VydmVycy5sZW5ndGg7XG4gICAgICAgIHZhciBjb3B5ID0gb2JzZXJ2ZXJzLnNsaWNlKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvcHlbaV0uZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9ic2VydmVycy5sZW5ndGggPSAwO1xuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXzEuT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgIHZhciBvYnNlcnZlcnMgPSB0aGlzLm9ic2VydmVycztcbiAgICAgICAgdmFyIGxlbiA9IG9ic2VydmVycy5sZW5ndGg7XG4gICAgICAgIHZhciBjb3B5ID0gb2JzZXJ2ZXJzLnNsaWNlKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvcHlbaV0uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9ic2VydmVycy5sZW5ndGggPSAwO1xuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9ic2VydmVycyA9IG51bGw7XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5fdHJ5U3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JfMS5PYmplY3RVbnN1YnNjcmliZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuX3RyeVN1YnNjcmliZS5jYWxsKHRoaXMsIHN1YnNjcmliZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JfMS5PYmplY3RVbnN1YnNjcmliZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaGFzRXJyb3IpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IodGhpcy50aHJvd25FcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uLkVNUFRZO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICByZXR1cm4gU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uLkVNUFRZO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlcnMucHVzaChzdWJzY3JpYmVyKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3ViamVjdFN1YnNjcmlwdGlvbl8xLlN1YmplY3RTdWJzY3JpcHRpb24odGhpcywgc3Vic2NyaWJlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLmFzT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUoKTtcbiAgICAgICAgb2JzZXJ2YWJsZS5zb3VyY2UgPSB0aGlzO1xuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZTtcbiAgICB9O1xuICAgIFN1YmplY3QuY3JlYXRlID0gZnVuY3Rpb24gKGRlc3RpbmF0aW9uLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNTdWJqZWN0KGRlc3RpbmF0aW9uLCBzb3VyY2UpO1xuICAgIH07XG4gICAgcmV0dXJuIFN1YmplY3Q7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLlN1YmplY3QgPSBTdWJqZWN0O1xuLyoqXG4gKiBAY2xhc3MgQW5vbnltb3VzU3ViamVjdDxUPlxuICovXG52YXIgQW5vbnltb3VzU3ViamVjdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFub255bW91c1N1YmplY3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQW5vbnltb3VzU3ViamVjdChkZXN0aW5hdGlvbiwgc291cmNlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gZGVzdGluYXRpb247XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICBBbm9ueW1vdXNTdWJqZWN0LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIGlmIChkZXN0aW5hdGlvbiAmJiBkZXN0aW5hdGlvbi5uZXh0KSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQW5vbnltb3VzU3ViamVjdC5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIGlmIChkZXN0aW5hdGlvbiAmJiBkZXN0aW5hdGlvbi5lcnJvcikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBbm9ueW1vdXNTdWJqZWN0LnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgaWYgKGRlc3RpbmF0aW9uICYmIGRlc3RpbmF0aW9uLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFub255bW91c1N1YmplY3QucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgc291cmNlID0gdGhpcy5zb3VyY2U7XG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uLkVNUFRZO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQW5vbnltb3VzU3ViamVjdDtcbn0oU3ViamVjdCkpO1xuZXhwb3J0cy5Bbm9ueW1vdXNTdWJqZWN0ID0gQW5vbnltb3VzU3ViamVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1YmplY3QuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvU3ViamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbi8vIHR5cGVvZiBhbnkgc28gdGhhdCBpdCB3ZSBkb24ndCBoYXZlIHRvIGNhc3Qgd2hlbiBjb21wYXJpbmcgYSByZXN1bHQgdG8gdGhlIGVycm9yIG9iamVjdFxuZXhwb3J0cy5lcnJvck9iamVjdCA9IHsgZToge30gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9yT2JqZWN0LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL3V0aWwvZXJyb3JPYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIHdpbmRvdzogYnJvd3NlciBpbiBET00gbWFpbiB0aHJlYWRcbiAqIHNlbGY6IGJyb3dzZXIgaW4gV2ViV29ya2VyXG4gKiBnbG9iYWw6IE5vZGUuanMvb3RoZXJcbiAqL1xuZXhwb3J0cy5yb290ID0gKHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93LndpbmRvdyA9PT0gd2luZG93ICYmIHdpbmRvd1xuICAgIHx8IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYuc2VsZiA9PT0gc2VsZiAmJiBzZWxmXG4gICAgfHwgdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwuZ2xvYmFsID09PSBnbG9iYWwgJiYgZ2xvYmFsKTtcbmlmICghZXhwb3J0cy5yb290KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSeEpTIGNvdWxkIG5vdCBmaW5kIGFueSBnbG9iYWwgY29udGV4dCAod2luZG93LCBzZWxmLCBnbG9iYWwpJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb290LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL3V0aWwvcm9vdC5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBlcnJvck9iamVjdF8xID0gcmVxdWlyZSgnLi9lcnJvck9iamVjdCcpO1xudmFyIHRyeUNhdGNoVGFyZ2V0O1xuZnVuY3Rpb24gdHJ5Q2F0Y2hlcigpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gdHJ5Q2F0Y2hUYXJnZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lID0gZTtcbiAgICAgICAgcmV0dXJuIGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3Q7XG4gICAgfVxufVxuZnVuY3Rpb24gdHJ5Q2F0Y2goZm4pIHtcbiAgICB0cnlDYXRjaFRhcmdldCA9IGZuO1xuICAgIHJldHVybiB0cnlDYXRjaGVyO1xufVxuZXhwb3J0cy50cnlDYXRjaCA9IHRyeUNhdGNoO1xuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJ5Q2F0Y2guanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvdXRpbC90cnlDYXRjaC5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBBc3luY0FjdGlvbl8xID0gcmVxdWlyZSgnLi9Bc3luY0FjdGlvbicpO1xudmFyIEFzeW5jU2NoZWR1bGVyXzEgPSByZXF1aXJlKCcuL0FzeW5jU2NoZWR1bGVyJyk7XG4vKipcbiAqXG4gKiBBc3luYyBTY2hlZHVsZXJcbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+U2NoZWR1bGUgdGFzayBhcyBpZiB5b3UgdXNlZCBzZXRUaW1lb3V0KHRhc2ssIGR1cmF0aW9uKTwvc3Bhbj5cbiAqXG4gKiBgYXN5bmNgIHNjaGVkdWxlciBzY2hlZHVsZXMgdGFza3MgYXN5bmNocm9ub3VzbHksIGJ5IHB1dHRpbmcgdGhlbSBvbiB0aGUgSmF2YVNjcmlwdFxuICogZXZlbnQgbG9vcCBxdWV1ZS4gSXQgaXMgYmVzdCB1c2VkIHRvIGRlbGF5IHRhc2tzIGluIHRpbWUgb3IgdG8gc2NoZWR1bGUgdGFza3MgcmVwZWF0aW5nXG4gKiBpbiBpbnRlcnZhbHMuXG4gKlxuICogSWYgeW91IGp1c3Qgd2FudCB0byBcImRlZmVyXCIgdGFzaywgdGhhdCBpcyB0byBwZXJmb3JtIGl0IHJpZ2h0IGFmdGVyIGN1cnJlbnRseVxuICogZXhlY3V0aW5nIHN5bmNocm9ub3VzIGNvZGUgZW5kcyAoY29tbW9ubHkgYWNoaWV2ZWQgYnkgYHNldFRpbWVvdXQoZGVmZXJyZWRUYXNrLCAwKWApLFxuICogYmV0dGVyIGNob2ljZSB3aWxsIGJlIHRoZSB7QGxpbmsgYXNhcH0gc2NoZWR1bGVyLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlVzZSBhc3luYyBzY2hlZHVsZXIgdG8gZGVsYXkgdGFzazwvY2FwdGlvbj5cbiAqIGNvbnN0IHRhc2sgPSAoKSA9PiBjb25zb2xlLmxvZygnaXQgd29ya3MhJyk7XG4gKlxuICogUnguU2NoZWR1bGVyLmFzeW5jLnNjaGVkdWxlKHRhc2ssIDIwMDApO1xuICpcbiAqIC8vIEFmdGVyIDIgc2Vjb25kcyBsb2dzOlxuICogLy8gXCJpdCB3b3JrcyFcIlxuICpcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Vc2UgYXN5bmMgc2NoZWR1bGVyIHRvIHJlcGVhdCB0YXNrIGluIGludGVydmFsczwvY2FwdGlvbj5cbiAqIGZ1bmN0aW9uIHRhc2soc3RhdGUpIHtcbiAqICAgY29uc29sZS5sb2coc3RhdGUpO1xuICogICB0aGlzLnNjaGVkdWxlKHN0YXRlICsgMSwgMTAwMCk7IC8vIGB0aGlzYCByZWZlcmVuY2VzIGN1cnJlbnRseSBleGVjdXRpbmcgQWN0aW9uLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoIHdlIHJlc2NoZWR1bGUgd2l0aCBuZXcgc3RhdGUgYW5kIGRlbGF5XG4gKiB9XG4gKlxuICogUnguU2NoZWR1bGVyLmFzeW5jLnNjaGVkdWxlKHRhc2ssIDMwMDAsIDApO1xuICpcbiAqIC8vIExvZ3M6XG4gKiAvLyAwIGFmdGVyIDNzXG4gKiAvLyAxIGFmdGVyIDRzXG4gKiAvLyAyIGFmdGVyIDVzXG4gKiAvLyAzIGFmdGVyIDZzXG4gKlxuICogQHN0YXRpYyB0cnVlXG4gKiBAbmFtZSBhc3luY1xuICogQG93bmVyIFNjaGVkdWxlclxuICovXG5leHBvcnRzLmFzeW5jID0gbmV3IEFzeW5jU2NoZWR1bGVyXzEuQXN5bmNTY2hlZHVsZXIoQXN5bmNBY3Rpb25fMS5Bc3luY0FjdGlvbik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3luYy5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9zY2hlZHVsZXIvYXN5bmMuanNcbi8vIG1vZHVsZSBpZCA9IDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG52YXIgU2NhbGFyT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9TY2FsYXJPYnNlcnZhYmxlJyk7XG52YXIgRW1wdHlPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL0VtcHR5T2JzZXJ2YWJsZScpO1xudmFyIGlzU2NoZWR1bGVyXzEgPSByZXF1aXJlKCcuLi91dGlsL2lzU2NoZWR1bGVyJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIEFycmF5T2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFycmF5T2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBcnJheU9ic2VydmFibGUoYXJyYXksIHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgaWYgKCFzY2hlZHVsZXIgJiYgYXJyYXkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLl9pc1NjYWxhciA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gYXJyYXlbMF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgQXJyYXlPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChhcnJheSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXJyYXlPYnNlcnZhYmxlKGFycmF5LCBzY2hlZHVsZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgc29tZSB2YWx1ZXMgeW91IHNwZWNpZnkgYXMgYXJndW1lbnRzLFxuICAgICAqIGltbWVkaWF0ZWx5IG9uZSBhZnRlciB0aGUgb3RoZXIsIGFuZCB0aGVuIGVtaXRzIGEgY29tcGxldGUgbm90aWZpY2F0aW9uLlxuICAgICAqXG4gICAgICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkVtaXRzIHRoZSBhcmd1bWVudHMgeW91IHByb3ZpZGUsIHRoZW4gY29tcGxldGVzLlxuICAgICAqIDwvc3Bhbj5cbiAgICAgKlxuICAgICAqIDxpbWcgc3JjPVwiLi9pbWcvb2YucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gICAgICpcbiAgICAgKiBUaGlzIHN0YXRpYyBvcGVyYXRvciBpcyB1c2VmdWwgZm9yIGNyZWF0aW5nIGEgc2ltcGxlIE9ic2VydmFibGUgdGhhdCBvbmx5XG4gICAgICogZW1pdHMgdGhlIGFyZ3VtZW50cyBnaXZlbiwgYW5kIHRoZSBjb21wbGV0ZSBub3RpZmljYXRpb24gdGhlcmVhZnRlci4gSXQgY2FuXG4gICAgICogYmUgdXNlZCBmb3IgY29tcG9zaW5nIHdpdGggb3RoZXIgT2JzZXJ2YWJsZXMsIHN1Y2ggYXMgd2l0aCB7QGxpbmsgY29uY2F0fS5cbiAgICAgKiBCeSBkZWZhdWx0LCBpdCB1c2VzIGEgYG51bGxgIElTY2hlZHVsZXIsIHdoaWNoIG1lYW5zIHRoZSBgbmV4dGBcbiAgICAgKiBub3RpZmljYXRpb25zIGFyZSBzZW50IHN5bmNocm9ub3VzbHksIGFsdGhvdWdoIHdpdGggYSBkaWZmZXJlbnQgSVNjaGVkdWxlclxuICAgICAqIGl0IGlzIHBvc3NpYmxlIHRvIGRldGVybWluZSB3aGVuIHRob3NlIG5vdGlmaWNhdGlvbnMgd2lsbCBiZSBkZWxpdmVyZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0IDEwLCAyMCwgMzAsIHRoZW4gJ2EnLCAnYicsICdjJywgdGhlbiBzdGFydCB0aWNraW5nIGV2ZXJ5IHNlY29uZC48L2NhcHRpb24+XG4gICAgICogdmFyIG51bWJlcnMgPSBSeC5PYnNlcnZhYmxlLm9mKDEwLCAyMCwgMzApO1xuICAgICAqIHZhciBsZXR0ZXJzID0gUnguT2JzZXJ2YWJsZS5vZignYScsICdiJywgJ2MnKTtcbiAgICAgKiB2YXIgaW50ZXJ2YWwgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApO1xuICAgICAqIHZhciByZXN1bHQgPSBudW1iZXJzLmNvbmNhdChsZXR0ZXJzKS5jb25jYXQoaW50ZXJ2YWwpO1xuICAgICAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBjcmVhdGV9XG4gICAgICogQHNlZSB7QGxpbmsgZW1wdHl9XG4gICAgICogQHNlZSB7QGxpbmsgbmV2ZXJ9XG4gICAgICogQHNlZSB7QGxpbmsgdGhyb3d9XG4gICAgICpcbiAgICAgKiBAcGFyYW0gey4uLlR9IHZhbHVlcyBBcmd1bWVudHMgdGhhdCByZXByZXNlbnQgYG5leHRgIHZhbHVlcyB0byBiZSBlbWl0dGVkLlxuICAgICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSBBIHtAbGluayBJU2NoZWR1bGVyfSB0byB1c2UgZm9yIHNjaGVkdWxpbmdcbiAgICAgKiB0aGUgZW1pc3Npb25zIG9mIHRoZSBgbmV4dGAgbm90aWZpY2F0aW9ucy5cbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgZWFjaCBnaXZlbiBpbnB1dCB2YWx1ZS5cbiAgICAgKiBAc3RhdGljIHRydWVcbiAgICAgKiBAbmFtZSBvZlxuICAgICAqIEBvd25lciBPYnNlcnZhYmxlXG4gICAgICovXG4gICAgQXJyYXlPYnNlcnZhYmxlLm9mID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFycmF5W19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzY2hlZHVsZXIgPSBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGlzU2NoZWR1bGVyXzEuaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSkge1xuICAgICAgICAgICAgYXJyYXkucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzY2hlZHVsZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5T2JzZXJ2YWJsZShhcnJheSwgc2NoZWR1bGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZW4gPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2NhbGFyT2JzZXJ2YWJsZV8xLlNjYWxhck9ic2VydmFibGUoYXJyYXlbMF0sIHNjaGVkdWxlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVtcHR5T2JzZXJ2YWJsZV8xLkVtcHR5T2JzZXJ2YWJsZShzY2hlZHVsZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBcnJheU9ic2VydmFibGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gc3RhdGUuYXJyYXksIGluZGV4ID0gc3RhdGUuaW5kZXgsIGNvdW50ID0gc3RhdGUuY291bnQsIHN1YnNjcmliZXIgPSBzdGF0ZS5zdWJzY3JpYmVyO1xuICAgICAgICBpZiAoaW5kZXggPj0gY291bnQpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdWJzY3JpYmVyLm5leHQoYXJyYXlbaW5kZXhdKTtcbiAgICAgICAgaWYgKHN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuaW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgIHRoaXMuc2NoZWR1bGUoc3RhdGUpO1xuICAgIH07XG4gICAgQXJyYXlPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheTtcbiAgICAgICAgdmFyIGNvdW50ID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICB2YXIgc2NoZWR1bGVyID0gdGhpcy5zY2hlZHVsZXI7XG4gICAgICAgIGlmIChzY2hlZHVsZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGUoQXJyYXlPYnNlcnZhYmxlLmRpc3BhdGNoLCAwLCB7XG4gICAgICAgICAgICAgICAgYXJyYXk6IGFycmF5LCBpbmRleDogaW5kZXgsIGNvdW50OiBjb3VudCwgc3Vic2NyaWJlcjogc3Vic2NyaWJlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50ICYmICFzdWJzY3JpYmVyLmNsb3NlZDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KGFycmF5W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEFycmF5T2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuQXJyYXlPYnNlcnZhYmxlID0gQXJyYXlPYnNlcnZhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXJyYXlPYnNlcnZhYmxlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29ic2VydmFibGUvQXJyYXlPYnNlcnZhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICYmIHR5cGVvZiB4Lmxlbmd0aCA9PT0gJ251bWJlcic7IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNBcnJheS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy91dGlsL2lzQXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gaXNTY2hlZHVsZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLnNjaGVkdWxlID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc1NjaGVkdWxlciA9IGlzU2NoZWR1bGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNTY2hlZHVsZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvdXRpbC9pc1NjaGVkdWxlci5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIEVtcHR5T2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEVtcHR5T2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFbXB0eU9ic2VydmFibGUoc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgbm8gaXRlbXMgdG8gdGhlIE9ic2VydmVyIGFuZCBpbW1lZGlhdGVseVxuICAgICAqIGVtaXRzIGEgY29tcGxldGUgbm90aWZpY2F0aW9uLlxuICAgICAqXG4gICAgICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkp1c3QgZW1pdHMgJ2NvbXBsZXRlJywgYW5kIG5vdGhpbmcgZWxzZS5cbiAgICAgKiA8L3NwYW4+XG4gICAgICpcbiAgICAgKiA8aW1nIHNyYz1cIi4vaW1nL2VtcHR5LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICAgICAqXG4gICAgICogVGhpcyBzdGF0aWMgb3BlcmF0b3IgaXMgdXNlZnVsIGZvciBjcmVhdGluZyBhIHNpbXBsZSBPYnNlcnZhYmxlIHRoYXQgb25seVxuICAgICAqIGVtaXRzIHRoZSBjb21wbGV0ZSBub3RpZmljYXRpb24uIEl0IGNhbiBiZSB1c2VkIGZvciBjb21wb3Npbmcgd2l0aCBvdGhlclxuICAgICAqIE9ic2VydmFibGVzLCBzdWNoIGFzIGluIGEge0BsaW5rIG1lcmdlTWFwfS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgdGhlIG51bWJlciA3LCB0aGVuIGNvbXBsZXRlLjwvY2FwdGlvbj5cbiAgICAgKiB2YXIgcmVzdWx0ID0gUnguT2JzZXJ2YWJsZS5lbXB0eSgpLnN0YXJ0V2l0aCg3KTtcbiAgICAgKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+TWFwIGFuZCBmbGF0dGVuIG9ubHkgb2RkIG51bWJlcnMgdG8gdGhlIHNlcXVlbmNlICdhJywgJ2InLCAnYyc8L2NhcHRpb24+XG4gICAgICogdmFyIGludGVydmFsID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAgICAgKiB2YXIgcmVzdWx0ID0gaW50ZXJ2YWwubWVyZ2VNYXAoeCA9PlxuICAgICAqICAgeCAlIDIgPT09IDEgPyBSeC5PYnNlcnZhYmxlLm9mKCdhJywgJ2InLCAnYycpIDogUnguT2JzZXJ2YWJsZS5lbXB0eSgpXG4gICAgICogKTtcbiAgICAgKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICAgICAqXG4gICAgICogLy8gUmVzdWx0cyBpbiB0aGUgZm9sbG93aW5nIHRvIHRoZSBjb25zb2xlOlxuICAgICAqIC8vIHggaXMgZXF1YWwgdG8gdGhlIGNvdW50IG9uIHRoZSBpbnRlcnZhbCBlZygwLDEsMiwzLC4uLilcbiAgICAgKiAvLyB4IHdpbGwgb2NjdXIgZXZlcnkgMTAwMG1zXG4gICAgICogLy8gaWYgeCAlIDIgaXMgZXF1YWwgdG8gMSBwcmludCBhYmNcbiAgICAgKiAvLyBpZiB4ICUgMiBpcyBub3QgZXF1YWwgdG8gMSBub3RoaW5nIHdpbGwgYmUgb3V0cHV0XG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBjcmVhdGV9XG4gICAgICogQHNlZSB7QGxpbmsgbmV2ZXJ9XG4gICAgICogQHNlZSB7QGxpbmsgb2Z9XG4gICAgICogQHNlZSB7QGxpbmsgdGhyb3d9XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gQSB7QGxpbmsgSVNjaGVkdWxlcn0gdG8gdXNlIGZvciBzY2hlZHVsaW5nXG4gICAgICogdGhlIGVtaXNzaW9uIG9mIHRoZSBjb21wbGV0ZSBub3RpZmljYXRpb24uXG4gICAgICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gXCJlbXB0eVwiIE9ic2VydmFibGU6IGVtaXRzIG9ubHkgdGhlIGNvbXBsZXRlXG4gICAgICogbm90aWZpY2F0aW9uLlxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBuYW1lIGVtcHR5XG4gICAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICAgKi9cbiAgICBFbXB0eU9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKHNjaGVkdWxlcikge1xuICAgICAgICByZXR1cm4gbmV3IEVtcHR5T2JzZXJ2YWJsZShzY2hlZHVsZXIpO1xuICAgIH07XG4gICAgRW1wdHlPYnNlcnZhYmxlLmRpc3BhdGNoID0gZnVuY3Rpb24gKGFyZykge1xuICAgICAgICB2YXIgc3Vic2NyaWJlciA9IGFyZy5zdWJzY3JpYmVyO1xuICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICBFbXB0eU9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgc2NoZWR1bGVyID0gdGhpcy5zY2hlZHVsZXI7XG4gICAgICAgIGlmIChzY2hlZHVsZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGUoRW1wdHlPYnNlcnZhYmxlLmRpc3BhdGNoLCAwLCB7IHN1YnNjcmliZXI6IHN1YnNjcmliZXIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBFbXB0eU9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLkVtcHR5T2JzZXJ2YWJsZSA9IEVtcHR5T2JzZXJ2YWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVtcHR5T2JzZXJ2YWJsZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vYnNlcnZhYmxlL0VtcHR5T2JzZXJ2YWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQ29ubmVjdGFibGVPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9vYnNlcnZhYmxlL0Nvbm5lY3RhYmxlT2JzZXJ2YWJsZScpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHJlc3VsdHMgb2YgaW52b2tpbmcgYSBzcGVjaWZpZWQgc2VsZWN0b3Igb24gaXRlbXNcbiAqIGVtaXR0ZWQgYnkgYSBDb25uZWN0YWJsZU9ic2VydmFibGUgdGhhdCBzaGFyZXMgYSBzaW5nbGUgc3Vic2NyaXB0aW9uIHRvIHRoZSB1bmRlcmx5aW5nIHN0cmVhbS5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL211bHRpY2FzdC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufFN1YmplY3R9IHN1YmplY3RPclN1YmplY3RGYWN0b3J5IC0gRmFjdG9yeSBmdW5jdGlvbiB0byBjcmVhdGUgYW4gaW50ZXJtZWRpYXRlIHN1YmplY3QgdGhyb3VnaFxuICogd2hpY2ggdGhlIHNvdXJjZSBzZXF1ZW5jZSdzIGVsZW1lbnRzIHdpbGwgYmUgbXVsdGljYXN0IHRvIHRoZSBzZWxlY3RvciBmdW5jdGlvblxuICogb3IgU3ViamVjdCB0byBwdXNoIHNvdXJjZSBlbGVtZW50cyBpbnRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3NlbGVjdG9yXSAtIE9wdGlvbmFsIHNlbGVjdG9yIGZ1bmN0aW9uIHRoYXQgY2FuIHVzZSB0aGUgbXVsdGljYXN0ZWQgc291cmNlIHN0cmVhbVxuICogYXMgbWFueSB0aW1lcyBhcyBuZWVkZWQsIHdpdGhvdXQgY2F1c2luZyBtdWx0aXBsZSBzdWJzY3JpcHRpb25zIHRvIHRoZSBzb3VyY2Ugc3RyZWFtLlxuICogU3Vic2NyaWJlcnMgdG8gdGhlIGdpdmVuIHNvdXJjZSB3aWxsIHJlY2VpdmUgYWxsIG5vdGlmaWNhdGlvbnMgb2YgdGhlIHNvdXJjZSBmcm9tIHRoZVxuICogdGltZSBvZiB0aGUgc3Vic2NyaXB0aW9uIGZvcndhcmQuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHJlc3VsdHMgb2YgaW52b2tpbmcgdGhlIHNlbGVjdG9yXG4gKiBvbiB0aGUgaXRlbXMgZW1pdHRlZCBieSBhIGBDb25uZWN0YWJsZU9ic2VydmFibGVgIHRoYXQgc2hhcmVzIGEgc2luZ2xlIHN1YnNjcmlwdGlvbiB0b1xuICogdGhlIHVuZGVybHlpbmcgc3RyZWFtLlxuICogQG1ldGhvZCBtdWx0aWNhc3RcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIG11bHRpY2FzdChzdWJqZWN0T3JTdWJqZWN0RmFjdG9yeSwgc2VsZWN0b3IpIHtcbiAgICB2YXIgc3ViamVjdEZhY3Rvcnk7XG4gICAgaWYgKHR5cGVvZiBzdWJqZWN0T3JTdWJqZWN0RmFjdG9yeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBzdWJqZWN0RmFjdG9yeSA9IHN1YmplY3RPclN1YmplY3RGYWN0b3J5O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3ViamVjdEZhY3RvcnkgPSBmdW5jdGlvbiBzdWJqZWN0RmFjdG9yeSgpIHtcbiAgICAgICAgICAgIHJldHVybiBzdWJqZWN0T3JTdWJqZWN0RmFjdG9yeTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBNdWx0aWNhc3RPcGVyYXRvcihzdWJqZWN0RmFjdG9yeSwgc2VsZWN0b3IpKTtcbiAgICB9XG4gICAgdmFyIGNvbm5lY3RhYmxlID0gT2JqZWN0LmNyZWF0ZSh0aGlzLCBDb25uZWN0YWJsZU9ic2VydmFibGVfMS5jb25uZWN0YWJsZU9ic2VydmFibGVEZXNjcmlwdG9yKTtcbiAgICBjb25uZWN0YWJsZS5zb3VyY2UgPSB0aGlzO1xuICAgIGNvbm5lY3RhYmxlLnN1YmplY3RGYWN0b3J5ID0gc3ViamVjdEZhY3Rvcnk7XG4gICAgcmV0dXJuIGNvbm5lY3RhYmxlO1xufVxuZXhwb3J0cy5tdWx0aWNhc3QgPSBtdWx0aWNhc3Q7XG52YXIgTXVsdGljYXN0T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE11bHRpY2FzdE9wZXJhdG9yKHN1YmplY3RGYWN0b3J5LCBzZWxlY3Rvcikge1xuICAgICAgICB0aGlzLnN1YmplY3RGYWN0b3J5ID0gc3ViamVjdEZhY3Rvcnk7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICB9XG4gICAgTXVsdGljYXN0T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHZhciBzZWxlY3RvciA9IHRoaXMuc2VsZWN0b3I7XG4gICAgICAgIHZhciBzdWJqZWN0ID0gdGhpcy5zdWJqZWN0RmFjdG9yeSgpO1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gc2VsZWN0b3Ioc3ViamVjdCkuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICBzdWJzY3JpcHRpb24uYWRkKHNvdXJjZS5zdWJzY3JpYmUoc3ViamVjdCkpO1xuICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgIH07XG4gICAgcmV0dXJuIE11bHRpY2FzdE9wZXJhdG9yO1xufSgpKTtcbmV4cG9ydHMuTXVsdGljYXN0T3BlcmF0b3IgPSBNdWx0aWNhc3RPcGVyYXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW11bHRpY2FzdC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvci9tdWx0aWNhc3QuanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vT2JzZXJ2YWJsZScpO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgcHVzaC1iYXNlZCBldmVudCBvciB2YWx1ZSB0aGF0IGFuIHtAbGluayBPYnNlcnZhYmxlfSBjYW4gZW1pdC5cbiAqIFRoaXMgY2xhc3MgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3Igb3BlcmF0b3JzIHRoYXQgbWFuYWdlIG5vdGlmaWNhdGlvbnMsXG4gKiBsaWtlIHtAbGluayBtYXRlcmlhbGl6ZX0sIHtAbGluayBkZW1hdGVyaWFsaXplfSwge0BsaW5rIG9ic2VydmVPbn0sIGFuZFxuICogb3RoZXJzLiBCZXNpZGVzIHdyYXBwaW5nIHRoZSBhY3R1YWwgZGVsaXZlcmVkIHZhbHVlLCBpdCBhbHNvIGFubm90YXRlcyBpdFxuICogd2l0aCBtZXRhZGF0YSBvZiwgZm9yIGluc3RhbmNlLCB3aGF0IHR5cGUgb2YgcHVzaCBtZXNzYWdlIGl0IGlzIChgbmV4dGAsXG4gKiBgZXJyb3JgLCBvciBgY29tcGxldGVgKS5cbiAqXG4gKiBAc2VlIHtAbGluayBtYXRlcmlhbGl6ZX1cbiAqIEBzZWUge0BsaW5rIGRlbWF0ZXJpYWxpemV9XG4gKiBAc2VlIHtAbGluayBvYnNlcnZlT259XG4gKlxuICogQGNsYXNzIE5vdGlmaWNhdGlvbjxUPlxuICovXG52YXIgTm90aWZpY2F0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb3RpZmljYXRpb24oa2luZCwgdmFsdWUsIGVycm9yKSB7XG4gICAgICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLmhhc1ZhbHVlID0ga2luZCA9PT0gJ04nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxpdmVycyB0byB0aGUgZ2l2ZW4gYG9ic2VydmVyYCB0aGUgdmFsdWUgd3JhcHBlZCBieSB0aGlzIE5vdGlmaWNhdGlvbi5cbiAgICAgKiBAcGFyYW0ge09ic2VydmVyfSBvYnNlcnZlclxuICAgICAqIEByZXR1cm5cbiAgICAgKi9cbiAgICBOb3RpZmljYXRpb24ucHJvdG90eXBlLm9ic2VydmUgPSBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLmtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgJ04nOlxuICAgICAgICAgICAgICAgIHJldHVybiBvYnNlcnZlci5uZXh0ICYmIG9ic2VydmVyLm5leHQodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICBjYXNlICdFJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXIuZXJyb3IgJiYgb2JzZXJ2ZXIuZXJyb3IodGhpcy5lcnJvcik7XG4gICAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXIuY29tcGxldGUgJiYgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogR2l2ZW4gc29tZSB7QGxpbmsgT2JzZXJ2ZXJ9IGNhbGxiYWNrcywgZGVsaXZlciB0aGUgdmFsdWUgcmVwcmVzZW50ZWQgYnkgdGhlXG4gICAgICogY3VycmVudCBOb3RpZmljYXRpb24gdG8gdGhlIGNvcnJlY3RseSBjb3JyZXNwb25kaW5nIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24odmFsdWU6IFQpOiB2b2lkfSBuZXh0IEFuIE9ic2VydmVyIGBuZXh0YCBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGVycjogYW55KTogdm9pZH0gW2Vycm9yXSBBbiBPYnNlcnZlciBgZXJyb3JgIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogdm9pZH0gW2NvbXBsZXRlXSBBbiBPYnNlcnZlciBgY29tcGxldGVgIGNhbGxiYWNrLlxuICAgICAqIEByZXR1cm4ge2FueX1cbiAgICAgKi9cbiAgICBOb3RpZmljYXRpb24ucHJvdG90eXBlLmRvID0gZnVuY3Rpb24gKG5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICB2YXIga2luZCA9IHRoaXMua2luZDtcbiAgICAgICAgc3dpdGNoIChraW5kKSB7XG4gICAgICAgICAgICBjYXNlICdOJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dCAmJiBuZXh0KHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAnRSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yICYmIGVycm9yKHRoaXMuZXJyb3IpO1xuICAgICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlICYmIGNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRha2VzIGFuIE9ic2VydmVyIG9yIGl0cyBpbmRpdmlkdWFsIGNhbGxiYWNrIGZ1bmN0aW9ucywgYW5kIGNhbGxzIGBvYnNlcnZlYFxuICAgICAqIG9yIGBkb2AgbWV0aG9kcyBhY2NvcmRpbmdseS5cbiAgICAgKiBAcGFyYW0ge09ic2VydmVyfGZ1bmN0aW9uKHZhbHVlOiBUKTogdm9pZH0gbmV4dE9yT2JzZXJ2ZXIgQW4gT2JzZXJ2ZXIgb3JcbiAgICAgKiB0aGUgYG5leHRgIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oZXJyOiBhbnkpOiB2b2lkfSBbZXJyb3JdIEFuIE9ic2VydmVyIGBlcnJvcmAgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpOiB2b2lkfSBbY29tcGxldGVdIEFuIE9ic2VydmVyIGBjb21wbGV0ZWAgY2FsbGJhY2suXG4gICAgICogQHJldHVybiB7YW55fVxuICAgICAqL1xuICAgIE5vdGlmaWNhdGlvbi5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgaWYgKG5leHRPck9ic2VydmVyICYmIHR5cGVvZiBuZXh0T3JPYnNlcnZlci5uZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vYnNlcnZlKG5leHRPck9ic2VydmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc2ltcGxlIE9ic2VydmFibGUgdGhhdCBqdXN0IGRlbGl2ZXJzIHRoZSBub3RpZmljYXRpb24gcmVwcmVzZW50ZWRcbiAgICAgKiBieSB0aGlzIE5vdGlmaWNhdGlvbiBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJuIHthbnl9XG4gICAgICovXG4gICAgTm90aWZpY2F0aW9uLnByb3RvdHlwZS50b09ic2VydmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBraW5kID0gdGhpcy5raW5kO1xuICAgICAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgJ04nOlxuICAgICAgICAgICAgICAgIHJldHVybiBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5vZih0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgJ0UnOlxuICAgICAgICAgICAgICAgIHJldHVybiBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS50aHJvdyh0aGlzLmVycm9yKTtcbiAgICAgICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgICAgICAgIHJldHVybiBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5lbXB0eSgpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBub3RpZmljYXRpb24ga2luZCB2YWx1ZScpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBzaG9ydGN1dCB0byBjcmVhdGUgYSBOb3RpZmljYXRpb24gaW5zdGFuY2Ugb2YgdGhlIHR5cGUgYG5leHRgIGZyb20gYVxuICAgICAqIGdpdmVuIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7VH0gdmFsdWUgVGhlIGBuZXh0YCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJuIHtOb3RpZmljYXRpb248VD59IFRoZSBcIm5leHRcIiBOb3RpZmljYXRpb24gcmVwcmVzZW50aW5nIHRoZVxuICAgICAqIGFyZ3VtZW50LlxuICAgICAqL1xuICAgIE5vdGlmaWNhdGlvbi5jcmVhdGVOZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5vdGlmaWNhdGlvbignTicsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy51bmRlZmluZWRWYWx1ZU5vdGlmaWNhdGlvbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgc2hvcnRjdXQgdG8gY3JlYXRlIGEgTm90aWZpY2F0aW9uIGluc3RhbmNlIG9mIHRoZSB0eXBlIGBlcnJvcmAgZnJvbSBhXG4gICAgICogZ2l2ZW4gZXJyb3IuXG4gICAgICogQHBhcmFtIHthbnl9IFtlcnJdIFRoZSBgZXJyb3JgIGVycm9yLlxuICAgICAqIEByZXR1cm4ge05vdGlmaWNhdGlvbjxUPn0gVGhlIFwiZXJyb3JcIiBOb3RpZmljYXRpb24gcmVwcmVzZW50aW5nIHRoZVxuICAgICAqIGFyZ3VtZW50LlxuICAgICAqL1xuICAgIE5vdGlmaWNhdGlvbi5jcmVhdGVFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb3RpZmljYXRpb24oJ0UnLCB1bmRlZmluZWQsIGVycik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIHNob3J0Y3V0IHRvIGNyZWF0ZSBhIE5vdGlmaWNhdGlvbiBpbnN0YW5jZSBvZiB0aGUgdHlwZSBgY29tcGxldGVgLlxuICAgICAqIEByZXR1cm4ge05vdGlmaWNhdGlvbjxhbnk+fSBUaGUgdmFsdWVsZXNzIFwiY29tcGxldGVcIiBOb3RpZmljYXRpb24uXG4gICAgICovXG4gICAgTm90aWZpY2F0aW9uLmNyZWF0ZUNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZU5vdGlmaWNhdGlvbjtcbiAgICB9O1xuICAgIE5vdGlmaWNhdGlvbi5jb21wbGV0ZU5vdGlmaWNhdGlvbiA9IG5ldyBOb3RpZmljYXRpb24oJ0MnKTtcbiAgICBOb3RpZmljYXRpb24udW5kZWZpbmVkVmFsdWVOb3RpZmljYXRpb24gPSBuZXcgTm90aWZpY2F0aW9uKCdOJywgdW5kZWZpbmVkKTtcbiAgICByZXR1cm4gTm90aWZpY2F0aW9uO1xufSgpKTtcbmV4cG9ydHMuTm90aWZpY2F0aW9uID0gTm90aWZpY2F0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Tm90aWZpY2F0aW9uLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL05vdGlmaWNhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciByb290XzEgPSByZXF1aXJlKCcuLi91dGlsL3Jvb3QnKTtcbnZhciBBY3Rpb25fMSA9IHJlcXVpcmUoJy4vQWN0aW9uJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIEFzeW5jQWN0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXN5bmNBY3Rpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXN5bmNBY3Rpb24oc2NoZWR1bGVyLCB3b3JrKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHNjaGVkdWxlciwgd29yayk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLndvcmsgPSB3b3JrO1xuICAgICAgICB0aGlzLnBlbmRpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgQXN5bmNBY3Rpb24ucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKHN0YXRlLCBkZWxheSkge1xuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBBbHdheXMgcmVwbGFjZSB0aGUgY3VycmVudCBzdGF0ZSB3aXRoIHRoZSBuZXcgc3RhdGUuXG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgLy8gU2V0IHRoZSBwZW5kaW5nIGZsYWcgaW5kaWNhdGluZyB0aGF0IHRoaXMgYWN0aW9uIGhhcyBiZWVuIHNjaGVkdWxlZCwgb3JcbiAgICAgICAgLy8gaGFzIHJlY3Vyc2l2ZWx5IHJlc2NoZWR1bGVkIGl0c2VsZi5cbiAgICAgICAgdGhpcy5wZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgdmFyIGlkID0gdGhpcy5pZDtcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICAvL1xuICAgICAgICAvLyBJbXBvcnRhbnQgaW1wbGVtZW50YXRpb24gbm90ZTpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gQWN0aW9ucyBvbmx5IGV4ZWN1dGUgb25jZSBieSBkZWZhdWx0LCB1bmxlc3MgcmVzY2hlZHVsZWQgZnJvbSB3aXRoaW4gdGhlXG4gICAgICAgIC8vIHNjaGVkdWxlZCBjYWxsYmFjay4gVGhpcyBhbGxvd3MgdXMgdG8gaW1wbGVtZW50IHNpbmdsZSBhbmQgcmVwZWF0XG4gICAgICAgIC8vIGFjdGlvbnMgdmlhIHRoZSBzYW1lIGNvZGUgcGF0aCwgd2l0aG91dCBhZGRpbmcgQVBJIHN1cmZhY2UgYXJlYSwgYXMgd2VsbFxuICAgICAgICAvLyBhcyBtaW1pYyB0cmFkaXRpb25hbCByZWN1cnNpb24gYnV0IGFjcm9zcyBhc3luY2hyb25vdXMgYm91bmRhcmllcy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSG93ZXZlciwgSlMgcnVudGltZXMgYW5kIHRpbWVycyBkaXN0aW5ndWlzaCBiZXR3ZWVuIGludGVydmFscyBhY2hpZXZlZCBieVxuICAgICAgICAvLyBzZXJpYWwgYHNldFRpbWVvdXRgIGNhbGxzIHZzLiBhIHNpbmdsZSBgc2V0SW50ZXJ2YWxgIGNhbGwuIEFuIGludGVydmFsIG9mXG4gICAgICAgIC8vIHNlcmlhbCBgc2V0VGltZW91dGAgY2FsbHMgY2FuIGJlIGluZGl2aWR1YWxseSBkZWxheWVkLCB3aGljaCBkZWxheXNcbiAgICAgICAgLy8gc2NoZWR1bGluZyB0aGUgbmV4dCBgc2V0VGltZW91dGAsIGFuZCBzbyBvbi4gYHNldEludGVydmFsYCBhdHRlbXB0cyB0b1xuICAgICAgICAvLyBndWFyYW50ZWUgdGhlIGludGVydmFsIGNhbGxiYWNrIHdpbGwgYmUgaW52b2tlZCBtb3JlIHByZWNpc2VseSB0byB0aGVcbiAgICAgICAgLy8gaW50ZXJ2YWwgcGVyaW9kLCByZWdhcmRsZXNzIG9mIGxvYWQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoZXJlZm9yZSwgd2UgdXNlIGBzZXRJbnRlcnZhbGAgdG8gc2NoZWR1bGUgc2luZ2xlIGFuZCByZXBlYXQgYWN0aW9ucy5cbiAgICAgICAgLy8gSWYgdGhlIGFjdGlvbiByZXNjaGVkdWxlcyBpdHNlbGYgd2l0aCB0aGUgc2FtZSBkZWxheSwgdGhlIGludGVydmFsIGlzIG5vdFxuICAgICAgICAvLyBjYW5jZWxlZC4gSWYgdGhlIGFjdGlvbiBkb2Vzbid0IHJlc2NoZWR1bGUsIG9yIHJlc2NoZWR1bGVzIHdpdGggYVxuICAgICAgICAvLyBkaWZmZXJlbnQgZGVsYXksIHRoZSBpbnRlcnZhbCB3aWxsIGJlIGNhbmNlbGVkIGFmdGVyIHNjaGVkdWxlZCBjYWxsYmFja1xuICAgICAgICAvLyBleGVjdXRpb24uXG4gICAgICAgIC8vXG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmlkID0gdGhpcy5yZWN5Y2xlQXN5bmNJZChzY2hlZHVsZXIsIGlkLCBkZWxheSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWxheSA9IGRlbGF5O1xuICAgICAgICAvLyBJZiB0aGlzIGFjdGlvbiBoYXMgYWxyZWFkeSBhbiBhc3luYyBJZCwgZG9uJ3QgcmVxdWVzdCBhIG5ldyBvbmUuXG4gICAgICAgIHRoaXMuaWQgPSB0aGlzLmlkIHx8IHRoaXMucmVxdWVzdEFzeW5jSWQoc2NoZWR1bGVyLCB0aGlzLmlkLCBkZWxheSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQXN5bmNBY3Rpb24ucHJvdG90eXBlLnJlcXVlc3RBc3luY0lkID0gZnVuY3Rpb24gKHNjaGVkdWxlciwgaWQsIGRlbGF5KSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxuICAgICAgICByZXR1cm4gcm9vdF8xLnJvb3Quc2V0SW50ZXJ2YWwoc2NoZWR1bGVyLmZsdXNoLmJpbmQoc2NoZWR1bGVyLCB0aGlzKSwgZGVsYXkpO1xuICAgIH07XG4gICAgQXN5bmNBY3Rpb24ucHJvdG90eXBlLnJlY3ljbGVBc3luY0lkID0gZnVuY3Rpb24gKHNjaGVkdWxlciwgaWQsIGRlbGF5KSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxuICAgICAgICAvLyBJZiB0aGlzIGFjdGlvbiBpcyByZXNjaGVkdWxlZCB3aXRoIHRoZSBzYW1lIGRlbGF5IHRpbWUsIGRvbid0IGNsZWFyIHRoZSBpbnRlcnZhbCBpZC5cbiAgICAgICAgaWYgKGRlbGF5ICE9PSBudWxsICYmIHRoaXMuZGVsYXkgPT09IGRlbGF5KSB7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBpZiB0aGUgYWN0aW9uJ3MgZGVsYXkgdGltZSBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgY3VycmVudCBkZWxheSxcbiAgICAgICAgLy8gY2xlYXIgdGhlIGludGVydmFsIGlkXG4gICAgICAgIHJldHVybiByb290XzEucm9vdC5jbGVhckludGVydmFsKGlkKSAmJiB1bmRlZmluZWQgfHwgdW5kZWZpbmVkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW1tZWRpYXRlbHkgZXhlY3V0ZXMgdGhpcyBhY3Rpb24gYW5kIHRoZSBgd29ya2AgaXQgY29udGFpbnMuXG4gICAgICogQHJldHVybiB7YW55fVxuICAgICAqL1xuICAgIEFzeW5jQWN0aW9uLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKHN0YXRlLCBkZWxheSkge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ2V4ZWN1dGluZyBhIGNhbmNlbGxlZCBhY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgdmFyIGVycm9yID0gdGhpcy5fZXhlY3V0ZShzdGF0ZSwgZGVsYXkpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnBlbmRpbmcgPT09IGZhbHNlICYmIHRoaXMuaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gRGVxdWV1ZSBpZiB0aGUgYWN0aW9uIGRpZG4ndCByZXNjaGVkdWxlIGl0c2VsZi4gRG9uJ3QgY2FsbFxuICAgICAgICAgICAgLy8gdW5zdWJzY3JpYmUoKSwgYmVjYXVzZSB0aGUgYWN0aW9uIGNvdWxkIHJlc2NoZWR1bGUgbGF0ZXIuXG4gICAgICAgICAgICAvLyBGb3IgZXhhbXBsZTpcbiAgICAgICAgICAgIC8vIGBgYFxuICAgICAgICAgICAgLy8gc2NoZWR1bGVyLnNjaGVkdWxlKGZ1bmN0aW9uIGRvV29yayhjb3VudGVyKSB7XG4gICAgICAgICAgICAvLyAgIC8qIC4uLiBJJ20gYSBidXN5IHdvcmtlciBiZWUgLi4uICovXG4gICAgICAgICAgICAvLyAgIHZhciBvcmlnaW5hbEFjdGlvbiA9IHRoaXM7XG4gICAgICAgICAgICAvLyAgIC8qIHdhaXQgMTAwbXMgYmVmb3JlIHJlc2NoZWR1bGluZyB0aGUgYWN0aW9uICovXG4gICAgICAgICAgICAvLyAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gICAgIG9yaWdpbmFsQWN0aW9uLnNjaGVkdWxlKGNvdW50ZXIgKyAxKTtcbiAgICAgICAgICAgIC8vICAgfSwgMTAwKTtcbiAgICAgICAgICAgIC8vIH0sIDEwMDApO1xuICAgICAgICAgICAgLy8gYGBgXG4gICAgICAgICAgICB0aGlzLmlkID0gdGhpcy5yZWN5Y2xlQXN5bmNJZCh0aGlzLnNjaGVkdWxlciwgdGhpcy5pZCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFzeW5jQWN0aW9uLnByb3RvdHlwZS5fZXhlY3V0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZGVsYXkpIHtcbiAgICAgICAgdmFyIGVycm9yZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGVycm9yVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLndvcmsoc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBlcnJvcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGVycm9yVmFsdWUgPSAhIWUgJiYgZSB8fCBuZXcgRXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yZWQpIHtcbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHJldHVybiBlcnJvclZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBc3luY0FjdGlvbi5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaWQgPSB0aGlzLmlkO1xuICAgICAgICB2YXIgc2NoZWR1bGVyID0gdGhpcy5zY2hlZHVsZXI7XG4gICAgICAgIHZhciBhY3Rpb25zID0gc2NoZWR1bGVyLmFjdGlvbnM7XG4gICAgICAgIHZhciBpbmRleCA9IGFjdGlvbnMuaW5kZXhPZih0aGlzKTtcbiAgICAgICAgdGhpcy53b3JrID0gbnVsbDtcbiAgICAgICAgdGhpcy5kZWxheSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuICAgICAgICB0aGlzLnBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBudWxsO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBhY3Rpb25zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSB0aGlzLnJlY3ljbGVBc3luY0lkKHNjaGVkdWxlciwgaWQsIG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQXN5bmNBY3Rpb247XG59KEFjdGlvbl8xLkFjdGlvbikpO1xuZXhwb3J0cy5Bc3luY0FjdGlvbiA9IEFzeW5jQWN0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXN5bmNBY3Rpb24uanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvc2NoZWR1bGVyL0FzeW5jQWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFNjaGVkdWxlcl8xID0gcmVxdWlyZSgnLi4vU2NoZWR1bGVyJyk7XG52YXIgQXN5bmNTY2hlZHVsZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBc3luY1NjaGVkdWxlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBc3luY1NjaGVkdWxlcigpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuYWN0aW9ucyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgdGhlIFNjaGVkdWxlciBpcyBjdXJyZW50bHkgZXhlY3V0aW5nIGEgYmF0Y2ggb2ZcbiAgICAgICAgICogcXVldWVkIGFjdGlvbnMuXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGludGVybmFsIElEIHVzZWQgdG8gdHJhY2sgdGhlIGxhdGVzdCBhc3luY2hyb25vdXMgdGFzayBzdWNoIGFzIHRob3NlXG4gICAgICAgICAqIGNvbWluZyBmcm9tIGBzZXRUaW1lb3V0YCwgYHNldEludGVydmFsYCwgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAsIGFuZFxuICAgICAgICAgKiBvdGhlcnMuXG4gICAgICAgICAqIEB0eXBlIHthbnl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNjaGVkdWxlZCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgQXN5bmNTY2hlZHVsZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICB2YXIgYWN0aW9ucyA9IHRoaXMuYWN0aW9ucztcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICBhY3Rpb25zLnB1c2goYWN0aW9uKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKGVycm9yID0gYWN0aW9uLmV4ZWN1dGUoYWN0aW9uLnN0YXRlLCBhY3Rpb24uZGVsYXkpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGFjdGlvbiA9IGFjdGlvbnMuc2hpZnQoKSk7IC8vIGV4aGF1c3QgdGhlIHNjaGVkdWxlciBxdWV1ZVxuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHdoaWxlIChhY3Rpb24gPSBhY3Rpb25zLnNoaWZ0KCkpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQXN5bmNTY2hlZHVsZXI7XG59KFNjaGVkdWxlcl8xLlNjaGVkdWxlcikpO1xuZXhwb3J0cy5Bc3luY1NjaGVkdWxlciA9IEFzeW5jU2NoZWR1bGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXN5bmNTY2hlZHVsZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvc2NoZWR1bGVyL0FzeW5jU2NoZWR1bGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciByb290XzEgPSByZXF1aXJlKCcuLi91dGlsL3Jvb3QnKTtcbmZ1bmN0aW9uIHN5bWJvbEl0ZXJhdG9yUG9ueWZpbGwocm9vdCkge1xuICAgIHZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAoIVN5bWJvbC5pdGVyYXRvcikge1xuICAgICAgICAgICAgU3ltYm9sLml0ZXJhdG9yID0gU3ltYm9sKCdpdGVyYXRvciBwb2x5ZmlsbCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTeW1ib2wuaXRlcmF0b3I7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBbZm9yIE1vemlsbGEgR2Vja28gMjctMzU6XShodHRwczovL216bC5sYS8yZXdFMXpDKVxuICAgICAgICB2YXIgU2V0XzEgPSByb290LlNldDtcbiAgICAgICAgaWYgKFNldF8xICYmIHR5cGVvZiBuZXcgU2V0XzEoKVsnQEBpdGVyYXRvciddID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0BAaXRlcmF0b3InO1xuICAgICAgICB9XG4gICAgICAgIHZhciBNYXBfMSA9IHJvb3QuTWFwO1xuICAgICAgICAvLyByZXF1aXJlZCBmb3IgY29tcGF0YWJpbGl0eSB3aXRoIGVzNi1zaGltXG4gICAgICAgIGlmIChNYXBfMSkge1xuICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhNYXBfMS5wcm90b3R5cGUpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgLy8gYWNjb3JkaW5nIHRvIHNwZWMsIE1hcC5wcm90b3R5cGVbQEBpdGVyYXRvcl0gYW5kIE1hcC5vcm90b3R5cGUuZW50cmllcyBtdXN0IGJlIGVxdWFsLlxuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICdlbnRyaWVzJyAmJiBrZXkgIT09ICdzaXplJyAmJiBNYXBfMS5wcm90b3R5cGVba2V5XSA9PT0gTWFwXzEucHJvdG90eXBlWydlbnRyaWVzJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdAQGl0ZXJhdG9yJztcbiAgICB9XG59XG5leHBvcnRzLnN5bWJvbEl0ZXJhdG9yUG9ueWZpbGwgPSBzeW1ib2xJdGVyYXRvclBvbnlmaWxsO1xuZXhwb3J0cy4kJGl0ZXJhdG9yID0gc3ltYm9sSXRlcmF0b3JQb255ZmlsbChyb290XzEucm9vdCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pdGVyYXRvci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9zeW1ib2wvaXRlcmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3ViamVjdF8xID0gcmVxdWlyZSgnLi9TdWJqZWN0Jyk7XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuL1N1YnNjcmlwdGlvbicpO1xuLyoqXG4gKiBAY2xhc3MgQXN5bmNTdWJqZWN0PFQ+XG4gKi9cbnZhciBBc3luY1N1YmplY3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBc3luY1N1YmplY3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXN5bmNTdWJqZWN0KCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFzTmV4dCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc0NvbXBsZXRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBBc3luY1N1YmplY3QucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICBpZiAodGhpcy5oYXNFcnJvcikge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcih0aGlzLnRocm93bkVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5oYXNDb21wbGV0ZWQgJiYgdGhpcy5oYXNOZXh0KSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICByZXR1cm4gU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uLkVNUFRZO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLl9zdWJzY3JpYmUuY2FsbCh0aGlzLCBzdWJzY3JpYmVyKTtcbiAgICB9O1xuICAgIEFzeW5jU3ViamVjdC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzQ29tcGxldGVkKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmhhc05leHQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBc3luY1N1YmplY3QucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNDb21wbGV0ZWQpIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZXJyb3IuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFzeW5jU3ViamVjdC5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuaGFzTmV4dCkge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZXh0LmNhbGwodGhpcywgdGhpcy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5jb21wbGV0ZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIEFzeW5jU3ViamVjdDtcbn0oU3ViamVjdF8xLlN1YmplY3QpKTtcbmV4cG9ydHMuQXN5bmNTdWJqZWN0ID0gQXN5bmNTdWJqZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXN5bmNTdWJqZWN0LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL0FzeW5jU3ViamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKipcbiAqIENvbnZlcnRzIGEgaGlnaGVyLW9yZGVyIE9ic2VydmFibGUgaW50byBhIGZpcnN0LW9yZGVyIE9ic2VydmFibGUgd2hpY2hcbiAqIGNvbmN1cnJlbnRseSBkZWxpdmVycyBhbGwgdmFsdWVzIHRoYXQgYXJlIGVtaXR0ZWQgb24gdGhlIGlubmVyIE9ic2VydmFibGVzLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5GbGF0dGVucyBhbiBPYnNlcnZhYmxlLW9mLU9ic2VydmFibGVzLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL21lcmdlQWxsLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBtZXJnZUFsbGAgc3Vic2NyaWJlcyB0byBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgT2JzZXJ2YWJsZXMsIGFsc28ga25vd24gYXNcbiAqIGEgaGlnaGVyLW9yZGVyIE9ic2VydmFibGUuIEVhY2ggdGltZSBpdCBvYnNlcnZlcyBvbmUgb2YgdGhlc2UgZW1pdHRlZCBpbm5lclxuICogT2JzZXJ2YWJsZXMsIGl0IHN1YnNjcmliZXMgdG8gdGhhdCBhbmQgZGVsaXZlcnMgYWxsIHRoZSB2YWx1ZXMgZnJvbSB0aGVcbiAqIGlubmVyIE9ic2VydmFibGUgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLiBUaGUgb3V0cHV0IE9ic2VydmFibGUgb25seVxuICogY29tcGxldGVzIG9uY2UgYWxsIGlubmVyIE9ic2VydmFibGVzIGhhdmUgY29tcGxldGVkLiBBbnkgZXJyb3IgZGVsaXZlcmVkIGJ5XG4gKiBhIGlubmVyIE9ic2VydmFibGUgd2lsbCBiZSBpbW1lZGlhdGVseSBlbWl0dGVkIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5TcGF3biBhIG5ldyBpbnRlcnZhbCBPYnNlcnZhYmxlIGZvciBlYWNoIGNsaWNrIGV2ZW50LCBhbmQgYmxlbmQgdGhlaXIgb3V0cHV0cyBhcyBvbmUgT2JzZXJ2YWJsZTwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgaGlnaGVyT3JkZXIgPSBjbGlja3MubWFwKChldikgPT4gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKSk7XG4gKiB2YXIgZmlyc3RPcmRlciA9IGhpZ2hlck9yZGVyLm1lcmdlQWxsKCk7XG4gKiBmaXJzdE9yZGVyLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db3VudCBmcm9tIDAgdG8gOSBldmVyeSBzZWNvbmQgZm9yIGVhY2ggY2xpY2ssIGJ1dCBvbmx5IGFsbG93IDIgY29uY3VycmVudCB0aW1lcnM8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIGhpZ2hlck9yZGVyID0gY2xpY2tzLm1hcCgoZXYpID0+IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkudGFrZSgxMCkpO1xuICogdmFyIGZpcnN0T3JkZXIgPSBoaWdoZXJPcmRlci5tZXJnZUFsbCgyKTtcbiAqIGZpcnN0T3JkZXIuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGNvbWJpbmVBbGx9XG4gKiBAc2VlIHtAbGluayBjb25jYXRBbGx9XG4gKiBAc2VlIHtAbGluayBleGhhdXN0fVxuICogQHNlZSB7QGxpbmsgbWVyZ2V9XG4gKiBAc2VlIHtAbGluayBtZXJnZU1hcH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlTWFwVG99XG4gKiBAc2VlIHtAbGluayBtZXJnZVNjYW59XG4gKiBAc2VlIHtAbGluayBzd2l0Y2h9XG4gKiBAc2VlIHtAbGluayB6aXBBbGx9XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFtjb25jdXJyZW50PU51bWJlci5QT1NJVElWRV9JTkZJTklUWV0gTWF4aW11bSBudW1iZXIgb2YgaW5uZXJcbiAqIE9ic2VydmFibGVzIGJlaW5nIHN1YnNjcmliZWQgdG8gY29uY3VycmVudGx5LlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHZhbHVlcyBjb21pbmcgZnJvbSBhbGwgdGhlXG4gKiBpbm5lciBPYnNlcnZhYmxlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEBtZXRob2QgbWVyZ2VBbGxcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIG1lcmdlQWxsKGNvbmN1cnJlbnQpIHtcbiAgICBpZiAoY29uY3VycmVudCA9PT0gdm9pZCAwKSB7IGNvbmN1cnJlbnQgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7IH1cbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBNZXJnZUFsbE9wZXJhdG9yKGNvbmN1cnJlbnQpKTtcbn1cbmV4cG9ydHMubWVyZ2VBbGwgPSBtZXJnZUFsbDtcbnZhciBNZXJnZUFsbE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZXJnZUFsbE9wZXJhdG9yKGNvbmN1cnJlbnQpIHtcbiAgICAgICAgdGhpcy5jb25jdXJyZW50ID0gY29uY3VycmVudDtcbiAgICB9XG4gICAgTWVyZ2VBbGxPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChvYnNlcnZlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBNZXJnZUFsbFN1YnNjcmliZXIob2JzZXJ2ZXIsIHRoaXMuY29uY3VycmVudCkpO1xuICAgIH07XG4gICAgcmV0dXJuIE1lcmdlQWxsT3BlcmF0b3I7XG59KCkpO1xuZXhwb3J0cy5NZXJnZUFsbE9wZXJhdG9yID0gTWVyZ2VBbGxPcGVyYXRvcjtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgTWVyZ2VBbGxTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWVyZ2VBbGxTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1lcmdlQWxsU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgY29uY3VycmVudCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuY29uY3VycmVudCA9IGNvbmN1cnJlbnQ7XG4gICAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gW107XG4gICAgICAgIHRoaXMuYWN0aXZlID0gMDtcbiAgICB9XG4gICAgTWVyZ2VBbGxTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uIChvYnNlcnZhYmxlKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSA8IHRoaXMuY29uY3VycmVudCkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmUrKztcbiAgICAgICAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgb2JzZXJ2YWJsZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaChvYnNlcnZhYmxlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWVyZ2VBbGxTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlID09PSAwICYmIHRoaXMuYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZXJnZUFsbFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKGlubmVyU3ViKSB7XG4gICAgICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgdGhpcy5yZW1vdmUoaW5uZXJTdWIpO1xuICAgICAgICB0aGlzLmFjdGl2ZS0tO1xuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX25leHQoYnVmZmVyLnNoaWZ0KCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYWN0aXZlID09PSAwICYmIHRoaXMuaGFzQ29tcGxldGVkKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBNZXJnZUFsbFN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuZXhwb3J0cy5NZXJnZUFsbFN1YnNjcmliZXIgPSBNZXJnZUFsbFN1YnNjcmliZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXJnZUFsbC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvci9tZXJnZUFsbC5qc1xuLy8gbW9kdWxlIGlkID0gMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcm9vdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9yb290Jyk7XG5mdW5jdGlvbiBnZXRTeW1ib2xPYnNlcnZhYmxlKGNvbnRleHQpIHtcbiAgICB2YXIgJCRvYnNlcnZhYmxlO1xuICAgIHZhciBTeW1ib2wgPSBjb250ZXh0LlN5bWJvbDtcbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAoU3ltYm9sLm9ic2VydmFibGUpIHtcbiAgICAgICAgICAgICQkb2JzZXJ2YWJsZSA9IFN5bWJvbC5vYnNlcnZhYmxlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgJCRvYnNlcnZhYmxlID0gU3ltYm9sKCdvYnNlcnZhYmxlJyk7XG4gICAgICAgICAgICBTeW1ib2wub2JzZXJ2YWJsZSA9ICQkb2JzZXJ2YWJsZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgJCRvYnNlcnZhYmxlID0gJ0BAb2JzZXJ2YWJsZSc7XG4gICAgfVxuICAgIHJldHVybiAkJG9ic2VydmFibGU7XG59XG5leHBvcnRzLmdldFN5bWJvbE9ic2VydmFibGUgPSBnZXRTeW1ib2xPYnNlcnZhYmxlO1xuZXhwb3J0cy4kJG9ic2VydmFibGUgPSBnZXRTeW1ib2xPYnNlcnZhYmxlKHJvb3RfMS5yb290KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9ic2VydmFibGUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvc3ltYm9sL29ic2VydmFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHJvb3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvcm9vdCcpO1xudmFyIFN5bWJvbCA9IHJvb3RfMS5yb290LlN5bWJvbDtcbmV4cG9ydHMuJCRyeFN1YnNjcmliZXIgPSAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLmZvciA9PT0gJ2Z1bmN0aW9uJykgP1xuICAgIFN5bWJvbC5mb3IoJ3J4U3Vic2NyaWJlcicpIDogJ0BAcnhTdWJzY3JpYmVyJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJ4U3Vic2NyaWJlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9zeW1ib2wvcnhTdWJzY3JpYmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xuLyoqXG4gKiBBbiBlcnJvciB0aHJvd24gd2hlbiBhbiBlbGVtZW50IHdhcyBxdWVyaWVkIGF0IGEgY2VydGFpbiBpbmRleCBvZiBhblxuICogT2JzZXJ2YWJsZSwgYnV0IG5vIHN1Y2ggaW5kZXggb3IgcG9zaXRpb24gZXhpc3RzIGluIHRoYXQgc2VxdWVuY2UuXG4gKlxuICogQHNlZSB7QGxpbmsgZWxlbWVudEF0fVxuICogQHNlZSB7QGxpbmsgdGFrZX1cbiAqIEBzZWUge0BsaW5rIHRha2VMYXN0fVxuICpcbiAqIEBjbGFzcyBBcmd1bWVudE91dE9mUmFuZ2VFcnJvclxuICovXG52YXIgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBcmd1bWVudE91dE9mUmFuZ2VFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcigpIHtcbiAgICAgICAgdmFyIGVyciA9IF9zdXBlci5jYWxsKHRoaXMsICdhcmd1bWVudCBvdXQgb2YgcmFuZ2UnKTtcbiAgICAgICAgdGhpcy5uYW1lID0gZXJyLm5hbWUgPSAnQXJndW1lbnRPdXRPZlJhbmdlRXJyb3InO1xuICAgICAgICB0aGlzLnN0YWNrID0gZXJyLnN0YWNrO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuIEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5Bcmd1bWVudE91dE9mUmFuZ2VFcnJvciA9IEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXJndW1lbnRPdXRPZlJhbmdlRXJyb3IuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvdXRpbC9Bcmd1bWVudE91dE9mUmFuZ2VFcnJvci5qc1xuLy8gbW9kdWxlIGlkID0gMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbi8qKlxuICogQW4gZXJyb3IgdGhyb3duIHdoZW4gYW4gT2JzZXJ2YWJsZSBvciBhIHNlcXVlbmNlIHdhcyBxdWVyaWVkIGJ1dCBoYXMgbm9cbiAqIGVsZW1lbnRzLlxuICpcbiAqIEBzZWUge0BsaW5rIGZpcnN0fVxuICogQHNlZSB7QGxpbmsgbGFzdH1cbiAqIEBzZWUge0BsaW5rIHNpbmdsZX1cbiAqXG4gKiBAY2xhc3MgRW1wdHlFcnJvclxuICovXG52YXIgRW1wdHlFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEVtcHR5RXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRW1wdHlFcnJvcigpIHtcbiAgICAgICAgdmFyIGVyciA9IF9zdXBlci5jYWxsKHRoaXMsICdubyBlbGVtZW50cyBpbiBzZXF1ZW5jZScpO1xuICAgICAgICB0aGlzLm5hbWUgPSBlcnIubmFtZSA9ICdFbXB0eUVycm9yJztcbiAgICAgICAgdGhpcy5zdGFjayA9IGVyci5zdGFjaztcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gICAgfVxuICAgIHJldHVybiBFbXB0eUVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5FbXB0eUVycm9yID0gRW1wdHlFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVtcHR5RXJyb3IuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvdXRpbC9FbXB0eUVycm9yLmpzXG4vLyBtb2R1bGUgaWQgPSAyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xuLyoqXG4gKiBBbiBlcnJvciB0aHJvd24gd2hlbiBhbiBhY3Rpb24gaXMgaW52YWxpZCBiZWNhdXNlIHRoZSBvYmplY3QgaGFzIGJlZW5cbiAqIHVuc3Vic2NyaWJlZC5cbiAqXG4gKiBAc2VlIHtAbGluayBTdWJqZWN0fVxuICogQHNlZSB7QGxpbmsgQmVoYXZpb3JTdWJqZWN0fVxuICpcbiAqIEBjbGFzcyBPYmplY3RVbnN1YnNjcmliZWRFcnJvclxuICovXG52YXIgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhPYmplY3RVbnN1YnNjcmliZWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBPYmplY3RVbnN1YnNjcmliZWRFcnJvcigpIHtcbiAgICAgICAgdmFyIGVyciA9IF9zdXBlci5jYWxsKHRoaXMsICdvYmplY3QgdW5zdWJzY3JpYmVkJyk7XG4gICAgICAgIHRoaXMubmFtZSA9IGVyci5uYW1lID0gJ09iamVjdFVuc3Vic2NyaWJlZEVycm9yJztcbiAgICAgICAgdGhpcy5zdGFjayA9IGVyci5zdGFjaztcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3RVbnN1YnNjcmliZWRFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IgPSBPYmplY3RVbnN1YnNjcmliZWRFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9iamVjdFVuc3Vic2NyaWJlZEVycm9yLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL3V0aWwvT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IuanNcbi8vIG1vZHVsZSBpZCA9IDI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gaXNEYXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRGF0ZSAmJiAhaXNOYU4oK3ZhbHVlKTtcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNEYXRlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL3V0aWwvaXNEYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGlzRnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc0Z1bmN0aW9uLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL3V0aWwvaXNGdW5jdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgaXNBcnJheV8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc0FycmF5Jyk7XG5mdW5jdGlvbiBpc051bWVyaWModmFsKSB7XG4gICAgLy8gcGFyc2VGbG9hdCBOYU5zIG51bWVyaWMtY2FzdCBmYWxzZSBwb3NpdGl2ZXMgKG51bGx8dHJ1ZXxmYWxzZXxcIlwiKVxuICAgIC8vIC4uLmJ1dCBtaXNpbnRlcnByZXRzIGxlYWRpbmctbnVtYmVyIHN0cmluZ3MsIHBhcnRpY3VsYXJseSBoZXggbGl0ZXJhbHMgKFwiMHguLi5cIilcbiAgICAvLyBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cbiAgICAvLyBhZGRpbmcgMSBjb3JyZWN0cyBsb3NzIG9mIHByZWNpc2lvbiBmcm9tIHBhcnNlRmxvYXQgKCMxNTEwMClcbiAgICByZXR1cm4gIWlzQXJyYXlfMS5pc0FycmF5KHZhbCkgJiYgKHZhbCAtIHBhcnNlRmxvYXQodmFsKSArIDEpID49IDA7XG59XG5leHBvcnRzLmlzTnVtZXJpYyA9IGlzTnVtZXJpYztcbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzTnVtZXJpYy5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy91dGlsL2lzTnVtZXJpYy5qc1xuLy8gbW9kdWxlIGlkID0gMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJqZWN0XzEgPSByZXF1aXJlKCcuL1N1YmplY3QnKTtcbnZhciBxdWV1ZV8xID0gcmVxdWlyZSgnLi9zY2hlZHVsZXIvcXVldWUnKTtcbnZhciBTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4vU3Vic2NyaXB0aW9uJyk7XG52YXIgb2JzZXJ2ZU9uXzEgPSByZXF1aXJlKCcuL29wZXJhdG9yL29ic2VydmVPbicpO1xudmFyIE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXzEgPSByZXF1aXJlKCcuL3V0aWwvT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3InKTtcbnZhciBTdWJqZWN0U3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuL1N1YmplY3RTdWJzY3JpcHRpb24nKTtcbi8qKlxuICogQGNsYXNzIFJlcGxheVN1YmplY3Q8VD5cbiAqL1xudmFyIFJlcGxheVN1YmplY3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZXBsYXlTdWJqZWN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlcGxheVN1YmplY3QoYnVmZmVyU2l6ZSwgd2luZG93VGltZSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIGlmIChidWZmZXJTaXplID09PSB2b2lkIDApIHsgYnVmZmVyU2l6ZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTsgfVxuICAgICAgICBpZiAod2luZG93VGltZSA9PT0gdm9pZCAwKSB7IHdpbmRvd1RpbWUgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7IH1cbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5fYnVmZmVyU2l6ZSA9IGJ1ZmZlclNpemUgPCAxID8gMSA6IGJ1ZmZlclNpemU7XG4gICAgICAgIHRoaXMuX3dpbmRvd1RpbWUgPSB3aW5kb3dUaW1lIDwgMSA/IDEgOiB3aW5kb3dUaW1lO1xuICAgIH1cbiAgICBSZXBsYXlTdWJqZWN0LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBub3cgPSB0aGlzLl9nZXROb3coKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzLnB1c2gobmV3IFJlcGxheUV2ZW50KG5vdywgdmFsdWUpKTtcbiAgICAgICAgdGhpcy5fdHJpbUJ1ZmZlclRoZW5HZXRFdmVudHMoKTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZXh0LmNhbGwodGhpcywgdmFsdWUpO1xuICAgIH07XG4gICAgUmVwbGF5U3ViamVjdC5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBfZXZlbnRzID0gdGhpcy5fdHJpbUJ1ZmZlclRoZW5HZXRFdmVudHMoKTtcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uO1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xLk9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5oYXNFcnJvcikge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0gU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uLkVNUFRZO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24gPSBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVycy5wdXNoKHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0gbmV3IFN1YmplY3RTdWJzY3JpcHRpb25fMS5TdWJqZWN0U3Vic2NyaXB0aW9uKHRoaXMsIHN1YnNjcmliZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlZHVsZXIpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuYWRkKHN1YnNjcmliZXIgPSBuZXcgb2JzZXJ2ZU9uXzEuT2JzZXJ2ZU9uU3Vic2NyaWJlcihzdWJzY3JpYmVyLCBzY2hlZHVsZXIpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuID0gX2V2ZW50cy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuICYmICFzdWJzY3JpYmVyLmNsb3NlZDsgaSsrKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQoX2V2ZW50c1tpXS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGFzRXJyb3IpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IodGhpcy50aHJvd25FcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgIH07XG4gICAgUmVwbGF5U3ViamVjdC5wcm90b3R5cGUuX2dldE5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnNjaGVkdWxlciB8fCBxdWV1ZV8xLnF1ZXVlKS5ub3coKTtcbiAgICB9O1xuICAgIFJlcGxheVN1YmplY3QucHJvdG90eXBlLl90cmltQnVmZmVyVGhlbkdldEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5vdyA9IHRoaXMuX2dldE5vdygpO1xuICAgICAgICB2YXIgX2J1ZmZlclNpemUgPSB0aGlzLl9idWZmZXJTaXplO1xuICAgICAgICB2YXIgX3dpbmRvd1RpbWUgPSB0aGlzLl93aW5kb3dUaW1lO1xuICAgICAgICB2YXIgX2V2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgICAgdmFyIGV2ZW50c0NvdW50ID0gX2V2ZW50cy5sZW5ndGg7XG4gICAgICAgIHZhciBzcGxpY2VDb3VudCA9IDA7XG4gICAgICAgIC8vIFRyaW0gZXZlbnRzIHRoYXQgZmFsbCBvdXQgb2YgdGhlIHRpbWUgd2luZG93LlxuICAgICAgICAvLyBTdGFydCBhdCB0aGUgZnJvbnQgb2YgdGhlIGxpc3QuIEJyZWFrIGVhcmx5IG9uY2VcbiAgICAgICAgLy8gd2UgZW5jb3VudGVyIGFuIGV2ZW50IHRoYXQgZmFsbHMgd2l0aGluIHRoZSB3aW5kb3cuXG4gICAgICAgIHdoaWxlIChzcGxpY2VDb3VudCA8IGV2ZW50c0NvdW50KSB7XG4gICAgICAgICAgICBpZiAoKG5vdyAtIF9ldmVudHNbc3BsaWNlQ291bnRdLnRpbWUpIDwgX3dpbmRvd1RpbWUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNwbGljZUNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50c0NvdW50ID4gX2J1ZmZlclNpemUpIHtcbiAgICAgICAgICAgIHNwbGljZUNvdW50ID0gTWF0aC5tYXgoc3BsaWNlQ291bnQsIGV2ZW50c0NvdW50IC0gX2J1ZmZlclNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzcGxpY2VDb3VudCA+IDApIHtcbiAgICAgICAgICAgIF9ldmVudHMuc3BsaWNlKDAsIHNwbGljZUNvdW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2V2ZW50cztcbiAgICB9O1xuICAgIHJldHVybiBSZXBsYXlTdWJqZWN0O1xufShTdWJqZWN0XzEuU3ViamVjdCkpO1xuZXhwb3J0cy5SZXBsYXlTdWJqZWN0ID0gUmVwbGF5U3ViamVjdDtcbnZhciBSZXBsYXlFdmVudCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVwbGF5RXZlbnQodGltZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy50aW1lID0gdGltZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gUmVwbGF5RXZlbnQ7XG59KCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVwbGF5U3ViamVjdC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9SZXBsYXlTdWJqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG52YXIgU2NhbGFyT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNjYWxhck9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2NhbGFyT2JzZXJ2YWJsZSh2YWx1ZSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLl9pc1NjYWxhciA9IHRydWU7XG4gICAgICAgIGlmIChzY2hlZHVsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzU2NhbGFyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgU2NhbGFyT2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAodmFsdWUsIHNjaGVkdWxlcikge1xuICAgICAgICByZXR1cm4gbmV3IFNjYWxhck9ic2VydmFibGUodmFsdWUsIHNjaGVkdWxlcik7XG4gICAgfTtcbiAgICBTY2FsYXJPYnNlcnZhYmxlLmRpc3BhdGNoID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHZhciBkb25lID0gc3RhdGUuZG9uZSwgdmFsdWUgPSBzdGF0ZS52YWx1ZSwgc3Vic2NyaWJlciA9IHN0YXRlLnN1YnNjcmliZXI7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3Vic2NyaWJlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgaWYgKHN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZG9uZSA9IHRydWU7XG4gICAgICAgIHRoaXMuc2NoZWR1bGUoc3RhdGUpO1xuICAgIH07XG4gICAgU2NhbGFyT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIHZhciBzY2hlZHVsZXIgPSB0aGlzLnNjaGVkdWxlcjtcbiAgICAgICAgaWYgKHNjaGVkdWxlcikge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShTY2FsYXJPYnNlcnZhYmxlLmRpc3BhdGNoLCAwLCB7XG4gICAgICAgICAgICAgICAgZG9uZTogZmFsc2UsIHZhbHVlOiB2YWx1ZSwgc3Vic2NyaWJlcjogc3Vic2NyaWJlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQodmFsdWUpO1xuICAgICAgICAgICAgaWYgKCFzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFNjYWxhck9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLlNjYWxhck9ic2VydmFibGUgPSBTY2FsYXJPYnNlcnZhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2NhbGFyT2JzZXJ2YWJsZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vYnNlcnZhYmxlL1NjYWxhck9ic2VydmFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgQXJyYXlPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9vYnNlcnZhYmxlL0FycmF5T2JzZXJ2YWJsZScpO1xudmFyIGlzQXJyYXlfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNBcnJheScpO1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbnZhciBub25lID0ge307XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBDb21iaW5lcyBtdWx0aXBsZSBPYnNlcnZhYmxlcyB0byBjcmVhdGUgYW4gT2JzZXJ2YWJsZSB3aG9zZSB2YWx1ZXMgYXJlXG4gKiBjYWxjdWxhdGVkIGZyb20gdGhlIGxhdGVzdCB2YWx1ZXMgb2YgZWFjaCBvZiBpdHMgaW5wdXQgT2JzZXJ2YWJsZXMuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPldoZW5ldmVyIGFueSBpbnB1dCBPYnNlcnZhYmxlIGVtaXRzIGEgdmFsdWUsIGl0XG4gKiBjb21wdXRlcyBhIGZvcm11bGEgdXNpbmcgdGhlIGxhdGVzdCB2YWx1ZXMgZnJvbSBhbGwgdGhlIGlucHV0cywgdGhlbiBlbWl0c1xuICogdGhlIG91dHB1dCBvZiB0aGF0IGZvcm11bGEuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvY29tYmluZUxhdGVzdC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgY29tYmluZUxhdGVzdGAgY29tYmluZXMgdGhlIHZhbHVlcyBmcm9tIHRoaXMgT2JzZXJ2YWJsZSB3aXRoIHZhbHVlcyBmcm9tXG4gKiBPYnNlcnZhYmxlcyBwYXNzZWQgYXMgYXJndW1lbnRzLiBUaGlzIGlzIGRvbmUgYnkgc3Vic2NyaWJpbmcgdG8gZWFjaFxuICogT2JzZXJ2YWJsZSwgaW4gb3JkZXIsIGFuZCBjb2xsZWN0aW5nIGFuIGFycmF5IG9mIGVhY2ggb2YgdGhlIG1vc3QgcmVjZW50XG4gKiB2YWx1ZXMgYW55IHRpbWUgYW55IG9mIHRoZSBpbnB1dCBPYnNlcnZhYmxlcyBlbWl0cywgdGhlbiBlaXRoZXIgdGFraW5nIHRoYXRcbiAqIGFycmF5IGFuZCBwYXNzaW5nIGl0IGFzIGFyZ3VtZW50cyB0byBhbiBvcHRpb25hbCBgcHJvamVjdGAgZnVuY3Rpb24gYW5kXG4gKiBlbWl0dGluZyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoYXQsIG9yIGp1c3QgZW1pdHRpbmcgdGhlIGFycmF5IG9mIHJlY2VudFxuICogdmFsdWVzIGRpcmVjdGx5IGlmIHRoZXJlIGlzIG5vIGBwcm9qZWN0YCBmdW5jdGlvbi5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5EeW5hbWljYWxseSBjYWxjdWxhdGUgdGhlIEJvZHktTWFzcyBJbmRleCBmcm9tIGFuIE9ic2VydmFibGUgb2Ygd2VpZ2h0IGFuZCBvbmUgZm9yIGhlaWdodDwvY2FwdGlvbj5cbiAqIHZhciB3ZWlnaHQgPSBSeC5PYnNlcnZhYmxlLm9mKDcwLCA3MiwgNzYsIDc5LCA3NSk7XG4gKiB2YXIgaGVpZ2h0ID0gUnguT2JzZXJ2YWJsZS5vZigxLjc2LCAxLjc3LCAxLjc4KTtcbiAqIHZhciBibWkgPSB3ZWlnaHQuY29tYmluZUxhdGVzdChoZWlnaHQsICh3LCBoKSA9PiB3IC8gKGggKiBoKSk7XG4gKiBibWkuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coJ0JNSSBpcyAnICsgeCkpO1xuICpcbiAqIC8vIFdpdGggb3V0cHV0IHRvIGNvbnNvbGU6XG4gKiAvLyBCTUkgaXMgMjQuMjEyMjkzMzg4NDI5NzUzXG4gKiAvLyBCTUkgaXMgMjMuOTM5NDgwOTkyMDUyMDlcbiAqIC8vIEJNSSBpcyAyMy42NzEyNTM2Mjk1OTIyMjJcbiAqXG4gKiBAc2VlIHtAbGluayBjb21iaW5lQWxsfVxuICogQHNlZSB7QGxpbmsgbWVyZ2V9XG4gKiBAc2VlIHtAbGluayB3aXRoTGF0ZXN0RnJvbX1cbiAqXG4gKiBAcGFyYW0ge09ic2VydmFibGVJbnB1dH0gb3RoZXIgQW4gaW5wdXQgT2JzZXJ2YWJsZSB0byBjb21iaW5lIHdpdGggdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZS4gTW9yZSB0aGFuIG9uZSBpbnB1dCBPYnNlcnZhYmxlcyBtYXkgYmUgZ2l2ZW4gYXMgYXJndW1lbnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbcHJvamVjdF0gQW4gb3B0aW9uYWwgZnVuY3Rpb24gdG8gcHJvamVjdCB0aGUgdmFsdWVzIGZyb21cbiAqIHRoZSBjb21iaW5lZCBsYXRlc3QgdmFsdWVzIGludG8gYSBuZXcgdmFsdWUgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSBvZiBwcm9qZWN0ZWQgdmFsdWVzIGZyb20gdGhlIG1vc3QgcmVjZW50XG4gKiB2YWx1ZXMgZnJvbSBlYWNoIGlucHV0IE9ic2VydmFibGUsIG9yIGFuIGFycmF5IG9mIHRoZSBtb3N0IHJlY2VudCB2YWx1ZXMgZnJvbVxuICogZWFjaCBpbnB1dCBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCBjb21iaW5lTGF0ZXN0XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBjb21iaW5lTGF0ZXN0KCkge1xuICAgIHZhciBvYnNlcnZhYmxlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG9ic2VydmFibGVzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgcHJvamVjdCA9IG51bGw7XG4gICAgaWYgKHR5cGVvZiBvYnNlcnZhYmxlc1tvYnNlcnZhYmxlcy5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcm9qZWN0ID0gb2JzZXJ2YWJsZXMucG9wKCk7XG4gICAgfVxuICAgIC8vIGlmIHRoZSBmaXJzdCBhbmQgb25seSBvdGhlciBhcmd1bWVudCBiZXNpZGVzIHRoZSByZXN1bHRTZWxlY3RvciBpcyBhbiBhcnJheVxuICAgIC8vIGFzc3VtZSBpdCdzIGJlZW4gY2FsbGVkIHdpdGggYGNvbWJpbmVMYXRlc3QoW29iczEsIG9iczIsIG9iczNdLCBwcm9qZWN0KWBcbiAgICBpZiAob2JzZXJ2YWJsZXMubGVuZ3RoID09PSAxICYmIGlzQXJyYXlfMS5pc0FycmF5KG9ic2VydmFibGVzWzBdKSkge1xuICAgICAgICBvYnNlcnZhYmxlcyA9IG9ic2VydmFibGVzWzBdLnNsaWNlKCk7XG4gICAgfVxuICAgIG9ic2VydmFibGVzLnVuc2hpZnQodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMubGlmdC5jYWxsKG5ldyBBcnJheU9ic2VydmFibGVfMS5BcnJheU9ic2VydmFibGUob2JzZXJ2YWJsZXMpLCBuZXcgQ29tYmluZUxhdGVzdE9wZXJhdG9yKHByb2plY3QpKTtcbn1cbmV4cG9ydHMuY29tYmluZUxhdGVzdCA9IGNvbWJpbmVMYXRlc3Q7XG52YXIgQ29tYmluZUxhdGVzdE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb21iaW5lTGF0ZXN0T3BlcmF0b3IocHJvamVjdCkge1xuICAgICAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgIH1cbiAgICBDb21iaW5lTGF0ZXN0T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBDb21iaW5lTGF0ZXN0U3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByb2plY3QpKTtcbiAgICB9O1xuICAgIHJldHVybiBDb21iaW5lTGF0ZXN0T3BlcmF0b3I7XG59KCkpO1xuZXhwb3J0cy5Db21iaW5lTGF0ZXN0T3BlcmF0b3IgPSBDb21iaW5lTGF0ZXN0T3BlcmF0b3I7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIENvbWJpbmVMYXRlc3RTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29tYmluZUxhdGVzdFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29tYmluZUxhdGVzdFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByb2plY3QpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IDA7XG4gICAgICAgIHRoaXMudmFsdWVzID0gW107XG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZXMgPSBbXTtcbiAgICB9XG4gICAgQ29tYmluZUxhdGVzdFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKG9ic2VydmFibGUpIHtcbiAgICAgICAgdGhpcy52YWx1ZXMucHVzaChub25lKTtcbiAgICAgICAgdGhpcy5vYnNlcnZhYmxlcy5wdXNoKG9ic2VydmFibGUpO1xuICAgIH07XG4gICAgQ29tYmluZUxhdGVzdFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9ic2VydmFibGVzID0gdGhpcy5vYnNlcnZhYmxlcztcbiAgICAgICAgdmFyIGxlbiA9IG9ic2VydmFibGVzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBsZW47XG4gICAgICAgICAgICB0aGlzLnRvUmVzcG9uZCA9IGxlbjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgb2JzZXJ2YWJsZSA9IG9ic2VydmFibGVzW2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgb2JzZXJ2YWJsZSwgb2JzZXJ2YWJsZSwgaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDb21iaW5lTGF0ZXN0U3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAodW51c2VkKSB7XG4gICAgICAgIGlmICgodGhpcy5hY3RpdmUgLT0gMSkgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29tYmluZUxhdGVzdFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuICAgICAgICB2YXIgb2xkVmFsID0gdmFsdWVzW291dGVySW5kZXhdO1xuICAgICAgICB2YXIgdG9SZXNwb25kID0gIXRoaXMudG9SZXNwb25kXG4gICAgICAgICAgICA/IDBcbiAgICAgICAgICAgIDogb2xkVmFsID09PSBub25lID8gLS10aGlzLnRvUmVzcG9uZCA6IHRoaXMudG9SZXNwb25kO1xuICAgICAgICB2YWx1ZXNbb3V0ZXJJbmRleF0gPSBpbm5lclZhbHVlO1xuICAgICAgICBpZiAodG9SZXNwb25kID09PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9qZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJ5UHJvamVjdCh2YWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlcy5zbGljZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29tYmluZUxhdGVzdFN1YnNjcmliZXIucHJvdG90eXBlLl90cnlQcm9qZWN0ID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wcm9qZWN0LmFwcGx5KHRoaXMsIHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChyZXN1bHQpO1xuICAgIH07XG4gICAgcmV0dXJuIENvbWJpbmVMYXRlc3RTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbmV4cG9ydHMuQ29tYmluZUxhdGVzdFN1YnNjcmliZXIgPSBDb21iaW5lTGF0ZXN0U3Vic2NyaWJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbWJpbmVMYXRlc3QuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3IvY29tYmluZUxhdGVzdC5qc1xuLy8gbW9kdWxlIGlkID0gMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIGlzU2NoZWR1bGVyXzEgPSByZXF1aXJlKCcuLi91dGlsL2lzU2NoZWR1bGVyJyk7XG52YXIgQXJyYXlPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9vYnNlcnZhYmxlL0FycmF5T2JzZXJ2YWJsZScpO1xudmFyIG1lcmdlQWxsXzEgPSByZXF1aXJlKCcuL21lcmdlQWxsJyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBDcmVhdGVzIGFuIG91dHB1dCBPYnNlcnZhYmxlIHdoaWNoIHNlcXVlbnRpYWxseSBlbWl0cyBhbGwgdmFsdWVzIGZyb20gZXZlcnlcbiAqIGdpdmVuIGlucHV0IE9ic2VydmFibGUgYWZ0ZXIgdGhlIGN1cnJlbnQgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+Q29uY2F0ZW5hdGVzIG11bHRpcGxlIE9ic2VydmFibGVzIHRvZ2V0aGVyIGJ5XG4gKiBzZXF1ZW50aWFsbHkgZW1pdHRpbmcgdGhlaXIgdmFsdWVzLCBvbmUgT2JzZXJ2YWJsZSBhZnRlciB0aGUgb3RoZXIuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvY29uY2F0LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEpvaW5zIHRoaXMgT2JzZXJ2YWJsZSB3aXRoIG11bHRpcGxlIG90aGVyIE9ic2VydmFibGVzIGJ5IHN1YnNjcmliaW5nIHRvIHRoZW1cbiAqIG9uZSBhdCBhIHRpbWUsIHN0YXJ0aW5nIHdpdGggdGhlIHNvdXJjZSwgYW5kIG1lcmdpbmcgdGhlaXIgcmVzdWx0cyBpbnRvIHRoZVxuICogb3V0cHV0IE9ic2VydmFibGUuIFdpbGwgd2FpdCBmb3IgZWFjaCBPYnNlcnZhYmxlIHRvIGNvbXBsZXRlIGJlZm9yZSBtb3ZpbmdcbiAqIG9uIHRvIHRoZSBuZXh0LlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNvbmNhdGVuYXRlIGEgdGltZXIgY291bnRpbmcgZnJvbSAwIHRvIDMgd2l0aCBhIHN5bmNocm9ub3VzIHNlcXVlbmNlIGZyb20gMSB0byAxMDwvY2FwdGlvbj5cbiAqIHZhciB0aW1lciA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkudGFrZSg0KTtcbiAqIHZhciBzZXF1ZW5jZSA9IFJ4Lk9ic2VydmFibGUucmFuZ2UoMSwgMTApO1xuICogdmFyIHJlc3VsdCA9IHRpbWVyLmNvbmNhdChzZXF1ZW5jZSk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIC8vIHJlc3VsdHMgaW46XG4gKiAvLyAxMDAwbXMtPiAwIC0xMDAwbXMtPiAxIC0xMDAwbXMtPiAyIC0xMDAwbXMtPiAzIC1pbW1lZGlhdGUtPiAxIC4uLiAxMFxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNvbmNhdGVuYXRlIDMgT2JzZXJ2YWJsZXM8L2NhcHRpb24+XG4gKiB2YXIgdGltZXIxID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKS50YWtlKDEwKTtcbiAqIHZhciB0aW1lcjIgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDIwMDApLnRha2UoNik7XG4gKiB2YXIgdGltZXIzID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCg1MDApLnRha2UoMTApO1xuICogdmFyIHJlc3VsdCA9IHRpbWVyMS5jb25jYXQodGltZXIyLCB0aW1lcjMpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyByZXN1bHRzIGluIHRoZSBmb2xsb3dpbmc6XG4gKiAvLyAoUHJpbnRzIHRvIGNvbnNvbGUgc2VxdWVudGlhbGx5KVxuICogLy8gLTEwMDBtcy0+IDAgLTEwMDBtcy0+IDEgLTEwMDBtcy0+IC4uLiA5XG4gKiAvLyAtMjAwMG1zLT4gMCAtMjAwMG1zLT4gMSAtMjAwMG1zLT4gLi4uIDVcbiAqIC8vIC01MDBtcy0+IDAgLTUwMG1zLT4gMSAtNTAwbXMtPiAuLi4gOVxuICpcbiAqIEBzZWUge0BsaW5rIGNvbmNhdEFsbH1cbiAqIEBzZWUge0BsaW5rIGNvbmNhdE1hcH1cbiAqIEBzZWUge0BsaW5rIGNvbmNhdE1hcFRvfVxuICpcbiAqIEBwYXJhbSB7T2JzZXJ2YWJsZUlucHV0fSBvdGhlciBBbiBpbnB1dCBPYnNlcnZhYmxlIHRvIGNvbmNhdGVuYXRlIGFmdGVyIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUuIE1vcmUgdGhhbiBvbmUgaW5wdXQgT2JzZXJ2YWJsZXMgbWF5IGJlIGdpdmVuIGFzIGFyZ3VtZW50LlxuICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9bnVsbF0gQW4gb3B0aW9uYWwgSVNjaGVkdWxlciB0byBzY2hlZHVsZSBlYWNoXG4gKiBPYnNlcnZhYmxlIHN1YnNjcmlwdGlvbiBvbi5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFsbCB2YWx1ZXMgb2YgZWFjaCBwYXNzZWQgT2JzZXJ2YWJsZSBtZXJnZWQgaW50byBhXG4gKiBzaW5nbGUgT2JzZXJ2YWJsZSwgaW4gb3JkZXIsIGluIHNlcmlhbCBmYXNoaW9uLlxuICogQG1ldGhvZCBjb25jYXRcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdCgpIHtcbiAgICB2YXIgb2JzZXJ2YWJsZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBvYnNlcnZhYmxlc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGlmdC5jYWxsKGNvbmNhdFN0YXRpYy5hcHBseSh2b2lkIDAsIFt0aGlzXS5jb25jYXQob2JzZXJ2YWJsZXMpKSk7XG59XG5leHBvcnRzLmNvbmNhdCA9IGNvbmNhdDtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIENyZWF0ZXMgYW4gb3V0cHV0IE9ic2VydmFibGUgd2hpY2ggc2VxdWVudGlhbGx5IGVtaXRzIGFsbCB2YWx1ZXMgZnJvbSBnaXZlblxuICogT2JzZXJ2YWJsZSBhbmQgdGhlbiBtb3ZlcyBvbiB0byB0aGUgbmV4dC5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+Q29uY2F0ZW5hdGVzIG11bHRpcGxlIE9ic2VydmFibGVzIHRvZ2V0aGVyIGJ5XG4gKiBzZXF1ZW50aWFsbHkgZW1pdHRpbmcgdGhlaXIgdmFsdWVzLCBvbmUgT2JzZXJ2YWJsZSBhZnRlciB0aGUgb3RoZXIuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvY29uY2F0LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBjb25jYXRgIGpvaW5zIG11bHRpcGxlIE9ic2VydmFibGVzIHRvZ2V0aGVyLCBieSBzdWJzY3JpYmluZyB0byB0aGVtIG9uZSBhdCBhIHRpbWUgYW5kXG4gKiBtZXJnaW5nIHRoZWlyIHJlc3VsdHMgaW50byB0aGUgb3V0cHV0IE9ic2VydmFibGUuIFlvdSBjYW4gcGFzcyBlaXRoZXIgYW4gYXJyYXkgb2ZcbiAqIE9ic2VydmFibGVzLCBvciBwdXQgdGhlbSBkaXJlY3RseSBhcyBhcmd1bWVudHMuIFBhc3NpbmcgYW4gZW1wdHkgYXJyYXkgd2lsbCByZXN1bHRcbiAqIGluIE9ic2VydmFibGUgdGhhdCBjb21wbGV0ZXMgaW1tZWRpYXRlbHkuXG4gKlxuICogYGNvbmNhdGAgd2lsbCBzdWJzY3JpYmUgdG8gZmlyc3QgaW5wdXQgT2JzZXJ2YWJsZSBhbmQgZW1pdCBhbGwgaXRzIHZhbHVlcywgd2l0aG91dFxuICogY2hhbmdpbmcgb3IgYWZmZWN0aW5nIHRoZW0gaW4gYW55IHdheS4gV2hlbiB0aGF0IE9ic2VydmFibGUgY29tcGxldGVzLCBpdCB3aWxsXG4gKiBzdWJzY3JpYmUgdG8gdGhlbiBuZXh0IE9ic2VydmFibGUgcGFzc2VkIGFuZCwgYWdhaW4sIGVtaXQgaXRzIHZhbHVlcy4gVGhpcyB3aWxsIGJlXG4gKiByZXBlYXRlZCwgdW50aWwgdGhlIG9wZXJhdG9yIHJ1bnMgb3V0IG9mIE9ic2VydmFibGVzLiBXaGVuIGxhc3QgaW5wdXQgT2JzZXJ2YWJsZSBjb21wbGV0ZXMsXG4gKiBgY29uY2F0YCB3aWxsIGNvbXBsZXRlIGFzIHdlbGwuIEF0IGFueSBnaXZlbiBtb21lbnQgb25seSBvbmUgT2JzZXJ2YWJsZSBwYXNzZWQgdG8gb3BlcmF0b3JcbiAqIGVtaXRzIHZhbHVlcy4gSWYgeW91IHdvdWxkIGxpa2UgdG8gZW1pdCB2YWx1ZXMgZnJvbSBwYXNzZWQgT2JzZXJ2YWJsZXMgY29uY3VycmVudGx5LCBjaGVjayBvdXRcbiAqIHtAbGluayBtZXJnZX0gaW5zdGVhZCwgZXNwZWNpYWxseSB3aXRoIG9wdGlvbmFsIGBjb25jdXJyZW50YCBwYXJhbWV0ZXIuIEFzIGEgbWF0dGVyIG9mIGZhY3QsXG4gKiBgY29uY2F0YCBpcyBhbiBlcXVpdmFsZW50IG9mIGBtZXJnZWAgb3BlcmF0b3Igd2l0aCBgY29uY3VycmVudGAgcGFyYW1ldGVyIHNldCB0byBgMWAuXG4gKlxuICogTm90ZSB0aGF0IGlmIHNvbWUgaW5wdXQgT2JzZXJ2YWJsZSBuZXZlciBjb21wbGV0ZXMsIGBjb25jYXRgIHdpbGwgYWxzbyBuZXZlciBjb21wbGV0ZVxuICogYW5kIE9ic2VydmFibGVzIGZvbGxvd2luZyB0aGUgb25lIHRoYXQgZGlkIG5vdCBjb21wbGV0ZSB3aWxsIG5ldmVyIGJlIHN1YnNjcmliZWQuIE9uIHRoZSBvdGhlclxuICogaGFuZCwgaWYgc29tZSBPYnNlcnZhYmxlIHNpbXBseSBjb21wbGV0ZXMgaW1tZWRpYXRlbHkgYWZ0ZXIgaXQgaXMgc3Vic2NyaWJlZCwgaXQgd2lsbCBiZVxuICogaW52aXNpYmxlIGZvciBgY29uY2F0YCwgd2hpY2ggd2lsbCBqdXN0IG1vdmUgb24gdG8gdGhlIG5leHQgT2JzZXJ2YWJsZS5cbiAqXG4gKiBJZiBhbnkgT2JzZXJ2YWJsZSBpbiBjaGFpbiBlcnJvcnMsIGluc3RlYWQgb2YgcGFzc2luZyBjb250cm9sIHRvIHRoZSBuZXh0IE9ic2VydmFibGUsXG4gKiBgY29uY2F0YCB3aWxsIGVycm9yIGltbWVkaWF0ZWx5IGFzIHdlbGwuIE9ic2VydmFibGVzIHRoYXQgd291bGQgYmUgc3Vic2NyaWJlZCBhZnRlclxuICogdGhlIG9uZSB0aGF0IGVtaXR0ZWQgZXJyb3IsIG5ldmVyIHdpbGwuXG4gKlxuICogSWYgeW91IHBhc3MgdG8gYGNvbmNhdGAgdGhlIHNhbWUgT2JzZXJ2YWJsZSBtYW55IHRpbWVzLCBpdHMgc3RyZWFtIG9mIHZhbHVlc1xuICogd2lsbCBiZSBcInJlcGxheWVkXCIgb24gZXZlcnkgc3Vic2NyaXB0aW9uLCB3aGljaCBtZWFucyB5b3UgY2FuIHJlcGVhdCBnaXZlbiBPYnNlcnZhYmxlXG4gKiBhcyBtYW55IHRpbWVzIGFzIHlvdSBsaWtlLiBJZiBwYXNzaW5nIHRoZSBzYW1lIE9ic2VydmFibGUgdG8gYGNvbmNhdGAgMTAwMCB0aW1lcyBiZWNvbWVzIHRlZGlvdXMsXG4gKiB5b3UgY2FuIGFsd2F5cyB1c2Uge0BsaW5rIHJlcGVhdH0uXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q29uY2F0ZW5hdGUgYSB0aW1lciBjb3VudGluZyBmcm9tIDAgdG8gMyB3aXRoIGEgc3luY2hyb25vdXMgc2VxdWVuY2UgZnJvbSAxIHRvIDEwPC9jYXB0aW9uPlxuICogdmFyIHRpbWVyID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKS50YWtlKDQpO1xuICogdmFyIHNlcXVlbmNlID0gUnguT2JzZXJ2YWJsZS5yYW5nZSgxLCAxMCk7XG4gKiB2YXIgcmVzdWx0ID0gUnguT2JzZXJ2YWJsZS5jb25jYXQodGltZXIsIHNlcXVlbmNlKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gcmVzdWx0cyBpbjpcbiAqIC8vIDAgLTEwMDBtcy0+IDEgLTEwMDBtcy0+IDIgLTEwMDBtcy0+IDMgLWltbWVkaWF0ZS0+IDEgLi4uIDEwXG4gKlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNvbmNhdGVuYXRlIGFuIGFycmF5IG9mIDMgT2JzZXJ2YWJsZXM8L2NhcHRpb24+XG4gKiB2YXIgdGltZXIxID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKS50YWtlKDEwKTtcbiAqIHZhciB0aW1lcjIgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDIwMDApLnRha2UoNik7XG4gKiB2YXIgdGltZXIzID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCg1MDApLnRha2UoMTApO1xuICogdmFyIHJlc3VsdCA9IFJ4Lk9ic2VydmFibGUuY29uY2F0KFt0aW1lcjEsIHRpbWVyMiwgdGltZXIzXSk7IC8vIG5vdGUgdGhhdCBhcnJheSBpcyBwYXNzZWRcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gcmVzdWx0cyBpbiB0aGUgZm9sbG93aW5nOlxuICogLy8gKFByaW50cyB0byBjb25zb2xlIHNlcXVlbnRpYWxseSlcbiAqIC8vIC0xMDAwbXMtPiAwIC0xMDAwbXMtPiAxIC0xMDAwbXMtPiAuLi4gOVxuICogLy8gLTIwMDBtcy0+IDAgLTIwMDBtcy0+IDEgLTIwMDBtcy0+IC4uLiA1XG4gKiAvLyAtNTAwbXMtPiAwIC01MDBtcy0+IDEgLTUwMG1zLT4gLi4uIDlcbiAqXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q29uY2F0ZW5hdGUgdGhlIHNhbWUgT2JzZXJ2YWJsZSB0byByZXBlYXQgaXQ8L2NhcHRpb24+XG4gKiBjb25zdCB0aW1lciA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkudGFrZSgyKTtcbiAqXG4gKiBSeC5PYnNlcnZhYmxlLmNvbmNhdCh0aW1lciwgdGltZXIpIC8vIGNvbmNhdGluZyB0aGUgc2FtZSBPYnNlcnZhYmxlIVxuICogLnN1YnNjcmliZShcbiAqICAgdmFsdWUgPT4gY29uc29sZS5sb2codmFsdWUpLFxuICogICBlcnIgPT4ge30sXG4gKiAgICgpID0+IGNvbnNvbGUubG9nKCcuLi5hbmQgaXQgaXMgZG9uZSEnKVxuICogKTtcbiAqXG4gKiAvLyBMb2dzOlxuICogLy8gMCBhZnRlciAxc1xuICogLy8gMSBhZnRlciAyc1xuICogLy8gMCBhZnRlciAzc1xuICogLy8gMSBhZnRlciA0c1xuICogLy8gXCIuLi5hbmQgaXQgaXMgZG9uZSFcIiBhbHNvIGFmdGVyIDRzXG4gKlxuICogQHNlZSB7QGxpbmsgY29uY2F0QWxsfVxuICogQHNlZSB7QGxpbmsgY29uY2F0TWFwfVxuICogQHNlZSB7QGxpbmsgY29uY2F0TWFwVG99XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlSW5wdXR9IGlucHV0MSBBbiBpbnB1dCBPYnNlcnZhYmxlIHRvIGNvbmNhdGVuYXRlIHdpdGggb3RoZXJzLlxuICogQHBhcmFtIHtPYnNlcnZhYmxlSW5wdXR9IGlucHV0MiBBbiBpbnB1dCBPYnNlcnZhYmxlIHRvIGNvbmNhdGVuYXRlIHdpdGggb3RoZXJzLlxuICogTW9yZSB0aGFuIG9uZSBpbnB1dCBPYnNlcnZhYmxlcyBtYXkgYmUgZ2l2ZW4gYXMgYXJndW1lbnQuXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcj1udWxsXSBBbiBvcHRpb25hbCBJU2NoZWR1bGVyIHRvIHNjaGVkdWxlIGVhY2hcbiAqIE9ic2VydmFibGUgc3Vic2NyaXB0aW9uIG9uLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQWxsIHZhbHVlcyBvZiBlYWNoIHBhc3NlZCBPYnNlcnZhYmxlIG1lcmdlZCBpbnRvIGFcbiAqIHNpbmdsZSBPYnNlcnZhYmxlLCBpbiBvcmRlciwgaW4gc2VyaWFsIGZhc2hpb24uXG4gKiBAc3RhdGljIHRydWVcbiAqIEBuYW1lIGNvbmNhdFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gY29uY2F0U3RhdGljKCkge1xuICAgIHZhciBvYnNlcnZhYmxlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG9ic2VydmFibGVzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgc2NoZWR1bGVyID0gbnVsbDtcbiAgICB2YXIgYXJncyA9IG9ic2VydmFibGVzO1xuICAgIGlmIChpc1NjaGVkdWxlcl8xLmlzU2NoZWR1bGVyKGFyZ3Nbb2JzZXJ2YWJsZXMubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgIHNjaGVkdWxlciA9IGFyZ3MucG9wKCk7XG4gICAgfVxuICAgIGlmIChzY2hlZHVsZXIgPT09IG51bGwgJiYgb2JzZXJ2YWJsZXMubGVuZ3RoID09PSAxICYmIG9ic2VydmFibGVzWzBdIGluc3RhbmNlb2YgT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpIHtcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGVzWzBdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEFycmF5T2JzZXJ2YWJsZV8xLkFycmF5T2JzZXJ2YWJsZShvYnNlcnZhYmxlcywgc2NoZWR1bGVyKS5saWZ0KG5ldyBtZXJnZUFsbF8xLk1lcmdlQWxsT3BlcmF0b3IoMSkpO1xufVxuZXhwb3J0cy5jb25jYXRTdGF0aWMgPSBjb25jYXRTdGF0aWM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25jYXQuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3IvY29uY2F0LmpzXG4vLyBtb2R1bGUgaWQgPSAzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbi8qKlxuICogQXBwbGllcyBhIGdpdmVuIGBwcm9qZWN0YCBmdW5jdGlvbiB0byBlYWNoIHZhbHVlIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSwgYW5kIGVtaXRzIHRoZSByZXN1bHRpbmcgdmFsdWVzIGFzIGFuIE9ic2VydmFibGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkxpa2UgW0FycmF5LnByb3RvdHlwZS5tYXAoKV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvbWFwKSxcbiAqIGl0IHBhc3NlcyBlYWNoIHNvdXJjZSB2YWx1ZSB0aHJvdWdoIGEgdHJhbnNmb3JtYXRpb24gZnVuY3Rpb24gdG8gZ2V0XG4gKiBjb3JyZXNwb25kaW5nIG91dHB1dCB2YWx1ZXMuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvbWFwLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFNpbWlsYXIgdG8gdGhlIHdlbGwga25vd24gYEFycmF5LnByb3RvdHlwZS5tYXBgIGZ1bmN0aW9uLCB0aGlzIG9wZXJhdG9yXG4gKiBhcHBsaWVzIGEgcHJvamVjdGlvbiB0byBlYWNoIHZhbHVlIGFuZCBlbWl0cyB0aGF0IHByb2plY3Rpb24gaW4gdGhlIG91dHB1dFxuICogT2JzZXJ2YWJsZS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5NYXAgZXZlcnkgZXZlcnkgY2xpY2sgdG8gdGhlIGNsaWVudFggcG9zaXRpb24gb2YgdGhhdCBjbGljazwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcG9zaXRpb25zID0gY2xpY2tzLm1hcChldiA9PiBldi5jbGllbnRYKTtcbiAqIHBvc2l0aW9ucy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgbWFwVG99XG4gKiBAc2VlIHtAbGluayBwbHVja31cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCBpbmRleDogbnVtYmVyKTogUn0gcHJvamVjdCBUaGUgZnVuY3Rpb24gdG8gYXBwbHlcbiAqIHRvIGVhY2ggYHZhbHVlYCBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS4gVGhlIGBpbmRleGAgcGFyYW1ldGVyIGlzXG4gKiB0aGUgbnVtYmVyIGBpYCBmb3IgdGhlIGktdGggZW1pc3Npb24gdGhhdCBoYXMgaGFwcGVuZWQgc2luY2UgdGhlXG4gKiBzdWJzY3JpcHRpb24sIHN0YXJ0aW5nIGZyb20gdGhlIG51bWJlciBgMGAuXG4gKiBAcGFyYW0ge2FueX0gW3RoaXNBcmddIEFuIG9wdGlvbmFsIGFyZ3VtZW50IHRvIGRlZmluZSB3aGF0IGB0aGlzYCBpcyBpbiB0aGVcbiAqIGBwcm9qZWN0YCBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8Uj59IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgdmFsdWVzIGZyb20gdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSB0cmFuc2Zvcm1lZCBieSB0aGUgZ2l2ZW4gYHByb2plY3RgIGZ1bmN0aW9uLlxuICogQG1ldGhvZCBtYXBcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIG1hcChwcm9qZWN0LCB0aGlzQXJnKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9qZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IGlzIG5vdCBhIGZ1bmN0aW9uLiBBcmUgeW91IGxvb2tpbmcgZm9yIGBtYXBUbygpYD8nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgTWFwT3BlcmF0b3IocHJvamVjdCwgdGhpc0FyZykpO1xufVxuZXhwb3J0cy5tYXAgPSBtYXA7XG52YXIgTWFwT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hcE9wZXJhdG9yKHByb2plY3QsIHRoaXNBcmcpIHtcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgICAgICAgdGhpcy50aGlzQXJnID0gdGhpc0FyZztcbiAgICB9XG4gICAgTWFwT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBNYXBTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMucHJvamVjdCwgdGhpcy50aGlzQXJnKSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWFwT3BlcmF0b3I7XG59KCkpO1xuZXhwb3J0cy5NYXBPcGVyYXRvciA9IE1hcE9wZXJhdG9yO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBNYXBTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFwU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYXBTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBwcm9qZWN0LCB0aGlzQXJnKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgICAgIHRoaXMudGhpc0FyZyA9IHRoaXNBcmcgfHwgdGhpcztcbiAgICB9XG4gICAgLy8gTk9URTogVGhpcyBsb29rcyB1bm9wdGltaXplZCwgYnV0IGl0J3MgYWN0dWFsbHkgcHVycG9zZWZ1bGx5IE5PVFxuICAgIC8vIHVzaW5nIHRyeS9jYXRjaCBvcHRpbWl6YXRpb25zLlxuICAgIE1hcFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnByb2plY3QuY2FsbCh0aGlzLnRoaXNBcmcsIHZhbHVlLCB0aGlzLmNvdW50KyspO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQocmVzdWx0KTtcbiAgICB9O1xuICAgIHJldHVybiBNYXBTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFwLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9yL21hcC5qc1xuLy8gbW9kdWxlIGlkID0gMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgTm90aWZpY2F0aW9uXzEgPSByZXF1aXJlKCcuLi9Ob3RpZmljYXRpb24nKTtcbi8qKlxuICogQHNlZSB7QGxpbmsgTm90aWZpY2F0aW9ufVxuICpcbiAqIEBwYXJhbSBzY2hlZHVsZXJcbiAqIEBwYXJhbSBkZWxheVxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxSPnxXZWJTb2NrZXRTdWJqZWN0PFQ+fE9ic2VydmFibGU8VD59XG4gKiBAbWV0aG9kIG9ic2VydmVPblxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gb2JzZXJ2ZU9uKHNjaGVkdWxlciwgZGVsYXkpIHtcbiAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBPYnNlcnZlT25PcGVyYXRvcihzY2hlZHVsZXIsIGRlbGF5KSk7XG59XG5leHBvcnRzLm9ic2VydmVPbiA9IG9ic2VydmVPbjtcbnZhciBPYnNlcnZlT25PcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT2JzZXJ2ZU9uT3BlcmF0b3Ioc2NoZWR1bGVyLCBkZWxheSkge1xuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIHRoaXMuZGVsYXkgPSBkZWxheTtcbiAgICB9XG4gICAgT2JzZXJ2ZU9uT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBPYnNlcnZlT25TdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuc2NoZWR1bGVyLCB0aGlzLmRlbGF5KSk7XG4gICAgfTtcbiAgICByZXR1cm4gT2JzZXJ2ZU9uT3BlcmF0b3I7XG59KCkpO1xuZXhwb3J0cy5PYnNlcnZlT25PcGVyYXRvciA9IE9ic2VydmVPbk9wZXJhdG9yO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBPYnNlcnZlT25TdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoT2JzZXJ2ZU9uU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBPYnNlcnZlT25TdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBzY2hlZHVsZXIsIGRlbGF5KSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLmRlbGF5ID0gZGVsYXk7XG4gICAgfVxuICAgIE9ic2VydmVPblN1YnNjcmliZXIuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHZhciBub3RpZmljYXRpb24gPSBhcmcubm90aWZpY2F0aW9uLCBkZXN0aW5hdGlvbiA9IGFyZy5kZXN0aW5hdGlvbjtcbiAgICAgICAgbm90aWZpY2F0aW9uLm9ic2VydmUoZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgICBPYnNlcnZlT25TdWJzY3JpYmVyLnByb3RvdHlwZS5zY2hlZHVsZU1lc3NhZ2UgPSBmdW5jdGlvbiAobm90aWZpY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuYWRkKHRoaXMuc2NoZWR1bGVyLnNjaGVkdWxlKE9ic2VydmVPblN1YnNjcmliZXIuZGlzcGF0Y2gsIHRoaXMuZGVsYXksIG5ldyBPYnNlcnZlT25NZXNzYWdlKG5vdGlmaWNhdGlvbiwgdGhpcy5kZXN0aW5hdGlvbikpKTtcbiAgICB9O1xuICAgIE9ic2VydmVPblN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVNZXNzYWdlKE5vdGlmaWNhdGlvbl8xLk5vdGlmaWNhdGlvbi5jcmVhdGVOZXh0KHZhbHVlKSk7XG4gICAgfTtcbiAgICBPYnNlcnZlT25TdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVNZXNzYWdlKE5vdGlmaWNhdGlvbl8xLk5vdGlmaWNhdGlvbi5jcmVhdGVFcnJvcihlcnIpKTtcbiAgICB9O1xuICAgIE9ic2VydmVPblN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZU1lc3NhZ2UoTm90aWZpY2F0aW9uXzEuTm90aWZpY2F0aW9uLmNyZWF0ZUNvbXBsZXRlKCkpO1xuICAgIH07XG4gICAgcmV0dXJuIE9ic2VydmVPblN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5leHBvcnRzLk9ic2VydmVPblN1YnNjcmliZXIgPSBPYnNlcnZlT25TdWJzY3JpYmVyO1xudmFyIE9ic2VydmVPbk1lc3NhZ2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9ic2VydmVPbk1lc3NhZ2Uobm90aWZpY2F0aW9uLCBkZXN0aW5hdGlvbikge1xuICAgICAgICB0aGlzLm5vdGlmaWNhdGlvbiA9IG5vdGlmaWNhdGlvbjtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gT2JzZXJ2ZU9uTWVzc2FnZTtcbn0oKSk7XG5leHBvcnRzLk9ic2VydmVPbk1lc3NhZ2UgPSBPYnNlcnZlT25NZXNzYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JzZXJ2ZU9uLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9yL29ic2VydmVPbi5qc1xuLy8gbW9kdWxlIGlkID0gMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBBcHBsaWVzIGFuIGFjY3VtdWxhdG9yIGZ1bmN0aW9uIG92ZXIgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCBhbmQgcmV0dXJucyB0aGVcbiAqIGFjY3VtdWxhdGVkIHJlc3VsdCB3aGVuIHRoZSBzb3VyY2UgY29tcGxldGVzLCBnaXZlbiBhbiBvcHRpb25hbCBzZWVkIHZhbHVlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5Db21iaW5lcyB0b2dldGhlciBhbGwgdmFsdWVzIGVtaXR0ZWQgb24gdGhlIHNvdXJjZSxcbiAqIHVzaW5nIGFuIGFjY3VtdWxhdG9yIGZ1bmN0aW9uIHRoYXQga25vd3MgaG93IHRvIGpvaW4gYSBuZXcgc291cmNlIHZhbHVlIGludG9cbiAqIHRoZSBhY2N1bXVsYXRpb24gZnJvbSB0aGUgcGFzdC48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9yZWR1Y2UucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogTGlrZVxuICogW0FycmF5LnByb3RvdHlwZS5yZWR1Y2UoKV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvcmVkdWNlKSxcbiAqIGByZWR1Y2VgIGFwcGxpZXMgYW4gYGFjY3VtdWxhdG9yYCBmdW5jdGlvbiBhZ2FpbnN0IGFuIGFjY3VtdWxhdGlvbiBhbmQgZWFjaFxuICogdmFsdWUgb2YgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIChmcm9tIHRoZSBwYXN0KSB0byByZWR1Y2UgaXQgdG8gYSBzaW5nbGVcbiAqIHZhbHVlLCBlbWl0dGVkIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS4gTm90ZSB0aGF0IGByZWR1Y2VgIHdpbGwgb25seSBlbWl0XG4gKiBvbmUgdmFsdWUsIG9ubHkgd2hlbiB0aGUgc291cmNlIE9ic2VydmFibGUgY29tcGxldGVzLiBJdCBpcyBlcXVpdmFsZW50IHRvXG4gKiBhcHBseWluZyBvcGVyYXRvciB7QGxpbmsgc2Nhbn0gZm9sbG93ZWQgYnkgb3BlcmF0b3Ige0BsaW5rIGxhc3R9LlxuICpcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGFwcGxpZXMgYSBzcGVjaWZpZWQgYGFjY3VtdWxhdG9yYCBmdW5jdGlvbiB0byBlYWNoXG4gKiBpdGVtIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiBJZiBhIGBzZWVkYCB2YWx1ZSBpcyBzcGVjaWZpZWQsIHRoZW5cbiAqIHRoYXQgdmFsdWUgd2lsbCBiZSB1c2VkIGFzIHRoZSBpbml0aWFsIHZhbHVlIGZvciB0aGUgYWNjdW11bGF0b3IuIElmIG5vIHNlZWRcbiAqIHZhbHVlIGlzIHNwZWNpZmllZCwgdGhlIGZpcnN0IGl0ZW0gb2YgdGhlIHNvdXJjZSBpcyB1c2VkIGFzIHRoZSBzZWVkLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNvdW50IHRoZSBudW1iZXIgb2YgY2xpY2sgZXZlbnRzIHRoYXQgaGFwcGVuZWQgaW4gNSBzZWNvbmRzPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrc0luRml2ZVNlY29uZHMgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJylcbiAqICAgLnRha2VVbnRpbChSeC5PYnNlcnZhYmxlLmludGVydmFsKDUwMDApKTtcbiAqIHZhciBvbmVzID0gY2xpY2tzSW5GaXZlU2Vjb25kcy5tYXBUbygxKTtcbiAqIHZhciBzZWVkID0gMDtcbiAqIHZhciBjb3VudCA9IG9uZXMucmVkdWNlKChhY2MsIG9uZSkgPT4gYWNjICsgb25lLCBzZWVkKTtcbiAqIGNvdW50LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBjb3VudH1cbiAqIEBzZWUge0BsaW5rIGV4cGFuZH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlU2Nhbn1cbiAqIEBzZWUge0BsaW5rIHNjYW59XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbihhY2M6IFIsIHZhbHVlOiBULCBpbmRleDogbnVtYmVyKTogUn0gYWNjdW11bGF0b3IgVGhlIGFjY3VtdWxhdG9yIGZ1bmN0aW9uXG4gKiBjYWxsZWQgb24gZWFjaCBzb3VyY2UgdmFsdWUuXG4gKiBAcGFyYW0ge1J9IFtzZWVkXSBUaGUgaW5pdGlhbCBhY2N1bXVsYXRpb24gdmFsdWUuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFI+fSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgYSBzaW5nbGUgdmFsdWUgdGhhdCBpcyB0aGVcbiAqIHJlc3VsdCBvZiBhY2N1bXVsYXRpbmcgdGhlIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEBtZXRob2QgcmVkdWNlXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiByZWR1Y2UoYWNjdW11bGF0b3IsIHNlZWQpIHtcbiAgICB2YXIgaGFzU2VlZCA9IGZhbHNlO1xuICAgIC8vIHByb3ZpZGluZyBhIHNlZWQgb2YgYHVuZGVmaW5lZGAgKnNob3VsZCogYmUgdmFsaWQgYW5kIHRyaWdnZXJcbiAgICAvLyBoYXNTZWVkISBzbyBkb24ndCB1c2UgYHNlZWQgIT09IHVuZGVmaW5lZGAgY2hlY2tzIVxuICAgIC8vIEZvciB0aGlzIHJlYXNvbiwgd2UgaGF2ZSB0byBjaGVjayBpdCBoZXJlIGF0IHRoZSBvcmlnaW5hbCBjYWxsIHNpdGVcbiAgICAvLyBvdGhlcndpc2UgaW5zaWRlIE9wZXJhdG9yL1N1YnNjcmliZXIgd2Ugd29uJ3Qga25vdyBpZiBgdW5kZWZpbmVkYFxuICAgIC8vIG1lYW5zIHRoZXkgZGlkbid0IHByb3ZpZGUgYW55dGhpbmcgb3IgaWYgdGhleSBsaXRlcmFsbHkgcHJvdmlkZWQgYHVuZGVmaW5lZGBcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgIGhhc1NlZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBSZWR1Y2VPcGVyYXRvcihhY2N1bXVsYXRvciwgc2VlZCwgaGFzU2VlZCkpO1xufVxuZXhwb3J0cy5yZWR1Y2UgPSByZWR1Y2U7XG52YXIgUmVkdWNlT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlZHVjZU9wZXJhdG9yKGFjY3VtdWxhdG9yLCBzZWVkLCBoYXNTZWVkKSB7XG4gICAgICAgIGlmIChoYXNTZWVkID09PSB2b2lkIDApIHsgaGFzU2VlZCA9IGZhbHNlOyB9XG4gICAgICAgIHRoaXMuYWNjdW11bGF0b3IgPSBhY2N1bXVsYXRvcjtcbiAgICAgICAgdGhpcy5zZWVkID0gc2VlZDtcbiAgICAgICAgdGhpcy5oYXNTZWVkID0gaGFzU2VlZDtcbiAgICB9XG4gICAgUmVkdWNlT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBSZWR1Y2VTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuYWNjdW11bGF0b3IsIHRoaXMuc2VlZCwgdGhpcy5oYXNTZWVkKSk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVkdWNlT3BlcmF0b3I7XG59KCkpO1xuZXhwb3J0cy5SZWR1Y2VPcGVyYXRvciA9IFJlZHVjZU9wZXJhdG9yO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBSZWR1Y2VTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVkdWNlU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZWR1Y2VTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBhY2N1bXVsYXRvciwgc2VlZCwgaGFzU2VlZCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuYWNjdW11bGF0b3IgPSBhY2N1bXVsYXRvcjtcbiAgICAgICAgdGhpcy5oYXNTZWVkID0gaGFzU2VlZDtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIHRoaXMuaGFzVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hY2MgPSBzZWVkO1xuICAgICAgICBpZiAoIXRoaXMuaGFzU2VlZCkge1xuICAgICAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIFJlZHVjZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc1ZhbHVlIHx8ICh0aGlzLmhhc1ZhbHVlID0gdGhpcy5oYXNTZWVkKSkge1xuICAgICAgICAgICAgdGhpcy5fdHJ5UmVkdWNlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWNjID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmhhc1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVkdWNlU3Vic2NyaWJlci5wcm90b3R5cGUuX3RyeVJlZHVjZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5hY2N1bXVsYXRvcih0aGlzLmFjYywgdmFsdWUsIHRoaXMuaW5kZXgrKyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWNjID0gcmVzdWx0O1xuICAgIH07XG4gICAgUmVkdWNlU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5oYXNWYWx1ZSB8fCB0aGlzLmhhc1NlZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh0aGlzLmFjYyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlZHVjZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5leHBvcnRzLlJlZHVjZVN1YnNjcmliZXIgPSBSZWR1Y2VTdWJzY3JpYmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVkdWNlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9yL3JlZHVjZS5qc1xuLy8gbW9kdWxlIGlkID0gMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBBcnJheU9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL29ic2VydmFibGUvQXJyYXlPYnNlcnZhYmxlJyk7XG52YXIgaXNBcnJheV8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc0FycmF5Jyk7XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbnZhciBpdGVyYXRvcl8xID0gcmVxdWlyZSgnLi4vc3ltYm9sL2l0ZXJhdG9yJyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBAcGFyYW0gb2JzZXJ2YWJsZXNcbiAqIEByZXR1cm4ge09ic2VydmFibGU8Uj59XG4gKiBAbWV0aG9kIHppcFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gemlwUHJvdG8oKSB7XG4gICAgdmFyIG9ic2VydmFibGVzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgb2JzZXJ2YWJsZXNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxpZnQuY2FsbCh6aXBTdGF0aWMuYXBwbHkodm9pZCAwLCBbdGhpc10uY29uY2F0KG9ic2VydmFibGVzKSkpO1xufVxuZXhwb3J0cy56aXBQcm90byA9IHppcFByb3RvO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogQ29tYmluZXMgbXVsdGlwbGUgT2JzZXJ2YWJsZXMgdG8gY3JlYXRlIGFuIE9ic2VydmFibGUgd2hvc2UgdmFsdWVzIGFyZSBjYWxjdWxhdGVkIGZyb20gdGhlIHZhbHVlcywgaW4gb3JkZXIsIG9mIGVhY2hcbiAqIG9mIGl0cyBpbnB1dCBPYnNlcnZhYmxlcy5cbiAqXG4gKiBJZiB0aGUgbGF0ZXN0IHBhcmFtZXRlciBpcyBhIGZ1bmN0aW9uLCB0aGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gY29tcHV0ZSB0aGUgY3JlYXRlZCB2YWx1ZSBmcm9tIHRoZSBpbnB1dCB2YWx1ZXMuXG4gKiBPdGhlcndpc2UsIGFuIGFycmF5IG9mIHRoZSBpbnB1dCB2YWx1ZXMgaXMgcmV0dXJuZWQuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q29tYmluZSBhZ2UgYW5kIG5hbWUgZnJvbSBkaWZmZXJlbnQgc291cmNlczwvY2FwdGlvbj5cbiAqXG4gKiBsZXQgYWdlJCA9IE9ic2VydmFibGUub2Y8bnVtYmVyPigyNywgMjUsIDI5KTtcbiAqIGxldCBuYW1lJCA9IE9ic2VydmFibGUub2Y8c3RyaW5nPignRm9vJywgJ0JhcicsICdCZWVyJyk7XG4gKiBsZXQgaXNEZXYkID0gT2JzZXJ2YWJsZS5vZjxib29sZWFuPih0cnVlLCB0cnVlLCBmYWxzZSk7XG4gKlxuICogT2JzZXJ2YWJsZVxuICogICAgIC56aXAoYWdlJCxcbiAqICAgICAgICAgIG5hbWUkLFxuICogICAgICAgICAgaXNEZXYkLFxuICogICAgICAgICAgKGFnZTogbnVtYmVyLCBuYW1lOiBzdHJpbmcsIGlzRGV2OiBib29sZWFuKSA9PiAoeyBhZ2UsIG5hbWUsIGlzRGV2IH0pKVxuICogICAgIC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gb3V0cHV0c1xuICogLy8geyBhZ2U6IDI3LCBuYW1lOiAnRm9vJywgaXNEZXY6IHRydWUgfVxuICogLy8geyBhZ2U6IDI1LCBuYW1lOiAnQmFyJywgaXNEZXY6IHRydWUgfVxuICogLy8geyBhZ2U6IDI5LCBuYW1lOiAnQmVlcicsIGlzRGV2OiBmYWxzZSB9XG4gKlxuICogQHBhcmFtIG9ic2VydmFibGVzXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFI+fVxuICogQHN0YXRpYyB0cnVlXG4gKiBAbmFtZSB6aXBcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHppcFN0YXRpYygpIHtcbiAgICB2YXIgb2JzZXJ2YWJsZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBvYnNlcnZhYmxlc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIHByb2plY3QgPSBvYnNlcnZhYmxlc1tvYnNlcnZhYmxlcy5sZW5ndGggLSAxXTtcbiAgICBpZiAodHlwZW9mIHByb2plY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb2JzZXJ2YWJsZXMucG9wKCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQXJyYXlPYnNlcnZhYmxlXzEuQXJyYXlPYnNlcnZhYmxlKG9ic2VydmFibGVzKS5saWZ0KG5ldyBaaXBPcGVyYXRvcihwcm9qZWN0KSk7XG59XG5leHBvcnRzLnppcFN0YXRpYyA9IHppcFN0YXRpYztcbnZhciBaaXBPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gWmlwT3BlcmF0b3IocHJvamVjdCkge1xuICAgICAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgIH1cbiAgICBaaXBPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFppcFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5wcm9qZWN0KSk7XG4gICAgfTtcbiAgICByZXR1cm4gWmlwT3BlcmF0b3I7XG59KCkpO1xuZXhwb3J0cy5aaXBPcGVyYXRvciA9IFppcE9wZXJhdG9yO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBaaXBTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWmlwU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBaaXBTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBwcm9qZWN0LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHZhbHVlcyA9PT0gdm9pZCAwKSB7IHZhbHVlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7IH1cbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLml0ZXJhdG9ycyA9IFtdO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IDA7XG4gICAgICAgIHRoaXMucHJvamVjdCA9ICh0eXBlb2YgcHJvamVjdCA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9qZWN0IDogbnVsbDtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgfVxuICAgIFppcFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBpdGVyYXRvcnMgPSB0aGlzLml0ZXJhdG9ycztcbiAgICAgICAgaWYgKGlzQXJyYXlfMS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgaXRlcmF0b3JzLnB1c2gobmV3IFN0YXRpY0FycmF5SXRlcmF0b3IodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWVbaXRlcmF0b3JfMS4kJGl0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaXRlcmF0b3JzLnB1c2gobmV3IFN0YXRpY0l0ZXJhdG9yKHZhbHVlW2l0ZXJhdG9yXzEuJCRpdGVyYXRvcl0oKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaXRlcmF0b3JzLnB1c2gobmV3IFppcEJ1ZmZlckl0ZXJhdG9yKHRoaXMuZGVzdGluYXRpb24sIHRoaXMsIHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFppcFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9ycyA9IHRoaXMuaXRlcmF0b3JzO1xuICAgICAgICB2YXIgbGVuID0gaXRlcmF0b3JzLmxlbmd0aDtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBsZW47XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yc1tpXTtcbiAgICAgICAgICAgIGlmIChpdGVyYXRvci5zdGlsbFVuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKGl0ZXJhdG9yLnN1YnNjcmliZShpdGVyYXRvciwgaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmUtLTsgLy8gbm90IGFuIG9ic2VydmFibGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgWmlwU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5SW5hY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlLS07XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBaaXBTdWJzY3JpYmVyLnByb3RvdHlwZS5jaGVja0l0ZXJhdG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9ycyA9IHRoaXMuaXRlcmF0b3JzO1xuICAgICAgICB2YXIgbGVuID0gaXRlcmF0b3JzLmxlbmd0aDtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgLy8gYWJvcnQgaWYgbm90IGFsbCBvZiB0aGVtIGhhdmUgdmFsdWVzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yc1tpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3IuaGFzVmFsdWUgPT09ICdmdW5jdGlvbicgJiYgIWl0ZXJhdG9yLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNob3VsZENvbXBsZXRlID0gZmFsc2U7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yc1tpXTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgaXQncyBjb21wbGV0ZWQgbm93IHRoYXQgeW91J3ZlIGdvdHRlblxuICAgICAgICAgICAgLy8gdGhlIG5leHQgdmFsdWUuXG4gICAgICAgICAgICBpZiAoaXRlcmF0b3IuaGFzQ29tcGxldGVkKCkpIHtcbiAgICAgICAgICAgICAgICBzaG91bGRDb21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFyZ3MucHVzaChyZXN1bHQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb2plY3QpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyeVByb2plY3QoYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRDb21wbGV0ZSkge1xuICAgICAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgWmlwU3Vic2NyaWJlci5wcm90b3R5cGUuX3RyeVByb2plY3QgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wcm9qZWN0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQocmVzdWx0KTtcbiAgICB9O1xuICAgIHJldHVybiBaaXBTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuZXhwb3J0cy5aaXBTdWJzY3JpYmVyID0gWmlwU3Vic2NyaWJlcjtcbnZhciBTdGF0aWNJdGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RhdGljSXRlcmF0b3IoaXRlcmF0b3IpIHtcbiAgICAgICAgdGhpcy5pdGVyYXRvciA9IGl0ZXJhdG9yO1xuICAgICAgICB0aGlzLm5leHRSZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgfVxuICAgIFN0YXRpY0l0ZXJhdG9yLnByb3RvdHlwZS5oYXNWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBTdGF0aWNJdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMubmV4dFJlc3VsdDtcbiAgICAgICAgdGhpcy5uZXh0UmVzdWx0ID0gdGhpcy5pdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBTdGF0aWNJdGVyYXRvci5wcm90b3R5cGUuaGFzQ29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV4dFJlc3VsdCA9IHRoaXMubmV4dFJlc3VsdDtcbiAgICAgICAgcmV0dXJuIG5leHRSZXN1bHQgJiYgbmV4dFJlc3VsdC5kb25lO1xuICAgIH07XG4gICAgcmV0dXJuIFN0YXRpY0l0ZXJhdG9yO1xufSgpKTtcbnZhciBTdGF0aWNBcnJheUl0ZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGF0aWNBcnJheUl0ZXJhdG9yKGFycmF5KSB7XG4gICAgICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgfVxuICAgIFN0YXRpY0FycmF5SXRlcmF0b3IucHJvdG90eXBlW2l0ZXJhdG9yXzEuJCRpdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgU3RhdGljQXJyYXlJdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgaSA9IHRoaXMuaW5kZXgrKztcbiAgICAgICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheTtcbiAgICAgICAgcmV0dXJuIGkgPCB0aGlzLmxlbmd0aCA/IHsgdmFsdWU6IGFycmF5W2ldLCBkb25lOiBmYWxzZSB9IDogeyB2YWx1ZTogbnVsbCwgZG9uZTogdHJ1ZSB9O1xuICAgIH07XG4gICAgU3RhdGljQXJyYXlJdGVyYXRvci5wcm90b3R5cGUuaGFzVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFycmF5Lmxlbmd0aCA+IHRoaXMuaW5kZXg7XG4gICAgfTtcbiAgICBTdGF0aWNBcnJheUl0ZXJhdG9yLnByb3RvdHlwZS5oYXNDb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFycmF5Lmxlbmd0aCA9PT0gdGhpcy5pbmRleDtcbiAgICB9O1xuICAgIHJldHVybiBTdGF0aWNBcnJheUl0ZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgWmlwQnVmZmVySXRlcmF0b3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhaaXBCdWZmZXJJdGVyYXRvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBaaXBCdWZmZXJJdGVyYXRvcihkZXN0aW5hdGlvbiwgcGFyZW50LCBvYnNlcnZhYmxlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZSA9IG9ic2VydmFibGU7XG4gICAgICAgIHRoaXMuc3RpbGxVbnN1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLmlzQ29tcGxldGUgPSBmYWxzZTtcbiAgICB9XG4gICAgWmlwQnVmZmVySXRlcmF0b3IucHJvdG90eXBlW2l0ZXJhdG9yXzEuJCRpdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLy8gTk9URTogdGhlcmUgaXMgYWN0dWFsbHkgYSBuYW1lIGNvbGxpc2lvbiBoZXJlIHdpdGggU3Vic2NyaWJlci5uZXh0IGFuZCBJdGVyYXRvci5uZXh0XG4gICAgLy8gICAgdGhpcyBpcyBsZWdpdCBiZWNhdXNlIGBuZXh0KClgIHdpbGwgbmV2ZXIgYmUgY2FsbGVkIGJ5IGEgc3Vic2NyaXB0aW9uIGluIHRoaXMgY2FzZS5cbiAgICBaaXBCdWZmZXJJdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmlzQ29tcGxldGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBudWxsLCBkb25lOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogYnVmZmVyLnNoaWZ0KCksIGRvbmU6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFppcEJ1ZmZlckl0ZXJhdG9yLnByb3RvdHlwZS5oYXNWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLmxlbmd0aCA+IDA7XG4gICAgfTtcbiAgICBaaXBCdWZmZXJJdGVyYXRvci5wcm90b3R5cGUuaGFzQ29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIubGVuZ3RoID09PSAwICYmIHRoaXMuaXNDb21wbGV0ZTtcbiAgICB9O1xuICAgIFppcEJ1ZmZlckl0ZXJhdG9yLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuaXNDb21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5ub3RpZnlJbmFjdGl2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBaaXBCdWZmZXJJdGVyYXRvci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKGlubmVyVmFsdWUpO1xuICAgICAgICB0aGlzLnBhcmVudC5jaGVja0l0ZXJhdG9ycygpO1xuICAgIH07XG4gICAgWmlwQnVmZmVySXRlcmF0b3IucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgdGhpcy5vYnNlcnZhYmxlLCB0aGlzLCBpbmRleCk7XG4gICAgfTtcbiAgICByZXR1cm4gWmlwQnVmZmVySXRlcmF0b3I7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9emlwLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9yL3ppcC5qc1xuLy8gbW9kdWxlIGlkID0gMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cy5hZ2VudCA9ICdwZW5kby1kZXNpZ25lci1hZ2VudCc7XG5leHBvcnRzLmJhY2tncm91bmQgPSAncGVuZG8tZGVzaWduZXItYmFja2dyb3VuZCc7XG5leHBvcnRzLmNvbnRlbnRTY3JpcHQgPSAncGVuZG8tZGVzaWduZXItY29udGVudC1zY3JpcHQnO1xuZXhwb3J0cy5kZXNpZ25lciA9ICdwZW5kby1kZXNpZ25lcic7XG5leHBvcnRzLnBsdWdpbiA9ICdwZW5kby1kZXNpZ25lci1wbHVnaW4nO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGx1Z2lucy9zb3VyY2VzLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJqZWN0XzEgPSByZXF1aXJlKCcuL1N1YmplY3QnKTtcbnZhciBPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xID0gcmVxdWlyZSgnLi91dGlsL09iamVjdFVuc3Vic2NyaWJlZEVycm9yJyk7XG4vKipcbiAqIEBjbGFzcyBCZWhhdmlvclN1YmplY3Q8VD5cbiAqL1xudmFyIEJlaGF2aW9yU3ViamVjdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJlaGF2aW9yU3ViamVjdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCZWhhdmlvclN1YmplY3QoX3ZhbHVlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IF92YWx1ZTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJlaGF2aW9yU3ViamVjdC5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEJlaGF2aW9yU3ViamVjdC5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBfc3VwZXIucHJvdG90eXBlLl9zdWJzY3JpYmUuY2FsbCh0aGlzLCBzdWJzY3JpYmVyKTtcbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvbiAmJiAhc3Vic2NyaXB0aW9uLmNsb3NlZCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHRoaXMuX3ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgIH07XG4gICAgQmVoYXZpb3JTdWJqZWN0LnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMudGhyb3duRXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xLk9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJlaGF2aW9yU3ViamVjdC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5leHQuY2FsbCh0aGlzLCB0aGlzLl92YWx1ZSA9IHZhbHVlKTtcbiAgICB9O1xuICAgIHJldHVybiBCZWhhdmlvclN1YmplY3Q7XG59KFN1YmplY3RfMS5TdWJqZWN0KSk7XG5leHBvcnRzLkJlaGF2aW9yU3ViamVjdCA9IEJlaGF2aW9yU3ViamVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJlaGF2aW9yU3ViamVjdC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9CZWhhdmlvclN1YmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5lbXB0eSA9IHtcbiAgICBjbG9zZWQ6IHRydWUsXG4gICAgbmV4dDogZnVuY3Rpb24gKHZhbHVlKSB7IH0sXG4gICAgZXJyb3I6IGZ1bmN0aW9uIChlcnIpIHsgdGhyb3cgZXJyOyB9LFxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7IH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PYnNlcnZlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9PYnNlcnZlci5qc1xuLy8gbW9kdWxlIGlkID0gMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4vU3Vic2NyaXB0aW9uJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFN1YmplY3RTdWJzY3JpcHRpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdWJqZWN0U3Vic2NyaXB0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN1YmplY3RTdWJzY3JpcHRpb24oc3ViamVjdCwgc3Vic2NyaWJlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5zdWJqZWN0ID0gc3ViamVjdDtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVyID0gc3Vic2NyaWJlcjtcbiAgICAgICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgU3ViamVjdFN1YnNjcmlwdGlvbi5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgdmFyIHN1YmplY3QgPSB0aGlzLnN1YmplY3Q7XG4gICAgICAgIHZhciBvYnNlcnZlcnMgPSBzdWJqZWN0Lm9ic2VydmVycztcbiAgICAgICAgdGhpcy5zdWJqZWN0ID0gbnVsbDtcbiAgICAgICAgaWYgKCFvYnNlcnZlcnMgfHwgb2JzZXJ2ZXJzLmxlbmd0aCA9PT0gMCB8fCBzdWJqZWN0LmlzU3RvcHBlZCB8fCBzdWJqZWN0LmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdWJzY3JpYmVySW5kZXggPSBvYnNlcnZlcnMuaW5kZXhPZih0aGlzLnN1YnNjcmliZXIpO1xuICAgICAgICBpZiAoc3Vic2NyaWJlckluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgb2JzZXJ2ZXJzLnNwbGljZShzdWJzY3JpYmVySW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU3ViamVjdFN1YnNjcmlwdGlvbjtcbn0oU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKSk7XG5leHBvcnRzLlN1YmplY3RTdWJzY3JpcHRpb24gPSBTdWJqZWN0U3Vic2NyaXB0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3ViamVjdFN1YnNjcmlwdGlvbi5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9TdWJqZWN0U3Vic2NyaXB0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YmplY3RfMSA9IHJlcXVpcmUoJy4uL1N1YmplY3QnKTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaXB0aW9uJyk7XG4vKipcbiAqIEBjbGFzcyBDb25uZWN0YWJsZU9ic2VydmFibGU8VD5cbiAqL1xudmFyIENvbm5lY3RhYmxlT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbm5lY3RhYmxlT2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb25uZWN0YWJsZU9ic2VydmFibGUoc291cmNlLCBzdWJqZWN0RmFjdG9yeSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuc3ViamVjdEZhY3RvcnkgPSBzdWJqZWN0RmFjdG9yeTtcbiAgICAgICAgdGhpcy5fcmVmQ291bnQgPSAwO1xuICAgIH1cbiAgICBDb25uZWN0YWJsZU9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdWJqZWN0KCkuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgIH07XG4gICAgQ29ubmVjdGFibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5nZXRTdWJqZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3ViamVjdCA9IHRoaXMuX3N1YmplY3Q7XG4gICAgICAgIGlmICghc3ViamVjdCB8fCBzdWJqZWN0LmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdGhpcy5fc3ViamVjdCA9IHRoaXMuc3ViamVjdEZhY3RvcnkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc3ViamVjdDtcbiAgICB9O1xuICAgIENvbm5lY3RhYmxlT2JzZXJ2YWJsZS5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbm5lY3Rpb24gPSB0aGlzLl9jb25uZWN0aW9uO1xuICAgICAgICBpZiAoIWNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24gPSB0aGlzLl9jb25uZWN0aW9uID0gbmV3IFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbigpO1xuICAgICAgICAgICAgY29ubmVjdGlvbi5hZGQodGhpcy5zb3VyY2VcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKG5ldyBDb25uZWN0YWJsZVN1YnNjcmliZXIodGhpcy5nZXRTdWJqZWN0KCksIHRoaXMpKSk7XG4gICAgICAgICAgICBpZiAoY29ubmVjdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uID0gU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uLkVNUFRZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gICAgfTtcbiAgICBDb25uZWN0YWJsZU9ic2VydmFibGUucHJvdG90eXBlLnJlZkNvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBSZWZDb3VudE9wZXJhdG9yKHRoaXMpKTtcbiAgICB9O1xuICAgIHJldHVybiBDb25uZWN0YWJsZU9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLkNvbm5lY3RhYmxlT2JzZXJ2YWJsZSA9IENvbm5lY3RhYmxlT2JzZXJ2YWJsZTtcbmV4cG9ydHMuY29ubmVjdGFibGVPYnNlcnZhYmxlRGVzY3JpcHRvciA9IHtcbiAgICBvcGVyYXRvcjogeyB2YWx1ZTogbnVsbCB9LFxuICAgIF9yZWZDb3VudDogeyB2YWx1ZTogMCwgd3JpdGFibGU6IHRydWUgfSxcbiAgICBfc3Vic2NyaWJlOiB7IHZhbHVlOiBDb25uZWN0YWJsZU9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgfSxcbiAgICBnZXRTdWJqZWN0OiB7IHZhbHVlOiBDb25uZWN0YWJsZU9ic2VydmFibGUucHJvdG90eXBlLmdldFN1YmplY3QgfSxcbiAgICBjb25uZWN0OiB7IHZhbHVlOiBDb25uZWN0YWJsZU9ic2VydmFibGUucHJvdG90eXBlLmNvbm5lY3QgfSxcbiAgICByZWZDb3VudDogeyB2YWx1ZTogQ29ubmVjdGFibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5yZWZDb3VudCB9XG59O1xudmFyIENvbm5lY3RhYmxlU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbm5lY3RhYmxlU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb25uZWN0YWJsZVN1YnNjcmliZXIoZGVzdGluYXRpb24sIGNvbm5lY3RhYmxlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5jb25uZWN0YWJsZSA9IGNvbm5lY3RhYmxlO1xuICAgIH1cbiAgICBDb25uZWN0YWJsZVN1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fZXJyb3IuY2FsbCh0aGlzLCBlcnIpO1xuICAgIH07XG4gICAgQ29ubmVjdGFibGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlKCk7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuX2NvbXBsZXRlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBDb25uZWN0YWJsZVN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbm5lY3RhYmxlID0gdGhpcy5jb25uZWN0YWJsZTtcbiAgICAgICAgaWYgKGNvbm5lY3RhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RhYmxlID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBjb25uZWN0aW9uID0gY29ubmVjdGFibGUuX2Nvbm5lY3Rpb247XG4gICAgICAgICAgICBjb25uZWN0YWJsZS5fcmVmQ291bnQgPSAwO1xuICAgICAgICAgICAgY29ubmVjdGFibGUuX3N1YmplY3QgPSBudWxsO1xuICAgICAgICAgICAgY29ubmVjdGFibGUuX2Nvbm5lY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDb25uZWN0YWJsZVN1YnNjcmliZXI7XG59KFN1YmplY3RfMS5TdWJqZWN0U3Vic2NyaWJlcikpO1xudmFyIFJlZkNvdW50T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlZkNvdW50T3BlcmF0b3IoY29ubmVjdGFibGUpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0YWJsZSA9IGNvbm5lY3RhYmxlO1xuICAgIH1cbiAgICBSZWZDb3VudE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICB2YXIgY29ubmVjdGFibGUgPSB0aGlzLmNvbm5lY3RhYmxlO1xuICAgICAgICBjb25uZWN0YWJsZS5fcmVmQ291bnQrKztcbiAgICAgICAgdmFyIHJlZkNvdW50ZXIgPSBuZXcgUmVmQ291bnRTdWJzY3JpYmVyKHN1YnNjcmliZXIsIGNvbm5lY3RhYmxlKTtcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHNvdXJjZS5zdWJzY3JpYmUocmVmQ291bnRlcik7XG4gICAgICAgIGlmICghcmVmQ291bnRlci5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJlZkNvdW50ZXIuY29ubmVjdGlvbiA9IGNvbm5lY3RhYmxlLmNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgIH07XG4gICAgcmV0dXJuIFJlZkNvdW50T3BlcmF0b3I7XG59KCkpO1xudmFyIFJlZkNvdW50U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlZkNvdW50U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZWZDb3VudFN1YnNjcmliZXIoZGVzdGluYXRpb24sIGNvbm5lY3RhYmxlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5jb25uZWN0YWJsZSA9IGNvbm5lY3RhYmxlO1xuICAgIH1cbiAgICBSZWZDb3VudFN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbm5lY3RhYmxlID0gdGhpcy5jb25uZWN0YWJsZTtcbiAgICAgICAgaWYgKCFjb25uZWN0YWJsZSkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbm5lY3RhYmxlID0gbnVsbDtcbiAgICAgICAgdmFyIHJlZkNvdW50ID0gY29ubmVjdGFibGUuX3JlZkNvdW50O1xuICAgICAgICBpZiAocmVmQ291bnQgPD0gMCkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0YWJsZS5fcmVmQ291bnQgPSByZWZDb3VudCAtIDE7XG4gICAgICAgIGlmIChyZWZDb3VudCA+IDEpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8vXG4gICAgICAgIC8vIENvbXBhcmUgdGhlIGxvY2FsIFJlZkNvdW50U3Vic2NyaWJlcidzIGNvbm5lY3Rpb24gU3Vic2NyaXB0aW9uIHRvIHRoZVxuICAgICAgICAvLyBjb25uZWN0aW9uIFN1YnNjcmlwdGlvbiBvbiB0aGUgc2hhcmVkIENvbm5lY3RhYmxlT2JzZXJ2YWJsZS4gSW4gY2FzZXNcbiAgICAgICAgLy8gd2hlcmUgdGhlIENvbm5lY3RhYmxlT2JzZXJ2YWJsZSBzb3VyY2Ugc3luY2hyb25vdXNseSBlbWl0cyB2YWx1ZXMsIGFuZFxuICAgICAgICAvLyB0aGUgUmVmQ291bnRTdWJzY3JpYmVyJ3MgZG93bnN0cmVhbSBPYnNlcnZlcnMgc3luY2hyb25vdXNseSB1bnN1YnNjcmliZSxcbiAgICAgICAgLy8gZXhlY3V0aW9uIGNvbnRpbnVlcyB0byBoZXJlIGJlZm9yZSB0aGUgUmVmQ291bnRPcGVyYXRvciBoYXMgYSBjaGFuY2UgdG9cbiAgICAgICAgLy8gc3VwcGx5IHRoZSBSZWZDb3VudFN1YnNjcmliZXIgd2l0aCB0aGUgc2hhcmVkIGNvbm5lY3Rpb24gU3Vic2NyaXB0aW9uLlxuICAgICAgICAvLyBGb3IgZXhhbXBsZTpcbiAgICAgICAgLy8gYGBgXG4gICAgICAgIC8vIE9ic2VydmFibGUucmFuZ2UoMCwgMTApXG4gICAgICAgIC8vICAgLnB1Ymxpc2goKVxuICAgICAgICAvLyAgIC5yZWZDb3VudCgpXG4gICAgICAgIC8vICAgLnRha2UoNSlcbiAgICAgICAgLy8gICAuc3Vic2NyaWJlKCk7XG4gICAgICAgIC8vIGBgYFxuICAgICAgICAvLyBJbiBvcmRlciB0byBhY2NvdW50IGZvciB0aGlzIGNhc2UsIFJlZkNvdW50U3Vic2NyaWJlciBzaG91bGQgb25seSBkaXNwb3NlXG4gICAgICAgIC8vIHRoZSBDb25uZWN0YWJsZU9ic2VydmFibGUncyBzaGFyZWQgY29ubmVjdGlvbiBTdWJzY3JpcHRpb24gaWYgdGhlXG4gICAgICAgIC8vIGNvbm5lY3Rpb24gU3Vic2NyaXB0aW9uIGV4aXN0cywgKmFuZCogZWl0aGVyOlxuICAgICAgICAvLyAgIGEuIFJlZkNvdW50U3Vic2NyaWJlciBkb2Vzbid0IGhhdmUgYSByZWZlcmVuY2UgdG8gdGhlIHNoYXJlZCBjb25uZWN0aW9uXG4gICAgICAgIC8vICAgICAgU3Vic2NyaXB0aW9uIHlldCwgb3IsXG4gICAgICAgIC8vICAgYi4gUmVmQ291bnRTdWJzY3JpYmVyJ3MgY29ubmVjdGlvbiBTdWJzY3JpcHRpb24gcmVmZXJlbmNlIGlzIGlkZW50aWNhbFxuICAgICAgICAvLyAgICAgIHRvIHRoZSBzaGFyZWQgY29ubmVjdGlvbiBTdWJzY3JpcHRpb25cbiAgICAgICAgLy8vXG4gICAgICAgIHZhciBjb25uZWN0aW9uID0gdGhpcy5jb25uZWN0aW9uO1xuICAgICAgICB2YXIgc2hhcmVkQ29ubmVjdGlvbiA9IGNvbm5lY3RhYmxlLl9jb25uZWN0aW9uO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBudWxsO1xuICAgICAgICBpZiAoc2hhcmVkQ29ubmVjdGlvbiAmJiAoIWNvbm5lY3Rpb24gfHwgc2hhcmVkQ29ubmVjdGlvbiA9PT0gY29ubmVjdGlvbikpIHtcbiAgICAgICAgICAgIHNoYXJlZENvbm5lY3Rpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFJlZkNvdW50U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbm5lY3RhYmxlT2JzZXJ2YWJsZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vYnNlcnZhYmxlL0Nvbm5lY3RhYmxlT2JzZXJ2YWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBpc0FycmF5XzEgPSByZXF1aXJlKCcuLi91dGlsL2lzQXJyYXknKTtcbnZhciBpc0FycmF5TGlrZV8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc0FycmF5TGlrZScpO1xudmFyIGlzUHJvbWlzZV8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc1Byb21pc2UnKTtcbnZhciBQcm9taXNlT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9Qcm9taXNlT2JzZXJ2YWJsZScpO1xudmFyIEl0ZXJhdG9yT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9JdGVyYXRvck9ic2VydmFibGUnKTtcbnZhciBBcnJheU9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vQXJyYXlPYnNlcnZhYmxlJyk7XG52YXIgQXJyYXlMaWtlT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9BcnJheUxpa2VPYnNlcnZhYmxlJyk7XG52YXIgaXRlcmF0b3JfMSA9IHJlcXVpcmUoJy4uL3N5bWJvbC9pdGVyYXRvcicpO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciBvYnNlcnZlT25fMSA9IHJlcXVpcmUoJy4uL29wZXJhdG9yL29ic2VydmVPbicpO1xudmFyIG9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL3N5bWJvbC9vYnNlcnZhYmxlJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIEZyb21PYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRnJvbU9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRnJvbU9ic2VydmFibGUoaXNoLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbnVsbCk7XG4gICAgICAgIHRoaXMuaXNoID0gaXNoO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIGZyb20gYW4gQXJyYXksIGFuIGFycmF5LWxpa2Ugb2JqZWN0LCBhIFByb21pc2UsIGFuXG4gICAgICogaXRlcmFibGUgb2JqZWN0LCBvciBhbiBPYnNlcnZhYmxlLWxpa2Ugb2JqZWN0LlxuICAgICAqXG4gICAgICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkNvbnZlcnRzIGFsbW9zdCBhbnl0aGluZyB0byBhbiBPYnNlcnZhYmxlLjwvc3Bhbj5cbiAgICAgKlxuICAgICAqIDxpbWcgc3JjPVwiLi9pbWcvZnJvbS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAgICAgKlxuICAgICAqIENvbnZlcnQgdmFyaW91cyBvdGhlciBvYmplY3RzIGFuZCBkYXRhIHR5cGVzIGludG8gT2JzZXJ2YWJsZXMuIGBmcm9tYFxuICAgICAqIGNvbnZlcnRzIGEgUHJvbWlzZSBvciBhbiBhcnJheS1saWtlIG9yIGFuXG4gICAgICogW2l0ZXJhYmxlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9JdGVyYXRpb25fcHJvdG9jb2xzI2l0ZXJhYmxlKVxuICAgICAqIG9iamVjdCBpbnRvIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgaXRlbXMgaW4gdGhhdCBwcm9taXNlIG9yIGFycmF5IG9yXG4gICAgICogaXRlcmFibGUuIEEgU3RyaW5nLCBpbiB0aGlzIGNvbnRleHQsIGlzIHRyZWF0ZWQgYXMgYW4gYXJyYXkgb2YgY2hhcmFjdGVycy5cbiAgICAgKiBPYnNlcnZhYmxlLWxpa2Ugb2JqZWN0cyAoY29udGFpbnMgYSBmdW5jdGlvbiBuYW1lZCB3aXRoIHRoZSBFUzIwMTUgU3ltYm9sXG4gICAgICogZm9yIE9ic2VydmFibGUpIGNhbiBhbHNvIGJlIGNvbnZlcnRlZCB0aHJvdWdoIHRoaXMgb3BlcmF0b3IuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db252ZXJ0cyBhbiBhcnJheSB0byBhbiBPYnNlcnZhYmxlPC9jYXB0aW9uPlxuICAgICAqIHZhciBhcnJheSA9IFsxMCwgMjAsIDMwXTtcbiAgICAgKiB2YXIgcmVzdWx0ID0gUnguT2JzZXJ2YWJsZS5mcm9tKGFycmF5KTtcbiAgICAgKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICAgICAqXG4gICAgICogLy8gUmVzdWx0cyBpbiB0aGUgZm9sbG93aW5nOlxuICAgICAqIC8vIDEwIDIwIDMwXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db252ZXJ0IGFuIGluZmluaXRlIGl0ZXJhYmxlIChmcm9tIGEgZ2VuZXJhdG9yKSB0byBhbiBPYnNlcnZhYmxlPC9jYXB0aW9uPlxuICAgICAqIGZ1bmN0aW9uKiBnZW5lcmF0ZURvdWJsZXMoc2VlZCkge1xuICAgICAqICAgdmFyIGkgPSBzZWVkO1xuICAgICAqICAgd2hpbGUgKHRydWUpIHtcbiAgICAgKiAgICAgeWllbGQgaTtcbiAgICAgKiAgICAgaSA9IDIgKiBpOyAvLyBkb3VibGUgaXRcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgaXRlcmF0b3IgPSBnZW5lcmF0ZURvdWJsZXMoMyk7XG4gICAgICogdmFyIHJlc3VsdCA9IFJ4Lk9ic2VydmFibGUuZnJvbShpdGVyYXRvcikudGFrZSgxMCk7XG4gICAgICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAgICAgKlxuICAgICAqIC8vIFJlc3VsdHMgaW4gdGhlIGZvbGxvd2luZzpcbiAgICAgKiAvLyAzIDYgMTIgMjQgNDggOTYgMTkyIDM4NCA3NjggMTUzNlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgY3JlYXRlfVxuICAgICAqIEBzZWUge0BsaW5rIGZyb21FdmVudH1cbiAgICAgKiBAc2VlIHtAbGluayBmcm9tRXZlbnRQYXR0ZXJufVxuICAgICAqIEBzZWUge0BsaW5rIGZyb21Qcm9taXNlfVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYnNlcnZhYmxlSW5wdXQ8VD59IGlzaCBBIHN1YnNjcmliYWJsZSBvYmplY3QsIGEgUHJvbWlzZSwgYW5cbiAgICAgKiBPYnNlcnZhYmxlLWxpa2UsIGFuIEFycmF5LCBhbiBpdGVyYWJsZSBvciBhbiBhcnJheS1saWtlIG9iamVjdCB0byBiZVxuICAgICAqIGNvbnZlcnRlZC5cbiAgICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gVGhlIHNjaGVkdWxlciBvbiB3aGljaCB0byBzY2hlZHVsZSB0aGVcbiAgICAgKiBlbWlzc2lvbnMgb2YgdmFsdWVzLlxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IFRoZSBPYnNlcnZhYmxlIHdob3NlIHZhbHVlcyBhcmUgb3JpZ2luYWxseSBmcm9tIHRoZVxuICAgICAqIGlucHV0IG9iamVjdCB0aGF0IHdhcyBjb252ZXJ0ZWQuXG4gICAgICogQHN0YXRpYyB0cnVlXG4gICAgICogQG5hbWUgZnJvbVxuICAgICAqIEBvd25lciBPYnNlcnZhYmxlXG4gICAgICovXG4gICAgRnJvbU9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKGlzaCwgc2NoZWR1bGVyKSB7XG4gICAgICAgIGlmIChpc2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpc2hbb2JzZXJ2YWJsZV8xLiQkb2JzZXJ2YWJsZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNoIGluc3RhbmNlb2YgT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUgJiYgIXNjaGVkdWxlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZyb21PYnNlcnZhYmxlKGlzaCwgc2NoZWR1bGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzQXJyYXlfMS5pc0FycmF5KGlzaCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5T2JzZXJ2YWJsZV8xLkFycmF5T2JzZXJ2YWJsZShpc2gsIHNjaGVkdWxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1Byb21pc2VfMS5pc1Byb21pc2UoaXNoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZU9ic2VydmFibGVfMS5Qcm9taXNlT2JzZXJ2YWJsZShpc2gsIHNjaGVkdWxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgaXNoW2l0ZXJhdG9yXzEuJCRpdGVyYXRvcl0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGlzaCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yT2JzZXJ2YWJsZV8xLkl0ZXJhdG9yT2JzZXJ2YWJsZShpc2gsIHNjaGVkdWxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0FycmF5TGlrZV8xLmlzQXJyYXlMaWtlKGlzaCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5TGlrZU9ic2VydmFibGVfMS5BcnJheUxpa2VPYnNlcnZhYmxlKGlzaCwgc2NoZWR1bGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKChpc2ggIT09IG51bGwgJiYgdHlwZW9mIGlzaCB8fCBpc2gpICsgJyBpcyBub3Qgb2JzZXJ2YWJsZScpO1xuICAgIH07XG4gICAgRnJvbU9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgaXNoID0gdGhpcy5pc2g7XG4gICAgICAgIHZhciBzY2hlZHVsZXIgPSB0aGlzLnNjaGVkdWxlcjtcbiAgICAgICAgaWYgKHNjaGVkdWxlciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNoW29ic2VydmFibGVfMS4kJG9ic2VydmFibGVdKCkuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGlzaFtvYnNlcnZhYmxlXzEuJCRvYnNlcnZhYmxlXSgpLnN1YnNjcmliZShuZXcgb2JzZXJ2ZU9uXzEuT2JzZXJ2ZU9uU3Vic2NyaWJlcihzdWJzY3JpYmVyLCBzY2hlZHVsZXIsIDApKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEZyb21PYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5Gcm9tT2JzZXJ2YWJsZSA9IEZyb21PYnNlcnZhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RnJvbU9ic2VydmFibGUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb2JzZXJ2YWJsZS9Gcm9tT2JzZXJ2YWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciByb290XzEgPSByZXF1aXJlKCcuLi91dGlsL3Jvb3QnKTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIFByb21pc2VPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUHJvbWlzZU9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUHJvbWlzZU9ic2VydmFibGUocHJvbWlzZSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBQcm9taXNlIHRvIGFuIE9ic2VydmFibGUuXG4gICAgICpcbiAgICAgKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+UmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQganVzdCBlbWl0cyB0aGUgUHJvbWlzZSdzXG4gICAgICogcmVzb2x2ZWQgdmFsdWUsIHRoZW4gY29tcGxldGVzLjwvc3Bhbj5cbiAgICAgKlxuICAgICAqIENvbnZlcnRzIGFuIEVTMjAxNSBQcm9taXNlIG9yIGEgUHJvbWlzZXMvQSsgc3BlYyBjb21wbGlhbnQgUHJvbWlzZSB0byBhblxuICAgICAqIE9ic2VydmFibGUuIElmIHRoZSBQcm9taXNlIHJlc29sdmVzIHdpdGggYSB2YWx1ZSwgdGhlIG91dHB1dCBPYnNlcnZhYmxlXG4gICAgICogZW1pdHMgdGhhdCByZXNvbHZlZCB2YWx1ZSBhcyBhIGBuZXh0YCwgYW5kIHRoZW4gY29tcGxldGVzLiBJZiB0aGUgUHJvbWlzZVxuICAgICAqIGlzIHJlamVjdGVkLCB0aGVuIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBlbWl0cyB0aGUgY29ycmVzcG9uZGluZyBFcnJvci5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkNvbnZlcnQgdGhlIFByb21pc2UgcmV0dXJuZWQgYnkgRmV0Y2ggdG8gYW4gT2JzZXJ2YWJsZTwvY2FwdGlvbj5cbiAgICAgKiB2YXIgcmVzdWx0ID0gUnguT2JzZXJ2YWJsZS5mcm9tUHJvbWlzZShmZXRjaCgnaHR0cDovL215c2VydmVyLmNvbS8nKSk7XG4gICAgICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpLCBlID0+IGNvbnNvbGUuZXJyb3IoZSkpO1xuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgYmluZENhbGxiYWNrfVxuICAgICAqIEBzZWUge0BsaW5rIGZyb219XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1Byb21pc2U8VD59IHByb21pc2UgVGhlIHByb21pc2UgdG8gYmUgY29udmVydGVkLlxuICAgICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSBBbiBvcHRpb25hbCBJU2NoZWR1bGVyIHRvIHVzZSBmb3Igc2NoZWR1bGluZ1xuICAgICAqIHRoZSBkZWxpdmVyeSBvZiB0aGUgcmVzb2x2ZWQgdmFsdWUgKG9yIHRoZSByZWplY3Rpb24pLlxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IEFuIE9ic2VydmFibGUgd2hpY2ggd3JhcHMgdGhlIFByb21pc2UuXG4gICAgICogQHN0YXRpYyB0cnVlXG4gICAgICogQG5hbWUgZnJvbVByb21pc2VcbiAgICAgKiBAb3duZXIgT2JzZXJ2YWJsZVxuICAgICAqL1xuICAgIFByb21pc2VPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChwcm9taXNlLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlT2JzZXJ2YWJsZShwcm9taXNlLCBzY2hlZHVsZXIpO1xuICAgIH07XG4gICAgUHJvbWlzZU9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcHJvbWlzZSA9IHRoaXMucHJvbWlzZTtcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICBpZiAoc2NoZWR1bGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1NjYWxhcikge1xuICAgICAgICAgICAgICAgIGlmICghc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5faXNTY2FsYXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAudGhlbihudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzY2FwZSB0aGUgcHJvbWlzZSB0cmFwLCB0aHJvdyB1bmhhbmRsZWQgZXJyb3JzXG4gICAgICAgICAgICAgICAgICAgIHJvb3RfMS5yb290LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyB0aHJvdyBlcnI7IH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzU2NhbGFyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoTmV4dCwgMCwgeyB2YWx1ZTogdGhpcy52YWx1ZSwgc3Vic2NyaWJlcjogc3Vic2NyaWJlciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9pc1NjYWxhciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuYWRkKHNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaE5leHQsIDAsIHsgdmFsdWU6IHZhbHVlLCBzdWJzY3JpYmVyOiBzdWJzY3JpYmVyIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoRXJyb3IsIDAsIHsgZXJyOiBlcnIsIHN1YnNjcmliZXI6IHN1YnNjcmliZXIgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4obnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2NhcGUgdGhlIHByb21pc2UgdHJhcCwgdGhyb3cgdW5oYW5kbGVkIGVycm9yc1xuICAgICAgICAgICAgICAgICAgICByb290XzEucm9vdC5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgdGhyb3cgZXJyOyB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFByb21pc2VPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5Qcm9taXNlT2JzZXJ2YWJsZSA9IFByb21pc2VPYnNlcnZhYmxlO1xuZnVuY3Rpb24gZGlzcGF0Y2hOZXh0KGFyZykge1xuICAgIHZhciB2YWx1ZSA9IGFyZy52YWx1ZSwgc3Vic2NyaWJlciA9IGFyZy5zdWJzY3JpYmVyO1xuICAgIGlmICghc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgc3Vic2NyaWJlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRpc3BhdGNoRXJyb3IoYXJnKSB7XG4gICAgdmFyIGVyciA9IGFyZy5lcnIsIHN1YnNjcmliZXIgPSBhcmcuc3Vic2NyaWJlcjtcbiAgICBpZiAoIXN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgIHN1YnNjcmliZXIuZXJyb3IoZXJyKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qcm9taXNlT2JzZXJ2YWJsZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vYnNlcnZhYmxlL1Byb21pc2VPYnNlcnZhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSA0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIHJvb3RfMSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvcm9vdCcpO1xudmFyIHRyeUNhdGNoXzEgPSByZXF1aXJlKCcuLi8uLi91dGlsL3RyeUNhdGNoJyk7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZXJyb3JPYmplY3QnKTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vLi4vU3Vic2NyaWJlcicpO1xudmFyIG1hcF8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvbWFwJyk7XG5mdW5jdGlvbiBnZXRDT1JTUmVxdWVzdCgpIHtcbiAgICBpZiAocm9vdF8xLnJvb3QuWE1MSHR0cFJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyByb290XzEucm9vdC5YTUxIdHRwUmVxdWVzdCgpO1xuICAgIH1cbiAgICBlbHNlIGlmICghIXJvb3RfMS5yb290LlhEb21haW5SZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiBuZXcgcm9vdF8xLnJvb3QuWERvbWFpblJlcXVlc3QoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ09SUyBpcyBub3Qgc3VwcG9ydGVkIGJ5IHlvdXIgYnJvd3NlcicpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFhNTEh0dHBSZXF1ZXN0KCkge1xuICAgIGlmIChyb290XzEucm9vdC5YTUxIdHRwUmVxdWVzdCkge1xuICAgICAgICByZXR1cm4gbmV3IHJvb3RfMS5yb290LlhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgcHJvZ0lkID0gdm9pZCAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHByb2dJZHMgPSBbJ01zeG1sMi5YTUxIVFRQJywgJ01pY3Jvc29mdC5YTUxIVFRQJywgJ01zeG1sMi5YTUxIVFRQLjQuMCddO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBwcm9nSWQgPSBwcm9nSWRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3IHJvb3RfMS5yb290LkFjdGl2ZVhPYmplY3QocHJvZ0lkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IHJvb3RfMS5yb290LkFjdGl2ZVhPYmplY3QocHJvZ0lkKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdYTUxIdHRwUmVxdWVzdCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHlvdXIgYnJvd3NlcicpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYWpheEdldCh1cmwsIGhlYWRlcnMpIHtcbiAgICBpZiAoaGVhZGVycyA9PT0gdm9pZCAwKSB7IGhlYWRlcnMgPSBudWxsOyB9XG4gICAgcmV0dXJuIG5ldyBBamF4T2JzZXJ2YWJsZSh7IG1ldGhvZDogJ0dFVCcsIHVybDogdXJsLCBoZWFkZXJzOiBoZWFkZXJzIH0pO1xufVxuZXhwb3J0cy5hamF4R2V0ID0gYWpheEdldDtcbjtcbmZ1bmN0aW9uIGFqYXhQb3N0KHVybCwgYm9keSwgaGVhZGVycykge1xuICAgIHJldHVybiBuZXcgQWpheE9ic2VydmFibGUoeyBtZXRob2Q6ICdQT1NUJywgdXJsOiB1cmwsIGJvZHk6IGJvZHksIGhlYWRlcnM6IGhlYWRlcnMgfSk7XG59XG5leHBvcnRzLmFqYXhQb3N0ID0gYWpheFBvc3Q7XG47XG5mdW5jdGlvbiBhamF4RGVsZXRlKHVybCwgaGVhZGVycykge1xuICAgIHJldHVybiBuZXcgQWpheE9ic2VydmFibGUoeyBtZXRob2Q6ICdERUxFVEUnLCB1cmw6IHVybCwgaGVhZGVyczogaGVhZGVycyB9KTtcbn1cbmV4cG9ydHMuYWpheERlbGV0ZSA9IGFqYXhEZWxldGU7XG47XG5mdW5jdGlvbiBhamF4UHV0KHVybCwgYm9keSwgaGVhZGVycykge1xuICAgIHJldHVybiBuZXcgQWpheE9ic2VydmFibGUoeyBtZXRob2Q6ICdQVVQnLCB1cmw6IHVybCwgYm9keTogYm9keSwgaGVhZGVyczogaGVhZGVycyB9KTtcbn1cbmV4cG9ydHMuYWpheFB1dCA9IGFqYXhQdXQ7XG47XG5mdW5jdGlvbiBhamF4UGF0Y2godXJsLCBib2R5LCBoZWFkZXJzKSB7XG4gICAgcmV0dXJuIG5ldyBBamF4T2JzZXJ2YWJsZSh7IG1ldGhvZDogJ1BBVENIJywgdXJsOiB1cmwsIGJvZHk6IGJvZHksIGhlYWRlcnM6IGhlYWRlcnMgfSk7XG59XG5leHBvcnRzLmFqYXhQYXRjaCA9IGFqYXhQYXRjaDtcbjtcbmZ1bmN0aW9uIGFqYXhHZXRKU09OKHVybCwgaGVhZGVycykge1xuICAgIHJldHVybiBuZXcgQWpheE9ic2VydmFibGUoeyBtZXRob2Q6ICdHRVQnLCB1cmw6IHVybCwgcmVzcG9uc2VUeXBlOiAnanNvbicsIGhlYWRlcnM6IGhlYWRlcnMgfSlcbiAgICAgICAgLmxpZnQobmV3IG1hcF8xLk1hcE9wZXJhdG9yKGZ1bmN0aW9uICh4LCBpbmRleCkgeyByZXR1cm4geC5yZXNwb25zZTsgfSwgbnVsbCkpO1xufVxuZXhwb3J0cy5hamF4R2V0SlNPTiA9IGFqYXhHZXRKU09OO1xuO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBBamF4T2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFqYXhPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFqYXhPYnNlcnZhYmxlKHVybE9yUmVxdWVzdCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdmFyIHJlcXVlc3QgPSB7XG4gICAgICAgICAgICBhc3luYzogdHJ1ZSxcbiAgICAgICAgICAgIGNyZWF0ZVhIUjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyb3NzRG9tYWluID8gZ2V0Q09SU1JlcXVlc3QuY2FsbCh0aGlzKSA6IGdldFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3Jvc3NEb21haW46IGZhbHNlLFxuICAgICAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBmYWxzZSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxuICAgICAgICAgICAgdGltZW91dDogMFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIHVybE9yUmVxdWVzdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJlcXVlc3QudXJsID0gdXJsT3JSZXF1ZXN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiB1cmxPclJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICBpZiAodXJsT3JSZXF1ZXN0Lmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RbcHJvcF0gPSB1cmxPclJlcXVlc3RbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgfVxuICAgIEFqYXhPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBamF4U3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnJlcXVlc3QpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYnNlcnZhYmxlIGZvciBhbiBBamF4IHJlcXVlc3Qgd2l0aCBlaXRoZXIgYSByZXF1ZXN0IG9iamVjdCB3aXRoXG4gICAgICogdXJsLCBoZWFkZXJzLCBldGMgb3IgYSBzdHJpbmcgZm9yIGEgVVJMLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBzb3VyY2UgPSBSeC5PYnNlcnZhYmxlLmFqYXgoJy9wcm9kdWN0cycpO1xuICAgICAqIHNvdXJjZSA9IFJ4Lk9ic2VydmFibGUuYWpheCh7IHVybDogJ3Byb2R1Y3RzJywgbWV0aG9kOiAnR0VUJyB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gcmVxdWVzdCBDYW4gYmUgb25lIG9mIHRoZSBmb2xsb3dpbmc6XG4gICAgICogICBBIHN0cmluZyBvZiB0aGUgVVJMIHRvIG1ha2UgdGhlIEFqYXggY2FsbC5cbiAgICAgKiAgIEFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllc1xuICAgICAqICAgLSB1cmw6IFVSTCBvZiB0aGUgcmVxdWVzdFxuICAgICAqICAgLSBib2R5OiBUaGUgYm9keSBvZiB0aGUgcmVxdWVzdFxuICAgICAqICAgLSBtZXRob2Q6IE1ldGhvZCBvZiB0aGUgcmVxdWVzdCwgc3VjaCBhcyBHRVQsIFBPU1QsIFBVVCwgUEFUQ0gsIERFTEVURVxuICAgICAqICAgLSBhc3luYzogV2hldGhlciB0aGUgcmVxdWVzdCBpcyBhc3luY1xuICAgICAqICAgLSBoZWFkZXJzOiBPcHRpb25hbCBoZWFkZXJzXG4gICAgICogICAtIGNyb3NzRG9tYWluOiB0cnVlIGlmIGEgY3Jvc3MgZG9tYWluIHJlcXVlc3QsIGVsc2UgZmFsc2VcbiAgICAgKiAgIC0gY3JlYXRlWEhSOiBhIGZ1bmN0aW9uIHRvIG92ZXJyaWRlIGlmIHlvdSBuZWVkIHRvIHVzZSBhbiBhbHRlcm5hdGVcbiAgICAgKiAgIFhNTEh0dHBSZXF1ZXN0IGltcGxlbWVudGF0aW9uLlxuICAgICAqICAgLSByZXN1bHRTZWxlY3RvcjogYSBmdW5jdGlvbiB0byB1c2UgdG8gYWx0ZXIgdGhlIG91dHB1dCB2YWx1ZSB0eXBlIG9mXG4gICAgICogICB0aGUgT2JzZXJ2YWJsZS4gR2V0cyB7QGxpbmsgQWpheFJlc3BvbnNlfSBhcyBhbiBhcmd1bWVudC5cbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIFhNTEh0dHBSZXF1ZXN0LlxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBuYW1lIGFqYXhcbiAgICAgKiBAb3duZXIgT2JzZXJ2YWJsZVxuICAgICovXG4gICAgQWpheE9ic2VydmFibGUuY3JlYXRlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNyZWF0ZSA9IGZ1bmN0aW9uICh1cmxPclJlcXVlc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWpheE9ic2VydmFibGUodXJsT3JSZXF1ZXN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgY3JlYXRlLmdldCA9IGFqYXhHZXQ7XG4gICAgICAgIGNyZWF0ZS5wb3N0ID0gYWpheFBvc3Q7XG4gICAgICAgIGNyZWF0ZS5kZWxldGUgPSBhamF4RGVsZXRlO1xuICAgICAgICBjcmVhdGUucHV0ID0gYWpheFB1dDtcbiAgICAgICAgY3JlYXRlLnBhdGNoID0gYWpheFBhdGNoO1xuICAgICAgICBjcmVhdGUuZ2V0SlNPTiA9IGFqYXhHZXRKU09OO1xuICAgICAgICByZXR1cm4gY3JlYXRlO1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIEFqYXhPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5BamF4T2JzZXJ2YWJsZSA9IEFqYXhPYnNlcnZhYmxlO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBBamF4U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFqYXhTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFqYXhTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCByZXF1ZXN0KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHZhciBoZWFkZXJzID0gcmVxdWVzdC5oZWFkZXJzID0gcmVxdWVzdC5oZWFkZXJzIHx8IHt9O1xuICAgICAgICAvLyBmb3JjZSBDT1JTIGlmIHJlcXVlc3RlZFxuICAgICAgICBpZiAoIXJlcXVlc3QuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbJ1gtUmVxdWVzdGVkLVdpdGgnXSkge1xuICAgICAgICAgICAgaGVhZGVyc1snWC1SZXF1ZXN0ZWQtV2l0aCddID0gJ1hNTEh0dHBSZXF1ZXN0JztcbiAgICAgICAgfVxuICAgICAgICAvLyBlbnN1cmUgY29udGVudCB0eXBlIGlzIHNldFxuICAgICAgICBpZiAoISgnQ29udGVudC1UeXBlJyBpbiBoZWFkZXJzKSAmJiAhKHJvb3RfMS5yb290LkZvcm1EYXRhICYmIHJlcXVlc3QuYm9keSBpbnN0YW5jZW9mIHJvb3RfMS5yb290LkZvcm1EYXRhKSAmJiB0eXBlb2YgcmVxdWVzdC5ib2R5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04JztcbiAgICAgICAgfVxuICAgICAgICAvLyBwcm9wZXJseSBzZXJpYWxpemUgYm9keVxuICAgICAgICByZXF1ZXN0LmJvZHkgPSB0aGlzLnNlcmlhbGl6ZUJvZHkocmVxdWVzdC5ib2R5LCByZXF1ZXN0LmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKTtcbiAgICAgICAgdGhpcy5zZW5kKCk7XG4gICAgfVxuICAgIEFqYXhTdWJzY3JpYmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgeGhyID0gX2EueGhyLCByZXF1ZXN0ID0gX2EucmVxdWVzdCwgZGVzdGluYXRpb24gPSBfYS5kZXN0aW5hdGlvbjtcbiAgICAgICAgdmFyIHJlc3BvbnNlID0gbmV3IEFqYXhSZXNwb25zZShlLCB4aHIsIHJlcXVlc3QpO1xuICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHJlc3BvbnNlKTtcbiAgICB9O1xuICAgIEFqYXhTdWJzY3JpYmVyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCByZXF1ZXN0ID0gX2EucmVxdWVzdCwgX2IgPSBfYS5yZXF1ZXN0LCB1c2VyID0gX2IudXNlciwgbWV0aG9kID0gX2IubWV0aG9kLCB1cmwgPSBfYi51cmwsIGFzeW5jID0gX2IuYXN5bmMsIHBhc3N3b3JkID0gX2IucGFzc3dvcmQsIGhlYWRlcnMgPSBfYi5oZWFkZXJzLCBib2R5ID0gX2IuYm9keTtcbiAgICAgICAgdmFyIGNyZWF0ZVhIUiA9IHJlcXVlc3QuY3JlYXRlWEhSO1xuICAgICAgICB2YXIgeGhyID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaChjcmVhdGVYSFIpLmNhbGwocmVxdWVzdCk7XG4gICAgICAgIGlmICh4aHIgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMueGhyID0geGhyO1xuICAgICAgICAgICAgLy8gc2V0IHVwIHRoZSBldmVudHMgYmVmb3JlIG9wZW4gWEhSXG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvWE1MSHR0cFJlcXVlc3QvVXNpbmdfWE1MSHR0cFJlcXVlc3RcbiAgICAgICAgICAgIC8vIFlvdSBuZWVkIHRvIGFkZCB0aGUgZXZlbnQgbGlzdGVuZXJzIGJlZm9yZSBjYWxsaW5nIG9wZW4oKSBvbiB0aGUgcmVxdWVzdC5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSB0aGUgcHJvZ3Jlc3MgZXZlbnRzIHdpbGwgbm90IGZpcmUuXG4gICAgICAgICAgICB0aGlzLnNldHVwRXZlbnRzKHhociwgcmVxdWVzdCk7XG4gICAgICAgICAgICAvLyBvcGVuIFhIUlxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICh1c2VyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaCh4aHIub3BlbikuY2FsbCh4aHIsIG1ldGhvZCwgdXJsLCBhc3luYywgdXNlciwgcGFzc3dvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaCh4aHIub3BlbikuY2FsbCh4aHIsIG1ldGhvZCwgdXJsLCBhc3luYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGltZW91dCwgcmVzcG9uc2VUeXBlIGFuZCB3aXRoQ3JlZGVudGlhbHMgY2FuIGJlIHNldCBvbmNlIHRoZSBYSFIgaXMgb3BlblxuICAgICAgICAgICAgeGhyLnRpbWVvdXQgPSByZXF1ZXN0LnRpbWVvdXQ7XG4gICAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gcmVxdWVzdC5yZXNwb25zZVR5cGU7XG4gICAgICAgICAgICBpZiAoJ3dpdGhDcmVkZW50aWFscycgaW4geGhyKSB7XG4gICAgICAgICAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9ICEhcmVxdWVzdC53aXRoQ3JlZGVudGlhbHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgaGVhZGVyc1xuICAgICAgICAgICAgdGhpcy5zZXRIZWFkZXJzKHhociwgaGVhZGVycyk7XG4gICAgICAgICAgICAvLyBmaW5hbGx5IHNlbmQgdGhlIHJlcXVlc3RcbiAgICAgICAgICAgIHJlc3VsdCA9IGJvZHkgPyB0cnlDYXRjaF8xLnRyeUNhdGNoKHhoci5zZW5kKS5jYWxsKHhociwgYm9keSkgOiB0cnlDYXRjaF8xLnRyeUNhdGNoKHhoci5zZW5kKS5jYWxsKHhocik7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4aHI7XG4gICAgfTtcbiAgICBBamF4U3Vic2NyaWJlci5wcm90b3R5cGUuc2VyaWFsaXplQm9keSA9IGZ1bmN0aW9uIChib2R5LCBjb250ZW50VHlwZSkge1xuICAgICAgICBpZiAoIWJvZHkgfHwgdHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gYm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyb290XzEucm9vdC5Gb3JtRGF0YSAmJiBib2R5IGluc3RhbmNlb2Ygcm9vdF8xLnJvb3QuRm9ybURhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBib2R5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZW50VHlwZSkge1xuICAgICAgICAgICAgdmFyIHNwbGl0SW5kZXggPSBjb250ZW50VHlwZS5pbmRleE9mKCc7Jyk7XG4gICAgICAgICAgICBpZiAoc3BsaXRJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlLnN1YnN0cmluZygwLCBzcGxpdEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGNvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgICBjYXNlICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhib2R5KS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gKGVuY29kZVVSSShrZXkpICsgXCI9XCIgKyBlbmNvZGVVUkkoYm9keVtrZXldKSk7IH0pLmpvaW4oJyYnKTtcbiAgICAgICAgICAgIGNhc2UgJ2FwcGxpY2F0aW9uL2pzb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShib2R5KTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFqYXhTdWJzY3JpYmVyLnByb3RvdHlwZS5zZXRIZWFkZXJzID0gZnVuY3Rpb24gKHhociwgaGVhZGVycykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gaGVhZGVycykge1xuICAgICAgICAgICAgaWYgKGhlYWRlcnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgaGVhZGVyc1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQWpheFN1YnNjcmliZXIucHJvdG90eXBlLnNldHVwRXZlbnRzID0gZnVuY3Rpb24gKHhociwgcmVxdWVzdCkge1xuICAgICAgICB2YXIgcHJvZ3Jlc3NTdWJzY3JpYmVyID0gcmVxdWVzdC5wcm9ncmVzc1N1YnNjcmliZXI7XG4gICAgICAgIGZ1bmN0aW9uIHhoclRpbWVvdXQoZSkge1xuICAgICAgICAgICAgdmFyIF9hID0geGhyVGltZW91dCwgc3Vic2NyaWJlciA9IF9hLnN1YnNjcmliZXIsIHByb2dyZXNzU3Vic2NyaWJlciA9IF9hLnByb2dyZXNzU3Vic2NyaWJlciwgcmVxdWVzdCA9IF9hLnJlcXVlc3Q7XG4gICAgICAgICAgICBpZiAocHJvZ3Jlc3NTdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3NTdWJzY3JpYmVyLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcihuZXcgQWpheFRpbWVvdXRFcnJvcih0aGlzLCByZXF1ZXN0KSk7IC8vVE9ETzogTWFrZSBiZXR0ZXJlci5cbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIHhoci5vbnRpbWVvdXQgPSB4aHJUaW1lb3V0O1xuICAgICAgICB4aHJUaW1lb3V0LnJlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICB4aHJUaW1lb3V0LnN1YnNjcmliZXIgPSB0aGlzO1xuICAgICAgICB4aHJUaW1lb3V0LnByb2dyZXNzU3Vic2NyaWJlciA9IHByb2dyZXNzU3Vic2NyaWJlcjtcbiAgICAgICAgaWYgKHhoci51cGxvYWQgJiYgJ3dpdGhDcmVkZW50aWFscycgaW4geGhyKSB7XG4gICAgICAgICAgICBpZiAocHJvZ3Jlc3NTdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHhoclByb2dyZXNzXzE7XG4gICAgICAgICAgICAgICAgeGhyUHJvZ3Jlc3NfMSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9ncmVzc1N1YnNjcmliZXIgPSB4aHJQcm9ncmVzc18xLnByb2dyZXNzU3Vic2NyaWJlcjtcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NTdWJzY3JpYmVyLm5leHQoZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAocm9vdF8xLnJvb3QuWERvbWFpblJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgeGhyLm9ucHJvZ3Jlc3MgPSB4aHJQcm9ncmVzc18xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeGhyLnVwbG9hZC5vbnByb2dyZXNzID0geGhyUHJvZ3Jlc3NfMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeGhyUHJvZ3Jlc3NfMS5wcm9ncmVzc1N1YnNjcmliZXIgPSBwcm9ncmVzc1N1YnNjcmliZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgeGhyRXJyb3JfMTtcbiAgICAgICAgICAgIHhockVycm9yXzEgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IHhockVycm9yXzEsIHByb2dyZXNzU3Vic2NyaWJlciA9IF9hLnByb2dyZXNzU3Vic2NyaWJlciwgc3Vic2NyaWJlciA9IF9hLnN1YnNjcmliZXIsIHJlcXVlc3QgPSBfYS5yZXF1ZXN0O1xuICAgICAgICAgICAgICAgIGlmIChwcm9ncmVzc1N1YnNjcmliZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NTdWJzY3JpYmVyLmVycm9yKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKG5ldyBBamF4RXJyb3IoJ2FqYXggZXJyb3InLCB0aGlzLCByZXF1ZXN0KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgeGhyLm9uZXJyb3IgPSB4aHJFcnJvcl8xO1xuICAgICAgICAgICAgeGhyRXJyb3JfMS5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICAgICAgICAgIHhockVycm9yXzEuc3Vic2NyaWJlciA9IHRoaXM7XG4gICAgICAgICAgICB4aHJFcnJvcl8xLnByb2dyZXNzU3Vic2NyaWJlciA9IHByb2dyZXNzU3Vic2NyaWJlcjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB4aHJSZWFkeVN0YXRlQ2hhbmdlKGUpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHhoclJlYWR5U3RhdGVDaGFuZ2UsIHN1YnNjcmliZXIgPSBfYS5zdWJzY3JpYmVyLCBwcm9ncmVzc1N1YnNjcmliZXIgPSBfYS5wcm9ncmVzc1N1YnNjcmliZXIsIHJlcXVlc3QgPSBfYS5yZXF1ZXN0O1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSBJRTkgYnVnIChodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xNDUwKVxuICAgICAgICAgICAgICAgIHZhciBzdGF0dXNfMSA9IHRoaXMuc3RhdHVzID09PSAxMjIzID8gMjA0IDogdGhpcy5zdGF0dXM7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0gKHRoaXMucmVzcG9uc2VUeXBlID09PSAndGV4dCcgPyAodGhpcy5yZXNwb25zZSB8fCB0aGlzLnJlc3BvbnNlVGV4dCkgOiB0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAvLyBmaXggc3RhdHVzIGNvZGUgd2hlbiBpdCBpcyAwICgwIHN0YXR1cyBpcyB1bmRvY3VtZW50ZWQpLlxuICAgICAgICAgICAgICAgIC8vIE9jY3VycyB3aGVuIGFjY2Vzc2luZyBmaWxlIHJlc291cmNlcyBvciBvbiBBbmRyb2lkIDQuMSBzdG9jayBicm93c2VyXG4gICAgICAgICAgICAgICAgLy8gd2hpbGUgcmV0cmlldmluZyBmaWxlcyBmcm9tIGFwcGxpY2F0aW9uIGNhY2hlLlxuICAgICAgICAgICAgICAgIGlmIChzdGF0dXNfMSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXNfMSA9IHJlc3BvbnNlID8gMjAwIDogMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKDIwMCA8PSBzdGF0dXNfMSAmJiBzdGF0dXNfMSA8IDMwMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvZ3Jlc3NTdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc1N1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQoZSk7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9ncmVzc1N1YnNjcmliZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzU3Vic2NyaWJlci5lcnJvcihlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKG5ldyBBamF4RXJyb3IoJ2FqYXggZXJyb3IgJyArIHN0YXR1c18xLCB0aGlzLCByZXF1ZXN0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHhoclJlYWR5U3RhdGVDaGFuZ2U7XG4gICAgICAgIHhoclJlYWR5U3RhdGVDaGFuZ2Uuc3Vic2NyaWJlciA9IHRoaXM7XG4gICAgICAgIHhoclJlYWR5U3RhdGVDaGFuZ2UucHJvZ3Jlc3NTdWJzY3JpYmVyID0gcHJvZ3Jlc3NTdWJzY3JpYmVyO1xuICAgICAgICB4aHJSZWFkeVN0YXRlQ2hhbmdlLnJlcXVlc3QgPSByZXF1ZXN0O1xuICAgIH07XG4gICAgQWpheFN1YnNjcmliZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBkb25lID0gX2EuZG9uZSwgeGhyID0gX2EueGhyO1xuICAgICAgICBpZiAoIWRvbmUgJiYgeGhyICYmIHhoci5yZWFkeVN0YXRlICE9PSA0ICYmIHR5cGVvZiB4aHIuYWJvcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHhoci5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudW5zdWJzY3JpYmUuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBBamF4U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbmV4cG9ydHMuQWpheFN1YnNjcmliZXIgPSBBamF4U3Vic2NyaWJlcjtcbi8qKlxuICogQSBub3JtYWxpemVkIEFKQVggcmVzcG9uc2UuXG4gKlxuICogQHNlZSB7QGxpbmsgYWpheH1cbiAqXG4gKiBAY2xhc3MgQWpheFJlc3BvbnNlXG4gKi9cbnZhciBBamF4UmVzcG9uc2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFqYXhSZXNwb25zZShvcmlnaW5hbEV2ZW50LCB4aHIsIHJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gb3JpZ2luYWxFdmVudDtcbiAgICAgICAgdGhpcy54aHIgPSB4aHI7XG4gICAgICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgIHRoaXMuc3RhdHVzID0geGhyLnN0YXR1cztcbiAgICAgICAgdGhpcy5yZXNwb25zZVR5cGUgPSB4aHIucmVzcG9uc2VUeXBlIHx8IHJlcXVlc3QucmVzcG9uc2VUeXBlO1xuICAgICAgICBzd2l0Y2ggKHRoaXMucmVzcG9uc2VUeXBlKSB7XG4gICAgICAgICAgICBjYXNlICdqc29uJzpcbiAgICAgICAgICAgICAgICBpZiAoJ3Jlc3BvbnNlJyBpbiB4aHIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9JRSBkb2VzIG5vdCBzdXBwb3J0IGpzb24gYXMgcmVzcG9uc2VUeXBlLCBwYXJzZSBpdCBpbnRlcm5hbGx5XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzcG9uc2UgPSB4aHIucmVzcG9uc2VUeXBlID8geGhyLnJlc3BvbnNlIDogSlNPTi5wYXJzZSh4aHIucmVzcG9uc2UgfHwgeGhyLnJlc3BvbnNlVGV4dCB8fCAnbnVsbCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNwb25zZSA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCB8fCAnbnVsbCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3htbCc6XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNwb25zZSA9IHhoci5yZXNwb25zZVhNTDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3BvbnNlID0gKCdyZXNwb25zZScgaW4geGhyKSA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEFqYXhSZXNwb25zZTtcbn0oKSk7XG5leHBvcnRzLkFqYXhSZXNwb25zZSA9IEFqYXhSZXNwb25zZTtcbi8qKlxuICogQSBub3JtYWxpemVkIEFKQVggZXJyb3IuXG4gKlxuICogQHNlZSB7QGxpbmsgYWpheH1cbiAqXG4gKiBAY2xhc3MgQWpheEVycm9yXG4gKi9cbnZhciBBamF4RXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBamF4RXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWpheEVycm9yKG1lc3NhZ2UsIHhociwgcmVxdWVzdCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy54aHIgPSB4aHI7XG4gICAgICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgIHRoaXMuc3RhdHVzID0geGhyLnN0YXR1cztcbiAgICB9XG4gICAgcmV0dXJuIEFqYXhFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuQWpheEVycm9yID0gQWpheEVycm9yO1xuLyoqXG4gKiBAc2VlIHtAbGluayBhamF4fVxuICpcbiAqIEBjbGFzcyBBamF4VGltZW91dEVycm9yXG4gKi9cbnZhciBBamF4VGltZW91dEVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWpheFRpbWVvdXRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBamF4VGltZW91dEVycm9yKHhociwgcmVxdWVzdCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCAnYWpheCB0aW1lb3V0JywgeGhyLCByZXF1ZXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIEFqYXhUaW1lb3V0RXJyb3I7XG59KEFqYXhFcnJvcikpO1xuZXhwb3J0cy5BamF4VGltZW91dEVycm9yID0gQWpheFRpbWVvdXRFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFqYXhPYnNlcnZhYmxlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29ic2VydmFibGUvZG9tL0FqYXhPYnNlcnZhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSA0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciB0cnlDYXRjaF8xID0gcmVxdWlyZSgnLi4vdXRpbC90cnlDYXRjaCcpO1xudmFyIGVycm9yT2JqZWN0XzEgPSByZXF1aXJlKCcuLi91dGlsL2Vycm9yT2JqZWN0Jyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBhbGwgaXRlbXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgdGhhdCBhcmUgZGlzdGluY3QgYnkgY29tcGFyaXNvbiBmcm9tIHRoZSBwcmV2aW91cyBpdGVtLlxuICpcbiAqIElmIGEgY29tcGFyYXRvciBmdW5jdGlvbiBpcyBwcm92aWRlZCwgdGhlbiBpdCB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaCBpdGVtIHRvIHRlc3QgZm9yIHdoZXRoZXIgb3Igbm90IHRoYXQgdmFsdWUgc2hvdWxkIGJlIGVtaXR0ZWQuXG4gKlxuICogSWYgYSBjb21wYXJhdG9yIGZ1bmN0aW9uIGlzIG5vdCBwcm92aWRlZCwgYW4gZXF1YWxpdHkgY2hlY2sgaXMgdXNlZCBieSBkZWZhdWx0LlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkEgc2ltcGxlIGV4YW1wbGUgd2l0aCBudW1iZXJzPC9jYXB0aW9uPlxuICogT2JzZXJ2YWJsZS5vZigxLCAxLCAyLCAyLCAyLCAxLCAxLCAyLCAzLCAzLCA0KVxuICogICAuZGlzdGluY3RVbnRpbENoYW5nZWQoKVxuICogICAuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpOyAvLyAxLCAyLCAxLCAyLCAzLCA0XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+QW4gZXhhbXBsZSB1c2luZyBhIGNvbXBhcmUgZnVuY3Rpb248L2NhcHRpb24+XG4gKiBpbnRlcmZhY2UgUGVyc29uIHtcbiAqICAgIGFnZTogbnVtYmVyLFxuICogICAgbmFtZTogc3RyaW5nXG4gKiB9XG4gKlxuICogT2JzZXJ2YWJsZS5vZjxQZXJzb24+KFxuICogICAgIHsgYWdlOiA0LCBuYW1lOiAnRm9vJ30sXG4gKiAgICAgeyBhZ2U6IDcsIG5hbWU6ICdCYXInfSxcbiAqICAgICB7IGFnZTogNSwgbmFtZTogJ0Zvbyd9KVxuICogICAgIHsgYWdlOiA2LCBuYW1lOiAnRm9vJ30pXG4gKiAgICAgLmRpc3RpbmN0VW50aWxDaGFuZ2VkKChwOiBQZXJzb24sIHE6IFBlcnNvbikgPT4gcC5uYW1lID09PSBxLm5hbWUpXG4gKiAgICAgLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBkaXNwbGF5czpcbiAqIC8vIHsgYWdlOiA0LCBuYW1lOiAnRm9vJyB9XG4gKiAvLyB7IGFnZTogNywgbmFtZTogJ0JhcicgfVxuICogLy8geyBhZ2U6IDUsIG5hbWU6ICdGb28nIH1cbiAqXG4gKiBAc2VlIHtAbGluayBkaXN0aW5jdH1cbiAqIEBzZWUge0BsaW5rIGRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkfVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjb21wYXJlXSBPcHRpb25hbCBjb21wYXJpc29uIGZ1bmN0aW9uIGNhbGxlZCB0byB0ZXN0IGlmIGFuIGl0ZW0gaXMgZGlzdGluY3QgZnJvbSB0aGUgcHJldmlvdXMgaXRlbSBpbiB0aGUgc291cmNlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGl0ZW1zIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHdpdGggZGlzdGluY3QgdmFsdWVzLlxuICogQG1ldGhvZCBkaXN0aW5jdFVudGlsQ2hhbmdlZFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gZGlzdGluY3RVbnRpbENoYW5nZWQoY29tcGFyZSwga2V5U2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBEaXN0aW5jdFVudGlsQ2hhbmdlZE9wZXJhdG9yKGNvbXBhcmUsIGtleVNlbGVjdG9yKSk7XG59XG5leHBvcnRzLmRpc3RpbmN0VW50aWxDaGFuZ2VkID0gZGlzdGluY3RVbnRpbENoYW5nZWQ7XG52YXIgRGlzdGluY3RVbnRpbENoYW5nZWRPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGlzdGluY3RVbnRpbENoYW5nZWRPcGVyYXRvcihjb21wYXJlLCBrZXlTZWxlY3Rvcikge1xuICAgICAgICB0aGlzLmNvbXBhcmUgPSBjb21wYXJlO1xuICAgICAgICB0aGlzLmtleVNlbGVjdG9yID0ga2V5U2VsZWN0b3I7XG4gICAgfVxuICAgIERpc3RpbmN0VW50aWxDaGFuZ2VkT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBEaXN0aW5jdFVudGlsQ2hhbmdlZFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5jb21wYXJlLCB0aGlzLmtleVNlbGVjdG9yKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGlzdGluY3RVbnRpbENoYW5nZWRPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIERpc3RpbmN0VW50aWxDaGFuZ2VkU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERpc3RpbmN0VW50aWxDaGFuZ2VkU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEaXN0aW5jdFVudGlsQ2hhbmdlZFN1YnNjcmliZXIoZGVzdGluYXRpb24sIGNvbXBhcmUsIGtleVNlbGVjdG9yKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5rZXlTZWxlY3RvciA9IGtleVNlbGVjdG9yO1xuICAgICAgICB0aGlzLmhhc0tleSA9IGZhbHNlO1xuICAgICAgICBpZiAodHlwZW9mIGNvbXBhcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcGFyZSA9IGNvbXBhcmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgRGlzdGluY3RVbnRpbENoYW5nZWRTdWJzY3JpYmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHggPT09IHk7XG4gICAgfTtcbiAgICBEaXN0aW5jdFVudGlsQ2hhbmdlZFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBrZXlTZWxlY3RvciA9IHRoaXMua2V5U2VsZWN0b3I7XG4gICAgICAgIHZhciBrZXkgPSB2YWx1ZTtcbiAgICAgICAgaWYgKGtleVNlbGVjdG9yKSB7XG4gICAgICAgICAgICBrZXkgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKHRoaXMua2V5U2VsZWN0b3IpKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuaGFzS2V5KSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKHRoaXMuY29tcGFyZSkodGhpcy5rZXksIGtleSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGFzS2V5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQm9vbGVhbihyZXN1bHQpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRGlzdGluY3RVbnRpbENoYW5nZWRTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlzdGluY3RVbnRpbENoYW5nZWQuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3IvZGlzdGluY3RVbnRpbENoYW5nZWQuanNcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogRmlsdGVyIGl0ZW1zIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGJ5IG9ubHkgZW1pdHRpbmcgdGhvc2UgdGhhdFxuICogc2F0aXNmeSBhIHNwZWNpZmllZCBwcmVkaWNhdGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkxpa2VcbiAqIFtBcnJheS5wcm90b3R5cGUuZmlsdGVyKCldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2ZpbHRlciksXG4gKiBpdCBvbmx5IGVtaXRzIGEgdmFsdWUgZnJvbSB0aGUgc291cmNlIGlmIGl0IHBhc3NlcyBhIGNyaXRlcmlvbiBmdW5jdGlvbi48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9maWx0ZXIucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogU2ltaWxhciB0byB0aGUgd2VsbC1rbm93biBgQXJyYXkucHJvdG90eXBlLmZpbHRlcmAgbWV0aG9kLCB0aGlzIG9wZXJhdG9yXG4gKiB0YWtlcyB2YWx1ZXMgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUsIHBhc3NlcyB0aGVtIHRocm91Z2ggYSBgcHJlZGljYXRlYFxuICogZnVuY3Rpb24gYW5kIG9ubHkgZW1pdHMgdGhvc2UgdmFsdWVzIHRoYXQgeWllbGRlZCBgdHJ1ZWAuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdCBvbmx5IGNsaWNrIGV2ZW50cyB3aG9zZSB0YXJnZXQgd2FzIGEgRElWIGVsZW1lbnQ8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIGNsaWNrc09uRGl2cyA9IGNsaWNrcy5maWx0ZXIoZXYgPT4gZXYudGFyZ2V0LnRhZ05hbWUgPT09ICdESVYnKTtcbiAqIGNsaWNrc09uRGl2cy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgZGlzdGluY3R9XG4gKiBAc2VlIHtAbGluayBkaXN0aW5jdFVudGlsQ2hhbmdlZH1cbiAqIEBzZWUge0BsaW5rIGRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkfVxuICogQHNlZSB7QGxpbmsgaWdub3JlRWxlbWVudHN9XG4gKiBAc2VlIHtAbGluayBwYXJ0aXRpb259XG4gKiBAc2VlIHtAbGluayBza2lwfVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24odmFsdWU6IFQsIGluZGV4OiBudW1iZXIpOiBib29sZWFufSBwcmVkaWNhdGUgQSBmdW5jdGlvbiB0aGF0XG4gKiBldmFsdWF0ZXMgZWFjaCB2YWx1ZSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS4gSWYgaXQgcmV0dXJucyBgdHJ1ZWAsXG4gKiB0aGUgdmFsdWUgaXMgZW1pdHRlZCwgaWYgYGZhbHNlYCB0aGUgdmFsdWUgaXMgbm90IHBhc3NlZCB0byB0aGUgb3V0cHV0XG4gKiBPYnNlcnZhYmxlLiBUaGUgYGluZGV4YCBwYXJhbWV0ZXIgaXMgdGhlIG51bWJlciBgaWAgZm9yIHRoZSBpLXRoIHNvdXJjZVxuICogZW1pc3Npb24gdGhhdCBoYXMgaGFwcGVuZWQgc2luY2UgdGhlIHN1YnNjcmlwdGlvbiwgc3RhcnRpbmcgZnJvbSB0aGUgbnVtYmVyXG4gKiBgMGAuXG4gKiBAcGFyYW0ge2FueX0gW3RoaXNBcmddIEFuIG9wdGlvbmFsIGFyZ3VtZW50IHRvIGRldGVybWluZSB0aGUgdmFsdWUgb2YgYHRoaXNgXG4gKiBpbiB0aGUgYHByZWRpY2F0ZWAgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIG9mIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2UgdGhhdCB3ZXJlXG4gKiBhbGxvd2VkIGJ5IHRoZSBgcHJlZGljYXRlYCBmdW5jdGlvbi5cbiAqIEBtZXRob2QgZmlsdGVyXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBmaWx0ZXIocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgRmlsdGVyT3BlcmF0b3IocHJlZGljYXRlLCB0aGlzQXJnKSk7XG59XG5leHBvcnRzLmZpbHRlciA9IGZpbHRlcjtcbnZhciBGaWx0ZXJPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRmlsdGVyT3BlcmF0b3IocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICB0aGlzLnRoaXNBcmcgPSB0aGlzQXJnO1xuICAgIH1cbiAgICBGaWx0ZXJPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IEZpbHRlclN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5wcmVkaWNhdGUsIHRoaXMudGhpc0FyZykpO1xuICAgIH07XG4gICAgcmV0dXJuIEZpbHRlck9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgRmlsdGVyU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZpbHRlclN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRmlsdGVyU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgIHRoaXMudGhpc0FyZyA9IHRoaXNBcmc7XG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICB9XG4gICAgLy8gdGhlIHRyeSBjYXRjaCBibG9jayBiZWxvdyBpcyBsZWZ0IHNwZWNpZmljYWxseSBmb3JcbiAgICAvLyBvcHRpbWl6YXRpb24gYW5kIHBlcmYgcmVhc29ucy4gYSB0cnlDYXRjaGVyIGlzIG5vdCBuZWNlc3NhcnkgaGVyZS5cbiAgICBGaWx0ZXJTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wcmVkaWNhdGUuY2FsbCh0aGlzLnRoaXNBcmcsIHZhbHVlLCB0aGlzLmNvdW50KyspO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRmlsdGVyU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbHRlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvci9maWx0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogRW1pdHMgb25seSB0aGUgZmlyc3QgdmFsdWUgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgdGhhdCBtZWV0cyBzb21lXG4gKiBjb25kaXRpb24uXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkZpbmRzIHRoZSBmaXJzdCB2YWx1ZSB0aGF0IHBhc3NlcyBzb21lIHRlc3QgYW5kIGVtaXRzXG4gKiB0aGF0Ljwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2ZpbmQucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYGZpbmRgIHNlYXJjaGVzIGZvciB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgc291cmNlIE9ic2VydmFibGUgdGhhdCBtYXRjaGVzIHRoZVxuICogc3BlY2lmaWVkIGNvbmRpdGlvbiBlbWJvZGllZCBieSB0aGUgYHByZWRpY2F0ZWAsIGFuZCByZXR1cm5zIHRoZSBmaXJzdFxuICogb2NjdXJyZW5jZSBpbiB0aGUgc291cmNlLiBVbmxpa2Uge0BsaW5rIGZpcnN0fSwgdGhlIGBwcmVkaWNhdGVgIGlzIHJlcXVpcmVkXG4gKiBpbiBgZmluZGAsIGFuZCBkb2VzIG5vdCBlbWl0IGFuIGVycm9yIGlmIGEgdmFsaWQgdmFsdWUgaXMgbm90IGZvdW5kLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkZpbmQgYW5kIGVtaXQgdGhlIGZpcnN0IGNsaWNrIHRoYXQgaGFwcGVucyBvbiBhIERJViBlbGVtZW50PC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3MuZmluZChldiA9PiBldi50YXJnZXQudGFnTmFtZSA9PT0gJ0RJVicpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBmaWx0ZXJ9XG4gKiBAc2VlIHtAbGluayBmaXJzdH1cbiAqIEBzZWUge0BsaW5rIGZpbmRJbmRleH1cbiAqIEBzZWUge0BsaW5rIHRha2V9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCwgaW5kZXg6IG51bWJlciwgc291cmNlOiBPYnNlcnZhYmxlPFQ+KTogYm9vbGVhbn0gcHJlZGljYXRlXG4gKiBBIGZ1bmN0aW9uIGNhbGxlZCB3aXRoIGVhY2ggaXRlbSB0byB0ZXN0IGZvciBjb25kaXRpb24gbWF0Y2hpbmcuXG4gKiBAcGFyYW0ge2FueX0gW3RoaXNBcmddIEFuIG9wdGlvbmFsIGFyZ3VtZW50IHRvIGRldGVybWluZSB0aGUgdmFsdWUgb2YgYHRoaXNgXG4gKiBpbiB0aGUgYHByZWRpY2F0ZWAgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBBbiBPYnNlcnZhYmxlIG9mIHRoZSBmaXJzdCBpdGVtIHRoYXQgbWF0Y2hlcyB0aGVcbiAqIGNvbmRpdGlvbi5cbiAqIEBtZXRob2QgZmluZFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gZmluZChwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwcmVkaWNhdGUgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgRmluZFZhbHVlT3BlcmF0b3IocHJlZGljYXRlLCB0aGlzLCBmYWxzZSwgdGhpc0FyZykpO1xufVxuZXhwb3J0cy5maW5kID0gZmluZDtcbnZhciBGaW5kVmFsdWVPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRmluZFZhbHVlT3BlcmF0b3IocHJlZGljYXRlLCBzb3VyY2UsIHlpZWxkSW5kZXgsIHRoaXNBcmcpIHtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLnlpZWxkSW5kZXggPSB5aWVsZEluZGV4O1xuICAgICAgICB0aGlzLnRoaXNBcmcgPSB0aGlzQXJnO1xuICAgIH1cbiAgICBGaW5kVmFsdWVPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChvYnNlcnZlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBGaW5kVmFsdWVTdWJzY3JpYmVyKG9ic2VydmVyLCB0aGlzLnByZWRpY2F0ZSwgdGhpcy5zb3VyY2UsIHRoaXMueWllbGRJbmRleCwgdGhpcy50aGlzQXJnKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRmluZFZhbHVlT3BlcmF0b3I7XG59KCkpO1xuZXhwb3J0cy5GaW5kVmFsdWVPcGVyYXRvciA9IEZpbmRWYWx1ZU9wZXJhdG9yO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBGaW5kVmFsdWVTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRmluZFZhbHVlU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGaW5kVmFsdWVTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBwcmVkaWNhdGUsIHNvdXJjZSwgeWllbGRJbmRleCwgdGhpc0FyZykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy55aWVsZEluZGV4ID0geWllbGRJbmRleDtcbiAgICAgICAgdGhpcy50aGlzQXJnID0gdGhpc0FyZztcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgfVxuICAgIEZpbmRWYWx1ZVN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIGRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgRmluZFZhbHVlU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcHJlZGljYXRlID0gX2EucHJlZGljYXRlLCB0aGlzQXJnID0gX2EudGhpc0FyZztcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleCsrO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHByZWRpY2F0ZS5jYWxsKHRoaXNBcmcgfHwgdGhpcywgdmFsdWUsIGluZGV4LCB0aGlzLnNvdXJjZSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlDb21wbGV0ZSh0aGlzLnlpZWxkSW5kZXggPyBpbmRleCA6IHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEZpbmRWYWx1ZVN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5ub3RpZnlDb21wbGV0ZSh0aGlzLnlpZWxkSW5kZXggPyAtMSA6IHVuZGVmaW5lZCk7XG4gICAgfTtcbiAgICByZXR1cm4gRmluZFZhbHVlU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbmV4cG9ydHMuRmluZFZhbHVlU3Vic2NyaWJlciA9IEZpbmRWYWx1ZVN1YnNjcmliZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maW5kLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9yL2ZpbmQuanNcbi8vIG1vZHVsZSBpZCA9IDQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciBBcnJheU9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL29ic2VydmFibGUvQXJyYXlPYnNlcnZhYmxlJyk7XG52YXIgbWVyZ2VBbGxfMSA9IHJlcXVpcmUoJy4vbWVyZ2VBbGwnKTtcbnZhciBpc1NjaGVkdWxlcl8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc1NjaGVkdWxlcicpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogQ3JlYXRlcyBhbiBvdXRwdXQgT2JzZXJ2YWJsZSB3aGljaCBjb25jdXJyZW50bHkgZW1pdHMgYWxsIHZhbHVlcyBmcm9tIGV2ZXJ5XG4gKiBnaXZlbiBpbnB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5GbGF0dGVucyBtdWx0aXBsZSBPYnNlcnZhYmxlcyB0b2dldGhlciBieSBibGVuZGluZ1xuICogdGhlaXIgdmFsdWVzIGludG8gb25lIE9ic2VydmFibGUuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvbWVyZ2UucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYG1lcmdlYCBzdWJzY3JpYmVzIHRvIGVhY2ggZ2l2ZW4gaW5wdXQgT2JzZXJ2YWJsZSAoZWl0aGVyIHRoZSBzb3VyY2Ugb3IgYW5cbiAqIE9ic2VydmFibGUgZ2l2ZW4gYXMgYXJndW1lbnQpLCBhbmQgc2ltcGx5IGZvcndhcmRzICh3aXRob3V0IGRvaW5nIGFueVxuICogdHJhbnNmb3JtYXRpb24pIGFsbCB0aGUgdmFsdWVzIGZyb20gYWxsIHRoZSBpbnB1dCBPYnNlcnZhYmxlcyB0byB0aGUgb3V0cHV0XG4gKiBPYnNlcnZhYmxlLiBUaGUgb3V0cHV0IE9ic2VydmFibGUgb25seSBjb21wbGV0ZXMgb25jZSBhbGwgaW5wdXQgT2JzZXJ2YWJsZXNcbiAqIGhhdmUgY29tcGxldGVkLiBBbnkgZXJyb3IgZGVsaXZlcmVkIGJ5IGFuIGlucHV0IE9ic2VydmFibGUgd2lsbCBiZSBpbW1lZGlhdGVseVxuICogZW1pdHRlZCBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+TWVyZ2UgdG9nZXRoZXIgdHdvIE9ic2VydmFibGVzOiAxcyBpbnRlcnZhbCBhbmQgY2xpY2tzPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciB0aW1lciA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gKiB2YXIgY2xpY2tzT3JUaW1lciA9IGNsaWNrcy5tZXJnZSh0aW1lcik7XG4gKiBjbGlja3NPclRpbWVyLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5NZXJnZSB0b2dldGhlciAzIE9ic2VydmFibGVzLCBidXQgb25seSAyIHJ1biBjb25jdXJyZW50bHk8L2NhcHRpb24+XG4gKiB2YXIgdGltZXIxID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKS50YWtlKDEwKTtcbiAqIHZhciB0aW1lcjIgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDIwMDApLnRha2UoNik7XG4gKiB2YXIgdGltZXIzID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCg1MDApLnRha2UoMTApO1xuICogdmFyIGNvbmN1cnJlbnQgPSAyOyAvLyB0aGUgYXJndW1lbnRcbiAqIHZhciBtZXJnZWQgPSB0aW1lcjEubWVyZ2UodGltZXIyLCB0aW1lcjMsIGNvbmN1cnJlbnQpO1xuICogbWVyZ2VkLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBtZXJnZUFsbH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlTWFwfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VNYXBUb31cbiAqIEBzZWUge0BsaW5rIG1lcmdlU2Nhbn1cbiAqXG4gKiBAcGFyYW0ge09ic2VydmFibGVJbnB1dH0gb3RoZXIgQW4gaW5wdXQgT2JzZXJ2YWJsZSB0byBtZXJnZSB3aXRoIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUuIE1vcmUgdGhhbiBvbmUgaW5wdXQgT2JzZXJ2YWJsZXMgbWF5IGJlIGdpdmVuIGFzIGFyZ3VtZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IFtjb25jdXJyZW50PU51bWJlci5QT1NJVElWRV9JTkZJTklUWV0gTWF4aW11bSBudW1iZXIgb2YgaW5wdXRcbiAqIE9ic2VydmFibGVzIGJlaW5nIHN1YnNjcmliZWQgdG8gY29uY3VycmVudGx5LlxuICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9bnVsbF0gVGhlIElTY2hlZHVsZXIgdG8gdXNlIGZvciBtYW5hZ2luZ1xuICogY29uY3VycmVuY3kgb2YgaW5wdXQgT2JzZXJ2YWJsZXMuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgaXRlbXMgdGhhdCBhcmUgdGhlIHJlc3VsdCBvZlxuICogZXZlcnkgaW5wdXQgT2JzZXJ2YWJsZS5cbiAqIEBtZXRob2QgbWVyZ2VcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIG1lcmdlKCkge1xuICAgIHZhciBvYnNlcnZhYmxlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG9ic2VydmFibGVzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5saWZ0LmNhbGwobWVyZ2VTdGF0aWMuYXBwbHkodm9pZCAwLCBbdGhpc10uY29uY2F0KG9ic2VydmFibGVzKSkpO1xufVxuZXhwb3J0cy5tZXJnZSA9IG1lcmdlO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogQ3JlYXRlcyBhbiBvdXRwdXQgT2JzZXJ2YWJsZSB3aGljaCBjb25jdXJyZW50bHkgZW1pdHMgYWxsIHZhbHVlcyBmcm9tIGV2ZXJ5XG4gKiBnaXZlbiBpbnB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5GbGF0dGVucyBtdWx0aXBsZSBPYnNlcnZhYmxlcyB0b2dldGhlciBieSBibGVuZGluZ1xuICogdGhlaXIgdmFsdWVzIGludG8gb25lIE9ic2VydmFibGUuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvbWVyZ2UucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYG1lcmdlYCBzdWJzY3JpYmVzIHRvIGVhY2ggZ2l2ZW4gaW5wdXQgT2JzZXJ2YWJsZSAoYXMgYXJndW1lbnRzKSwgYW5kIHNpbXBseVxuICogZm9yd2FyZHMgKHdpdGhvdXQgZG9pbmcgYW55IHRyYW5zZm9ybWF0aW9uKSBhbGwgdGhlIHZhbHVlcyBmcm9tIGFsbCB0aGUgaW5wdXRcbiAqIE9ic2VydmFibGVzIHRvIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS4gVGhlIG91dHB1dCBPYnNlcnZhYmxlIG9ubHkgY29tcGxldGVzXG4gKiBvbmNlIGFsbCBpbnB1dCBPYnNlcnZhYmxlcyBoYXZlIGNvbXBsZXRlZC4gQW55IGVycm9yIGRlbGl2ZXJlZCBieSBhbiBpbnB1dFxuICogT2JzZXJ2YWJsZSB3aWxsIGJlIGltbWVkaWF0ZWx5IGVtaXR0ZWQgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPk1lcmdlIHRvZ2V0aGVyIHR3byBPYnNlcnZhYmxlczogMXMgaW50ZXJ2YWwgYW5kIGNsaWNrczwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgdGltZXIgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApO1xuICogdmFyIGNsaWNrc09yVGltZXIgPSBSeC5PYnNlcnZhYmxlLm1lcmdlKGNsaWNrcywgdGltZXIpO1xuICogY2xpY2tzT3JUaW1lci5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gUmVzdWx0cyBpbiB0aGUgZm9sbG93aW5nOlxuICogLy8gdGltZXIgd2lsbCBlbWl0IGFzY2VuZGluZyB2YWx1ZXMsIG9uZSBldmVyeSBzZWNvbmQoMTAwMG1zKSB0byBjb25zb2xlXG4gKiAvLyBjbGlja3MgbG9ncyBNb3VzZUV2ZW50cyB0byBjb25zb2xlIGV2ZXJ5dGltZSB0aGUgXCJkb2N1bWVudFwiIGlzIGNsaWNrZWRcbiAqIC8vIFNpbmNlIHRoZSB0d28gc3RyZWFtcyBhcmUgbWVyZ2VkIHlvdSBzZWUgdGhlc2UgaGFwcGVuaW5nXG4gKiAvLyBhcyB0aGV5IG9jY3VyLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPk1lcmdlIHRvZ2V0aGVyIDMgT2JzZXJ2YWJsZXMsIGJ1dCBvbmx5IDIgcnVuIGNvbmN1cnJlbnRseTwvY2FwdGlvbj5cbiAqIHZhciB0aW1lcjEgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApLnRha2UoMTApO1xuICogdmFyIHRpbWVyMiA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMjAwMCkudGFrZSg2KTtcbiAqIHZhciB0aW1lcjMgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDUwMCkudGFrZSgxMCk7XG4gKiB2YXIgY29uY3VycmVudCA9IDI7IC8vIHRoZSBhcmd1bWVudFxuICogdmFyIG1lcmdlZCA9IFJ4Lk9ic2VydmFibGUubWVyZ2UodGltZXIxLCB0aW1lcjIsIHRpbWVyMywgY29uY3VycmVudCk7XG4gKiBtZXJnZWQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIC8vIFJlc3VsdHMgaW4gdGhlIGZvbGxvd2luZzpcbiAqIC8vIC0gRmlyc3QgdGltZXIxIGFuZCB0aW1lcjIgd2lsbCBydW4gY29uY3VycmVudGx5XG4gKiAvLyAtIHRpbWVyMSB3aWxsIGVtaXQgYSB2YWx1ZSBldmVyeSAxMDAwbXMgZm9yIDEwIGl0ZXJhdGlvbnNcbiAqIC8vIC0gdGltZXIyIHdpbGwgZW1pdCBhIHZhbHVlIGV2ZXJ5IDIwMDBtcyBmb3IgNiBpdGVyYXRpb25zXG4gKiAvLyAtIGFmdGVyIHRpbWVyMSBoaXRzIGl0J3MgbWF4IGl0ZXJhdGlvbiwgdGltZXIyIHdpbGxcbiAqIC8vICAgY29udGludWUsIGFuZCB0aW1lcjMgd2lsbCBzdGFydCB0byBydW4gY29uY3VycmVudGx5IHdpdGggdGltZXIyXG4gKiAvLyAtIHdoZW4gdGltZXIyIGhpdHMgaXQncyBtYXggaXRlcmF0aW9uIGl0IHRlcm1pbmF0ZXMsIGFuZFxuICogLy8gICB0aW1lcjMgd2lsbCBjb250aW51ZSB0byBlbWl0IGEgdmFsdWUgZXZlcnkgNTAwbXMgdW50aWwgaXQgaXMgY29tcGxldGVcbiAqXG4gKiBAc2VlIHtAbGluayBtZXJnZUFsbH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlTWFwfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VNYXBUb31cbiAqIEBzZWUge0BsaW5rIG1lcmdlU2Nhbn1cbiAqXG4gKiBAcGFyYW0gey4uLk9ic2VydmFibGVJbnB1dH0gb2JzZXJ2YWJsZXMgSW5wdXQgT2JzZXJ2YWJsZXMgdG8gbWVyZ2UgdG9nZXRoZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvbmN1cnJlbnQ9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSBNYXhpbXVtIG51bWJlciBvZiBpbnB1dFxuICogT2JzZXJ2YWJsZXMgYmVpbmcgc3Vic2NyaWJlZCB0byBjb25jdXJyZW50bHkuXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcj1udWxsXSBUaGUgSVNjaGVkdWxlciB0byB1c2UgZm9yIG1hbmFnaW5nXG4gKiBjb25jdXJyZW5jeSBvZiBpbnB1dCBPYnNlcnZhYmxlcy5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBpdGVtcyB0aGF0IGFyZSB0aGUgcmVzdWx0IG9mXG4gKiBldmVyeSBpbnB1dCBPYnNlcnZhYmxlLlxuICogQHN0YXRpYyB0cnVlXG4gKiBAbmFtZSBtZXJnZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gbWVyZ2VTdGF0aWMoKSB7XG4gICAgdmFyIG9ic2VydmFibGVzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgb2JzZXJ2YWJsZXNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBjb25jdXJyZW50ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIHZhciBzY2hlZHVsZXIgPSBudWxsO1xuICAgIHZhciBsYXN0ID0gb2JzZXJ2YWJsZXNbb2JzZXJ2YWJsZXMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGlzU2NoZWR1bGVyXzEuaXNTY2hlZHVsZXIobGFzdCkpIHtcbiAgICAgICAgc2NoZWR1bGVyID0gb2JzZXJ2YWJsZXMucG9wKCk7XG4gICAgICAgIGlmIChvYnNlcnZhYmxlcy5sZW5ndGggPiAxICYmIHR5cGVvZiBvYnNlcnZhYmxlc1tvYnNlcnZhYmxlcy5sZW5ndGggLSAxXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGNvbmN1cnJlbnQgPSBvYnNlcnZhYmxlcy5wb3AoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgbGFzdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgY29uY3VycmVudCA9IG9ic2VydmFibGVzLnBvcCgpO1xuICAgIH1cbiAgICBpZiAoc2NoZWR1bGVyID09PSBudWxsICYmIG9ic2VydmFibGVzLmxlbmd0aCA9PT0gMSAmJiBvYnNlcnZhYmxlc1swXSBpbnN0YW5jZW9mIE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSB7XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBcnJheU9ic2VydmFibGVfMS5BcnJheU9ic2VydmFibGUob2JzZXJ2YWJsZXMsIHNjaGVkdWxlcikubGlmdChuZXcgbWVyZ2VBbGxfMS5NZXJnZUFsbE9wZXJhdG9yKGNvbmN1cnJlbnQpKTtcbn1cbmV4cG9ydHMubWVyZ2VTdGF0aWMgPSBtZXJnZVN0YXRpYztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmdlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9yL21lcmdlLmpzXG4vLyBtb2R1bGUgaWQgPSA0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIFByb2plY3RzIGVhY2ggc291cmNlIHZhbHVlIHRvIGFuIE9ic2VydmFibGUgd2hpY2ggaXMgbWVyZ2VkIGluIHRoZSBvdXRwdXRcbiAqIE9ic2VydmFibGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPk1hcHMgZWFjaCB2YWx1ZSB0byBhbiBPYnNlcnZhYmxlLCB0aGVuIGZsYXR0ZW5zIGFsbCBvZlxuICogdGhlc2UgaW5uZXIgT2JzZXJ2YWJsZXMgdXNpbmcge0BsaW5rIG1lcmdlQWxsfS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9tZXJnZU1hcC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBpdGVtcyBiYXNlZCBvbiBhcHBseWluZyBhIGZ1bmN0aW9uIHRoYXQgeW91XG4gKiBzdXBwbHkgdG8gZWFjaCBpdGVtIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCB3aGVyZSB0aGF0IGZ1bmN0aW9uXG4gKiByZXR1cm5zIGFuIE9ic2VydmFibGUsIGFuZCB0aGVuIG1lcmdpbmcgdGhvc2UgcmVzdWx0aW5nIE9ic2VydmFibGVzIGFuZFxuICogZW1pdHRpbmcgdGhlIHJlc3VsdHMgb2YgdGhpcyBtZXJnZXIuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+TWFwIGFuZCBmbGF0dGVuIGVhY2ggbGV0dGVyIHRvIGFuIE9ic2VydmFibGUgdGlja2luZyBldmVyeSAxIHNlY29uZDwvY2FwdGlvbj5cbiAqIHZhciBsZXR0ZXJzID0gUnguT2JzZXJ2YWJsZS5vZignYScsICdiJywgJ2MnKTtcbiAqIHZhciByZXN1bHQgPSBsZXR0ZXJzLm1lcmdlTWFwKHggPT5cbiAqICAgUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKS5tYXAoaSA9PiB4K2kpXG4gKiApO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBSZXN1bHRzIGluIHRoZSBmb2xsb3dpbmc6XG4gKiAvLyBhMFxuICogLy8gYjBcbiAqIC8vIGMwXG4gKiAvLyBhMVxuICogLy8gYjFcbiAqIC8vIGMxXG4gKiAvLyBjb250aW51ZXMgdG8gbGlzdCBhLGIsYyB3aXRoIHJlc3BlY3RpdmUgYXNjZW5kaW5nIGludGVnZXJzXG4gKlxuICogQHNlZSB7QGxpbmsgY29uY2F0TWFwfVxuICogQHNlZSB7QGxpbmsgZXhoYXVzdE1hcH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VBbGx9XG4gKiBAc2VlIHtAbGluayBtZXJnZU1hcFRvfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VTY2FufVxuICogQHNlZSB7QGxpbmsgc3dpdGNoTWFwfVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24odmFsdWU6IFQsID9pbmRleDogbnVtYmVyKTogT2JzZXJ2YWJsZUlucHV0fSBwcm9qZWN0IEEgZnVuY3Rpb25cbiAqIHRoYXQsIHdoZW4gYXBwbGllZCB0byBhbiBpdGVtIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCByZXR1cm5zIGFuXG4gKiBPYnNlcnZhYmxlLlxuICogQHBhcmFtIHtmdW5jdGlvbihvdXRlclZhbHVlOiBULCBpbm5lclZhbHVlOiBJLCBvdXRlckluZGV4OiBudW1iZXIsIGlubmVySW5kZXg6IG51bWJlcik6IGFueX0gW3Jlc3VsdFNlbGVjdG9yXVxuICogQSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB2YWx1ZSBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUgYmFzZWQgb24gdGhlIHZhbHVlc1xuICogYW5kIHRoZSBpbmRpY2VzIG9mIHRoZSBzb3VyY2UgKG91dGVyKSBlbWlzc2lvbiBhbmQgdGhlIGlubmVyIE9ic2VydmFibGVcbiAqIGVtaXNzaW9uLiBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uIGFyZTpcbiAqIC0gYG91dGVyVmFsdWVgOiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHNvdXJjZVxuICogLSBgaW5uZXJWYWx1ZWA6IHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgcHJvamVjdGVkIE9ic2VydmFibGVcbiAqIC0gYG91dGVySW5kZXhgOiB0aGUgXCJpbmRleFwiIG9mIHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgc291cmNlXG4gKiAtIGBpbm5lckluZGV4YDogdGhlIFwiaW5kZXhcIiBvZiB0aGUgdmFsdWUgZnJvbSB0aGUgcHJvamVjdGVkIE9ic2VydmFibGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbY29uY3VycmVudD1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFldIE1heGltdW0gbnVtYmVyIG9mIGlucHV0XG4gKiBPYnNlcnZhYmxlcyBiZWluZyBzdWJzY3JpYmVkIHRvIGNvbmN1cnJlbnRseS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIHRoZVxuICogcHJvamVjdGlvbiBmdW5jdGlvbiAoYW5kIHRoZSBvcHRpb25hbCBgcmVzdWx0U2VsZWN0b3JgKSB0byBlYWNoIGl0ZW0gZW1pdHRlZFxuICogYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGFuZCBtZXJnaW5nIHRoZSByZXN1bHRzIG9mIHRoZSBPYnNlcnZhYmxlcyBvYnRhaW5lZFxuICogZnJvbSB0aGlzIHRyYW5zZm9ybWF0aW9uLlxuICogQG1ldGhvZCBtZXJnZU1hcFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gbWVyZ2VNYXAocHJvamVjdCwgcmVzdWx0U2VsZWN0b3IsIGNvbmN1cnJlbnQpIHtcbiAgICBpZiAoY29uY3VycmVudCA9PT0gdm9pZCAwKSB7IGNvbmN1cnJlbnQgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7IH1cbiAgICBpZiAodHlwZW9mIHJlc3VsdFNlbGVjdG9yID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb25jdXJyZW50ID0gcmVzdWx0U2VsZWN0b3I7XG4gICAgICAgIHJlc3VsdFNlbGVjdG9yID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgTWVyZ2VNYXBPcGVyYXRvcihwcm9qZWN0LCByZXN1bHRTZWxlY3RvciwgY29uY3VycmVudCkpO1xufVxuZXhwb3J0cy5tZXJnZU1hcCA9IG1lcmdlTWFwO1xudmFyIE1lcmdlTWFwT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1lcmdlTWFwT3BlcmF0b3IocHJvamVjdCwgcmVzdWx0U2VsZWN0b3IsIGNvbmN1cnJlbnQpIHtcbiAgICAgICAgaWYgKGNvbmN1cnJlbnQgPT09IHZvaWQgMCkgeyBjb25jdXJyZW50ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZOyB9XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgICAgIHRoaXMucmVzdWx0U2VsZWN0b3IgPSByZXN1bHRTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5jb25jdXJyZW50ID0gY29uY3VycmVudDtcbiAgICB9XG4gICAgTWVyZ2VNYXBPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChvYnNlcnZlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBNZXJnZU1hcFN1YnNjcmliZXIob2JzZXJ2ZXIsIHRoaXMucHJvamVjdCwgdGhpcy5yZXN1bHRTZWxlY3RvciwgdGhpcy5jb25jdXJyZW50KSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWVyZ2VNYXBPcGVyYXRvcjtcbn0oKSk7XG5leHBvcnRzLk1lcmdlTWFwT3BlcmF0b3IgPSBNZXJnZU1hcE9wZXJhdG9yO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBNZXJnZU1hcFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZXJnZU1hcFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVyZ2VNYXBTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBwcm9qZWN0LCByZXN1bHRTZWxlY3RvciwgY29uY3VycmVudCkge1xuICAgICAgICBpZiAoY29uY3VycmVudCA9PT0gdm9pZCAwKSB7IGNvbmN1cnJlbnQgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7IH1cbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgICAgICB0aGlzLnJlc3VsdFNlbGVjdG9yID0gcmVzdWx0U2VsZWN0b3I7XG4gICAgICAgIHRoaXMuY29uY3VycmVudCA9IGNvbmN1cnJlbnQ7XG4gICAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gW107XG4gICAgICAgIHRoaXMuYWN0aXZlID0gMDtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgfVxuICAgIE1lcmdlTWFwU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlIDwgdGhpcy5jb25jdXJyZW50KSB7XG4gICAgICAgICAgICB0aGlzLl90cnlOZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZXJnZU1hcFN1YnNjcmliZXIucHJvdG90eXBlLl90cnlOZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXgrKztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucHJvamVjdCh2YWx1ZSwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2ZSsrO1xuICAgICAgICB0aGlzLl9pbm5lclN1YihyZXN1bHQsIHZhbHVlLCBpbmRleCk7XG4gICAgfTtcbiAgICBNZXJnZU1hcFN1YnNjcmliZXIucHJvdG90eXBlLl9pbm5lclN1YiA9IGZ1bmN0aW9uIChpc2gsIHZhbHVlLCBpbmRleCkge1xuICAgICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIGlzaCwgdmFsdWUsIGluZGV4KSk7XG4gICAgfTtcbiAgICBNZXJnZU1hcFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUgPT09IDAgJiYgdGhpcy5idWZmZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1lcmdlTWFwU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICBpZiAodGhpcy5yZXN1bHRTZWxlY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5fbm90aWZ5UmVzdWx0U2VsZWN0b3Iob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoaW5uZXJWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1lcmdlTWFwU3Vic2NyaWJlci5wcm90b3R5cGUuX25vdGlmeVJlc3VsdFNlbGVjdG9yID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucmVzdWx0U2VsZWN0b3Iob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChyZXN1bHQpO1xuICAgIH07XG4gICAgTWVyZ2VNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uIChpbm5lclN1Yikge1xuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXI7XG4gICAgICAgIHRoaXMucmVtb3ZlKGlubmVyU3ViKTtcbiAgICAgICAgdGhpcy5hY3RpdmUtLTtcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9uZXh0KGJ1ZmZlci5zaGlmdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmFjdGl2ZSA9PT0gMCAmJiB0aGlzLmhhc0NvbXBsZXRlZCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTWVyZ2VNYXBTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbmV4cG9ydHMuTWVyZ2VNYXBTdWJzY3JpYmVyID0gTWVyZ2VNYXBTdWJzY3JpYmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVyZ2VNYXAuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3IvbWVyZ2VNYXAuanNcbi8vIG1vZHVsZSBpZCA9IDQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogUHJvamVjdHMgZWFjaCBzb3VyY2UgdmFsdWUgdG8gdGhlIHNhbWUgT2JzZXJ2YWJsZSB3aGljaCBpcyBtZXJnZWQgbXVsdGlwbGVcbiAqIHRpbWVzIGluIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SXQncyBsaWtlIHtAbGluayBtZXJnZU1hcH0sIGJ1dCBtYXBzIGVhY2ggdmFsdWUgYWx3YXlzXG4gKiB0byB0aGUgc2FtZSBpbm5lciBPYnNlcnZhYmxlLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL21lcmdlTWFwVG8ucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogTWFwcyBlYWNoIHNvdXJjZSB2YWx1ZSB0byB0aGUgZ2l2ZW4gT2JzZXJ2YWJsZSBgaW5uZXJPYnNlcnZhYmxlYCByZWdhcmRsZXNzXG4gKiBvZiB0aGUgc291cmNlIHZhbHVlLCBhbmQgdGhlbiBtZXJnZXMgdGhvc2UgcmVzdWx0aW5nIE9ic2VydmFibGVzIGludG8gb25lXG4gKiBzaW5nbGUgT2JzZXJ2YWJsZSwgd2hpY2ggaXMgdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkZvciBlYWNoIGNsaWNrIGV2ZW50LCBzdGFydCBhbiBpbnRlcnZhbCBPYnNlcnZhYmxlIHRpY2tpbmcgZXZlcnkgMSBzZWNvbmQ8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy5tZXJnZU1hcFRvKFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBjb25jYXRNYXBUb31cbiAqIEBzZWUge0BsaW5rIG1lcmdlfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VBbGx9XG4gKiBAc2VlIHtAbGluayBtZXJnZU1hcH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlU2Nhbn1cbiAqIEBzZWUge0BsaW5rIHN3aXRjaE1hcFRvfVxuICpcbiAqIEBwYXJhbSB7T2JzZXJ2YWJsZUlucHV0fSBpbm5lck9ic2VydmFibGUgQW4gT2JzZXJ2YWJsZSB0byByZXBsYWNlIGVhY2ggdmFsdWUgZnJvbVxuICogdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQHBhcmFtIHtmdW5jdGlvbihvdXRlclZhbHVlOiBULCBpbm5lclZhbHVlOiBJLCBvdXRlckluZGV4OiBudW1iZXIsIGlubmVySW5kZXg6IG51bWJlcik6IGFueX0gW3Jlc3VsdFNlbGVjdG9yXVxuICogQSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB2YWx1ZSBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUgYmFzZWQgb24gdGhlIHZhbHVlc1xuICogYW5kIHRoZSBpbmRpY2VzIG9mIHRoZSBzb3VyY2UgKG91dGVyKSBlbWlzc2lvbiBhbmQgdGhlIGlubmVyIE9ic2VydmFibGVcbiAqIGVtaXNzaW9uLiBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uIGFyZTpcbiAqIC0gYG91dGVyVmFsdWVgOiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHNvdXJjZVxuICogLSBgaW5uZXJWYWx1ZWA6IHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgcHJvamVjdGVkIE9ic2VydmFibGVcbiAqIC0gYG91dGVySW5kZXhgOiB0aGUgXCJpbmRleFwiIG9mIHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgc291cmNlXG4gKiAtIGBpbm5lckluZGV4YDogdGhlIFwiaW5kZXhcIiBvZiB0aGUgdmFsdWUgZnJvbSB0aGUgcHJvamVjdGVkIE9ic2VydmFibGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbY29uY3VycmVudD1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFldIE1heGltdW0gbnVtYmVyIG9mIGlucHV0XG4gKiBPYnNlcnZhYmxlcyBiZWluZyBzdWJzY3JpYmVkIHRvIGNvbmN1cnJlbnRseS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBpdGVtcyBmcm9tIHRoZSBnaXZlblxuICogYGlubmVyT2JzZXJ2YWJsZWAgKGFuZCBvcHRpb25hbGx5IHRyYW5zZm9ybWVkIHRocm91Z2ggYHJlc3VsdFNlbGVjdG9yYCkgZXZlcnlcbiAqIHRpbWUgYSB2YWx1ZSBpcyBlbWl0dGVkIG9uIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEBtZXRob2QgbWVyZ2VNYXBUb1xuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gbWVyZ2VNYXBUbyhpbm5lck9ic2VydmFibGUsIHJlc3VsdFNlbGVjdG9yLCBjb25jdXJyZW50KSB7XG4gICAgaWYgKGNvbmN1cnJlbnQgPT09IHZvaWQgMCkgeyBjb25jdXJyZW50ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZOyB9XG4gICAgaWYgKHR5cGVvZiByZXN1bHRTZWxlY3RvciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgY29uY3VycmVudCA9IHJlc3VsdFNlbGVjdG9yO1xuICAgICAgICByZXN1bHRTZWxlY3RvciA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IE1lcmdlTWFwVG9PcGVyYXRvcihpbm5lck9ic2VydmFibGUsIHJlc3VsdFNlbGVjdG9yLCBjb25jdXJyZW50KSk7XG59XG5leHBvcnRzLm1lcmdlTWFwVG8gPSBtZXJnZU1hcFRvO1xuLy8gVE9ETzogRmlndXJlIG91dCBjb3JyZWN0IHNpZ25hdHVyZSBoZXJlOiBhbiBPcGVyYXRvcjxPYnNlcnZhYmxlPFQ+LCBSPlxuLy8gICAgICAgbmVlZHMgdG8gaW1wbGVtZW50IGNhbGwob2JzZXJ2ZXI6IFN1YnNjcmliZXI8Uj4pOiBTdWJzY3JpYmVyPE9ic2VydmFibGU8VD4+XG52YXIgTWVyZ2VNYXBUb09wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZXJnZU1hcFRvT3BlcmF0b3IoaXNoLCByZXN1bHRTZWxlY3RvciwgY29uY3VycmVudCkge1xuICAgICAgICBpZiAoY29uY3VycmVudCA9PT0gdm9pZCAwKSB7IGNvbmN1cnJlbnQgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7IH1cbiAgICAgICAgdGhpcy5pc2ggPSBpc2g7XG4gICAgICAgIHRoaXMucmVzdWx0U2VsZWN0b3IgPSByZXN1bHRTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5jb25jdXJyZW50ID0gY29uY3VycmVudDtcbiAgICB9XG4gICAgTWVyZ2VNYXBUb09wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKG9ic2VydmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IE1lcmdlTWFwVG9TdWJzY3JpYmVyKG9ic2VydmVyLCB0aGlzLmlzaCwgdGhpcy5yZXN1bHRTZWxlY3RvciwgdGhpcy5jb25jdXJyZW50KSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWVyZ2VNYXBUb09wZXJhdG9yO1xufSgpKTtcbmV4cG9ydHMuTWVyZ2VNYXBUb09wZXJhdG9yID0gTWVyZ2VNYXBUb09wZXJhdG9yO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBNZXJnZU1hcFRvU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1lcmdlTWFwVG9TdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1lcmdlTWFwVG9TdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBpc2gsIHJlc3VsdFNlbGVjdG9yLCBjb25jdXJyZW50KSB7XG4gICAgICAgIGlmIChjb25jdXJyZW50ID09PSB2b2lkIDApIHsgY29uY3VycmVudCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTsgfVxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuaXNoID0gaXNoO1xuICAgICAgICB0aGlzLnJlc3VsdFNlbGVjdG9yID0gcmVzdWx0U2VsZWN0b3I7XG4gICAgICAgIHRoaXMuY29uY3VycmVudCA9IGNvbmN1cnJlbnQ7XG4gICAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gW107XG4gICAgICAgIHRoaXMuYWN0aXZlID0gMDtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgfVxuICAgIE1lcmdlTWFwVG9TdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUgPCB0aGlzLmNvbmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRTZWxlY3RvciA9IHRoaXMucmVzdWx0U2VsZWN0b3I7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4Kys7XG4gICAgICAgICAgICB2YXIgaXNoID0gdGhpcy5pc2g7XG4gICAgICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmUrKztcbiAgICAgICAgICAgIHRoaXMuX2lubmVyU3ViKGlzaCwgZGVzdGluYXRpb24sIHJlc3VsdFNlbGVjdG9yLCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1lcmdlTWFwVG9TdWJzY3JpYmVyLnByb3RvdHlwZS5faW5uZXJTdWIgPSBmdW5jdGlvbiAoaXNoLCBkZXN0aW5hdGlvbiwgcmVzdWx0U2VsZWN0b3IsIHZhbHVlLCBpbmRleCkge1xuICAgICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIGlzaCwgdmFsdWUsIGluZGV4KSk7XG4gICAgfTtcbiAgICBNZXJnZU1hcFRvU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmhhc0NvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSA9PT0gMCAmJiB0aGlzLmJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWVyZ2VNYXBUb1N1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcmVzdWx0U2VsZWN0b3IgPSBfYS5yZXN1bHRTZWxlY3RvciwgZGVzdGluYXRpb24gPSBfYS5kZXN0aW5hdGlvbjtcbiAgICAgICAgaWYgKHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnRyeVNlbGVjdFJlc3VsdChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQoaW5uZXJWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1lcmdlTWFwVG9TdWJzY3JpYmVyLnByb3RvdHlwZS50cnlTZWxlY3RSZXN1bHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCByZXN1bHRTZWxlY3RvciA9IF9hLnJlc3VsdFNlbGVjdG9yLCBkZXN0aW5hdGlvbiA9IF9hLmRlc3RpbmF0aW9uO1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0U2VsZWN0b3Iob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHJlc3VsdCk7XG4gICAgfTtcbiAgICBNZXJnZU1hcFRvU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5RXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICB9O1xuICAgIE1lcmdlTWFwVG9TdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uIChpbm5lclN1Yikge1xuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXI7XG4gICAgICAgIHRoaXMucmVtb3ZlKGlubmVyU3ViKTtcbiAgICAgICAgdGhpcy5hY3RpdmUtLTtcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9uZXh0KGJ1ZmZlci5zaGlmdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmFjdGl2ZSA9PT0gMCAmJiB0aGlzLmhhc0NvbXBsZXRlZCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTWVyZ2VNYXBUb1N1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuZXhwb3J0cy5NZXJnZU1hcFRvU3Vic2NyaWJlciA9IE1lcmdlTWFwVG9TdWJzY3JpYmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVyZ2VNYXBUby5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvci9tZXJnZU1hcFRvLmpzXG4vLyBtb2R1bGUgaWQgPSA1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIEZyb21PYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9vYnNlcnZhYmxlL0Zyb21PYnNlcnZhYmxlJyk7XG52YXIgaXNBcnJheV8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc0FycmF5Jyk7XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbmZ1bmN0aW9uIG9uRXJyb3JSZXN1bWVOZXh0KCkge1xuICAgIHZhciBuZXh0U291cmNlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG5leHRTb3VyY2VzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICBpZiAobmV4dFNvdXJjZXMubGVuZ3RoID09PSAxICYmIGlzQXJyYXlfMS5pc0FycmF5KG5leHRTb3VyY2VzWzBdKSkge1xuICAgICAgICBuZXh0U291cmNlcyA9IG5leHRTb3VyY2VzWzBdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBPbkVycm9yUmVzdW1lTmV4dE9wZXJhdG9yKG5leHRTb3VyY2VzKSk7XG59XG5leHBvcnRzLm9uRXJyb3JSZXN1bWVOZXh0ID0gb25FcnJvclJlc3VtZU5leHQ7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuZnVuY3Rpb24gb25FcnJvclJlc3VtZU5leHRTdGF0aWMoKSB7XG4gICAgdmFyIG5leHRTb3VyY2VzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgbmV4dFNvdXJjZXNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBzb3VyY2UgPSBudWxsO1xuICAgIGlmIChuZXh0U291cmNlcy5sZW5ndGggPT09IDEgJiYgaXNBcnJheV8xLmlzQXJyYXkobmV4dFNvdXJjZXNbMF0pKSB7XG4gICAgICAgIG5leHRTb3VyY2VzID0gbmV4dFNvdXJjZXNbMF07XG4gICAgfVxuICAgIHNvdXJjZSA9IG5leHRTb3VyY2VzLnNoaWZ0KCk7XG4gICAgcmV0dXJuIG5ldyBGcm9tT2JzZXJ2YWJsZV8xLkZyb21PYnNlcnZhYmxlKHNvdXJjZSwgbnVsbCkubGlmdChuZXcgT25FcnJvclJlc3VtZU5leHRPcGVyYXRvcihuZXh0U291cmNlcykpO1xufVxuZXhwb3J0cy5vbkVycm9yUmVzdW1lTmV4dFN0YXRpYyA9IG9uRXJyb3JSZXN1bWVOZXh0U3RhdGljO1xudmFyIE9uRXJyb3JSZXN1bWVOZXh0T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9uRXJyb3JSZXN1bWVOZXh0T3BlcmF0b3IobmV4dFNvdXJjZXMpIHtcbiAgICAgICAgdGhpcy5uZXh0U291cmNlcyA9IG5leHRTb3VyY2VzO1xuICAgIH1cbiAgICBPbkVycm9yUmVzdW1lTmV4dE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgT25FcnJvclJlc3VtZU5leHRTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMubmV4dFNvdXJjZXMpKTtcbiAgICB9O1xuICAgIHJldHVybiBPbkVycm9yUmVzdW1lTmV4dE9wZXJhdG9yO1xufSgpKTtcbnZhciBPbkVycm9yUmVzdW1lTmV4dFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhPbkVycm9yUmVzdW1lTmV4dFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gT25FcnJvclJlc3VtZU5leHRTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBuZXh0U291cmNlcykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgdGhpcy5uZXh0U291cmNlcyA9IG5leHRTb3VyY2VzO1xuICAgIH1cbiAgICBPbkVycm9yUmVzdW1lTmV4dFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUVycm9yID0gZnVuY3Rpb24gKGVycm9yLCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLnN1YnNjcmliZVRvTmV4dFNvdXJjZSgpO1xuICAgIH07XG4gICAgT25FcnJvclJlc3VtZU5leHRTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uIChpbm5lclN1Yikge1xuICAgICAgICB0aGlzLnN1YnNjcmliZVRvTmV4dFNvdXJjZSgpO1xuICAgIH07XG4gICAgT25FcnJvclJlc3VtZU5leHRTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlVG9OZXh0U291cmNlKCk7XG4gICAgfTtcbiAgICBPbkVycm9yUmVzdW1lTmV4dFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVUb05leHRTb3VyY2UoKTtcbiAgICB9O1xuICAgIE9uRXJyb3JSZXN1bWVOZXh0U3Vic2NyaWJlci5wcm90b3R5cGUuc3Vic2NyaWJlVG9OZXh0U291cmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV4dCA9IHRoaXMubmV4dFNvdXJjZXMuc2hpZnQoKTtcbiAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgbmV4dCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gT25FcnJvclJlc3VtZU5leHRTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9uRXJyb3JSZXN1bWVOZXh0LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9yL29uRXJyb3JSZXN1bWVOZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSA1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGlzQXJyYXlfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNBcnJheScpO1xudmFyIEFycmF5T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vb2JzZXJ2YWJsZS9BcnJheU9ic2VydmFibGUnKTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBtaXJyb3JzIHRoZSBmaXJzdCBzb3VyY2UgT2JzZXJ2YWJsZSB0byBlbWl0IGFuIGl0ZW1cbiAqIGZyb20gdGhlIGNvbWJpbmF0aW9uIG9mIHRoaXMgT2JzZXJ2YWJsZSBhbmQgc3VwcGxpZWQgT2JzZXJ2YWJsZXMuXG4gKiBAcGFyYW0gey4uLk9ic2VydmFibGVzfSAuLi5vYnNlcnZhYmxlcyBTb3VyY2VzIHVzZWQgdG8gcmFjZSBmb3Igd2hpY2ggT2JzZXJ2YWJsZSBlbWl0cyBmaXJzdC5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBtaXJyb3JzIHRoZSBvdXRwdXQgb2YgdGhlIGZpcnN0IE9ic2VydmFibGUgdG8gZW1pdCBhbiBpdGVtLlxuICogQG1ldGhvZCByYWNlXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiByYWNlKCkge1xuICAgIHZhciBvYnNlcnZhYmxlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG9ic2VydmFibGVzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICAvLyBpZiB0aGUgb25seSBhcmd1bWVudCBpcyBhbiBhcnJheSwgaXQgd2FzIG1vc3QgbGlrZWx5IGNhbGxlZCB3aXRoXG4gICAgLy8gYHBhaXIoW29iczEsIG9iczIsIC4uLl0pYFxuICAgIGlmIChvYnNlcnZhYmxlcy5sZW5ndGggPT09IDEgJiYgaXNBcnJheV8xLmlzQXJyYXkob2JzZXJ2YWJsZXNbMF0pKSB7XG4gICAgICAgIG9ic2VydmFibGVzID0gb2JzZXJ2YWJsZXNbMF07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxpZnQuY2FsbChyYWNlU3RhdGljLmFwcGx5KHZvaWQgMCwgW3RoaXNdLmNvbmNhdChvYnNlcnZhYmxlcykpKTtcbn1cbmV4cG9ydHMucmFjZSA9IHJhY2U7XG5mdW5jdGlvbiByYWNlU3RhdGljKCkge1xuICAgIHZhciBvYnNlcnZhYmxlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG9ic2VydmFibGVzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICAvLyBpZiB0aGUgb25seSBhcmd1bWVudCBpcyBhbiBhcnJheSwgaXQgd2FzIG1vc3QgbGlrZWx5IGNhbGxlZCB3aXRoXG4gICAgLy8gYHBhaXIoW29iczEsIG9iczIsIC4uLl0pYFxuICAgIGlmIChvYnNlcnZhYmxlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaWYgKGlzQXJyYXlfMS5pc0FycmF5KG9ic2VydmFibGVzWzBdKSkge1xuICAgICAgICAgICAgb2JzZXJ2YWJsZXMgPSBvYnNlcnZhYmxlc1swXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBvYnNlcnZhYmxlc1swXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IEFycmF5T2JzZXJ2YWJsZV8xLkFycmF5T2JzZXJ2YWJsZShvYnNlcnZhYmxlcykubGlmdChuZXcgUmFjZU9wZXJhdG9yKCkpO1xufVxuZXhwb3J0cy5yYWNlU3RhdGljID0gcmFjZVN0YXRpYztcbnZhciBSYWNlT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJhY2VPcGVyYXRvcigpIHtcbiAgICB9XG4gICAgUmFjZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgUmFjZVN1YnNjcmliZXIoc3Vic2NyaWJlcikpO1xuICAgIH07XG4gICAgcmV0dXJuIFJhY2VPcGVyYXRvcjtcbn0oKSk7XG5leHBvcnRzLlJhY2VPcGVyYXRvciA9IFJhY2VPcGVyYXRvcjtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgUmFjZVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSYWNlU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSYWNlU3Vic2NyaWJlcihkZXN0aW5hdGlvbikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuaGFzRmlyc3QgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vYnNlcnZhYmxlcyA9IFtdO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBbXTtcbiAgICB9XG4gICAgUmFjZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKG9ic2VydmFibGUpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZhYmxlcy5wdXNoKG9ic2VydmFibGUpO1xuICAgIH07XG4gICAgUmFjZVN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9ic2VydmFibGVzID0gdGhpcy5vYnNlcnZhYmxlcztcbiAgICAgICAgdmFyIGxlbiA9IG9ic2VydmFibGVzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW4gJiYgIXRoaXMuaGFzRmlyc3Q7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBvYnNlcnZhYmxlID0gb2JzZXJ2YWJsZXNbaV07XG4gICAgICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgb2JzZXJ2YWJsZSwgb2JzZXJ2YWJsZSwgaSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChzdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmFkZChzdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vYnNlcnZhYmxlcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJhY2VTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNGaXJzdCkge1xuICAgICAgICAgICAgdGhpcy5oYXNGaXJzdCA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3Vic2NyaXB0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpICE9PSBvdXRlckluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGlzLnN1YnNjcmlwdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZShzdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KGlubmVyVmFsdWUpO1xuICAgIH07XG4gICAgcmV0dXJuIFJhY2VTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbmV4cG9ydHMuUmFjZVN1YnNjcmliZXIgPSBSYWNlU3Vic2NyaWJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJhY2UuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3IvcmFjZS5qc1xuLy8gbW9kdWxlIGlkID0gNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJy4uL3NjaGVkdWxlci9hc3luYycpO1xuLyoqXG4gKiBAcGFyYW0gc2NoZWR1bGVyXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFRpbWVJbnRlcnZhbDxhbnk+PnxXZWJTb2NrZXRTdWJqZWN0PFQ+fE9ic2VydmFibGU8VD59XG4gKiBAbWV0aG9kIHRpbWVJbnRlcnZhbFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gdGltZUludGVydmFsKHNjaGVkdWxlcikge1xuICAgIGlmIChzY2hlZHVsZXIgPT09IHZvaWQgMCkgeyBzY2hlZHVsZXIgPSBhc3luY18xLmFzeW5jOyB9XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgVGltZUludGVydmFsT3BlcmF0b3Ioc2NoZWR1bGVyKSk7XG59XG5leHBvcnRzLnRpbWVJbnRlcnZhbCA9IHRpbWVJbnRlcnZhbDtcbnZhciBUaW1lSW50ZXJ2YWwgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRpbWVJbnRlcnZhbCh2YWx1ZSwgaW50ZXJ2YWwpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmludGVydmFsID0gaW50ZXJ2YWw7XG4gICAgfVxuICAgIHJldHVybiBUaW1lSW50ZXJ2YWw7XG59KCkpO1xuZXhwb3J0cy5UaW1lSW50ZXJ2YWwgPSBUaW1lSW50ZXJ2YWw7XG47XG52YXIgVGltZUludGVydmFsT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRpbWVJbnRlcnZhbE9wZXJhdG9yKHNjaGVkdWxlcikge1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgVGltZUludGVydmFsT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAob2JzZXJ2ZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgVGltZUludGVydmFsU3Vic2NyaWJlcihvYnNlcnZlciwgdGhpcy5zY2hlZHVsZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBUaW1lSW50ZXJ2YWxPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFRpbWVJbnRlcnZhbFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUaW1lSW50ZXJ2YWxTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRpbWVJbnRlcnZhbFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLmxhc3RUaW1lID0gMDtcbiAgICAgICAgdGhpcy5sYXN0VGltZSA9IHNjaGVkdWxlci5ub3coKTtcbiAgICB9XG4gICAgVGltZUludGVydmFsU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIG5vdyA9IHRoaXMuc2NoZWR1bGVyLm5vdygpO1xuICAgICAgICB2YXIgc3BhbiA9IG5vdyAtIHRoaXMubGFzdFRpbWU7XG4gICAgICAgIHRoaXMubGFzdFRpbWUgPSBub3c7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChuZXcgVGltZUludGVydmFsKHZhbHVlLCBzcGFuKSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGltZUludGVydmFsU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbWVJbnRlcnZhbC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvci90aW1lSW50ZXJ2YWwuanNcbi8vIG1vZHVsZSBpZCA9IDUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIGFzeW5jXzEgPSByZXF1aXJlKCcuLi9zY2hlZHVsZXIvYXN5bmMnKTtcbi8qKlxuICogQHBhcmFtIHNjaGVkdWxlclxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUaW1lc3RhbXA8YW55Pj58V2ViU29ja2V0U3ViamVjdDxUPnxPYnNlcnZhYmxlPFQ+fVxuICogQG1ldGhvZCB0aW1lc3RhbXBcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHRpbWVzdGFtcChzY2hlZHVsZXIpIHtcbiAgICBpZiAoc2NoZWR1bGVyID09PSB2b2lkIDApIHsgc2NoZWR1bGVyID0gYXN5bmNfMS5hc3luYzsgfVxuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFRpbWVzdGFtcE9wZXJhdG9yKHNjaGVkdWxlcikpO1xufVxuZXhwb3J0cy50aW1lc3RhbXAgPSB0aW1lc3RhbXA7XG52YXIgVGltZXN0YW1wID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUaW1lc3RhbXAodmFsdWUsIHRpbWVzdGFtcCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMudGltZXN0YW1wID0gdGltZXN0YW1wO1xuICAgIH1cbiAgICByZXR1cm4gVGltZXN0YW1wO1xufSgpKTtcbmV4cG9ydHMuVGltZXN0YW1wID0gVGltZXN0YW1wO1xuO1xudmFyIFRpbWVzdGFtcE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUaW1lc3RhbXBPcGVyYXRvcihzY2hlZHVsZXIpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgfVxuICAgIFRpbWVzdGFtcE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKG9ic2VydmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFRpbWVzdGFtcFN1YnNjcmliZXIob2JzZXJ2ZXIsIHRoaXMuc2NoZWR1bGVyKSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGltZXN0YW1wT3BlcmF0b3I7XG59KCkpO1xudmFyIFRpbWVzdGFtcFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUaW1lc3RhbXBTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRpbWVzdGFtcFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIH1cbiAgICBUaW1lc3RhbXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgbm93ID0gdGhpcy5zY2hlZHVsZXIubm93KCk7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChuZXcgVGltZXN0YW1wKHZhbHVlLCBub3cpKTtcbiAgICB9O1xuICAgIHJldHVybiBUaW1lc3RhbXBTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGltZXN0YW1wLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9yL3RpbWVzdGFtcC5qc1xuLy8gbW9kdWxlIGlkID0gNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBBc3luY0FjdGlvbl8xID0gcmVxdWlyZSgnLi9Bc3luY0FjdGlvbicpO1xudmFyIEFzeW5jU2NoZWR1bGVyXzEgPSByZXF1aXJlKCcuL0FzeW5jU2NoZWR1bGVyJyk7XG52YXIgVmlydHVhbFRpbWVTY2hlZHVsZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhWaXJ0dWFsVGltZVNjaGVkdWxlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBWaXJ0dWFsVGltZVNjaGVkdWxlcihTY2hlZHVsZXJBY3Rpb24sIG1heEZyYW1lcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoU2NoZWR1bGVyQWN0aW9uID09PSB2b2lkIDApIHsgU2NoZWR1bGVyQWN0aW9uID0gVmlydHVhbEFjdGlvbjsgfVxuICAgICAgICBpZiAobWF4RnJhbWVzID09PSB2b2lkIDApIHsgbWF4RnJhbWVzID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZOyB9XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIFNjaGVkdWxlckFjdGlvbiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZnJhbWU7IH0pO1xuICAgICAgICB0aGlzLm1heEZyYW1lcyA9IG1heEZyYW1lcztcbiAgICAgICAgdGhpcy5mcmFtZSA9IDA7XG4gICAgICAgIHRoaXMuaW5kZXggPSAtMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvbXB0IHRoZSBTY2hlZHVsZXIgdG8gZXhlY3V0ZSBhbGwgb2YgaXRzIHF1ZXVlZCBhY3Rpb25zLCB0aGVyZWZvcmVcbiAgICAgKiBjbGVhcmluZyBpdHMgcXVldWUuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBWaXJ0dWFsVGltZVNjaGVkdWxlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGFjdGlvbnMgPSBfYS5hY3Rpb25zLCBtYXhGcmFtZXMgPSBfYS5tYXhGcmFtZXM7XG4gICAgICAgIHZhciBlcnJvciwgYWN0aW9uO1xuICAgICAgICB3aGlsZSAoKGFjdGlvbiA9IGFjdGlvbnMuc2hpZnQoKSkgJiYgKHRoaXMuZnJhbWUgPSBhY3Rpb24uZGVsYXkpIDw9IG1heEZyYW1lcykge1xuICAgICAgICAgICAgaWYgKGVycm9yID0gYWN0aW9uLmV4ZWN1dGUoYWN0aW9uLnN0YXRlLCBhY3Rpb24uZGVsYXkpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICB3aGlsZSAoYWN0aW9uID0gYWN0aW9ucy5zaGlmdCgpKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVmlydHVhbFRpbWVTY2hlZHVsZXIuZnJhbWVUaW1lRmFjdG9yID0gMTA7XG4gICAgcmV0dXJuIFZpcnR1YWxUaW1lU2NoZWR1bGVyO1xufShBc3luY1NjaGVkdWxlcl8xLkFzeW5jU2NoZWR1bGVyKSk7XG5leHBvcnRzLlZpcnR1YWxUaW1lU2NoZWR1bGVyID0gVmlydHVhbFRpbWVTY2hlZHVsZXI7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFZpcnR1YWxBY3Rpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhWaXJ0dWFsQWN0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFZpcnR1YWxBY3Rpb24oc2NoZWR1bGVyLCB3b3JrLCBpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPT09IHZvaWQgMCkgeyBpbmRleCA9IHNjaGVkdWxlci5pbmRleCArPSAxOyB9XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHNjaGVkdWxlciwgd29yayk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLndvcmsgPSB3b3JrO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuaW5kZXggPSBzY2hlZHVsZXIuaW5kZXggPSBpbmRleDtcbiAgICB9XG4gICAgVmlydHVhbEFjdGlvbi5wcm90b3R5cGUuc2NoZWR1bGUgPSBmdW5jdGlvbiAoc3RhdGUsIGRlbGF5KSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxuICAgICAgICBpZiAoIXRoaXMuaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnNjaGVkdWxlLmNhbGwodGhpcywgc3RhdGUsIGRlbGF5KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBhbiBhY3Rpb24gaXMgcmVzY2hlZHVsZWQsIHdlIHNhdmUgYWxsb2NhdGlvbnMgYnkgbXV0YXRpbmcgaXRzIHN0YXRlLFxuICAgICAgICAvLyBwdXNoaW5nIGl0IHRvIHRoZSBlbmQgb2YgdGhlIHNjaGVkdWxlciBxdWV1ZSwgYW5kIHJlY3ljbGluZyB0aGUgYWN0aW9uLlxuICAgICAgICAvLyBCdXQgc2luY2UgdGhlIFZpcnR1YWxUaW1lU2NoZWR1bGVyIGlzIHVzZWQgZm9yIHRlc3RpbmcsIFZpcnR1YWxBY3Rpb25zXG4gICAgICAgIC8vIG11c3QgYmUgaW1tdXRhYmxlIHNvIHRoZXkgY2FuIGJlIGluc3BlY3RlZCBsYXRlci5cbiAgICAgICAgdmFyIGFjdGlvbiA9IG5ldyBWaXJ0dWFsQWN0aW9uKHRoaXMuc2NoZWR1bGVyLCB0aGlzLndvcmspO1xuICAgICAgICB0aGlzLmFkZChhY3Rpb24pO1xuICAgICAgICByZXR1cm4gYWN0aW9uLnNjaGVkdWxlKHN0YXRlLCBkZWxheSk7XG4gICAgfTtcbiAgICBWaXJ0dWFsQWN0aW9uLnByb3RvdHlwZS5yZXF1ZXN0QXN5bmNJZCA9IGZ1bmN0aW9uIChzY2hlZHVsZXIsIGlkLCBkZWxheSkge1xuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cbiAgICAgICAgdGhpcy5kZWxheSA9IHNjaGVkdWxlci5mcmFtZSArIGRlbGF5O1xuICAgICAgICB2YXIgYWN0aW9ucyA9IHNjaGVkdWxlci5hY3Rpb25zO1xuICAgICAgICBhY3Rpb25zLnB1c2godGhpcyk7XG4gICAgICAgIGFjdGlvbnMuc29ydChWaXJ0dWFsQWN0aW9uLnNvcnRBY3Rpb25zKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBWaXJ0dWFsQWN0aW9uLnByb3RvdHlwZS5yZWN5Y2xlQXN5bmNJZCA9IGZ1bmN0aW9uIChzY2hlZHVsZXIsIGlkLCBkZWxheSkge1xuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIFZpcnR1YWxBY3Rpb24uc29ydEFjdGlvbnMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICBpZiAoYS5kZWxheSA9PT0gYi5kZWxheSkge1xuICAgICAgICAgICAgaWYgKGEuaW5kZXggPT09IGIuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGEuaW5kZXggPiBiLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYS5kZWxheSA+IGIuZGVsYXkpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVmlydHVhbEFjdGlvbjtcbn0oQXN5bmNBY3Rpb25fMS5Bc3luY0FjdGlvbikpO1xuZXhwb3J0cy5WaXJ0dWFsQWN0aW9uID0gVmlydHVhbEFjdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZpcnR1YWxUaW1lU2NoZWR1bGVyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL3NjaGVkdWxlci9WaXJ0dWFsVGltZVNjaGVkdWxlci5qc1xuLy8gbW9kdWxlIGlkID0gNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQXNhcEFjdGlvbl8xID0gcmVxdWlyZSgnLi9Bc2FwQWN0aW9uJyk7XG52YXIgQXNhcFNjaGVkdWxlcl8xID0gcmVxdWlyZSgnLi9Bc2FwU2NoZWR1bGVyJyk7XG4vKipcbiAqXG4gKiBBc2FwIFNjaGVkdWxlclxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5QZXJmb3JtIHRhc2sgYXMgZmFzdCBhcyBpdCBjYW4gYmUgcGVyZm9ybWVkIGFzeW5jaHJvbm91c2x5PC9zcGFuPlxuICpcbiAqIGBhc2FwYCBzY2hlZHVsZXIgYmVoYXZlcyB0aGUgc2FtZSBhcyB7QGxpbmsgYXN5bmN9IHNjaGVkdWxlciB3aGVuIHlvdSB1c2UgaXQgdG8gZGVsYXkgdGFza1xuICogaW4gdGltZS4gSWYgaG93ZXZlciB5b3Ugc2V0IGRlbGF5IHRvIGAwYCwgYGFzYXBgIHdpbGwgd2FpdCBmb3IgY3VycmVudCBzeW5jaHJvbm91c2x5IGV4ZWN1dGluZ1xuICogY29kZSB0byBlbmQgYW5kIHRoZW4gaXQgd2lsbCB0cnkgdG8gZXhlY3V0ZSBnaXZlbiB0YXNrIGFzIGZhc3QgYXMgcG9zc2libGUuXG4gKlxuICogYGFzYXBgIHNjaGVkdWxlciB3aWxsIGRvIGl0cyBiZXN0IHRvIG1pbmltaXplIHRpbWUgYmV0d2VlbiBlbmQgb2YgY3VycmVudGx5IGV4ZWN1dGluZyBjb2RlXG4gKiBhbmQgc3RhcnQgb2Ygc2NoZWR1bGVkIHRhc2suIFRoaXMgbWFrZXMgaXQgYmVzdCBjYW5kaWRhdGUgZm9yIHBlcmZvcm1pbmcgc28gY2FsbGVkIFwiZGVmZXJyaW5nXCIuXG4gKiBUcmFkaXRpb25hbGx5IHRoaXMgd2FzIGFjaGlldmVkIGJ5IGNhbGxpbmcgYHNldFRpbWVvdXQoZGVmZXJyZWRUYXNrLCAwKWAsIGJ1dCB0aGF0IHRlY2huaXF1ZSBpbnZvbHZlc1xuICogc29tZSAoYWx0aG91Z2ggbWluaW1hbCkgdW53YW50ZWQgZGVsYXkuXG4gKlxuICogTm90ZSB0aGF0IHVzaW5nIGBhc2FwYCBzY2hlZHVsZXIgZG9lcyBub3QgbmVjZXNzYXJpbHkgbWVhbiB0aGF0IHlvdXIgdGFzayB3aWxsIGJlIGZpcnN0IHRvIHByb2Nlc3NcbiAqIGFmdGVyIGN1cnJlbnRseSBleGVjdXRpbmcgY29kZS4gSW4gcGFydGljdWxhciwgaWYgc29tZSB0YXNrIHdhcyBhbHNvIHNjaGVkdWxlZCB3aXRoIGBhc2FwYCBiZWZvcmUsXG4gKiB0aGF0IHRhc2sgd2lsbCBleGVjdXRlIGZpcnN0LiBUaGF0IGJlaW5nIHNhaWQsIGlmIHlvdSBuZWVkIHRvIHNjaGVkdWxlIHRhc2sgYXN5bmNocm9ub3VzbHksIGJ1dFxuICogYXMgc29vbiBhcyBwb3NzaWJsZSwgYGFzYXBgIHNjaGVkdWxlciBpcyB5b3VyIGJlc3QgYmV0LlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNvbXBhcmUgYXN5bmMgYW5kIGFzYXAgc2NoZWR1bGVyPC9jYXB0aW9uPlxuICpcbiAqIFJ4LlNjaGVkdWxlci5hc3luYy5zY2hlZHVsZSgoKSA9PiBjb25zb2xlLmxvZygnYXN5bmMnKSk7IC8vIHNjaGVkdWxpbmcgJ2FzeW5jJyBmaXJzdC4uLlxuICogUnguU2NoZWR1bGVyLmFzYXAuc2NoZWR1bGUoKCkgPT4gY29uc29sZS5sb2coJ2FzYXAnKSk7XG4gKlxuICogLy8gTG9nczpcbiAqIC8vIFwiYXNhcFwiXG4gKiAvLyBcImFzeW5jXCJcbiAqIC8vIC4uLiBidXQgJ2FzYXAnIGdvZXMgZmlyc3QhXG4gKlxuICogQHN0YXRpYyB0cnVlXG4gKiBAbmFtZSBhc2FwXG4gKiBAb3duZXIgU2NoZWR1bGVyXG4gKi9cbmV4cG9ydHMuYXNhcCA9IG5ldyBBc2FwU2NoZWR1bGVyXzEuQXNhcFNjaGVkdWxlcihBc2FwQWN0aW9uXzEuQXNhcEFjdGlvbik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc2FwLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL3NjaGVkdWxlci9hc2FwLmpzXG4vLyBtb2R1bGUgaWQgPSA1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBRdWV1ZUFjdGlvbl8xID0gcmVxdWlyZSgnLi9RdWV1ZUFjdGlvbicpO1xudmFyIFF1ZXVlU2NoZWR1bGVyXzEgPSByZXF1aXJlKCcuL1F1ZXVlU2NoZWR1bGVyJyk7XG4vKipcbiAqXG4gKiBRdWV1ZSBTY2hlZHVsZXJcbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+UHV0IGV2ZXJ5IG5leHQgdGFzayBvbiBhIHF1ZXVlLCBpbnN0ZWFkIG9mIGV4ZWN1dGluZyBpdCBpbW1lZGlhdGVseTwvc3Bhbj5cbiAqXG4gKiBgcXVldWVgIHNjaGVkdWxlciwgd2hlbiB1c2VkIHdpdGggZGVsYXksIGJlaGF2ZXMgdGhlIHNhbWUgYXMge0BsaW5rIGFzeW5jfSBzY2hlZHVsZXIuXG4gKlxuICogV2hlbiB1c2VkIHdpdGhvdXQgZGVsYXksIGl0IHNjaGVkdWxlcyBnaXZlbiB0YXNrIHN5bmNocm9ub3VzbHkgLSBleGVjdXRlcyBpdCByaWdodCB3aGVuXG4gKiBpdCBpcyBzY2hlZHVsZWQuIEhvd2V2ZXIgd2hlbiBjYWxsZWQgcmVjdXJzaXZlbHksIHRoYXQgaXMgd2hlbiBpbnNpZGUgdGhlIHNjaGVkdWxlZCB0YXNrLFxuICogYW5vdGhlciB0YXNrIGlzIHNjaGVkdWxlZCB3aXRoIHF1ZXVlIHNjaGVkdWxlciwgaW5zdGVhZCBvZiBleGVjdXRpbmcgaW1tZWRpYXRlbHkgYXMgd2VsbCxcbiAqIHRoYXQgdGFzayB3aWxsIGJlIHB1dCBvbiBhIHF1ZXVlIGFuZCB3YWl0IGZvciBjdXJyZW50IG9uZSB0byBmaW5pc2guXG4gKlxuICogVGhpcyBtZWFucyB0aGF0IHdoZW4geW91IGV4ZWN1dGUgdGFzayB3aXRoIGBxdWV1ZWAgc2NoZWR1bGVyLCB5b3UgYXJlIHN1cmUgaXQgd2lsbCBlbmRcbiAqIGJlZm9yZSBhbnkgb3RoZXIgdGFzayBzY2hlZHVsZWQgd2l0aCB0aGF0IHNjaGVkdWxlciB3aWxsIHN0YXJ0LlxuICpcbiAqIEBleGFtcGxlcyA8Y2FwdGlvbj5TY2hlZHVsZSByZWN1cnNpdmVseSBmaXJzdCwgdGhlbiBkbyBzb21ldGhpbmc8L2NhcHRpb24+XG4gKlxuICogUnguU2NoZWR1bGVyLnF1ZXVlLnNjaGVkdWxlKCgpID0+IHtcbiAqICAgUnguU2NoZWR1bGVyLnF1ZXVlLnNjaGVkdWxlKCgpID0+IGNvbnNvbGUubG9nKCdzZWNvbmQnKSk7IC8vIHdpbGwgbm90IGhhcHBlbiBub3csIGJ1dCB3aWxsIGJlIHB1dCBvbiBhIHF1ZXVlXG4gKlxuICogICBjb25zb2xlLmxvZygnZmlyc3QnKTtcbiAqIH0pO1xuICpcbiAqIC8vIExvZ3M6XG4gKiAvLyBcImZpcnN0XCJcbiAqIC8vIFwic2Vjb25kXCJcbiAqXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+UmVzY2hlZHVsZSBpdHNlbGYgcmVjdXJzaXZlbHk8L2NhcHRpb24+XG4gKlxuICogUnguU2NoZWR1bGVyLnF1ZXVlLnNjaGVkdWxlKGZ1bmN0aW9uKHN0YXRlKSB7XG4gKiAgIGlmIChzdGF0ZSAhPT0gMCkge1xuICogICAgIGNvbnNvbGUubG9nKCdiZWZvcmUnLCBzdGF0ZSk7XG4gKiAgICAgdGhpcy5zY2hlZHVsZShzdGF0ZSAtIDEpOyAvLyBgdGhpc2AgcmVmZXJlbmNlcyBjdXJyZW50bHkgZXhlY3V0aW5nIEFjdGlvbixcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoIHdlIHJlc2NoZWR1bGUgd2l0aCBuZXcgc3RhdGVcbiAqICAgICBjb25zb2xlLmxvZygnYWZ0ZXInLCBzdGF0ZSk7XG4gKiAgIH1cbiAqIH0sIDAsIDMpO1xuICpcbiAqIC8vIEluIHNjaGVkdWxlciB0aGF0IHJ1bnMgcmVjdXJzaXZlbHksIHlvdSB3b3VsZCBleHBlY3Q6XG4gKiAvLyBcImJlZm9yZVwiLCAzXG4gKiAvLyBcImJlZm9yZVwiLCAyXG4gKiAvLyBcImJlZm9yZVwiLCAxXG4gKiAvLyBcImFmdGVyXCIsIDFcbiAqIC8vIFwiYWZ0ZXJcIiwgMlxuICogLy8gXCJhZnRlclwiLCAzXG4gKlxuICogLy8gQnV0IHdpdGggcXVldWUgaXQgbG9nczpcbiAqIC8vIFwiYmVmb3JlXCIsIDNcbiAqIC8vIFwiYWZ0ZXJcIiwgM1xuICogLy8gXCJiZWZvcmVcIiwgMlxuICogLy8gXCJhZnRlclwiLCAyXG4gKiAvLyBcImJlZm9yZVwiLCAxXG4gKiAvLyBcImFmdGVyXCIsIDFcbiAqXG4gKlxuICogQHN0YXRpYyB0cnVlXG4gKiBAbmFtZSBxdWV1ZVxuICogQG93bmVyIFNjaGVkdWxlclxuICovXG5leHBvcnRzLnF1ZXVlID0gbmV3IFF1ZXVlU2NoZWR1bGVyXzEuUXVldWVTY2hlZHVsZXIoUXVldWVBY3Rpb25fMS5RdWV1ZUFjdGlvbik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWV1ZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9zY2hlZHVsZXIvcXVldWUuanNcbi8vIG1vZHVsZSBpZCA9IDU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIFN1YnNjcmlwdGlvbkxvZyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3Vic2NyaXB0aW9uTG9nKHN1YnNjcmliZWRGcmFtZSwgdW5zdWJzY3JpYmVkRnJhbWUpIHtcbiAgICAgICAgaWYgKHVuc3Vic2NyaWJlZEZyYW1lID09PSB2b2lkIDApIHsgdW5zdWJzY3JpYmVkRnJhbWUgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7IH1cbiAgICAgICAgdGhpcy5zdWJzY3JpYmVkRnJhbWUgPSBzdWJzY3JpYmVkRnJhbWU7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmVkRnJhbWUgPSB1bnN1YnNjcmliZWRGcmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIFN1YnNjcmlwdGlvbkxvZztcbn0oKSk7XG5leHBvcnRzLlN1YnNjcmlwdGlvbkxvZyA9IFN1YnNjcmlwdGlvbkxvZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1YnNjcmlwdGlvbkxvZy5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy90ZXN0aW5nL1N1YnNjcmlwdGlvbkxvZy5qc1xuLy8gbW9kdWxlIGlkID0gNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgU3Vic2NyaXB0aW9uTG9nXzEgPSByZXF1aXJlKCcuL1N1YnNjcmlwdGlvbkxvZycpO1xudmFyIFN1YnNjcmlwdGlvbkxvZ2dhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdWJzY3JpcHRpb25Mb2dnYWJsZSgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gW107XG4gICAgfVxuICAgIFN1YnNjcmlwdGlvbkxvZ2dhYmxlLnByb3RvdHlwZS5sb2dTdWJzY3JpYmVkRnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKG5ldyBTdWJzY3JpcHRpb25Mb2dfMS5TdWJzY3JpcHRpb25Mb2codGhpcy5zY2hlZHVsZXIubm93KCkpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3Vic2NyaXB0aW9ucy5sZW5ndGggLSAxO1xuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uTG9nZ2FibGUucHJvdG90eXBlLmxvZ1Vuc3Vic2NyaWJlZEZyYW1lID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb25Mb2dzID0gdGhpcy5zdWJzY3JpcHRpb25zO1xuICAgICAgICB2YXIgb2xkU3Vic2NyaXB0aW9uTG9nID0gc3Vic2NyaXB0aW9uTG9nc1tpbmRleF07XG4gICAgICAgIHN1YnNjcmlwdGlvbkxvZ3NbaW5kZXhdID0gbmV3IFN1YnNjcmlwdGlvbkxvZ18xLlN1YnNjcmlwdGlvbkxvZyhvbGRTdWJzY3JpcHRpb25Mb2cuc3Vic2NyaWJlZEZyYW1lLCB0aGlzLnNjaGVkdWxlci5ub3coKSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3Vic2NyaXB0aW9uTG9nZ2FibGU7XG59KCkpO1xuZXhwb3J0cy5TdWJzY3JpcHRpb25Mb2dnYWJsZSA9IFN1YnNjcmlwdGlvbkxvZ2dhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3Vic2NyaXB0aW9uTG9nZ2FibGUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvdGVzdGluZy9TdWJzY3JpcHRpb25Mb2dnYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbi8qKlxuICogQW4gZXJyb3IgdGhyb3duIHdoZW4gZHVldGltZSBlbGFwc2VzLlxuICpcbiAqIEBzZWUge0BsaW5rIHRpbWVvdXR9XG4gKlxuICogQGNsYXNzIFRpbWVvdXRFcnJvclxuICovXG52YXIgVGltZW91dEVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGltZW91dEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRpbWVvdXRFcnJvcigpIHtcbiAgICAgICAgdmFyIGVyciA9IF9zdXBlci5jYWxsKHRoaXMsICdUaW1lb3V0IGhhcyBvY2N1cnJlZCcpO1xuICAgICAgICB0aGlzLm5hbWUgPSBlcnIubmFtZSA9ICdUaW1lb3V0RXJyb3InO1xuICAgICAgICB0aGlzLnN0YWNrID0gZXJyLnN0YWNrO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuIFRpbWVvdXRFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuVGltZW91dEVycm9yID0gVGltZW91dEVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGltZW91dEVycm9yLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL3V0aWwvVGltZW91dEVycm9yLmpzXG4vLyBtb2R1bGUgaWQgPSA2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xuLyoqXG4gKiBBbiBlcnJvciB0aHJvd24gd2hlbiBvbmUgb3IgbW9yZSBlcnJvcnMgaGF2ZSBvY2N1cnJlZCBkdXJpbmcgdGhlXG4gKiBgdW5zdWJzY3JpYmVgIG9mIGEge0BsaW5rIFN1YnNjcmlwdGlvbn0uXG4gKi9cbnZhciBVbnN1YnNjcmlwdGlvbkVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVW5zdWJzY3JpcHRpb25FcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBVbnN1YnNjcmlwdGlvbkVycm9yKGVycm9ycykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIHZhciBlcnIgPSBFcnJvci5jYWxsKHRoaXMsIGVycm9ycyA/XG4gICAgICAgICAgICBlcnJvcnMubGVuZ3RoICsgXCIgZXJyb3JzIG9jY3VycmVkIGR1cmluZyB1bnN1YnNjcmlwdGlvbjpcXG4gIFwiICsgZXJyb3JzLm1hcChmdW5jdGlvbiAoZXJyLCBpKSB7IHJldHVybiAoKGkgKyAxKSArIFwiKSBcIiArIGVyci50b1N0cmluZygpKTsgfSkuam9pbignXFxuICAnKSA6ICcnKTtcbiAgICAgICAgdGhpcy5uYW1lID0gZXJyLm5hbWUgPSAnVW5zdWJzY3JpcHRpb25FcnJvcic7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBlcnIuc3RhY2s7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGVyci5tZXNzYWdlO1xuICAgIH1cbiAgICByZXR1cm4gVW5zdWJzY3JpcHRpb25FcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuVW5zdWJzY3JpcHRpb25FcnJvciA9IFVuc3Vic2NyaXB0aW9uRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1VbnN1YnNjcmlwdGlvbkVycm9yLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL3V0aWwvVW5zdWJzY3JpcHRpb25FcnJvci5qc1xuLy8gbW9kdWxlIGlkID0gNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBhcHBseU1peGlucyhkZXJpdmVkQ3RvciwgYmFzZUN0b3JzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJhc2VDdG9ycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgYmFzZUN0b3IgPSBiYXNlQ3RvcnNbaV07XG4gICAgICAgIHZhciBwcm9wZXJ0eUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhiYXNlQ3Rvci5wcm90b3R5cGUpO1xuICAgICAgICBmb3IgKHZhciBqID0gMCwgbGVuMiA9IHByb3BlcnR5S2V5cy5sZW5ndGg7IGogPCBsZW4yOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBuYW1lXzEgPSBwcm9wZXJ0eUtleXNbal07XG4gICAgICAgICAgICBkZXJpdmVkQ3Rvci5wcm90b3R5cGVbbmFtZV8xXSA9IGJhc2VDdG9yLnByb3RvdHlwZVtuYW1lXzFdO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5hcHBseU1peGlucyA9IGFwcGx5TWl4aW5zO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwbHlNaXhpbnMuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvdXRpbC9hcHBseU1peGlucy5qc1xuLy8gbW9kdWxlIGlkID0gNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmlzQXJyYXlMaWtlID0gKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICYmIHR5cGVvZiB4Lmxlbmd0aCA9PT0gJ251bWJlcic7IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNBcnJheUxpa2UuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvdXRpbC9pc0FycmF5TGlrZS5qc1xuLy8gbW9kdWxlIGlkID0gNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBpc09iamVjdCh4KSB7XG4gICAgcmV0dXJuIHggIT0gbnVsbCAmJiB0eXBlb2YgeCA9PT0gJ29iamVjdCc7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc09iamVjdC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy91dGlsL2lzT2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGlzUHJvbWlzZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUuc3Vic2NyaWJlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc1Byb21pc2UgPSBpc1Byb21pc2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc1Byb21pc2UuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvdXRpbC9pc1Byb21pc2UuanNcbi8vIG1vZHVsZSBpZCA9IDY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuLyogdHNsaW50OmRpc2FibGU6bm8tZW1wdHkgKi9cbmZ1bmN0aW9uIG5vb3AoKSB7IH1cbmV4cG9ydHMubm9vcCA9IG5vb3A7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub29wLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL3V0aWwvbm9vcC5qc1xuLy8gbW9kdWxlIGlkID0gNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qc1xuLy8gbW9kdWxlIGlkID0gNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSA2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgKiBhcyBzb3VyY2VzIGZyb20gJy4vc291cmNlcyc7XG5pbXBvcnQgc2VsZWN0aW9uIGZyb20gJy4vc2VsZWN0aW9uJztcbmltcG9ydCB7T2JzZXJ2YWJsZX0gZnJvbSAncnhqcyc7XG5cbmxldCBpcGNSZW5kZXJlciA9IHdpbmRvdy5pcGNSZW5kZXJlcjtcbmxldCBpc0VsZWN0cm9uID0gISFpcGNSZW5kZXJlcjtcblxuZnVuY3Rpb24gaXNUb3AgKCkge1xuICAgIHJldHVybiB3aW5kb3cudG9wID09PSB3aW5kb3c7XG59XG5cbmZ1bmN0aW9uIGhhc1BlbmRvQWdlbnQgKCkge1xuICAgIHJldHVybiB3aW5kb3cucGVuZG8gJiYgd2luZG93LnBlbmRvLmlzUmVhZHkgJiYgd2luZG93LnBlbmRvLmlzUmVhZHkoKTtcbn1cblxuZnVuY3Rpb24gdHlwZUVxdWFscyAodHlwZSkge1xuICAgIHJldHVybiAoZXZlbnQpID0+IGV2ZW50LmRhdGEudHlwZSA9PT0gdHlwZTtcbn1cblxuZnVuY3Rpb24gZGVzdGluYXRpb25FcXVhbHMgKGRlc3RpbmF0aW9uKSB7XG4gICAgcmV0dXJuIChldmVudCkgPT4gZXZlbnQuZGF0YS5kZXN0aW5hdGlvbiA9PT0gZGVzdGluYXRpb247XG59XG5cbmZ1bmN0aW9uIG9wZW5QYW5lbElmQ2xvc2VkIChldmVudCkge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwZW5kby1kZXNpZ25lci1jb250YWluZXInKTtcbiAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKCdjbG9zZWQnKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlY2VpdmVGcmFtZUluZm8gKGZyYW1lcykge1xuICAgIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgIGNvbnN0IGZyYW1lID0gZnJhbWVzLmZpbmQoKGYpID0+IGYud2luZG93ID09PSBldmVudC5zb3VyY2UpO1xuXG4gICAgICAgIGlmIChmcmFtZSkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihmcmFtZSwgbWVzc2FnZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcmFtZXMucHVzaChPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICBpZDogZnJhbWVzLmxlbmd0aCArIDEsXG4gICAgICAgICAgICAgICAgd2luZG93OiBldmVudC5zb3VyY2VcbiAgICAgICAgICAgIH0sIG1lc3NhZ2UpKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHNlbmRGcmFtZUluZm8gKCkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgIHR5cGU6ICdmcmFtZV9pbmZvJyxcbiAgICAgICAgc291cmNlOiBzb3VyY2VzLnBsdWdpbixcbiAgICAgICAgZGVzdGluYXRpb246IHNvdXJjZXMucGx1Z2luLFxuICAgICAgICB1cmw6IGxvY2F0aW9uLmhyZWYsXG4gICAgICAgIGlzVG9wOiBpc1RvcCgpXG4gICAgfTtcbiAgICBpZiAoaGFzUGVuZG9BZ2VudCgpKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24obWVzc2FnZSwge1xuICAgICAgICAgICAgYWdlbnQ6IHtcbiAgICAgICAgICAgICAgICBFTlY6IHdpbmRvdy5wZW5kby5FTlYsXG4gICAgICAgICAgICAgICAgSE9TVDogd2luZG93LnBlbmRvLkhPU1QsXG4gICAgICAgICAgICAgICAgaG9zdExvY2F0aW9uOiBsb2NhdGlvbi5vcmlnaW5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHdpbmRvdy50b3AucG9zdE1lc3NhZ2UobWVzc2FnZSwgJyonKTtcbn1cblxuZnVuY3Rpb24gcmVhZFBlbmRvQWdlbnRTZXR0aW5ncyAoZnJhbWVzKSB7XG4gICAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCBmcmFtZSA9IGZyYW1lcy5maW5kKChmKSA9PiBmLmFnZW50KTtcblxuICAgICAgICBjb25zdCBtZXNzYWdlT2JqID0ge1xuICAgICAgICAgICAgdHlwZTogJ3BlbmRvX2FnZW50X3NldHRpbmdzJyxcbiAgICAgICAgICAgIHNvdXJjZTogc291cmNlcy5wbHVnaW4sXG4gICAgICAgICAgICBwYXlsb2FkOiBmcmFtZSAmJiBmcmFtZS5hZ2VudCxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uOiBzb3VyY2VzLmRlc2lnbmVyXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGlzRWxlY3Ryb24pIHtcbiAgICAgICAgICAgIGlwY1JlbmRlcmVyLnNlbmQoJ3BlbmRvLWRlc2lnbmVyLW1lc3NhZ2UnLCBtZXNzYWdlT2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV2ZW50LnNvdXJjZS5wb3N0TWVzc2FnZShtZXNzYWdlT2JqLCAnKicpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcmVhZExvY2F0aW9uIChmcmFtZXMpIHtcbiAgICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGZyYW1lID0gZnJhbWVzLmZpbmQoKGYpID0+IGYuYWdlbnQpO1xuXG4gICAgICAgIGNvbnN0IG1lc3NhZ2VPYmogPSB7XG4gICAgICAgICAgICB0eXBlOiAncmVtb3RlX2xvY2F0aW9uJyxcbiAgICAgICAgICAgIHVybDogZnJhbWUudXJsLFxuICAgICAgICAgICAgc291cmNlOiBzb3VyY2VzLnBsdWdpbixcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uOiBzb3VyY2VzLmRlc2lnbmVyXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGlzRWxlY3Ryb24pIHtcbiAgICAgICAgICAgIGlwY1JlbmRlcmVyLnNlbmQoJ3BlbmRvLWRlc2lnbmVyLW1lc3NhZ2UnLCBtZXNzYWdlT2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV2ZW50LnNvdXJjZS5wb3N0TWVzc2FnZShtZXNzYWdlT2JqLCAnKicpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZm9yd2FyZFRvRnJhbWVzV2l0aEFuSW5zdGFsbGVkQWdlbnQgKGZyYW1lcywgdG9wV2luZG93KSB7XG4gICAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgZnJhbWVzLmZpbHRlcigoZikgPT4ge1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZnJhbWVJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmLmlkID09PSBtZXNzYWdlLmZyYW1lSWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmLmFnZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS5maWx0ZXIoKGYpID0+IHtcbiAgICAgICAgICAgIC8vIHRoZSB0b3Agd2luZG93IGFscmVhZHkgaGFzIGEgaGFuZGxlciBhdHRhY2hlZCBmb3IgYWdlbnQtYm91bmQgbWVzc2FnZXNcbiAgICAgICAgICAgIHJldHVybiBmLndpbmRvdyAhPT0gdG9wV2luZG93O1xuICAgICAgICB9KS5mb3JFYWNoKChmKSA9PiB7XG4gICAgICAgICAgICBmLndpbmRvdy5wb3N0TWVzc2FnZShtZXNzYWdlLCAnKicpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBoYW5kbGVHdWlkZVByZXZpZXcgKGZyYW1lcykge1xuICAgIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICAgICAgLy8gRklYTUUgLSBzcGVjaWFsIGNhc2UgZm9yIGd1aWRlIHByZXZpZXcsIG9ubHkgcHJldmlldyBpbiB0aGUgdG9wLW1vc3RcbiAgICAgICAgLy8gZnJhbWUsIGZvciBub3cuIEV2ZW50dWFsbHksIHByZXZpZXcgaW4gdGhlIGNvcnJlY3QgZnJhbWUsIGlmIHBvc3NpYmxlLFxuICAgICAgICAvLyBvciBqdXN0IGZsb2F0IGluIHRoZSB0b3AtbW9zdC5cbiAgICAgICAgY29uc3QgdG9wRnJhbWUgPSBmcmFtZXMuZmluZCgoZikgPT4gZi5pc1RvcCk7XG4gICAgICAgIGNvbnN0IGZyYW1lID0gZnJhbWVzLmZpbmQoKGYpID0+IGYuYWdlbnQgJiYgIWYuaXNUb3ApO1xuXG4gICAgICAgIGlmIChmcmFtZSAmJiAhdG9wRnJhbWUuYWdlbnQpIHtcbiAgICAgICAgICAgIGZyYW1lLndpbmRvdy5wb3N0TWVzc2FnZShldmVudC5kYXRhLCAnKicpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZm9yd2FyZFRvQ29udGVudFNjcmlwdCAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuc291cmNlID09PSB3aW5kb3cpIHJldHVybjtcbiAgICB3aW5kb3cucG9zdE1lc3NhZ2UoZXZlbnQuZGF0YSwgJyonKTtcbn1cblxuZnVuY3Rpb24gZm9yd2FyZFRvRGVzaWduZXIgKGZyYW1lcykge1xuICAgIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgIGNvbnN0IGZyYW1lID0gZnJhbWVzLmZpbmQoKGYpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBmLndpbmRvdyA9PT0gZXZlbnQuc291cmNlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGZyYW1lKSB7XG4gICAgICAgICAgICBtZXNzYWdlLmZyYW1lSWQgPSBmcmFtZS5pZDtcbiAgICAgICAgfVxuICAgICAgICBzZW5kVG9EZXNpZ25lcihtZXNzYWdlKTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBwb2xsRm9yUGVuZG9BZ2VudCAoKSB7XG4gICAgaWYgKGhhc1BlbmRvQWdlbnQoKSkge1xuICAgICAgICBzdGFydEFnZW50TWVzc2FnZUxpc3RlbmVyKCk7XG4gICAgICAgIHNlbmRGcmFtZUluZm8oKTtcbiAgICAgICAgd2luZG93LnBlbmRvLnVybC53YXRjaChzZW5kRnJhbWVJbmZvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzZXRUaW1lb3V0KHBvbGxGb3JQZW5kb0FnZW50LCAxMDAwKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNlbmRUb0Rlc2lnbmVyIChtZXNzYWdlKSB7XG4gICAgaWYgKGlzRWxlY3Ryb24pIHtcbiAgICAgICAgaXBjUmVuZGVyZXIuc2VuZCgncGVuZG8tZGVzaWduZXItbWVzc2FnZScsIG1lc3NhZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGZyYW1lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BlbmRvLWRlc2lnbmVyLWlmcmFtZScpO1xuICAgICAgICBpZiAoZnJhbWUgJiYgZnJhbWUuY29udGVudFdpbmRvdykge1xuICAgICAgICAgICAgZnJhbWUuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZShtZXNzYWdlLCAnKicpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzdGFydEFnZW50TWVzc2FnZUxpc3RlbmVyICgpIHtcbiAgICBpZiAoIXdpbmRvdy5wZW5kbykgcmV0dXJuO1xuXG4gICAgLy8gVGhlIGFnZW50IGRvZXNuJ3QgbGlzdGVuIHRvIG1lc3NhZ2VzIGlmIGl0IGlzbid0IGluIGFuIGlmcmFtZVxuICAgIGNvbnN0IGFnZW50ID0gT2JzZXJ2YWJsZS5mcm9tRXZlbnQod2luZG93LCAnbWVzc2FnZScpXG4gICAgICAgIC5maWx0ZXIoZGVzdGluYXRpb25FcXVhbHMoc291cmNlcy5hZ2VudCkpO1xuXG4gICAgYWdlbnQuc3Vic2NyaWJlKHdpbmRvdy5wZW5kby5tZXNzYWdlRGlzcGF0Y2hlcik7IC8vIFNraXAgXCJ2YWxpZGF0aW9uXCIgKHBhcnNpbmcpIGFuZCBvcmlnaW4gdGVzdGluZ1xuXG4gICAgYWdlbnQuZmlsdGVyKHR5cGVFcXVhbHMoJ2Nvbm5lY3QnKSlcbiAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICBpZiAod2luZG93LnNlbG1vKSByZXR1cm47XG4gICAgICAgICAgICBzZWxlY3Rpb24od2luZG93LCBkb2N1bWVudCk7XG4gICAgICAgIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RhcnRGcmFtZU1lc3NhZ2VSb3V0ZXIgKCkge1xuICAgIGlmICghaXNUb3AoKSkgcmV0dXJuO1xuXG4gICAgaWYgKGlzRWxlY3Ryb24pIHtcbiAgICAgICAgaXBjUmVuZGVyZXIub24oJ3BlbmRvLWRlc2lnbmVyLW1lc3NhZ2UnLCAoZXZlbnQsIG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZShtZXNzYWdlLCAnKicpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBmcmFtZXMgPSBbXTtcblxuICAgIGNvbnN0IG1lc3NhZ2VzID0gT2JzZXJ2YWJsZS5mcm9tRXZlbnQod2luZG93LCAnbWVzc2FnZScpXG4gICAgICAgIC5maWx0ZXIoKGV2ZW50KSA9PiAhIWV2ZW50LmRhdGEpO1xuXG4gICAgY29uc3QgcGx1Z2luID0gbWVzc2FnZXMuZmlsdGVyKGRlc3RpbmF0aW9uRXF1YWxzKHNvdXJjZXMucGx1Z2luKSk7XG5cbiAgICBwbHVnaW4uZmlsdGVyKHR5cGVFcXVhbHMoJ2ZyYW1lX2luZm8nKSlcbiAgICAgICAgLnN1YnNjcmliZShyZWNlaXZlRnJhbWVJbmZvKGZyYW1lcykpO1xuXG4gICAgcGx1Z2luLmZpbHRlcih0eXBlRXF1YWxzKCdyZWFkX3BlbmRvX2FnZW50X3NldHRpbmdzJykpXG4gICAgICAgIC5zdWJzY3JpYmUocmVhZFBlbmRvQWdlbnRTZXR0aW5ncyhmcmFtZXMpKTtcblxuICAgIHBsdWdpbi5maWx0ZXIodHlwZUVxdWFscygnb3Blbl9wYW5lbF9pZl9jbG9zZWQnKSlcbiAgICAgICAgLnN1YnNjcmliZShvcGVuUGFuZWxJZkNsb3NlZCk7XG5cbiAgICBwbHVnaW4uZmlsdGVyKHR5cGVFcXVhbHMoJ3JlYWRfbG9jYXRpb24nKSlcbiAgICAgICAgLnN1YnNjcmliZShyZWFkTG9jYXRpb24oZnJhbWVzKSk7XG5cbiAgICBjb25zdCBhZ2VudCA9IG1lc3NhZ2VzLmZpbHRlcihkZXN0aW5hdGlvbkVxdWFscyhzb3VyY2VzLmFnZW50KSk7XG5cbiAgICBhZ2VudC5maWx0ZXIoKGV2ZW50KSA9PiBldmVudC5kYXRhLnR5cGUgIT09ICdwcmV2aWV3LWd1aWRlJylcbiAgICAgICAgLnN1YnNjcmliZShmb3J3YXJkVG9GcmFtZXNXaXRoQW5JbnN0YWxsZWRBZ2VudChmcmFtZXMsIHdpbmRvdykpO1xuXG4gICAgYWdlbnQuZmlsdGVyKHR5cGVFcXVhbHMoJ3ByZXZpZXctZ3VpZGUnKSlcbiAgICAgICAgLnN1YnNjcmliZShoYW5kbGVHdWlkZVByZXZpZXcoZnJhbWVzKSk7XG5cbiAgICBtZXNzYWdlcy5maWx0ZXIoZGVzdGluYXRpb25FcXVhbHMoc291cmNlcy5iYWNrZ3JvdW5kKSlcbiAgICAgICAgLnN1YnNjcmliZShmb3J3YXJkVG9Db250ZW50U2NyaXB0KTtcblxuICAgIG1lc3NhZ2VzLmZpbHRlcihkZXN0aW5hdGlvbkVxdWFscyhzb3VyY2VzLmRlc2lnbmVyKSlcbiAgICAgICAgLnN1YnNjcmliZShmb3J3YXJkVG9EZXNpZ25lcihmcmFtZXMpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyV2l0aEZyYW1lTWVzc2FnZVJvdXRlciAoKSB7XG4gICAgc2VuZEZyYW1lSW5mbygpO1xuICAgIHBvbGxGb3JQZW5kb0FnZW50KCk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wbHVnaW5zL2ZyYW1lcy5qcyIsIi8qZXNsaW50LWRpc2FibGUqL1xuLy8gdG9vIG1hbnkgZXNsaW50IHZpb2xhdGlvbnMsIHRoaXMgZmlsZSBoYXMgYSBoaWdoIHJpc2sgb2YgYmVpbmcgZGFtYWdlZCBcbi8vIGJ5IGVzbGludCBtb2RpZmljYXRpb25zXG5cbi8qXG4gIGh0bWwyY2FudmFzIDAuNC4xIDxodHRwOi8vaHRtbDJjYW52YXMuaGVydHplbi5jb20+XG4gIENvcHlyaWdodCAoYykgMjAxMyBOaWtsYXMgdm9uIEhlcnR6ZW5cblxuICBSZWxlYXNlZCB1bmRlciBNSVQgTGljZW5zZVxuKi9cblxuKGZ1bmN0aW9uICh3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpIHtcbiAgICB2YXIgX2h0bWwyY2FudmFzID0ge30sXG4gICAgICAgIHByZXZpb3VzRWxlbWVudCxcbiAgICAgICAgY29tcHV0ZWRDU1MsXG4gICAgICAgIGh0bWwyY2FudmFzO1xuXG4gICAgX2h0bWwyY2FudmFzLlV0aWwgPSB7fTtcblxuICAgIF9odG1sMmNhbnZhcy5VdGlsLmxvZyA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIGlmIChfaHRtbDJjYW52YXMubG9nZ2luZyAmJiB3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS5sb2cpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhhKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBfaHRtbDJjYW52YXMuVXRpbC50cmltVGV4dCA9IChmdW5jdGlvbiAoaXNOYXRpdmUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzTmF0aXZlID8gaXNOYXRpdmUuYXBwbHkoaW5wdXQpIDogKChpbnB1dCB8fCAnJykgKyAnJykucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xuICAgICAgICB9O1xuICAgIH0pKFN0cmluZy5wcm90b3R5cGUudHJpbSk7XG5cbiAgICBfaHRtbDJjYW52YXMuVXRpbC5hc0Zsb2F0ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodik7XG4gICAgfTtcblxuICAgIChmdW5jdGlvbiAoKSB7XG4gIC8vIFRPRE86IHN1cHBvcnQgYWxsIHBvc3NpYmxlIGxlbmd0aCB2YWx1ZXNcbiAgICAgICAgdmFyIFRFWFRfU0hBRE9XX1BST1BFUlRZID0gLygocmdiYXxyZ2IpXFwoW15cXCldK1xcKShcXHMtP1xcZCtweCl7MCx9KS9nO1xuICAgICAgICB2YXIgVEVYVF9TSEFET1dfVkFMVUVTID0gLygtP1xcZCtweCl8KCMuKyl8KHJnYlxcKC4rXFwpKXwocmdiYVxcKC4rXFwpKS9nO1xuICAgICAgICBfaHRtbDJjYW52YXMuVXRpbC5wYXJzZVRleHRTaGFkb3dzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIXZhbHVlIHx8IHZhbHVlID09PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG5cbiAgICAvLyBmaW5kIG11bHRpcGxlIHNoYWRvdyBkZWNsYXJhdGlvbnNcbiAgICAgICAgICAgIHZhciBzaGFkb3dzID0gdmFsdWUubWF0Y2goVEVYVF9TSEFET1dfUFJPUEVSVFkpLFxuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBzaGFkb3dzICYmIChpIDwgc2hhZG93cy5sZW5ndGgpOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IHNoYWRvd3NbaV0ubWF0Y2goVEVYVF9TSEFET1dfVkFMVUVTKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBjb2xvcjogc1swXSxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WDogc1sxXSA/IHNbMV0ucmVwbGFjZSgncHgnLCAnJykgOiAwLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRZOiBzWzJdID8gc1syXS5yZXBsYWNlKCdweCcsICcnKSA6IDAsXG4gICAgICAgICAgICAgICAgICAgIGJsdXI6IHNbM10gPyBzWzNdLnJlcGxhY2UoJ3B4JywgJycpIDogMFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH07XG4gICAgfSkoKTtcblxuICAgIF9odG1sMmNhbnZhcy5VdGlsLnBhcnNlQmFja2dyb3VuZEltYWdlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciB3aGl0ZXNwYWNlID0gJyBcXHJcXG5cXHQnLFxuICAgICAgICAgICAgbWV0aG9kLCBkZWZpbml0aW9uLCBwcmVmaXgsIHByZWZpeF9pLCBibG9jaywgcmVzdWx0cyA9IFtdLFxuICAgICAgICAgICAgYywgbW9kZSA9IDAsIG51bVBhcmVuID0gMCwgcXVvdGUsIGFyZ3M7XG5cbiAgICAgICAgdmFyIGFwcGVuZFJlc3VsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVmaW5pdGlvbi5zdWJzdHIoMCwgMSkgPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbiA9IGRlZmluaXRpb24uc3Vic3RyKDEsIGRlZmluaXRpb24ubGVuZ3RoIC0gMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkZWZpbml0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChkZWZpbml0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1ldGhvZC5zdWJzdHIoMCwgMSkgPT09ICctJyAmJlxuICAgICAgICAgICAgICAgICAgICAocHJlZml4X2kgPSBtZXRob2QuaW5kZXhPZignLScsIDEpICsgMSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWZpeCA9IG1ldGhvZC5zdWJzdHIoMCwgcHJlZml4X2kpO1xuICAgICAgICAgICAgICAgICAgICBtZXRob2QgPSBtZXRob2Quc3Vic3RyKHByZWZpeF9pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBibG9jayxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogYXJnc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJncyA9IFtdOyAvLyBmb3Igc29tZSBvZGQgcmVhc29uLCBzZXR0aW5nIC5sZW5ndGggPSAwIGRpZG4ndCB3b3JrIGluIHNhZmFyaVxuICAgICAgICAgICAgbWV0aG9kID1cbiAgICAgICAgICAgIHByZWZpeCA9XG4gICAgICAgICAgICBkZWZpbml0aW9uID1cbiAgICAgICAgICAgIGJsb2NrID0gJyc7XG4gICAgICAgIH07XG5cbiAgICAgICAgYXBwZW5kUmVzdWx0KCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHZhbHVlLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIGMgPSB2YWx1ZVtpXTtcbiAgICAgICAgICAgIGlmIChtb2RlID09PSAwICYmIHdoaXRlc3BhY2UuaW5kZXhPZihjKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgICAgICAgICBpZiAoIXF1b3RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1b3RlID0gYztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHF1b3RlID09PSBjKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1b3RlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJygnOlxuICAgICAgICAgICAgICAgIGlmIChxdW90ZSkgeyBicmVhazsgfSBlbHNlIGlmIChtb2RlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGUgPSAxO1xuICAgICAgICAgICAgICAgICAgICBibG9jayArPSBjO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBudW1QYXJlbisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnKSc6XG4gICAgICAgICAgICAgICAgaWYgKHF1b3RlKSB7IGJyZWFrOyB9IGVsc2UgaWYgKG1vZGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG51bVBhcmVuID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrICs9IGM7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBlbmRSZXN1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtUGFyZW4tLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnLCc6XG4gICAgICAgICAgICAgICAgaWYgKHF1b3RlKSB7IGJyZWFrOyB9IGVsc2UgaWYgKG1vZGUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwZW5kUmVzdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobnVtUGFyZW4gPT09IDAgJiYgIW1ldGhvZC5tYXRjaCgvXnVybCQvaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChkZWZpbml0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb24gPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrICs9IGM7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYmxvY2sgKz0gYztcbiAgICAgICAgICAgIGlmIChtb2RlID09PSAwKSB7IG1ldGhvZCArPSBjOyB9IGVsc2UgeyBkZWZpbml0aW9uICs9IGM7IH1cbiAgICAgICAgfVxuICAgICAgICBhcHBlbmRSZXN1bHQoKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuXG4gICAgX2h0bWwyY2FudmFzLlV0aWwuQm91bmRzID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGNsaWVudFJlY3QsIGJvdW5kcyA9IHt9O1xuXG4gICAgICAgIGlmIChlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCkge1xuICAgICAgICAgICAgY2xpZW50UmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAvLyBUT0RPIGFkZCBzY3JvbGwgcG9zaXRpb24gdG8gYm91bmRzLCBzbyBubyBzY3JvbGxpbmcgb2Ygd2luZG93IG5lY2Vzc2FyeVxuICAgICAgICAgICAgYm91bmRzLnRvcCA9IGNsaWVudFJlY3QudG9wO1xuICAgICAgICAgICAgYm91bmRzLmJvdHRvbSA9IGNsaWVudFJlY3QuYm90dG9tIHx8IChjbGllbnRSZWN0LnRvcCArIGNsaWVudFJlY3QuaGVpZ2h0KTtcbiAgICAgICAgICAgIGJvdW5kcy5sZWZ0ID0gY2xpZW50UmVjdC5sZWZ0O1xuXG4gICAgICAgICAgICBib3VuZHMud2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgYm91bmRzLmhlaWdodCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICB9O1xuXG4vLyBUT0RPIGlkZWFsbHksIHdlJ2Qgd2FudCBldmVyeXRoaW5nIHRvIGdvIHRocm91Z2ggdGhpcyBmdW5jdGlvbiBpbnN0ZWFkIG9mIFV0aWwuQm91bmRzLFxuLy8gYnV0IHdvdWxkIHJlcXVpcmUgZnVydGhlciB3b3JrIHRvIGNhbGN1bGF0ZSB0aGUgY29ycmVjdCBwb3NpdGlvbnMgZm9yIGVsZW1lbnRzIHdpdGggb2Zmc2V0UGFyZW50c1xuICAgIF9odG1sMmNhbnZhcy5VdGlsLk9mZnNldEJvdW5kcyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBlbGVtZW50Lm9mZnNldFBhcmVudCA/IF9odG1sMmNhbnZhcy5VdGlsLk9mZnNldEJvdW5kcyhlbGVtZW50Lm9mZnNldFBhcmVudCkgOiB7dG9wOiAwLCBsZWZ0OiAwfTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wOiBlbGVtZW50Lm9mZnNldFRvcCArIHBhcmVudC50b3AsXG4gICAgICAgICAgICBib3R0b206IGVsZW1lbnQub2Zmc2V0VG9wICsgZWxlbWVudC5vZmZzZXRIZWlnaHQgKyBwYXJlbnQudG9wLFxuICAgICAgICAgICAgbGVmdDogZWxlbWVudC5vZmZzZXRMZWZ0ICsgcGFyZW50LmxlZnQsXG4gICAgICAgICAgICB3aWR0aDogZWxlbWVudC5vZmZzZXRXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogZWxlbWVudC5vZmZzZXRIZWlnaHRcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gdG9QWCAoZWxlbWVudCwgYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgICAgICB2YXIgcnNMZWZ0ID0gZWxlbWVudC5ydW50aW1lU3R5bGUgJiYgZWxlbWVudC5ydW50aW1lU3R5bGVbYXR0cmlidXRlXSxcbiAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICBzdHlsZSA9IGVsZW1lbnQuc3R5bGU7XG5cbiAgICAvLyBDaGVjayBpZiB3ZSBhcmUgbm90IGRlYWxpbmcgd2l0aCBwaXhlbHMsIChPcGVyYSBoYXMgaXNzdWVzIHdpdGggdGhpcylcbiAgICAvLyBQb3J0ZWQgZnJvbSBqUXVlcnkgY3NzLmpzXG4gICAgLy8gRnJvbSB0aGUgYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1xuICAgIC8vIGh0dHA6Ly9lcmlrLmVhZS5uZXQvYXJjaGl2ZXMvMjAwNy8wNy8yNy8xOC41NC4xNS8jY29tbWVudC0xMDIyOTFcblxuICAgIC8vIElmIHdlJ3JlIG5vdCBkZWFsaW5nIHdpdGggYSByZWd1bGFyIHBpeGVsIG51bWJlclxuICAgIC8vIGJ1dCBhIG51bWJlciB0aGF0IGhhcyBhIHdlaXJkIGVuZGluZywgd2UgbmVlZCB0byBjb252ZXJ0IGl0IHRvIHBpeGVsc1xuXG4gICAgICAgIGlmICghL14tP1swLTldK1xcLj9bMC05XSooPzpweCk/JC9pLnRlc3QodmFsdWUpICYmIC9eLT9cXGQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcbiAgICAgICAgICAgIGxlZnQgPSBzdHlsZS5sZWZ0O1xuXG4gICAgICAgIC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcbiAgICAgICAgICAgIGlmIChyc0xlZnQpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJ1bnRpbWVTdHlsZS5sZWZ0ID0gZWxlbWVudC5jdXJyZW50U3R5bGUubGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0eWxlLmxlZnQgPSBhdHRyaWJ1dGUgPT09ICdmb250U2l6ZScgPyAnMWVtJyA6ICh2YWx1ZSB8fCAwKTtcbiAgICAgICAgICAgIHZhbHVlID0gc3R5bGUucGl4ZWxMZWZ0ICsgJ3B4JztcblxuICAgICAgICAvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXG4gICAgICAgICAgICBzdHlsZS5sZWZ0ID0gbGVmdDtcbiAgICAgICAgICAgIGlmIChyc0xlZnQpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJ1bnRpbWVTdHlsZS5sZWZ0ID0gcnNMZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEvXih0aGlufG1lZGl1bXx0aGljaykkL2kudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHBhcnNlRmxvYXQodmFsdWUpKSArICdweCc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXNJbnQgKHZhbCkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQodmFsLCAxMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VCYWNrZ3JvdW5kU2l6ZVBvc2l0aW9uICh2YWx1ZSwgZWxlbWVudCwgYXR0cmlidXRlLCBpbmRleCkge1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8fCAnJykuc3BsaXQoJywnKTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZVtpbmRleCB8fCAwXSB8fCB2YWx1ZVswXSB8fCAnYXV0byc7XG4gICAgICAgIHZhbHVlID0gX2h0bWwyY2FudmFzLlV0aWwudHJpbVRleHQodmFsdWUpLnNwbGl0KCcgJyk7XG5cbiAgICAgICAgaWYgKGF0dHJpYnV0ZSA9PT0gJ2JhY2tncm91bmRTaXplJyAmJiAoIXZhbHVlWzBdIHx8IHZhbHVlWzBdLm1hdGNoKC9jb3Zlcnxjb250YWlufGF1dG8vKSkpIHtcbiAgICAgICAgLy8gdGhlc2UgdmFsdWVzIHdpbGwgYmUgaGFuZGxlZCBpbiB0aGUgcGFyZW50IGZ1bmN0aW9uXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZVswXSA9ICh2YWx1ZVswXS5pbmRleE9mKCclJykgPT09IC0xKSA/IHRvUFgoZWxlbWVudCwgYXR0cmlidXRlICsgJ1gnLCB2YWx1ZVswXSkgOiB2YWx1ZVswXTtcbiAgICAgICAgICAgIGlmICh2YWx1ZVsxXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZSA9PT0gJ2JhY2tncm91bmRTaXplJykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZVsxXSA9ICdhdXRvJztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSUUgOSBkb2Vzbid0IHJldHVybiBkb3VibGUgZGlnaXQgYWx3YXlzXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlWzFdID0gdmFsdWVbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWVbMV0gPSAodmFsdWVbMV0uaW5kZXhPZignJScpID09PSAtMSkgPyB0b1BYKGVsZW1lbnQsIGF0dHJpYnV0ZSArICdZJywgdmFsdWVbMV0pIDogdmFsdWVbMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIF9odG1sMmNhbnZhcy5VdGlsLmdldENTUyA9IGZ1bmN0aW9uIChlbGVtZW50LCBhdHRyaWJ1dGUsIGluZGV4KSB7XG4gICAgICAgIGlmIChwcmV2aW91c0VsZW1lbnQgIT09IGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbXB1dGVkQ1NTID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2YWx1ZSA9IGNvbXB1dGVkQ1NTW2F0dHJpYnV0ZV07XG5cbiAgICAgICAgaWYgKC9eYmFja2dyb3VuZChTaXplfFBvc2l0aW9uKSQvLnRlc3QoYXR0cmlidXRlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlQmFja2dyb3VuZFNpemVQb3NpdGlvbih2YWx1ZSwgZWxlbWVudCwgYXR0cmlidXRlLCBpbmRleCk7XG4gICAgICAgIH0gZWxzZSBpZiAoL2JvcmRlcihUb3B8Qm90dG9tKShMZWZ0fFJpZ2h0KVJhZGl1cy8udGVzdChhdHRyaWJ1dGUpKSB7XG4gICAgICAgICAgICB2YXIgYXJyID0gdmFsdWUuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgIGlmIChhcnIubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICBhcnJbMV0gPSBhcnJbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXJyLm1hcChhc0ludCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcblxuICAgIF9odG1sMmNhbnZhcy5VdGlsLnJlc2l6ZUJvdW5kcyA9IGZ1bmN0aW9uIChjdXJyZW50X3dpZHRoLCBjdXJyZW50X2hlaWdodCwgdGFyZ2V0X3dpZHRoLCB0YXJnZXRfaGVpZ2h0LCBzdHJldGNoX21vZGUpIHtcbiAgICAgICAgdmFyIHRhcmdldF9yYXRpbyA9IHRhcmdldF93aWR0aCAvIHRhcmdldF9oZWlnaHQsXG4gICAgICAgICAgICBjdXJyZW50X3JhdGlvID0gY3VycmVudF93aWR0aCAvIGN1cnJlbnRfaGVpZ2h0LFxuICAgICAgICAgICAgb3V0cHV0X3dpZHRoLCBvdXRwdXRfaGVpZ2h0O1xuXG4gICAgICAgIGlmICghc3RyZXRjaF9tb2RlIHx8IHN0cmV0Y2hfbW9kZSA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICBvdXRwdXRfd2lkdGggPSB0YXJnZXRfd2lkdGg7XG4gICAgICAgICAgICBvdXRwdXRfaGVpZ2h0ID0gdGFyZ2V0X2hlaWdodDtcbiAgICAgICAgfSBlbHNlIGlmICh0YXJnZXRfcmF0aW8gPCBjdXJyZW50X3JhdGlvIF4gc3RyZXRjaF9tb2RlID09PSAnY29udGFpbicpIHtcbiAgICAgICAgICAgIG91dHB1dF9oZWlnaHQgPSB0YXJnZXRfaGVpZ2h0O1xuICAgICAgICAgICAgb3V0cHV0X3dpZHRoID0gdGFyZ2V0X2hlaWdodCAqIGN1cnJlbnRfcmF0aW87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXRwdXRfd2lkdGggPSB0YXJnZXRfd2lkdGg7XG4gICAgICAgICAgICBvdXRwdXRfaGVpZ2h0ID0gdGFyZ2V0X3dpZHRoIC8gY3VycmVudF9yYXRpbztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogb3V0cHV0X3dpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBvdXRwdXRfaGVpZ2h0XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGJhY2tncm91bmRCb3VuZHNGYWN0b3J5IChwcm9wLCBlbCwgYm91bmRzLCBpbWFnZSwgaW1hZ2VJbmRleCwgYmFja2dyb3VuZFNpemUpIHtcbiAgICAgICAgdmFyIGJncG9zaXRpb24gPSBfaHRtbDJjYW52YXMuVXRpbC5nZXRDU1MoZWwsIHByb3AsIGltYWdlSW5kZXgpLFxuICAgICAgICAgICAgdG9wUG9zLFxuICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgIHBlcmNlbnRhZ2UsXG4gICAgICAgICAgICB2YWw7XG5cbiAgICAgICAgaWYgKGJncG9zaXRpb24ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB2YWwgPSBiZ3Bvc2l0aW9uWzBdO1xuXG4gICAgICAgICAgICBiZ3Bvc2l0aW9uID0gW107XG5cbiAgICAgICAgICAgIGJncG9zaXRpb25bMF0gPSB2YWw7XG4gICAgICAgICAgICBiZ3Bvc2l0aW9uWzFdID0gdmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJncG9zaXRpb25bMF0udG9TdHJpbmcoKS5pbmRleE9mKCclJykgIT09IC0xKSB7XG4gICAgICAgICAgICBwZXJjZW50YWdlID0gKHBhcnNlRmxvYXQoYmdwb3NpdGlvblswXSkgLyAxMDApO1xuICAgICAgICAgICAgbGVmdCA9IGJvdW5kcy53aWR0aCAqIHBlcmNlbnRhZ2U7XG4gICAgICAgICAgICBpZiAocHJvcCAhPT0gJ2JhY2tncm91bmRTaXplJykge1xuICAgICAgICAgICAgICAgIGxlZnQgLT0gKGJhY2tncm91bmRTaXplIHx8IGltYWdlKS53aWR0aCAqIHBlcmNlbnRhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gJ2JhY2tncm91bmRTaXplJykge1xuICAgICAgICAgICAgICAgIGlmIChiZ3Bvc2l0aW9uWzBdID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGltYWdlLndpZHRoO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgvY29udGFpbnxjb3Zlci8udGVzdChiZ3Bvc2l0aW9uWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc2l6ZWQgPSBfaHRtbDJjYW52YXMuVXRpbC5yZXNpemVCb3VuZHMoaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgYm91bmRzLndpZHRoLCBib3VuZHMuaGVpZ2h0LCBiZ3Bvc2l0aW9uWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSByZXNpemVkLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wUG9zID0gcmVzaXplZC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gcGFyc2VJbnQoYmdwb3NpdGlvblswXSwgMTApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gcGFyc2VJbnQoYmdwb3NpdGlvblswXSwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJncG9zaXRpb25bMV0gPT09ICdhdXRvJykge1xuICAgICAgICAgICAgdG9wUG9zID0gbGVmdCAvIGltYWdlLndpZHRoICogaW1hZ2UuaGVpZ2h0O1xuICAgICAgICB9IGVsc2UgaWYgKGJncG9zaXRpb25bMV0udG9TdHJpbmcoKS5pbmRleE9mKCclJykgIT09IC0xKSB7XG4gICAgICAgICAgICBwZXJjZW50YWdlID0gKHBhcnNlRmxvYXQoYmdwb3NpdGlvblsxXSkgLyAxMDApO1xuICAgICAgICAgICAgdG9wUG9zID0gYm91bmRzLmhlaWdodCAqIHBlcmNlbnRhZ2U7XG4gICAgICAgICAgICBpZiAocHJvcCAhPT0gJ2JhY2tncm91bmRTaXplJykge1xuICAgICAgICAgICAgICAgIHRvcFBvcyAtPSAoYmFja2dyb3VuZFNpemUgfHwgaW1hZ2UpLmhlaWdodCAqIHBlcmNlbnRhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b3BQb3MgPSBwYXJzZUludChiZ3Bvc2l0aW9uWzFdLCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW2xlZnQsIHRvcFBvc107XG4gICAgfVxuXG4gICAgX2h0bWwyY2FudmFzLlV0aWwuQmFja2dyb3VuZFBvc2l0aW9uID0gZnVuY3Rpb24gKGVsLCBib3VuZHMsIGltYWdlLCBpbWFnZUluZGV4LCBiYWNrZ3JvdW5kU2l6ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gYmFja2dyb3VuZEJvdW5kc0ZhY3RvcnkoJ2JhY2tncm91bmRQb3NpdGlvbicsIGVsLCBib3VuZHMsIGltYWdlLCBpbWFnZUluZGV4LCBiYWNrZ3JvdW5kU2l6ZSk7XG4gICAgICAgIHJldHVybiB7IGxlZnQ6IHJlc3VsdFswXSwgdG9wOiByZXN1bHRbMV0gfTtcbiAgICB9O1xuXG4gICAgX2h0bWwyY2FudmFzLlV0aWwuQmFja2dyb3VuZFNpemUgPSBmdW5jdGlvbiAoZWwsIGJvdW5kcywgaW1hZ2UsIGltYWdlSW5kZXgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGJhY2tncm91bmRCb3VuZHNGYWN0b3J5KCdiYWNrZ3JvdW5kU2l6ZScsIGVsLCBib3VuZHMsIGltYWdlLCBpbWFnZUluZGV4KTtcbiAgICAgICAgcmV0dXJuIHsgd2lkdGg6IHJlc3VsdFswXSwgaGVpZ2h0OiByZXN1bHRbMV0gfTtcbiAgICB9O1xuXG4gICAgX2h0bWwyY2FudmFzLlV0aWwuRXh0ZW5kID0gZnVuY3Rpb24gKG9wdGlvbnMsIGRlZmF1bHRzKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdHNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmYXVsdHM7XG4gICAgfTtcblxuLypcbiAqIERlcml2ZWQgZnJvbSBqUXVlcnkuY29udGVudHMoKVxuICogQ29weXJpZ2h0IDIwMTAsIEpvaG4gUmVzaWdcbiAqIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBvciBHUEwgVmVyc2lvbiAyIGxpY2Vuc2VzLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICovXG4gICAgX2h0bWwyY2FudmFzLlV0aWwuQ2hpbGRyZW4gPSBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICB2YXIgY2hpbGRyZW47XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjaGlsZHJlbiA9IChlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ0lGUkFNRScpID8gZWxlbS5jb250ZW50RG9jdW1lbnQgfHwgZWxlbS5jb250ZW50V2luZG93LmRvY3VtZW50IDogKGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICAgICAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAoYXJyYXkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uIChmaXJzdCwgc2Vjb25kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGZpcnN0Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWNvbmQubGVuZ3RoID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGwgPSBzZWNvbmQubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0W2krK10gPSBzZWNvbmRbal07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc2Vjb25kW2pdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RbaSsrXSA9IHNlY29uZFtqKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QubGVuZ3RoID0gaTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpcnN0O1xuICAgICAgICAgICAgICAgICAgICB9KShyZXQsIGFycmF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH0pKGVsZW0uY2hpbGROb2Rlcyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICBfaHRtbDJjYW52YXMuVXRpbC5sb2coJ2h0bWwyY2FudmFzLlV0aWwuQ2hpbGRyZW4gZmFpbGVkIHdpdGggZXhjZXB0aW9uOiAnICsgZXgubWVzc2FnZSk7XG4gICAgICAgICAgICBjaGlsZHJlbiA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICB9O1xuXG4gICAgX2h0bWwyY2FudmFzLlV0aWwuaXNUcmFuc3BhcmVudCA9IGZ1bmN0aW9uIChiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgcmV0dXJuIChiYWNrZ3JvdW5kQ29sb3IgPT09ICd0cmFuc3BhcmVudCcgfHwgYmFja2dyb3VuZENvbG9yID09PSAncmdiYSgwLCAwLCAwLCAwKScpO1xuICAgIH07XG4gICAgX2h0bWwyY2FudmFzLlV0aWwuRm9udCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmb250RGF0YSA9IHt9O1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZm9udCwgZm9udFNpemUsIGRvYykge1xuICAgICAgICAgICAgaWYgKGZvbnREYXRhW2ZvbnQgKyAnLScgKyBmb250U2l6ZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmb250RGF0YVtmb250ICsgJy0nICsgZm9udFNpemVdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgICAgICAgICAgIGltZyA9IGRvYy5jcmVhdGVFbGVtZW50KCdpbWcnKSxcbiAgICAgICAgICAgICAgICBzcGFuID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKSxcbiAgICAgICAgICAgICAgICBzYW1wbGVUZXh0ID0gJ0hpZGRlbiBUZXh0JyxcbiAgICAgICAgICAgICAgICBiYXNlbGluZSxcbiAgICAgICAgICAgICAgICBtaWRkbGUsXG4gICAgICAgICAgICAgICAgbWV0cmljc09iajtcblxuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5mb250RmFtaWx5ID0gZm9udDtcbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5mb250U2l6ZSA9IGZvbnRTaXplO1xuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLm1hcmdpbiA9IDA7XG4gICAgICAgICAgICBjb250YWluZXIuc3R5bGUucGFkZGluZyA9IDA7XG5cbiAgICAgICAgICAgIGRvYy5ib2R5LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG5cbiAgICAvLyBodHRwOi8vcHJvYmFibHlwcm9ncmFtbWluZy5jb20vMjAwOS8wMy8xNS90aGUtdGluaWVzdC1naWYtZXZlciAoaGFuZHRpbnl3aGl0ZS5naWYpXG4gICAgICAgICAgICBpbWcuc3JjID0gJ2RhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBSUFCQVAvLy93QUFBQ3dBQUFBQUFRQUJBQUFDQWtRQkFEcz0nO1xuICAgICAgICAgICAgaW1nLndpZHRoID0gMTtcbiAgICAgICAgICAgIGltZy5oZWlnaHQgPSAxO1xuXG4gICAgICAgICAgICBpbWcuc3R5bGUubWFyZ2luID0gMDtcbiAgICAgICAgICAgIGltZy5zdHlsZS5wYWRkaW5nID0gMDtcbiAgICAgICAgICAgIGltZy5zdHlsZS52ZXJ0aWNhbEFsaWduID0gJ2Jhc2VsaW5lJztcblxuICAgICAgICAgICAgc3Bhbi5zdHlsZS5mb250RmFtaWx5ID0gZm9udDtcbiAgICAgICAgICAgIHNwYW4uc3R5bGUuZm9udFNpemUgPSBmb250U2l6ZTtcbiAgICAgICAgICAgIHNwYW4uc3R5bGUubWFyZ2luID0gMDtcbiAgICAgICAgICAgIHNwYW4uc3R5bGUucGFkZGluZyA9IDA7XG5cbiAgICAgICAgICAgIHNwYW4uYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZVRleHROb2RlKHNhbXBsZVRleHQpKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChzcGFuKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChpbWcpO1xuICAgICAgICAgICAgYmFzZWxpbmUgPSAoaW1nLm9mZnNldFRvcCAtIHNwYW4ub2Zmc2V0VG9wKSArIDE7XG5cbiAgICAgICAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChzcGFuKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChkb2MuY3JlYXRlVGV4dE5vZGUoc2FtcGxlVGV4dCkpO1xuXG4gICAgICAgICAgICBjb250YWluZXIuc3R5bGUubGluZUhlaWdodCA9ICdub3JtYWwnO1xuICAgICAgICAgICAgaW1nLnN0eWxlLnZlcnRpY2FsQWxpZ24gPSAnc3VwZXInO1xuXG4gICAgICAgICAgICBtaWRkbGUgPSAoaW1nLm9mZnNldFRvcCAtIGNvbnRhaW5lci5vZmZzZXRUb3ApICsgMTtcbiAgICAgICAgICAgIG1ldHJpY3NPYmogPSB7XG4gICAgICAgICAgICAgICAgYmFzZWxpbmU6IGJhc2VsaW5lLFxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgICAgICAgICAgICBtaWRkbGU6IG1pZGRsZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZm9udERhdGFbZm9udCArICctJyArIGZvbnRTaXplXSA9IG1ldHJpY3NPYmo7XG5cbiAgICAgICAgICAgIGRvYy5ib2R5LnJlbW92ZUNoaWxkKGNvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIHJldHVybiBtZXRyaWNzT2JqO1xuICAgICAgICB9O1xuICAgIH0pKCk7XG5cbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgVXRpbCA9IF9odG1sMmNhbnZhcy5VdGlsLFxuICAgICAgICAgICAgR2VuZXJhdGUgPSB7fTtcblxuICAgICAgICBfaHRtbDJjYW52YXMuR2VuZXJhdGUgPSBHZW5lcmF0ZTtcblxuICAgICAgICB2YXIgcmVHcmFkaWVudHMgPSBbXG4gICAgICAgICAgICAvXigtd2Via2l0LWxpbmVhci1ncmFkaWVudClcXCgoW2Etelxcc10rKShbXFx3XFxkXFwuXFxzLCVcXChcXCldKylcXCkkLyxcbiAgICAgICAgICAgIC9eKC1vLWxpbmVhci1ncmFkaWVudClcXCgoW2Etelxcc10rKShbXFx3XFxkXFwuXFxzLCVcXChcXCldKylcXCkkLyxcbiAgICAgICAgICAgIC9eKC13ZWJraXQtZ3JhZGllbnQpXFwoKGxpbmVhcnxyYWRpYWwpLFxccygoPzpcXGR7MSwzfSU/KVxccyg/OlxcZHsxLDN9JT8pLFxccyg/OlxcZHsxLDN9JT8pXFxzKD86XFxkezEsM30lPykpKFtcXHdcXGRcXC5cXHMsJVxcKFxcKVxcLV0rKVxcKSQvLFxuICAgICAgICAgICAgL14oLW1vei1saW5lYXItZ3JhZGllbnQpXFwoKCg/OlxcZHsxLDN9JT8pXFxzKD86XFxkezEsM30lPykpKFtcXHdcXGRcXC5cXHMsJVxcKFxcKV0rKVxcKSQvLFxuICAgICAgICAgICAgL14oLXdlYmtpdC1yYWRpYWwtZ3JhZGllbnQpXFwoKCg/OlxcZHsxLDN9JT8pXFxzKD86XFxkezEsM30lPykpLFxccyhcXHcrKVxccyhbYS16XFwtXSspKFtcXHdcXGRcXC5cXHMsJVxcKFxcKV0rKVxcKSQvLFxuICAgICAgICAgICAgL14oLW1vei1yYWRpYWwtZ3JhZGllbnQpXFwoKCg/OlxcZHsxLDN9JT8pXFxzKD86XFxkezEsM30lPykpLFxccyhcXHcrKVxccz8oW2EtelxcLV0qKShbXFx3XFxkXFwuXFxzLCVcXChcXCldKylcXCkkLyxcbiAgICAgICAgICAgIC9eKC1vLXJhZGlhbC1ncmFkaWVudClcXCgoKD86XFxkezEsM30lPylcXHMoPzpcXGR7MSwzfSU/KSksXFxzKFxcdyspXFxzKFthLXpcXC1dKykoW1xcd1xcZFxcLlxccywlXFwoXFwpXSspXFwpJC9cbiAgICAgICAgXTtcblxuICAvKlxuICogVE9ETzogQWRkIElFMTAgdmVuZG9yIHByZWZpeCAoLW1zKSBzdXBwb3J0XG4gKiBUT0RPOiBBZGQgVzNDIGdyYWRpZW50IChsaW5lYXItZ3JhZGllbnQpIHN1cHBvcnRcbiAqIFRPRE86IEFkZCBvbGQgV2Via2l0IC13ZWJraXQtZ3JhZGllbnQocmFkaWFsLCAuLi4pIHN1cHBvcnRcbiAqIFRPRE86IE1heWJlIHNvbWUgUmVnRXhwIG9wdGltaXphdGlvbnMgYXJlIHBvc3NpYmxlIDtvKVxuICovXG4gICAgICAgIEdlbmVyYXRlLnBhcnNlR3JhZGllbnQgPSBmdW5jdGlvbiAoY3NzLCBib3VuZHMpIHtcbiAgICAgICAgICAgIHZhciBncmFkaWVudCwgaSwgbGVuID0gcmVHcmFkaWVudHMubGVuZ3RoLCBtMSwgc3RvcCwgbTIsIG0yTGVuLCBzdGVwLCBtMywgdGwsIHRyLCBiciwgYmw7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIG0xID0gY3NzLm1hdGNoKHJlR3JhZGllbnRzW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAobTEpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobTEpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG0xWzFdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnLXdlYmtpdC1saW5lYXItZ3JhZGllbnQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJy1vLWxpbmVhci1ncmFkaWVudCc6XG5cbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbGluZWFyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHgwOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICB4MTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JTdG9wczogW11cbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIGdldCBjb29yZGluYXRlc1xuICAgICAgICAgICAgICAgICAgICBtMiA9IG0xWzJdLm1hdGNoKC9cXHcrL2cpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0yTGVuID0gbTIubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG0yTGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG0yW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnQueTAgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFkaWVudC55MSA9IGJvdW5kcy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFkaWVudC54MCA9IGJvdW5kcy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnQueDEgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyYWRpZW50LnkwID0gYm91bmRzLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnQueTEgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFkaWVudC54MCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyYWRpZW50LngxID0gYm91bmRzLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGdyYWRpZW50LngwID09PSBudWxsICYmIGdyYWRpZW50LngxID09PSBudWxsKSB7IC8vIGNlbnRlclxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnQueDAgPSBncmFkaWVudC54MSA9IGJvdW5kcy53aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGdyYWRpZW50LnkwID09PSBudWxsICYmIGdyYWRpZW50LnkxID09PSBudWxsKSB7IC8vIGNlbnRlclxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnQueTAgPSBncmFkaWVudC55MSA9IGJvdW5kcy5oZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBnZXQgY29sb3JzIGFuZCBzdG9wc1xuICAgICAgICAgICAgICAgICAgICBtMiA9IG0xWzNdLm1hdGNoKC8oKD86cmdifHJnYmEpXFwoXFxkezEsM30sXFxzXFxkezEsM30sXFxzXFxkezEsM30oPzosXFxzWzAtOVxcLl0rKT9cXCkoPzpcXHNcXGR7MSwzfSg/OiV8cHgpKT8pKy9nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG0yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtMkxlbiA9IG0yLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXAgPSAxIC8gTWF0aC5tYXgobTJMZW4gLSAxLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBtMkxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbTMgPSBtMltpXS5tYXRjaCgvKCg/OnJnYnxyZ2JhKVxcKFxcZHsxLDN9LFxcc1xcZHsxLDN9LFxcc1xcZHsxLDN9KD86LFxcc1swLTlcXC5dKyk/XFwpKVxccyooXFxkezEsM30pPyglfHB4KT8vKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobTNbMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcCA9IHBhcnNlRmxvYXQobTNbMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobTNbM10gPT09ICclJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcCAvPSAxMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIHB4IC0gc3R1cGlkIG9wZXJhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9wIC89IGJvdW5kcy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3AgPSBpICogc3RlcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnQuY29sb3JTdG9wcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IG0zWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9wOiBzdG9wXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICctd2Via2l0LWdyYWRpZW50JzpcblxuICAgICAgICAgICAgICAgICAgICBncmFkaWVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG0xWzJdID09PSAncmFkaWFsJyA/ICdjaXJjbGUnIDogbTFbMl0sIC8vIFRPRE86IEFkZCByYWRpYWwgZ3JhZGllbnQgc3VwcG9ydCBmb3Igb2xkZXIgbW96aWxsYSBkZWZpbml0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgeDA6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB5MDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHgxOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTE6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvclN0b3BzOiBbXVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gZ2V0IGNvb3JkaW5hdGVzXG4gICAgICAgICAgICAgICAgICAgIG0yID0gbTFbM10ubWF0Y2goLyhcXGR7MSwzfSklP1xccyhcXGR7MSwzfSklPyxcXHMoXFxkezEsM30pJT9cXHMoXFxkezEsM30pJT8vKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG0yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncmFkaWVudC54MCA9IChtMlsxXSAqIGJvdW5kcy53aWR0aCkgLyAxMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBncmFkaWVudC55MCA9IChtMlsyXSAqIGJvdW5kcy5oZWlnaHQpIC8gMTAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnQueDEgPSAobTJbM10gKiBib3VuZHMud2lkdGgpIC8gMTAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnQueTEgPSAobTJbNF0gKiBib3VuZHMuaGVpZ2h0KSAvIDEwMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gZ2V0IGNvbG9ycyBhbmQgc3RvcHNcbiAgICAgICAgICAgICAgICAgICAgbTIgPSBtMVs0XS5tYXRjaCgvKCg/OmZyb218dG98Y29sb3Itc3RvcClcXCgoPzpbMC05XFwuXSssXFxzKT8oPzpyZ2J8cmdiYSlcXChcXGR7MSwzfSxcXHNcXGR7MSwzfSxcXHNcXGR7MSwzfSg/OixcXHNbMC05XFwuXSspP1xcKVxcKSkrL2cpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0yTGVuID0gbTIubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG0yTGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtMyA9IG0yW2ldLm1hdGNoKC8oZnJvbXx0b3xjb2xvci1zdG9wKVxcKChbMC05XFwuXSspPyg/OixcXHMpPygoPzpyZ2J8cmdiYSlcXChcXGR7MSwzfSxcXHNcXGR7MSwzfSxcXHNcXGR7MSwzfSg/OixcXHNbMC05XFwuXSspP1xcKSlcXCkvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9wID0gcGFyc2VGbG9hdChtM1syXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0zWzFdID09PSAnZnJvbScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcCA9IDAuMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0zWzFdID09PSAndG8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3AgPSAxLjA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyYWRpZW50LmNvbG9yU3RvcHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBtM1szXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcDogc3RvcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnLW1vei1saW5lYXItZ3JhZGllbnQnOlxuXG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2xpbmVhcicsXG4gICAgICAgICAgICAgICAgICAgICAgICB4MDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHkwOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgeDE6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB5MTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yU3RvcHM6IFtdXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBnZXQgY29vcmRpbmF0ZXNcbiAgICAgICAgICAgICAgICAgICAgbTIgPSBtMVsyXS5tYXRjaCgvKFxcZHsxLDN9KSU/XFxzKFxcZHsxLDN9KSU/Lyk7XG5cbiAgICAgICAgICAvLyBtMlsxXSA9PSAwJSAgIC0+IGxlZnRcbiAgICAgICAgICAvLyBtMlsxXSA9PSA1MCUgIC0+IGNlbnRlclxuICAgICAgICAgIC8vIG0yWzFdID09IDEwMCUgLT4gcmlnaHRcblxuICAgICAgICAgIC8vIG0yWzJdID09IDAlICAgLT4gdG9wXG4gICAgICAgICAgLy8gbTJbMl0gPT0gNTAlICAtPiBjZW50ZXJcbiAgICAgICAgICAvLyBtMlsyXSA9PSAxMDAlIC0+IGJvdHRvbVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChtMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnQueDAgPSAobTJbMV0gKiBib3VuZHMud2lkdGgpIC8gMTAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnQueTAgPSAobTJbMl0gKiBib3VuZHMuaGVpZ2h0KSAvIDEwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYWRpZW50LngxID0gYm91bmRzLndpZHRoIC0gZ3JhZGllbnQueDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBncmFkaWVudC55MSA9IGJvdW5kcy5oZWlnaHQgLSBncmFkaWVudC55MDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gZ2V0IGNvbG9ycyBhbmQgc3RvcHNcbiAgICAgICAgICAgICAgICAgICAgbTIgPSBtMVszXS5tYXRjaCgvKCg/OnJnYnxyZ2JhKVxcKFxcZHsxLDN9LFxcc1xcZHsxLDN9LFxcc1xcZHsxLDN9KD86LFxcc1swLTlcXC5dKyk/XFwpKD86XFxzXFxkezEsM30lKT8pKy9nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG0yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtMkxlbiA9IG0yLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXAgPSAxIC8gTWF0aC5tYXgobTJMZW4gLSAxLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBtMkxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbTMgPSBtMltpXS5tYXRjaCgvKCg/OnJnYnxyZ2JhKVxcKFxcZHsxLDN9LFxcc1xcZHsxLDN9LFxcc1xcZHsxLDN9KD86LFxcc1swLTlcXC5dKyk/XFwpKVxccyooXFxkezEsM30pPyglKT8vKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobTNbMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcCA9IHBhcnNlRmxvYXQobTNbMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobTNbM10pIHsgLy8gcGVyY2VudGFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcCAvPSAxMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9wID0gaSAqIHN0ZXA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyYWRpZW50LmNvbG9yU3RvcHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBtM1sxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcDogc3RvcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnLXdlYmtpdC1yYWRpYWwtZ3JhZGllbnQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJy1tb3otcmFkaWFsLWdyYWRpZW50JzpcbiAgICAgICAgICAgICAgICBjYXNlICctby1yYWRpYWwtZ3JhZGllbnQnOlxuXG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NpcmNsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICB4MDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHkwOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgeDE6IGJvdW5kcy53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxOiBib3VuZHMuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgY3g6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBjeTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ4OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgcnk6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvclN0b3BzOiBbXVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gY2VudGVyXG4gICAgICAgICAgICAgICAgICAgIG0yID0gbTFbMl0ubWF0Y2goLyhcXGR7MSwzfSklP1xccyhcXGR7MSwzfSklPy8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYWRpZW50LmN4ID0gKG0yWzFdICogYm91bmRzLndpZHRoKSAvIDEwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYWRpZW50LmN5ID0gKG0yWzJdICogYm91bmRzLmhlaWdodCkgLyAxMDA7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHNpemVcbiAgICAgICAgICAgICAgICAgICAgbTIgPSBtMVszXS5tYXRjaCgvXFx3Ky8pO1xuICAgICAgICAgICAgICAgICAgICBtMyA9IG0xWzRdLm1hdGNoKC9bYS16XFwtXSovKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG0yICYmIG0zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG0zWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdmYXJ0aGVzdC1jb3JuZXInOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY292ZXInOiAvLyBpcyBlcXVpdmFsZW50IHRvIGZhcnRoZXN0LWNvcm5lclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnJzogLy8gbW96aWxsYSByZW1vdmVzIFwiY292ZXJcIiBmcm9tIGRlZmluaXRpb24gOihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bCA9IE1hdGguc3FydChNYXRoLnBvdyhncmFkaWVudC5jeCwgMikgKyBNYXRoLnBvdyhncmFkaWVudC5jeSwgMikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyID0gTWF0aC5zcXJ0KE1hdGgucG93KGdyYWRpZW50LmN4LCAyKSArIE1hdGgucG93KGdyYWRpZW50LnkxIC0gZ3JhZGllbnQuY3ksIDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiciA9IE1hdGguc3FydChNYXRoLnBvdyhncmFkaWVudC54MSAtIGdyYWRpZW50LmN4LCAyKSArIE1hdGgucG93KGdyYWRpZW50LnkxIC0gZ3JhZGllbnQuY3ksIDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibCA9IE1hdGguc3FydChNYXRoLnBvdyhncmFkaWVudC54MSAtIGdyYWRpZW50LmN4LCAyKSArIE1hdGgucG93KGdyYWRpZW50LmN5LCAyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnQucnggPSBncmFkaWVudC5yeSA9IE1hdGgubWF4KHRsLCB0ciwgYnIsIGJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Nsb3Nlc3QtY29ybmVyJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bCA9IE1hdGguc3FydChNYXRoLnBvdyhncmFkaWVudC5jeCwgMikgKyBNYXRoLnBvdyhncmFkaWVudC5jeSwgMikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyID0gTWF0aC5zcXJ0KE1hdGgucG93KGdyYWRpZW50LmN4LCAyKSArIE1hdGgucG93KGdyYWRpZW50LnkxIC0gZ3JhZGllbnQuY3ksIDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiciA9IE1hdGguc3FydChNYXRoLnBvdyhncmFkaWVudC54MSAtIGdyYWRpZW50LmN4LCAyKSArIE1hdGgucG93KGdyYWRpZW50LnkxIC0gZ3JhZGllbnQuY3ksIDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibCA9IE1hdGguc3FydChNYXRoLnBvdyhncmFkaWVudC54MSAtIGdyYWRpZW50LmN4LCAyKSArIE1hdGgucG93KGdyYWRpZW50LmN5LCAyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnQucnggPSBncmFkaWVudC5yeSA9IE1hdGgubWluKHRsLCB0ciwgYnIsIGJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ZhcnRoZXN0LXNpZGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtMlswXSA9PT0gJ2NpcmNsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnQucnggPSBncmFkaWVudC5yeSA9IE1hdGgubWF4KFxuICAgICAgICAgICAgICAgICAgICBncmFkaWVudC5jeCxcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnQuY3ksXG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50LngxIC0gZ3JhZGllbnQuY3gsXG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50LnkxIC0gZ3JhZGllbnQuY3lcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuIC8vIGVsbGlwc2VcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFkaWVudC50eXBlID0gbTJbMF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnQucnggPSBNYXRoLm1heChcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnQuY3gsXG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50LngxIC0gZ3JhZGllbnQuY3hcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnQucnkgPSBNYXRoLm1heChcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnQuY3ksXG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50LnkxIC0gZ3JhZGllbnQuY3lcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjbG9zZXN0LXNpZGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29udGFpbic6IC8vIGlzIGVxdWl2YWxlbnQgdG8gY2xvc2VzdC1zaWRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0yWzBdID09PSAnY2lyY2xlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFkaWVudC5yeCA9IGdyYWRpZW50LnJ5ID0gTWF0aC5taW4oXG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50LmN4LFxuICAgICAgICAgICAgICAgICAgICBncmFkaWVudC5jeSxcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnQueDEgLSBncmFkaWVudC5jeCxcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnQueTEgLSBncmFkaWVudC5jeVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gLy8gZWxsaXBzZVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyYWRpZW50LnR5cGUgPSBtMlswXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFkaWVudC5yeCA9IE1hdGgubWluKFxuICAgICAgICAgICAgICAgICAgICBncmFkaWVudC5jeCxcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnQueDEgLSBncmFkaWVudC5jeFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFkaWVudC5yeSA9IE1hdGgubWluKFxuICAgICAgICAgICAgICAgICAgICBncmFkaWVudC5jeSxcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnQueTEgLSBncmFkaWVudC5jeVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgLy8gVE9ETzogYWRkIHN1cHBvcnQgZm9yIFwiMzBweCA0MHB4XCIgc2l6ZXMgKHdlYmtpdCBvbmx5KVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBjb2xvciBzdG9wc1xuICAgICAgICAgICAgICAgICAgICBtMiA9IG0xWzVdLm1hdGNoKC8oKD86cmdifHJnYmEpXFwoXFxkezEsM30sXFxzXFxkezEsM30sXFxzXFxkezEsM30oPzosXFxzWzAtOVxcLl0rKT9cXCkoPzpcXHNcXGR7MSwzfSg/OiV8cHgpKT8pKy9nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG0yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtMkxlbiA9IG0yLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXAgPSAxIC8gTWF0aC5tYXgobTJMZW4gLSAxLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBtMkxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbTMgPSBtMltpXS5tYXRjaCgvKCg/OnJnYnxyZ2JhKVxcKFxcZHsxLDN9LFxcc1xcZHsxLDN9LFxcc1xcZHsxLDN9KD86LFxcc1swLTlcXC5dKyk/XFwpKVxccyooXFxkezEsM30pPyglfHB4KT8vKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobTNbMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcCA9IHBhcnNlRmxvYXQobTNbMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobTNbM10gPT09ICclJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcCAvPSAxMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIHB4IC0gc3R1cGlkIG9wZXJhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9wIC89IGJvdW5kcy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3AgPSBpICogc3RlcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnQuY29sb3JTdG9wcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IG0zWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9wOiBzdG9wXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZ3JhZGllbnQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gYWRkU2Nyb2xsU3RvcHMgKGdyYWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29sb3JTdG9wKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZC5hZGRDb2xvclN0b3AoY29sb3JTdG9wLnN0b3AsIGNvbG9yU3RvcC5jb2xvcik7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBVdGlsLmxvZyhbJ2ZhaWxlZCB0byBhZGQgY29sb3Igc3RvcDogJywgZSwgJzsgdHJpZWQgdG8gYWRkOiAnLCBjb2xvclN0b3BdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgR2VuZXJhdGUuR3JhZGllbnQgPSBmdW5jdGlvbiAoc3JjLCBib3VuZHMpIHtcbiAgICAgICAgICAgIGlmIChib3VuZHMud2lkdGggPT09IDAgfHwgYm91bmRzLmhlaWdodCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLFxuICAgICAgICAgICAgICAgIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLFxuICAgICAgICAgICAgICAgIGdyYWRpZW50LCBncmFkO1xuXG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSBib3VuZHMud2lkdGg7XG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gYm91bmRzLmhlaWdodDtcblxuICAgIC8vIFRPRE86IGFkZCBzdXBwb3J0IGZvciBtdWx0aSBkZWZpbmVkIGJhY2tncm91bmQgZ3JhZGllbnRzXG4gICAgICAgICAgICBncmFkaWVudCA9IF9odG1sMmNhbnZhcy5HZW5lcmF0ZS5wYXJzZUdyYWRpZW50KHNyYywgYm91bmRzKTtcblxuICAgICAgICAgICAgaWYgKGdyYWRpZW50KSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChncmFkaWVudC50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnbGluZWFyJzpcbiAgICAgICAgICAgICAgICAgICAgZ3JhZCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudChncmFkaWVudC54MCwgZ3JhZGllbnQueTAsIGdyYWRpZW50LngxLCBncmFkaWVudC55MSk7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50LmNvbG9yU3RvcHMuZm9yRWFjaChhZGRTY3JvbGxTdG9wcyhncmFkKSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBncmFkO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgYm91bmRzLndpZHRoLCBib3VuZHMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdjaXJjbGUnOlxuICAgICAgICAgICAgICAgICAgICBncmFkID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KGdyYWRpZW50LmN4LCBncmFkaWVudC5jeSwgMCwgZ3JhZGllbnQuY3gsIGdyYWRpZW50LmN5LCBncmFkaWVudC5yeCk7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50LmNvbG9yU3RvcHMuZm9yRWFjaChhZGRTY3JvbGxTdG9wcyhncmFkKSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBncmFkO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgYm91bmRzLndpZHRoLCBib3VuZHMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdlbGxpcHNlJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhbnZhc1JhZGlhbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4UmFkaWFsID0gY2FudmFzUmFkaWFsLmdldENvbnRleHQoJzJkJyksXG4gICAgICAgICAgICAgICAgICAgICAgICByaSA9IE1hdGgubWF4KGdyYWRpZW50LnJ4LCBncmFkaWVudC5yeSksXG4gICAgICAgICAgICAgICAgICAgICAgICBkaSA9IHJpICogMjtcblxuICAgICAgICAgICAgICAgICAgICBjYW52YXNSYWRpYWwud2lkdGggPSBjYW52YXNSYWRpYWwuaGVpZ2h0ID0gZGk7XG5cbiAgICAgICAgICAgICAgICAgICAgZ3JhZCA9IGN0eFJhZGlhbC5jcmVhdGVSYWRpYWxHcmFkaWVudChncmFkaWVudC5yeCwgZ3JhZGllbnQucnksIDAsIGdyYWRpZW50LnJ4LCBncmFkaWVudC5yeSwgcmkpO1xuICAgICAgICAgICAgICAgICAgICBncmFkaWVudC5jb2xvclN0b3BzLmZvckVhY2goYWRkU2Nyb2xsU3RvcHMoZ3JhZCkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGN0eFJhZGlhbC5maWxsU3R5bGUgPSBncmFkO1xuICAgICAgICAgICAgICAgICAgICBjdHhSYWRpYWwuZmlsbFJlY3QoMCwgMCwgZGksIGRpKTtcblxuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZ3JhZGllbnQuY29sb3JTdG9wc1tncmFkaWVudC5jb2xvclN0b3BzLmxlbmd0aCAtIDFdLmNvbG9yO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShjYW52YXNSYWRpYWwsIGdyYWRpZW50LmN4IC0gZ3JhZGllbnQucngsIGdyYWRpZW50LmN5IC0gZ3JhZGllbnQucnksIDIgKiBncmFkaWVudC5yeCwgMiAqIGdyYWRpZW50LnJ5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY2FudmFzO1xuICAgICAgICB9O1xuXG4gICAgICAgIEdlbmVyYXRlLkxpc3RBbHBoYSA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHZhciB0bXAgPSAnJyxcbiAgICAgICAgICAgICAgICBtb2R1bHVzO1xuXG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgbW9kdWx1cyA9IG51bWJlciAlIDI2O1xuICAgICAgICAgICAgICAgIHRtcCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoKG1vZHVsdXMpICsgNjQpICsgdG1wO1xuICAgICAgICAgICAgICAgIG51bWJlciA9IG51bWJlciAvIDI2O1xuICAgICAgICAgICAgfSB3aGlsZSAoKG51bWJlciAqIDI2KSA+IDI2KTtcblxuICAgICAgICAgICAgcmV0dXJuIHRtcDtcbiAgICAgICAgfTtcblxuICAgICAgICBHZW5lcmF0ZS5MaXN0Um9tYW4gPSBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgcm9tYW5BcnJheSA9IFsnTScsICdDTScsICdEJywgJ0NEJywgJ0MnLCAnWEMnLCAnTCcsICdYTCcsICdYJywgJ0lYJywgJ1YnLCAnSVYnLCAnSSddLFxuICAgICAgICAgICAgICAgIGRlY2ltYWwgPSBbMTAwMCwgOTAwLCA1MDAsIDQwMCwgMTAwLCA5MCwgNTAsIDQwLCAxMCwgOSwgNSwgNCwgMV0sXG4gICAgICAgICAgICAgICAgcm9tYW4gPSAnJyxcbiAgICAgICAgICAgICAgICB2LFxuICAgICAgICAgICAgICAgIGxlbiA9IHJvbWFuQXJyYXkubGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAobnVtYmVyIDw9IDAgfHwgbnVtYmVyID49IDQwMDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHYgPSAwOyB2IDwgbGVuOyB2ICs9IDEpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAobnVtYmVyID49IGRlY2ltYWxbdl0pIHtcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyIC09IGRlY2ltYWxbdl07XG4gICAgICAgICAgICAgICAgICAgIHJvbWFuICs9IHJvbWFuQXJyYXlbdl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcm9tYW47XG4gICAgICAgIH07XG4gICAgfSkoKTtcbiAgICBmdW5jdGlvbiBoMmNSZW5kZXJDb250ZXh0ICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHZhciBzdG9yYWdlID0gW107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdG9yYWdlOiBzdG9yYWdlLFxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICBjbGlwOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc3RvcmFnZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2NsaXAnLFxuICAgICAgICAgICAgICAgICAgICAnYXJndW1lbnRzJzogYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJhbnNsYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc3RvcmFnZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3RyYW5zbGF0ZScsXG4gICAgICAgICAgICAgICAgICAgICdhcmd1bWVudHMnOiBhcmd1bWVudHNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc3RvcmFnZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2ZpbGwnLFxuICAgICAgICAgICAgICAgICAgICAnYXJndW1lbnRzJzogYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2F2ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN0b3JhZ2UucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdzYXZlJyxcbiAgICAgICAgICAgICAgICAgICAgJ2FyZ3VtZW50cyc6IGFyZ3VtZW50c1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc3RvcmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzdG9yYWdlLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAncmVzdG9yZScsXG4gICAgICAgICAgICAgICAgICAgICdhcmd1bWVudHMnOiBhcmd1bWVudHNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaWxsUmVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN0b3JhZ2UucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdmaWxsUmVjdCcsXG4gICAgICAgICAgICAgICAgICAgICdhcmd1bWVudHMnOiBhcmd1bWVudHNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjcmVhdGVQYXR0ZXJuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc3RvcmFnZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2NyZWF0ZVBhdHRlcm4nLFxuICAgICAgICAgICAgICAgICAgICAnYXJndW1lbnRzJzogYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHJhd1NoYXBlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNoYXBlID0gW107XG5cbiAgICAgICAgICAgICAgICBzdG9yYWdlLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnZHJhd1NoYXBlJyxcbiAgICAgICAgICAgICAgICAgICAgJ2FyZ3VtZW50cyc6IHNoYXBlXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtb3ZlVG86IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdtb3ZlVG8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdhcmd1bWVudHMnOiBhcmd1bWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBsaW5lVG86IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdsaW5lVG8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdhcmd1bWVudHMnOiBhcmd1bWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBhcmNUbzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGUucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2FyY1RvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYXJndW1lbnRzJzogYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYmV6aWVyQ3VydmVUbzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGUucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2JlemllckN1cnZlVG8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdhcmd1bWVudHMnOiBhcmd1bWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBxdWFkcmF0aWNDdXJ2ZVRvOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFwZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncXVhZHJhdGljQ3VydmVUbycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FyZ3VtZW50cyc6IGFyZ3VtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRyYXdJbWFnZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN0b3JhZ2UucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdkcmF3SW1hZ2UnLFxuICAgICAgICAgICAgICAgICAgICAnYXJndW1lbnRzJzogYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmlsbFRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzdG9yYWdlLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnZmlsbFRleHQnLFxuICAgICAgICAgICAgICAgICAgICAnYXJndW1lbnRzJzogYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0VmFyaWFibGU6IGZ1bmN0aW9uICh2YXJpYWJsZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBzdG9yYWdlLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAndmFyaWFibGUnLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiB2YXJpYWJsZSxcbiAgICAgICAgICAgICAgICAgICAgJ2FyZ3VtZW50cyc6IHZhbHVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBfaHRtbDJjYW52YXMuUGFyc2UgPSBmdW5jdGlvbiAoaW1hZ2VzLCBvcHRpb25zKSB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGwoMCwgMCk7XG5cbiAgICAgICAgdmFyIGVsZW1lbnQgPSAoKG9wdGlvbnMuZWxlbWVudHMgPT09IHVuZGVmaW5lZCkgPyBkb2N1bWVudC5ib2R5IDogb3B0aW9ucy5lbGVtZW50c1swXSksIC8vIHNlbGVjdCBib2R5IGJ5IGRlZmF1bHRcbiAgICAgICAgICAgIG51bURyYXdzID0gMCxcbiAgICAgICAgICAgIGRvYyA9IGVsZW1lbnQub3duZXJEb2N1bWVudCxcbiAgICAgICAgICAgIFV0aWwgPSBfaHRtbDJjYW52YXMuVXRpbCxcbiAgICAgICAgICAgIHN1cHBvcnQgPSBVdGlsLlN1cHBvcnQob3B0aW9ucywgZG9jKSxcbiAgICAgICAgICAgIGlnbm9yZUVsZW1lbnRzUmVnRXhwID0gbmV3IFJlZ0V4cCgnKCcgKyBvcHRpb25zLmlnbm9yZUVsZW1lbnRzICsgJyknKSxcbiAgICAgICAgICAgIGJvZHkgPSBkb2MuYm9keSxcbiAgICAgICAgICAgIGdldENTUyA9IFV0aWwuZ2V0Q1NTLFxuICAgICAgICAgICAgcHNldWRvSGlkZSA9ICdfX19odG1sMmNhbnZhc19fX3BzZXVkb2VsZW1lbnQnLFxuICAgICAgICAgICAgaGlkZVBzZXVkb0VsZW1lbnRzID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG5cbiAgICAgICAgaGlkZVBzZXVkb0VsZW1lbnRzLmlubmVySFRNTCA9ICcuJyArIHBzZXVkb0hpZGUgKyAnLWJlZm9yZTpiZWZvcmUgeyBjb250ZW50OiBcIlwiICFpbXBvcnRhbnQ7IGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDsgfScgK1xuICAnLicgKyBwc2V1ZG9IaWRlICsgJy1hZnRlcjphZnRlciB7IGNvbnRlbnQ6IFwiXCIgIWltcG9ydGFudDsgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50OyB9JztcblxuICAgICAgICBib2R5LmFwcGVuZENoaWxkKGhpZGVQc2V1ZG9FbGVtZW50cyk7XG5cbiAgICAgICAgaW1hZ2VzID0gaW1hZ2VzIHx8IHt9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGRvY3VtZW50V2lkdGggKCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KFxuICAgICAgTWF0aC5tYXgoZG9jLmJvZHkuc2Nyb2xsV2lkdGgsIGRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsV2lkdGgpLFxuICAgICAgTWF0aC5tYXgoZG9jLmJvZHkub2Zmc2V0V2lkdGgsIGRvYy5kb2N1bWVudEVsZW1lbnQub2Zmc2V0V2lkdGgpLFxuICAgICAgTWF0aC5tYXgoZG9jLmJvZHkuY2xpZW50V2lkdGgsIGRvYy5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgpXG4gICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZG9jdW1lbnRIZWlnaHQgKCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KFxuICAgICAgTWF0aC5tYXgoZG9jLmJvZHkuc2Nyb2xsSGVpZ2h0LCBkb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodCksXG4gICAgICBNYXRoLm1heChkb2MuYm9keS5vZmZzZXRIZWlnaHQsIGRvYy5kb2N1bWVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0KSxcbiAgICAgIE1hdGgubWF4KGRvYy5ib2R5LmNsaWVudEhlaWdodCwgZG9jLmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpXG4gICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0Q1NTSW50IChlbGVtZW50LCBhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSBwYXJzZUludChnZXRDU1MoZWxlbWVudCwgYXR0cmlidXRlKSwgMTApO1xuICAgICAgICAgICAgcmV0dXJuIChpc05hTih2YWwpKSA/IDAgOiB2YWw7IC8vIGJvcmRlcnMgaW4gb2xkIElFIGFyZSB0aHJvd2luZyAnbWVkaXVtJyBmb3IgZGVtby5odG1sXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZW5kZXJSZWN0IChjdHgsIHgsIHksIHcsIGgsIGJnY29sb3IpIHtcbiAgICAgICAgICAgIGlmIChiZ2NvbG9yICE9PSAndHJhbnNwYXJlbnQnKSB7XG4gICAgICAgICAgICAgICAgY3R4LnNldFZhcmlhYmxlKCdmaWxsU3R5bGUnLCBiZ2NvbG9yKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgICAgICAgICAgbnVtRHJhd3MgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNhcGl0YWxpemUgKG0sIHAxLCBwMikge1xuICAgICAgICAgICAgaWYgKG0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwMSArIHAyLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB0ZXh0VHJhbnNmb3JtICh0ZXh0LCB0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBjYXNlICdsb3dlcmNhc2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBjYXNlICdjYXBpdGFsaXplJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC8oXnxcXHN8OnwtfFxcKHxcXCkpKFthLXpdKS9nLCBjYXBpdGFsaXplKTtcbiAgICAgICAgICAgIGNhc2UgJ3VwcGVyY2FzZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHQudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBub0xldHRlclNwYWNpbmcgKGxldHRlcl9zcGFjaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gKC9eKG5vcm1hbHxub25lfDBweCkkLy50ZXN0KGxldHRlcl9zcGFjaW5nKSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBkcmF3VGV4dCAoY3VycmVudFRleHQsIHgsIHksIGN0eCkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRUZXh0ICE9PSBudWxsICYmIFV0aWwudHJpbVRleHQoY3VycmVudFRleHQpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQoY3VycmVudFRleHQsIHgsIHkpO1xuICAgICAgICAgICAgICAgIG51bURyYXdzICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzZXRUZXh0VmFyaWFibGVzIChjdHgsIGVsLCB0ZXh0X2RlY29yYXRpb24sIGNvbG9yKSB7XG4gICAgICAgICAgICB2YXIgYWxpZ24gPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBib2xkID0gZ2V0Q1NTKGVsLCAnZm9udFdlaWdodCcpLFxuICAgICAgICAgICAgICAgIGZhbWlseSA9IGdldENTUyhlbCwgJ2ZvbnRGYW1pbHknKSxcbiAgICAgICAgICAgICAgICBzaXplID0gZ2V0Q1NTKGVsLCAnZm9udFNpemUnKSxcbiAgICAgICAgICAgICAgICBzaGFkb3dzID0gVXRpbC5wYXJzZVRleHRTaGFkb3dzKGdldENTUyhlbCwgJ3RleHRTaGFkb3cnKSk7XG5cbiAgICAgICAgICAgIHN3aXRjaCAocGFyc2VJbnQoYm9sZCwgMTApKSB7XG4gICAgICAgICAgICBjYXNlIDQwMTpcbiAgICAgICAgICAgICAgICBib2xkID0gJ2JvbGQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0MDA6XG4gICAgICAgICAgICAgICAgYm9sZCA9ICdub3JtYWwnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHguc2V0VmFyaWFibGUoJ2ZpbGxTdHlsZScsIGNvbG9yKTtcbiAgICAgICAgICAgIGN0eC5zZXRWYXJpYWJsZSgnZm9udCcsIFtnZXRDU1MoZWwsICdmb250U3R5bGUnKSwgZ2V0Q1NTKGVsLCAnZm9udFZhcmlhbnQnKSwgYm9sZCwgc2l6ZSwgZmFtaWx5XS5qb2luKCcgJykpO1xuICAgICAgICAgICAgY3R4LnNldFZhcmlhYmxlKCd0ZXh0QWxpZ24nLCAoYWxpZ24pID8gJ3JpZ2h0JyA6ICdsZWZ0Jyk7XG5cbiAgICAgICAgICAgIGlmIChzaGFkb3dzLmxlbmd0aCkge1xuICAgICAgLy8gVE9ETzogc3VwcG9ydCBtdWx0aXBsZSB0ZXh0IHNoYWRvd3NcbiAgICAgIC8vIGFwcGx5IHRoZSBmaXJzdCB0ZXh0IHNoYWRvd1xuICAgICAgICAgICAgICAgIGN0eC5zZXRWYXJpYWJsZSgnc2hhZG93Q29sb3InLCBzaGFkb3dzWzBdLmNvbG9yKTtcbiAgICAgICAgICAgICAgICBjdHguc2V0VmFyaWFibGUoJ3NoYWRvd09mZnNldFgnLCBzaGFkb3dzWzBdLm9mZnNldFgpO1xuICAgICAgICAgICAgICAgIGN0eC5zZXRWYXJpYWJsZSgnc2hhZG93T2Zmc2V0WScsIHNoYWRvd3NbMF0ub2Zmc2V0WSk7XG4gICAgICAgICAgICAgICAgY3R4LnNldFZhcmlhYmxlKCdzaGFkb3dCbHVyJywgc2hhZG93c1swXS5ibHVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRleHRfZGVjb3JhdGlvbiAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWwuRm9udChmYW1pbHksIHNpemUsIGRvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZW5kZXJUZXh0RGVjb3JhdGlvbiAoY3R4LCB0ZXh0X2RlY29yYXRpb24sIGJvdW5kcywgbWV0cmljcywgY29sb3IpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGV4dF9kZWNvcmF0aW9uKSB7XG4gICAgICAgICAgICBjYXNlICd1bmRlcmxpbmUnOlxuICAgICAgICAvLyBEcmF3cyBhIGxpbmUgYXQgdGhlIGJhc2VsaW5lIG9mIHRoZSBmb250XG4gICAgICAgIC8vIFRPRE8gQXMgc29tZSBicm93c2VycyBkaXNwbGF5IHRoZSBsaW5lIGFzIG1vcmUgdGhhbiAxcHggaWYgdGhlIGZvbnQtc2l6ZSBpcyBiaWcsIG5lZWQgdG8gdGFrZSB0aGF0IGludG8gYWNjb3VudCBib3RoIGluIHBvc2l0aW9uIGFuZCBzaXplXG4gICAgICAgICAgICAgICAgcmVuZGVyUmVjdChjdHgsIGJvdW5kcy5sZWZ0LCBNYXRoLnJvdW5kKGJvdW5kcy50b3AgKyBtZXRyaWNzLmJhc2VsaW5lICsgbWV0cmljcy5saW5lV2lkdGgpLCBib3VuZHMud2lkdGgsIDEsIGNvbG9yKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ292ZXJsaW5lJzpcbiAgICAgICAgICAgICAgICByZW5kZXJSZWN0KGN0eCwgYm91bmRzLmxlZnQsIE1hdGgucm91bmQoYm91bmRzLnRvcCksIGJvdW5kcy53aWR0aCwgMSwgY29sb3IpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbGluZS10aHJvdWdoJzpcbiAgICAgICAgLy8gVE9ETyB0cnkgYW5kIGZpbmQgZXhhY3QgcG9zaXRpb24gZm9yIGxpbmUtdGhyb3VnaFxuICAgICAgICAgICAgICAgIHJlbmRlclJlY3QoY3R4LCBib3VuZHMubGVmdCwgTWF0aC5jZWlsKGJvdW5kcy50b3AgKyBtZXRyaWNzLm1pZGRsZSArIG1ldHJpY3MubGluZVdpZHRoKSwgYm91bmRzLndpZHRoLCAxLCBjb2xvcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRUZXh0Qm91bmRzIChzdGF0ZSwgdGV4dCwgdGV4dERlY29yYXRpb24sIGlzTGFzdCwgdHJhbnNmb3JtKSB7XG4gICAgICAgICAgICB2YXIgYm91bmRzO1xuICAgICAgICAgICAgaWYgKHN1cHBvcnQucmFuZ2VCb3VuZHMgJiYgIXRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0RGVjb3JhdGlvbiAhPT0gJ25vbmUnIHx8IFV0aWwudHJpbVRleHQodGV4dCkubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJvdW5kcyA9IHRleHRSYW5nZUJvdW5kcyh0ZXh0LCBzdGF0ZS5ub2RlLCBzdGF0ZS50ZXh0T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGUudGV4dE9mZnNldCArPSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUubm9kZSAmJiB0eXBlb2Ygc3RhdGUubm9kZS5ub2RlVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1RleHROb2RlID0gKGlzTGFzdCkgPyBzdGF0ZS5ub2RlLnNwbGl0VGV4dCh0ZXh0Lmxlbmd0aCkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGJvdW5kcyA9IHRleHRXcmFwcGVyQm91bmRzKHN0YXRlLm5vZGUsIHRyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgc3RhdGUubm9kZSA9IG5ld1RleHROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHRleHRSYW5nZUJvdW5kcyAodGV4dCwgdGV4dE5vZGUsIHRleHRPZmZzZXQpIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IGRvYy5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQodGV4dE5vZGUsIHRleHRPZmZzZXQpO1xuICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKHRleHROb2RlLCB0ZXh0T2Zmc2V0ICsgdGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIHJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdGV4dFdyYXBwZXJCb3VuZHMgKG9sZFRleHROb2RlLCB0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBvbGRUZXh0Tm9kZS5wYXJlbnROb2RlLFxuICAgICAgICAgICAgICAgIHdyYXBFbGVtZW50ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3dyYXBwZXInKSxcbiAgICAgICAgICAgICAgICBiYWNrdXBUZXh0ID0gb2xkVGV4dE5vZGUuY2xvbmVOb2RlKHRydWUpO1xuXG4gICAgICAgICAgICB3cmFwRWxlbWVudC5hcHBlbmRDaGlsZChvbGRUZXh0Tm9kZS5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgICAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh3cmFwRWxlbWVudCwgb2xkVGV4dE5vZGUpO1xuXG4gICAgICAgICAgICB2YXIgYm91bmRzID0gdHJhbnNmb3JtID8gVXRpbC5PZmZzZXRCb3VuZHMod3JhcEVsZW1lbnQpIDogVXRpbC5Cb3VuZHMod3JhcEVsZW1lbnQpO1xuICAgICAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZChiYWNrdXBUZXh0LCB3cmFwRWxlbWVudCk7XG4gICAgICAgICAgICByZXR1cm4gYm91bmRzO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVuZGVyVGV4dCAoZWwsIHRleHROb2RlLCBzdGFjaykge1xuICAgICAgICAgICAgdmFyIGN0eCA9IHN0YWNrLmN0eCxcbiAgICAgICAgICAgICAgICBjb2xvciA9IGdldENTUyhlbCwgJ2NvbG9yJyksXG4gICAgICAgICAgICAgICAgdGV4dERlY29yYXRpb24gPSBnZXRDU1MoZWwsICd0ZXh0RGVjb3JhdGlvbicpLFxuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9IGdldENTUyhlbCwgJ3RleHRBbGlnbicpLFxuICAgICAgICAgICAgICAgIG1ldHJpY3MsXG4gICAgICAgICAgICAgICAgdGV4dExpc3QsXG4gICAgICAgICAgICAgICAgc3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGU6IHRleHROb2RlLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0T2Zmc2V0OiAwXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKFV0aWwudHJpbVRleHQodGV4dE5vZGUubm9kZVZhbHVlKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGV4dE5vZGUubm9kZVZhbHVlID0gdGV4dFRyYW5zZm9ybSh0ZXh0Tm9kZS5ub2RlVmFsdWUsIGdldENTUyhlbCwgJ3RleHRUcmFuc2Zvcm0nKSk7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gdGV4dEFsaWduLnJlcGxhY2UoWyctd2Via2l0LWF1dG8nXSwgWydhdXRvJ10pO1xuXG4gICAgICAgICAgICAgICAgdGV4dExpc3QgPSAoIW9wdGlvbnMubGV0dGVyUmVuZGVyaW5nICYmIC9eKGxlZnR8cmlnaHR8anVzdGlmeXxhdXRvKSQvLnRlc3QodGV4dEFsaWduKSAmJiBub0xldHRlclNwYWNpbmcoZ2V0Q1NTKGVsLCAnbGV0dGVyU3BhY2luZycpKSlcbiAgICAgID8gdGV4dE5vZGUubm9kZVZhbHVlLnNwbGl0KC8oXFxifCApLylcbiAgICAgIDogdGV4dE5vZGUubm9kZVZhbHVlLnNwbGl0KCcnKTtcblxuICAgICAgICAgICAgICAgIG1ldHJpY3MgPSBzZXRUZXh0VmFyaWFibGVzKGN0eCwgZWwsIHRleHREZWNvcmF0aW9uLCBjb2xvcik7XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jaGluZXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRMaXN0LmZvckVhY2goZnVuY3Rpb24gKHdvcmQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoLy4qW1xcdTRFMDAtXFx1OUZBNV0uKiQvLnRlc3Qod29yZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JkID0gd29yZC5zcGxpdCgnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29yZC51bnNoaWZ0KGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0TGlzdC5zcGxpY2UuYXBwbHkodGV4dExpc3QsIHdvcmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0ZXh0TGlzdC5mb3JFYWNoKGZ1bmN0aW9uICh0ZXh0LCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYm91bmRzID0gZ2V0VGV4dEJvdW5kcyhzdGF0ZSwgdGV4dCwgdGV4dERlY29yYXRpb24sIChpbmRleCA8IHRleHRMaXN0Lmxlbmd0aCAtIDEpLCBzdGFjay50cmFuc2Zvcm0ubWF0cml4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvdW5kcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJhd1RleHQodGV4dCwgYm91bmRzLmxlZnQsIGJvdW5kcy5ib3R0b20sIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJUZXh0RGVjb3JhdGlvbihjdHgsIHRleHREZWNvcmF0aW9uLCBib3VuZHMsIG1ldHJpY3MsIGNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbGlzdFBvc2l0aW9uIChlbGVtZW50LCB2YWwpIHtcbiAgICAgICAgICAgIHZhciBib3VuZEVsZW1lbnQgPSBkb2MuY3JlYXRlRWxlbWVudCgnYm91bmRlbGVtZW50JyksXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxUeXBlLFxuICAgICAgICAgICAgICAgIGJvdW5kcztcblxuICAgICAgICAgICAgYm91bmRFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lJztcblxuICAgICAgICAgICAgb3JpZ2luYWxUeXBlID0gZWxlbWVudC5zdHlsZS5saXN0U3R5bGVUeXBlO1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5saXN0U3R5bGVUeXBlID0gJ25vbmUnO1xuXG4gICAgICAgICAgICBib3VuZEVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZVRleHROb2RlKHZhbCkpO1xuXG4gICAgICAgICAgICBlbGVtZW50Lmluc2VydEJlZm9yZShib3VuZEVsZW1lbnQsIGVsZW1lbnQuZmlyc3RDaGlsZCk7XG5cbiAgICAgICAgICAgIGJvdW5kcyA9IFV0aWwuQm91bmRzKGJvdW5kRWxlbWVudCk7XG4gICAgICAgICAgICBlbGVtZW50LnJlbW92ZUNoaWxkKGJvdW5kRWxlbWVudCk7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLmxpc3RTdHlsZVR5cGUgPSBvcmlnaW5hbFR5cGU7XG4gICAgICAgICAgICByZXR1cm4gYm91bmRzO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZWxlbWVudEluZGV4IChlbCkge1xuICAgICAgICAgICAgdmFyIGkgPSAtMSxcbiAgICAgICAgICAgICAgICBjb3VudCA9IDEsXG4gICAgICAgICAgICAgICAgY2hpbGRzID0gZWwucGFyZW50Tm9kZS5jaGlsZE5vZGVzO1xuXG4gICAgICAgICAgICBpZiAoZWwucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChjaGlsZHNbKytpXSAhPT0gZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkc1tpXS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGxpc3RJdGVtVGV4dCAoZWxlbWVudCwgdHlwZSkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IGVsZW1lbnRJbmRleChlbGVtZW50KSwgdGV4dDtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnZGVjaW1hbCc6XG4gICAgICAgICAgICAgICAgdGV4dCA9IGN1cnJlbnRJbmRleDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2RlY2ltYWwtbGVhZGluZy16ZXJvJzpcbiAgICAgICAgICAgICAgICB0ZXh0ID0gKGN1cnJlbnRJbmRleC50b1N0cmluZygpLmxlbmd0aCA9PT0gMSkgPyBjdXJyZW50SW5kZXggPSAnMCcgKyBjdXJyZW50SW5kZXgudG9TdHJpbmcoKSA6IGN1cnJlbnRJbmRleC50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndXBwZXItcm9tYW4nOlxuICAgICAgICAgICAgICAgIHRleHQgPSBfaHRtbDJjYW52YXMuR2VuZXJhdGUuTGlzdFJvbWFuKGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdsb3dlci1yb21hbic6XG4gICAgICAgICAgICAgICAgdGV4dCA9IF9odG1sMmNhbnZhcy5HZW5lcmF0ZS5MaXN0Um9tYW4oY3VycmVudEluZGV4KS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbG93ZXItYWxwaGEnOlxuICAgICAgICAgICAgICAgIHRleHQgPSBfaHRtbDJjYW52YXMuR2VuZXJhdGUuTGlzdEFscGhhKGN1cnJlbnRJbmRleCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3VwcGVyLWFscGhhJzpcbiAgICAgICAgICAgICAgICB0ZXh0ID0gX2h0bWwyY2FudmFzLkdlbmVyYXRlLkxpc3RBbHBoYShjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGV4dCArICcuICc7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZW5kZXJMaXN0SXRlbSAoZWxlbWVudCwgc3RhY2ssIGVsQm91bmRzKSB7XG4gICAgICAgICAgICB2YXIgeCxcbiAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgIGN0eCA9IHN0YWNrLmN0eCxcbiAgICAgICAgICAgICAgICB0eXBlID0gZ2V0Q1NTKGVsZW1lbnQsICdsaXN0U3R5bGVUeXBlJyksXG4gICAgICAgICAgICAgICAgbGlzdEJvdW5kcztcblxuICAgICAgICAgICAgaWYgKC9eKGRlY2ltYWx8ZGVjaW1hbC1sZWFkaW5nLXplcm98dXBwZXItYWxwaGF8dXBwZXItbGF0aW58dXBwZXItcm9tYW58bG93ZXItYWxwaGF8bG93ZXItZ3JlZWt8bG93ZXItbGF0aW58bG93ZXItcm9tYW4pJC9pLnRlc3QodHlwZSkpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gbGlzdEl0ZW1UZXh0KGVsZW1lbnQsIHR5cGUpO1xuICAgICAgICAgICAgICAgIGxpc3RCb3VuZHMgPSBsaXN0UG9zaXRpb24oZWxlbWVudCwgdGV4dCk7XG4gICAgICAgICAgICAgICAgc2V0VGV4dFZhcmlhYmxlcyhjdHgsIGVsZW1lbnQsICdub25lJywgZ2V0Q1NTKGVsZW1lbnQsICdjb2xvcicpKTtcblxuICAgICAgICAgICAgICAgIGlmIChnZXRDU1MoZWxlbWVudCwgJ2xpc3RTdHlsZVBvc2l0aW9uJykgPT09ICdpbnNpZGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zZXRWYXJpYWJsZSgndGV4dEFsaWduJywgJ2xlZnQnKTtcbiAgICAgICAgICAgICAgICAgICAgeCA9IGVsQm91bmRzLmxlZnQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRyYXdUZXh0KHRleHQsIHgsIGxpc3RCb3VuZHMuYm90dG9tLCBjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbG9hZEltYWdlIChzcmMpIHtcbiAgICAgICAgICAgIHZhciBpbWcgPSBpbWFnZXNbc3JjXTtcbiAgICAgICAgICAgIHJldHVybiAoaW1nICYmIGltZy5zdWNjZWVkZWQgPT09IHRydWUpID8gaW1nLmltZyA6IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY2xpcEJvdW5kcyAoc3JjLCBkc3QpIHtcbiAgICAgICAgICAgIHZhciB4ID0gTWF0aC5tYXgoc3JjLmxlZnQsIGRzdC5sZWZ0KSxcbiAgICAgICAgICAgICAgICB5ID0gTWF0aC5tYXgoc3JjLnRvcCwgZHN0LnRvcCksXG4gICAgICAgICAgICAgICAgeDIgPSBNYXRoLm1pbigoc3JjLmxlZnQgKyBzcmMud2lkdGgpLCAoZHN0LmxlZnQgKyBkc3Qud2lkdGgpKSxcbiAgICAgICAgICAgICAgICB5MiA9IE1hdGgubWluKChzcmMudG9wICsgc3JjLmhlaWdodCksIChkc3QudG9wICsgZHN0LmhlaWdodCkpO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGxlZnQ6IHgsXG4gICAgICAgICAgICAgICAgdG9wOiB5LFxuICAgICAgICAgICAgICAgIHdpZHRoOiB4MiAtIHgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB5MiAtIHlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzZXRaIChlbGVtZW50LCBzdGFjaywgcGFyZW50U3RhY2spIHtcbiAgICAgICAgICAgIHZhciBuZXdDb250ZXh0LFxuICAgICAgICAgICAgICAgIGlzUG9zaXRpb25lZCA9IHN0YWNrLmNzc1Bvc2l0aW9uICE9PSAnc3RhdGljJyxcbiAgICAgICAgICAgICAgICB6SW5kZXggPSBpc1Bvc2l0aW9uZWQgPyBnZXRDU1MoZWxlbWVudCwgJ3pJbmRleCcpIDogJ2F1dG8nLFxuICAgICAgICAgICAgICAgIG9wYWNpdHkgPSBnZXRDU1MoZWxlbWVudCwgJ29wYWNpdHknKSxcbiAgICAgICAgICAgICAgICBpc0Zsb2F0ZWQgPSBnZXRDU1MoZWxlbWVudCwgJ2Nzc0Zsb2F0JykgIT09ICdub25lJztcblxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0d1aWRlL0NTUy9VbmRlcnN0YW5kaW5nX3pfaW5kZXgvVGhlX3N0YWNraW5nX2NvbnRleHRcbiAgICAvLyBXaGVuIGEgbmV3IHN0YWNraW5nIGNvbnRleHQgc2hvdWxkIGJlIGNyZWF0ZWQ6XG4gICAgLy8gdGhlIHJvb3QgZWxlbWVudCAoSFRNTCksXG4gICAgLy8gcG9zaXRpb25lZCAoYWJzb2x1dGVseSBvciByZWxhdGl2ZWx5KSB3aXRoIGEgei1pbmRleCB2YWx1ZSBvdGhlciB0aGFuIFwiYXV0b1wiLFxuICAgIC8vIGVsZW1lbnRzIHdpdGggYW4gb3BhY2l0eSB2YWx1ZSBsZXNzIHRoYW4gMS4gKFNlZSB0aGUgc3BlY2lmaWNhdGlvbiBmb3Igb3BhY2l0eSksXG4gICAgLy8gb24gbW9iaWxlIFdlYktpdCBhbmQgQ2hyb21lIDIyKywgcG9zaXRpb246IGZpeGVkIGFsd2F5cyBjcmVhdGVzIGEgbmV3IHN0YWNraW5nIGNvbnRleHQsIGV2ZW4gd2hlbiB6LWluZGV4IGlzIFwiYXV0b1wiIChTZWUgdGhpcyBwb3N0KVxuXG4gICAgICAgICAgICBzdGFjay56SW5kZXggPSBuZXdDb250ZXh0ID0gaDJjekNvbnRleHQoekluZGV4KTtcbiAgICAgICAgICAgIG5ld0NvbnRleHQuaXNQb3NpdGlvbmVkID0gaXNQb3NpdGlvbmVkO1xuICAgICAgICAgICAgbmV3Q29udGV4dC5pc0Zsb2F0ZWQgPSBpc0Zsb2F0ZWQ7XG4gICAgICAgICAgICBuZXdDb250ZXh0Lm9wYWNpdHkgPSBvcGFjaXR5O1xuICAgICAgICAgICAgbmV3Q29udGV4dC5vd25TdGFja2luZyA9ICh6SW5kZXggIT09ICdhdXRvJyB8fCBvcGFjaXR5IDwgMSk7XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnRTdGFjaykge1xuICAgICAgICAgICAgICAgIHBhcmVudFN0YWNrLnpJbmRleC5jaGlsZHJlbi5wdXNoKHN0YWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlbmRlckltYWdlIChjdHgsIGVsZW1lbnQsIGltYWdlLCBib3VuZHMsIGJvcmRlcnMpIHtcbiAgICAgICAgICAgIHZhciBwYWRkaW5nTGVmdCA9IGdldENTU0ludChlbGVtZW50LCAncGFkZGluZ0xlZnQnKSxcbiAgICAgICAgICAgICAgICBwYWRkaW5nVG9wID0gZ2V0Q1NTSW50KGVsZW1lbnQsICdwYWRkaW5nVG9wJyksXG4gICAgICAgICAgICAgICAgcGFkZGluZ1JpZ2h0ID0gZ2V0Q1NTSW50KGVsZW1lbnQsICdwYWRkaW5nUmlnaHQnKSxcbiAgICAgICAgICAgICAgICBwYWRkaW5nQm90dG9tID0gZ2V0Q1NTSW50KGVsZW1lbnQsICdwYWRkaW5nQm90dG9tJyk7XG5cbiAgICAgICAgICAgIGRyYXdJbWFnZShcbiAgICAgIGN0eCxcbiAgICAgIGltYWdlLFxuICAgICAgMCwgLy8gc3hcbiAgICAgIDAsIC8vIHN5XG4gICAgICBpbWFnZS53aWR0aCwgLy8gc3dcbiAgICAgIGltYWdlLmhlaWdodCwgLy8gc2hcbiAgICAgIGJvdW5kcy5sZWZ0ICsgcGFkZGluZ0xlZnQgKyBib3JkZXJzWzNdLndpZHRoLCAvLyBkeFxuICAgICAgYm91bmRzLnRvcCArIHBhZGRpbmdUb3AgKyBib3JkZXJzWzBdLndpZHRoLCAvLyBkeVxuICAgICAgYm91bmRzLndpZHRoIC0gKGJvcmRlcnNbMV0ud2lkdGggKyBib3JkZXJzWzNdLndpZHRoICsgcGFkZGluZ0xlZnQgKyBwYWRkaW5nUmlnaHQpLCAvLyBkd1xuICAgICAgYm91bmRzLmhlaWdodCAtIChib3JkZXJzWzBdLndpZHRoICsgYm9yZGVyc1syXS53aWR0aCArIHBhZGRpbmdUb3AgKyBwYWRkaW5nQm90dG9tKSAvLyBkaFxuICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldEJvcmRlckRhdGEgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBbJ1RvcCcsICdSaWdodCcsICdCb3R0b20nLCAnTGVmdCddLm1hcChmdW5jdGlvbiAoc2lkZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBnZXRDU1NJbnQoZWxlbWVudCwgJ2JvcmRlcicgKyBzaWRlICsgJ1dpZHRoJyksXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBnZXRDU1MoZWxlbWVudCwgJ2JvcmRlcicgKyBzaWRlICsgJ0NvbG9yJylcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRCb3JkZXJSYWRpdXNEYXRhIChlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gWydUb3BMZWZ0JywgJ1RvcFJpZ2h0JywgJ0JvdHRvbVJpZ2h0JywgJ0JvdHRvbUxlZnQnXS5tYXAoZnVuY3Rpb24gKHNpZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Q1NTKGVsZW1lbnQsICdib3JkZXInICsgc2lkZSArICdSYWRpdXMnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGdldEN1cnZlUG9pbnRzID0gKGZ1bmN0aW9uIChrYXBwYSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4LCB5LCByMSwgcjIpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3ggPSAocjEpICoga2FwcGEsIC8vIGNvbnRyb2wgcG9pbnQgb2Zmc2V0IGhvcml6b250YWxcbiAgICAgICAgICAgICAgICAgICAgb3kgPSAocjIpICoga2FwcGEsIC8vIGNvbnRyb2wgcG9pbnQgb2Zmc2V0IHZlcnRpY2FsXG4gICAgICAgICAgICAgICAgICAgIHhtID0geCArIHIxLCAvLyB4LW1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB5bSA9IHkgKyByMjsgLy8geS1taWRkbGVcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0b3BMZWZ0OiBiZXppZXJDdXJ2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogeW1cbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHltIC0gb3lcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogeG0gLSBveCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHlcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogeG0sXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiB5XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICB0b3BSaWdodDogYmV6aWVyQ3VydmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHlcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogeCArIG94LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogeVxuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB4bSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHltIC0gb3lcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogeG0sXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiB5bVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tUmlnaHQ6IGJlemllckN1cnZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHhtLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogeVxuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB4bSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHkgKyBveVxuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB4ICsgb3gsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiB5bVxuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogeW1cbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbUxlZnQ6IGJlemllckN1cnZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHhtLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogeW1cbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogeG0gLSBveCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHltXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiB5ICsgb3lcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkoNCAqICgoTWF0aC5zcXJ0KDIpIC0gMSkgLyAzKSk7XG5cbiAgICAgICAgZnVuY3Rpb24gYmV6aWVyQ3VydmUgKHN0YXJ0LCBzdGFydENvbnRyb2wsIGVuZENvbnRyb2wsIGVuZCkge1xuICAgICAgICAgICAgdmFyIGxlcnAgPSBmdW5jdGlvbiAoYSwgYiwgdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGEueCArIChiLnggLSBhLngpICogdCxcbiAgICAgICAgICAgICAgICAgICAgeTogYS55ICsgKGIueSAtIGEueSkgKiB0XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgIHN0YXJ0Q29udHJvbDogc3RhcnRDb250cm9sLFxuICAgICAgICAgICAgICAgIGVuZENvbnRyb2w6IGVuZENvbnRyb2wsXG4gICAgICAgICAgICAgICAgZW5kOiBlbmQsXG4gICAgICAgICAgICAgICAgc3ViZGl2aWRlOiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWIgPSBsZXJwKHN0YXJ0LCBzdGFydENvbnRyb2wsIHQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmMgPSBsZXJwKHN0YXJ0Q29udHJvbCwgZW5kQ29udHJvbCwgdCksXG4gICAgICAgICAgICAgICAgICAgICAgICBjZCA9IGxlcnAoZW5kQ29udHJvbCwgZW5kLCB0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFiYmMgPSBsZXJwKGFiLCBiYywgdCksXG4gICAgICAgICAgICAgICAgICAgICAgICBiY2NkID0gbGVycChiYywgY2QsIHQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdCA9IGxlcnAoYWJiYywgYmNjZCwgdCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbYmV6aWVyQ3VydmUoc3RhcnQsIGFiLCBhYmJjLCBkZXN0KSwgYmV6aWVyQ3VydmUoZGVzdCwgYmNjZCwgY2QsIGVuZCldO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY3VydmVUbzogZnVuY3Rpb24gKGJvcmRlckFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyQXJncy5wdXNoKFsnYmV6aWVyQ3VydmUnLCBzdGFydENvbnRyb2wueCwgc3RhcnRDb250cm9sLnksIGVuZENvbnRyb2wueCwgZW5kQ29udHJvbC55LCBlbmQueCwgZW5kLnldKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGN1cnZlVG9SZXZlcnNlZDogZnVuY3Rpb24gKGJvcmRlckFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyQXJncy5wdXNoKFsnYmV6aWVyQ3VydmUnLCBlbmRDb250cm9sLngsIGVuZENvbnRyb2wueSwgc3RhcnRDb250cm9sLngsIHN0YXJ0Q29udHJvbC55LCBzdGFydC54LCBzdGFydC55XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlQ29ybmVyIChib3JkZXJBcmdzLCByYWRpdXMxLCByYWRpdXMyLCBjb3JuZXIxLCBjb3JuZXIyLCB4LCB5KSB7XG4gICAgICAgICAgICBpZiAocmFkaXVzMVswXSA+IDAgfHwgcmFkaXVzMVsxXSA+IDApIHtcbiAgICAgICAgICAgICAgICBib3JkZXJBcmdzLnB1c2goWydsaW5lJywgY29ybmVyMVswXS5zdGFydC54LCBjb3JuZXIxWzBdLnN0YXJ0LnldKTtcbiAgICAgICAgICAgICAgICBjb3JuZXIxWzBdLmN1cnZlVG8oYm9yZGVyQXJncyk7XG4gICAgICAgICAgICAgICAgY29ybmVyMVsxXS5jdXJ2ZVRvKGJvcmRlckFyZ3MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBib3JkZXJBcmdzLnB1c2goWydsaW5lJywgeCwgeV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmFkaXVzMlswXSA+IDAgfHwgcmFkaXVzMlsxXSA+IDApIHtcbiAgICAgICAgICAgICAgICBib3JkZXJBcmdzLnB1c2goWydsaW5lJywgY29ybmVyMlswXS5zdGFydC54LCBjb3JuZXIyWzBdLnN0YXJ0LnldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGRyYXdTaWRlIChib3JkZXJEYXRhLCByYWRpdXMxLCByYWRpdXMyLCBvdXRlcjEsIGlubmVyMSwgb3V0ZXIyLCBpbm5lcjIpIHtcbiAgICAgICAgICAgIHZhciBib3JkZXJBcmdzID0gW107XG5cbiAgICAgICAgICAgIGlmIChyYWRpdXMxWzBdID4gMCB8fCByYWRpdXMxWzFdID4gMCkge1xuICAgICAgICAgICAgICAgIGJvcmRlckFyZ3MucHVzaChbJ2xpbmUnLCBvdXRlcjFbMV0uc3RhcnQueCwgb3V0ZXIxWzFdLnN0YXJ0LnldKTtcbiAgICAgICAgICAgICAgICBvdXRlcjFbMV0uY3VydmVUbyhib3JkZXJBcmdzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYm9yZGVyQXJncy5wdXNoKFsgJ2xpbmUnLCBib3JkZXJEYXRhLmMxWzBdLCBib3JkZXJEYXRhLmMxWzFdXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyYWRpdXMyWzBdID4gMCB8fCByYWRpdXMyWzFdID4gMCkge1xuICAgICAgICAgICAgICAgIGJvcmRlckFyZ3MucHVzaChbJ2xpbmUnLCBvdXRlcjJbMF0uc3RhcnQueCwgb3V0ZXIyWzBdLnN0YXJ0LnldKTtcbiAgICAgICAgICAgICAgICBvdXRlcjJbMF0uY3VydmVUbyhib3JkZXJBcmdzKTtcbiAgICAgICAgICAgICAgICBib3JkZXJBcmdzLnB1c2goWydsaW5lJywgaW5uZXIyWzBdLmVuZC54LCBpbm5lcjJbMF0uZW5kLnldKTtcbiAgICAgICAgICAgICAgICBpbm5lcjJbMF0uY3VydmVUb1JldmVyc2VkKGJvcmRlckFyZ3MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBib3JkZXJBcmdzLnB1c2goWyAnbGluZScsIGJvcmRlckRhdGEuYzJbMF0sIGJvcmRlckRhdGEuYzJbMV1dKTtcbiAgICAgICAgICAgICAgICBib3JkZXJBcmdzLnB1c2goWyAnbGluZScsIGJvcmRlckRhdGEuYzNbMF0sIGJvcmRlckRhdGEuYzNbMV1dKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJhZGl1czFbMF0gPiAwIHx8IHJhZGl1czFbMV0gPiAwKSB7XG4gICAgICAgICAgICAgICAgYm9yZGVyQXJncy5wdXNoKFsnbGluZScsIGlubmVyMVsxXS5lbmQueCwgaW5uZXIxWzFdLmVuZC55XSk7XG4gICAgICAgICAgICAgICAgaW5uZXIxWzFdLmN1cnZlVG9SZXZlcnNlZChib3JkZXJBcmdzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYm9yZGVyQXJncy5wdXNoKFsgJ2xpbmUnLCBib3JkZXJEYXRhLmM0WzBdLCBib3JkZXJEYXRhLmM0WzFdXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBib3JkZXJBcmdzO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY2FsY3VsYXRlQ3VydmVQb2ludHMgKGJvdW5kcywgYm9yZGVyUmFkaXVzLCBib3JkZXJzKSB7XG4gICAgICAgICAgICB2YXIgeCA9IGJvdW5kcy5sZWZ0LFxuICAgICAgICAgICAgICAgIHkgPSBib3VuZHMudG9wLFxuICAgICAgICAgICAgICAgIHdpZHRoID0gYm91bmRzLndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodCA9IGJvdW5kcy5oZWlnaHQsXG5cbiAgICAgICAgICAgICAgICB0bGggPSBib3JkZXJSYWRpdXNbMF1bMF0sXG4gICAgICAgICAgICAgICAgdGx2ID0gYm9yZGVyUmFkaXVzWzBdWzFdLFxuICAgICAgICAgICAgICAgIHRyaCA9IGJvcmRlclJhZGl1c1sxXVswXSxcbiAgICAgICAgICAgICAgICB0cnYgPSBib3JkZXJSYWRpdXNbMV1bMV0sXG4gICAgICAgICAgICAgICAgYnJoID0gYm9yZGVyUmFkaXVzWzJdWzBdLFxuICAgICAgICAgICAgICAgIGJydiA9IGJvcmRlclJhZGl1c1syXVsxXSxcbiAgICAgICAgICAgICAgICBibGggPSBib3JkZXJSYWRpdXNbM11bMF0sXG4gICAgICAgICAgICAgICAgYmx2ID0gYm9yZGVyUmFkaXVzWzNdWzFdLFxuXG4gICAgICAgICAgICAgICAgdG9wV2lkdGggPSB3aWR0aCAtIHRyaCxcbiAgICAgICAgICAgICAgICByaWdodEhlaWdodCA9IGhlaWdodCAtIGJydixcbiAgICAgICAgICAgICAgICBib3R0b21XaWR0aCA9IHdpZHRoIC0gYnJoLFxuICAgICAgICAgICAgICAgIGxlZnRIZWlnaHQgPSBoZWlnaHQgLSBibHY7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9wTGVmdE91dGVyOiBnZXRDdXJ2ZVBvaW50cyhcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgdGxoLFxuICAgICAgICB0bHZcbiAgICAgICAgKS50b3BMZWZ0LnN1YmRpdmlkZSgwLjUpLFxuXG4gICAgICAgICAgICAgICAgdG9wTGVmdElubmVyOiBnZXRDdXJ2ZVBvaW50cyhcbiAgICAgICAgeCArIGJvcmRlcnNbM10ud2lkdGgsXG4gICAgICAgIHkgKyBib3JkZXJzWzBdLndpZHRoLFxuICAgICAgICBNYXRoLm1heCgwLCB0bGggLSBib3JkZXJzWzNdLndpZHRoKSxcbiAgICAgICAgTWF0aC5tYXgoMCwgdGx2IC0gYm9yZGVyc1swXS53aWR0aClcbiAgICAgICAgKS50b3BMZWZ0LnN1YmRpdmlkZSgwLjUpLFxuXG4gICAgICAgICAgICAgICAgdG9wUmlnaHRPdXRlcjogZ2V0Q3VydmVQb2ludHMoXG4gICAgICAgIHggKyB0b3BXaWR0aCxcbiAgICAgICAgeSxcbiAgICAgICAgdHJoLFxuICAgICAgICB0cnZcbiAgICAgICAgKS50b3BSaWdodC5zdWJkaXZpZGUoMC41KSxcblxuICAgICAgICAgICAgICAgIHRvcFJpZ2h0SW5uZXI6IGdldEN1cnZlUG9pbnRzKFxuICAgICAgICB4ICsgTWF0aC5taW4odG9wV2lkdGgsIHdpZHRoICsgYm9yZGVyc1szXS53aWR0aCksXG4gICAgICAgIHkgKyBib3JkZXJzWzBdLndpZHRoLFxuICAgICAgICAodG9wV2lkdGggPiB3aWR0aCArIGJvcmRlcnNbM10ud2lkdGgpID8gMCA6IHRyaCAtIGJvcmRlcnNbM10ud2lkdGgsXG4gICAgICAgIHRydiAtIGJvcmRlcnNbMF0ud2lkdGhcbiAgICAgICAgKS50b3BSaWdodC5zdWJkaXZpZGUoMC41KSxcblxuICAgICAgICAgICAgICAgIGJvdHRvbVJpZ2h0T3V0ZXI6IGdldEN1cnZlUG9pbnRzKFxuICAgICAgICB4ICsgYm90dG9tV2lkdGgsXG4gICAgICAgIHkgKyByaWdodEhlaWdodCxcbiAgICAgICAgYnJoLFxuICAgICAgICBicnZcbiAgICAgICAgKS5ib3R0b21SaWdodC5zdWJkaXZpZGUoMC41KSxcblxuICAgICAgICAgICAgICAgIGJvdHRvbVJpZ2h0SW5uZXI6IGdldEN1cnZlUG9pbnRzKFxuICAgICAgICB4ICsgTWF0aC5taW4oYm90dG9tV2lkdGgsIHdpZHRoICsgYm9yZGVyc1szXS53aWR0aCksXG4gICAgICAgIHkgKyBNYXRoLm1pbihyaWdodEhlaWdodCwgaGVpZ2h0ICsgYm9yZGVyc1swXS53aWR0aCksXG4gICAgICAgIE1hdGgubWF4KDAsIGJyaCAtIGJvcmRlcnNbMV0ud2lkdGgpLFxuICAgICAgICBNYXRoLm1heCgwLCBicnYgLSBib3JkZXJzWzJdLndpZHRoKVxuICAgICAgICApLmJvdHRvbVJpZ2h0LnN1YmRpdmlkZSgwLjUpLFxuXG4gICAgICAgICAgICAgICAgYm90dG9tTGVmdE91dGVyOiBnZXRDdXJ2ZVBvaW50cyhcbiAgICAgICAgeCxcbiAgICAgICAgeSArIGxlZnRIZWlnaHQsXG4gICAgICAgIGJsaCxcbiAgICAgICAgYmx2XG4gICAgICAgICkuYm90dG9tTGVmdC5zdWJkaXZpZGUoMC41KSxcblxuICAgICAgICAgICAgICAgIGJvdHRvbUxlZnRJbm5lcjogZ2V0Q3VydmVQb2ludHMoXG4gICAgICAgIHggKyBib3JkZXJzWzNdLndpZHRoLFxuICAgICAgICB5ICsgbGVmdEhlaWdodCxcbiAgICAgICAgTWF0aC5tYXgoMCwgYmxoIC0gYm9yZGVyc1szXS53aWR0aCksXG4gICAgICAgIE1hdGgubWF4KDAsIGJsdiAtIGJvcmRlcnNbMl0ud2lkdGgpXG4gICAgICAgICkuYm90dG9tTGVmdC5zdWJkaXZpZGUoMC41KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldEJvcmRlckNsaXAgKGVsZW1lbnQsIGJvcmRlclBvaW50cywgYm9yZGVycywgcmFkaXVzLCBib3VuZHMpIHtcbiAgICAgICAgICAgIHZhciBiYWNrZ3JvdW5kQ2xpcCA9IGdldENTUyhlbGVtZW50LCAnYmFja2dyb3VuZENsaXAnKSxcbiAgICAgICAgICAgICAgICBib3JkZXJBcmdzID0gW107XG5cbiAgICAgICAgICAgIHN3aXRjaCAoYmFja2dyb3VuZENsaXApIHtcbiAgICAgICAgICAgIGNhc2UgJ2NvbnRlbnQtYm94JzpcbiAgICAgICAgICAgIGNhc2UgJ3BhZGRpbmctYm94JzpcbiAgICAgICAgICAgICAgICBwYXJzZUNvcm5lcihib3JkZXJBcmdzLCByYWRpdXNbMF0sIHJhZGl1c1sxXSwgYm9yZGVyUG9pbnRzLnRvcExlZnRJbm5lciwgYm9yZGVyUG9pbnRzLnRvcFJpZ2h0SW5uZXIsIGJvdW5kcy5sZWZ0ICsgYm9yZGVyc1szXS53aWR0aCwgYm91bmRzLnRvcCArIGJvcmRlcnNbMF0ud2lkdGgpO1xuICAgICAgICAgICAgICAgIHBhcnNlQ29ybmVyKGJvcmRlckFyZ3MsIHJhZGl1c1sxXSwgcmFkaXVzWzJdLCBib3JkZXJQb2ludHMudG9wUmlnaHRJbm5lciwgYm9yZGVyUG9pbnRzLmJvdHRvbVJpZ2h0SW5uZXIsIGJvdW5kcy5sZWZ0ICsgYm91bmRzLndpZHRoIC0gYm9yZGVyc1sxXS53aWR0aCwgYm91bmRzLnRvcCArIGJvcmRlcnNbMF0ud2lkdGgpO1xuICAgICAgICAgICAgICAgIHBhcnNlQ29ybmVyKGJvcmRlckFyZ3MsIHJhZGl1c1syXSwgcmFkaXVzWzNdLCBib3JkZXJQb2ludHMuYm90dG9tUmlnaHRJbm5lciwgYm9yZGVyUG9pbnRzLmJvdHRvbUxlZnRJbm5lciwgYm91bmRzLmxlZnQgKyBib3VuZHMud2lkdGggLSBib3JkZXJzWzFdLndpZHRoLCBib3VuZHMudG9wICsgYm91bmRzLmhlaWdodCAtIGJvcmRlcnNbMl0ud2lkdGgpO1xuICAgICAgICAgICAgICAgIHBhcnNlQ29ybmVyKGJvcmRlckFyZ3MsIHJhZGl1c1szXSwgcmFkaXVzWzBdLCBib3JkZXJQb2ludHMuYm90dG9tTGVmdElubmVyLCBib3JkZXJQb2ludHMudG9wTGVmdElubmVyLCBib3VuZHMubGVmdCArIGJvcmRlcnNbM10ud2lkdGgsIGJvdW5kcy50b3AgKyBib3VuZHMuaGVpZ2h0IC0gYm9yZGVyc1syXS53aWR0aCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcGFyc2VDb3JuZXIoYm9yZGVyQXJncywgcmFkaXVzWzBdLCByYWRpdXNbMV0sIGJvcmRlclBvaW50cy50b3BMZWZ0T3V0ZXIsIGJvcmRlclBvaW50cy50b3BSaWdodE91dGVyLCBib3VuZHMubGVmdCwgYm91bmRzLnRvcCk7XG4gICAgICAgICAgICAgICAgcGFyc2VDb3JuZXIoYm9yZGVyQXJncywgcmFkaXVzWzFdLCByYWRpdXNbMl0sIGJvcmRlclBvaW50cy50b3BSaWdodE91dGVyLCBib3JkZXJQb2ludHMuYm90dG9tUmlnaHRPdXRlciwgYm91bmRzLmxlZnQgKyBib3VuZHMud2lkdGgsIGJvdW5kcy50b3ApO1xuICAgICAgICAgICAgICAgIHBhcnNlQ29ybmVyKGJvcmRlckFyZ3MsIHJhZGl1c1syXSwgcmFkaXVzWzNdLCBib3JkZXJQb2ludHMuYm90dG9tUmlnaHRPdXRlciwgYm9yZGVyUG9pbnRzLmJvdHRvbUxlZnRPdXRlciwgYm91bmRzLmxlZnQgKyBib3VuZHMud2lkdGgsIGJvdW5kcy50b3AgKyBib3VuZHMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBwYXJzZUNvcm5lcihib3JkZXJBcmdzLCByYWRpdXNbM10sIHJhZGl1c1swXSwgYm9yZGVyUG9pbnRzLmJvdHRvbUxlZnRPdXRlciwgYm9yZGVyUG9pbnRzLnRvcExlZnRPdXRlciwgYm91bmRzLmxlZnQsIGJvdW5kcy50b3AgKyBib3VuZHMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGJvcmRlckFyZ3M7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwYXJzZUJvcmRlcnMgKGVsZW1lbnQsIGJvdW5kcywgYm9yZGVycykge1xuICAgICAgICAgICAgdmFyIHggPSBib3VuZHMubGVmdCxcbiAgICAgICAgICAgICAgICB5ID0gYm91bmRzLnRvcCxcbiAgICAgICAgICAgICAgICB3aWR0aCA9IGJvdW5kcy53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBib3VuZHMuaGVpZ2h0LFxuICAgICAgICAgICAgICAgIGJvcmRlclNpZGUsXG4gICAgICAgICAgICAgICAgYngsXG4gICAgICAgICAgICAgICAgYnksXG4gICAgICAgICAgICAgICAgYncsXG4gICAgICAgICAgICAgICAgYmgsXG4gICAgICAgICAgICAgICAgYm9yZGVyQXJncyxcbiAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWJhY2tncm91bmQvI3RoZS1ib3JkZXItcmFkaXVzXG4gICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzID0gZ2V0Qm9yZGVyUmFkaXVzRGF0YShlbGVtZW50KSxcbiAgICAgICAgICAgICAgICBib3JkZXJQb2ludHMgPSBjYWxjdWxhdGVDdXJ2ZVBvaW50cyhib3VuZHMsIGJvcmRlclJhZGl1cywgYm9yZGVycyksXG4gICAgICAgICAgICAgICAgYm9yZGVyRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgY2xpcDogZ2V0Qm9yZGVyQ2xpcChlbGVtZW50LCBib3JkZXJQb2ludHMsIGJvcmRlcnMsIGJvcmRlclJhZGl1cywgYm91bmRzKSxcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyczogW11cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmb3IgKGJvcmRlclNpZGUgPSAwOyBib3JkZXJTaWRlIDwgNDsgYm9yZGVyU2lkZSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJvcmRlcnNbYm9yZGVyU2lkZV0ud2lkdGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgYnkgPSB5O1xuICAgICAgICAgICAgICAgICAgICBidyA9IHdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBiaCA9IGhlaWdodCAtIChib3JkZXJzWzJdLndpZHRoKTtcblxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGJvcmRlclNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgLy8gdG9wIGJvcmRlclxuICAgICAgICAgICAgICAgICAgICAgICAgYmggPSBib3JkZXJzWzBdLndpZHRoO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJBcmdzID0gZHJhd1NpZGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxOiBbYngsIGJ5XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMjogW2J4ICsgYncsIGJ5XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMzogW2J4ICsgYncgLSBib3JkZXJzWzFdLndpZHRoLCBieSArIGJoXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjNDogW2J4ICsgYm9yZGVyc1szXS53aWR0aCwgYnkgKyBiaF1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGJvcmRlclJhZGl1c1swXSwgYm9yZGVyUmFkaXVzWzFdLFxuICAgICAgICAgICAgYm9yZGVyUG9pbnRzLnRvcExlZnRPdXRlciwgYm9yZGVyUG9pbnRzLnRvcExlZnRJbm5lciwgYm9yZGVyUG9pbnRzLnRvcFJpZ2h0T3V0ZXIsIGJvcmRlclBvaW50cy50b3BSaWdodElubmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAvLyByaWdodCBib3JkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ4ID0geCArIHdpZHRoIC0gKGJvcmRlcnNbMV0ud2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYncgPSBib3JkZXJzWzFdLndpZHRoO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJBcmdzID0gZHJhd1NpZGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxOiBbYnggKyBidywgYnldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyOiBbYnggKyBidywgYnkgKyBiaCArIGJvcmRlcnNbMl0ud2lkdGhdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMzOiBbYngsIGJ5ICsgYmhdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM0OiBbYngsIGJ5ICsgYm9yZGVyc1swXS53aWR0aF1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGJvcmRlclJhZGl1c1sxXSwgYm9yZGVyUmFkaXVzWzJdLFxuICAgICAgICAgICAgYm9yZGVyUG9pbnRzLnRvcFJpZ2h0T3V0ZXIsIGJvcmRlclBvaW50cy50b3BSaWdodElubmVyLCBib3JkZXJQb2ludHMuYm90dG9tUmlnaHRPdXRlciwgYm9yZGVyUG9pbnRzLmJvdHRvbVJpZ2h0SW5uZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIC8vIGJvdHRvbSBib3JkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5ID0gKGJ5ICsgaGVpZ2h0KSAtIChib3JkZXJzWzJdLndpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJoID0gYm9yZGVyc1syXS53aWR0aDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyQXJncyA9IGRyYXdTaWRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMTogW2J4ICsgYncsIGJ5ICsgYmhdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyOiBbYngsIGJ5ICsgYmhdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMzOiBbYnggKyBib3JkZXJzWzNdLndpZHRoLCBieV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzQ6IFtieCArIGJ3IC0gYm9yZGVyc1szXS53aWR0aCwgYnldXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBib3JkZXJSYWRpdXNbMl0sIGJvcmRlclJhZGl1c1szXSxcbiAgICAgICAgICAgIGJvcmRlclBvaW50cy5ib3R0b21SaWdodE91dGVyLCBib3JkZXJQb2ludHMuYm90dG9tUmlnaHRJbm5lciwgYm9yZGVyUG9pbnRzLmJvdHRvbUxlZnRPdXRlciwgYm9yZGVyUG9pbnRzLmJvdHRvbUxlZnRJbm5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgLy8gbGVmdCBib3JkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ3ID0gYm9yZGVyc1szXS53aWR0aDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyQXJncyA9IGRyYXdTaWRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMTogW2J4LCBieSArIGJoICsgYm9yZGVyc1syXS53aWR0aF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzI6IFtieCwgYnldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMzOiBbYnggKyBidywgYnkgKyBib3JkZXJzWzBdLndpZHRoXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjNDogW2J4ICsgYncsIGJ5ICsgYmhdXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBib3JkZXJSYWRpdXNbM10sIGJvcmRlclJhZGl1c1swXSxcbiAgICAgICAgICAgIGJvcmRlclBvaW50cy5ib3R0b21MZWZ0T3V0ZXIsIGJvcmRlclBvaW50cy5ib3R0b21MZWZ0SW5uZXIsIGJvcmRlclBvaW50cy50b3BMZWZ0T3V0ZXIsIGJvcmRlclBvaW50cy50b3BMZWZ0SW5uZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBib3JkZXJEYXRhLmJvcmRlcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBib3JkZXJBcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGJvcmRlcnNbYm9yZGVyU2lkZV0uY29sb3JcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYm9yZGVyRGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVNoYXBlIChjdHgsIGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IGN0eC5kcmF3U2hhcGUoKTtcbiAgICAgICAgICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbiAoYm9yZGVyLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHNoYXBlWyhpbmRleCA9PT0gMCkgPyAnbW92ZVRvJyA6IGJvcmRlclswXSArICdUbycgXS5hcHBseShudWxsLCBib3JkZXIuc2xpY2UoMSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gc2hhcGU7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZW5kZXJCb3JkZXJzIChjdHgsIGJvcmRlckFyZ3MsIGNvbG9yKSB7XG4gICAgICAgICAgICBpZiAoY29sb3IgIT09ICd0cmFuc3BhcmVudCcpIHtcbiAgICAgICAgICAgICAgICBjdHguc2V0VmFyaWFibGUoJ2ZpbGxTdHlsZScsIGNvbG9yKTtcbiAgICAgICAgICAgICAgICBjcmVhdGVTaGFwZShjdHgsIGJvcmRlckFyZ3MpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICAgICAgbnVtRHJhd3MgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlbmRlckZvcm1WYWx1ZSAoZWwsIGJvdW5kcywgc3RhY2spIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZVdyYXAgPSBkb2MuY3JlYXRlRWxlbWVudCgndmFsdWV3cmFwJyksXG4gICAgICAgICAgICAgICAgY3NzUHJvcGVydHlBcnJheSA9IFsnbGluZUhlaWdodCcsICd0ZXh0QWxpZ24nLCAnZm9udEZhbWlseScsICdjb2xvcicsICdmb250U2l6ZScsICdwYWRkaW5nTGVmdCcsICdwYWRkaW5nVG9wJywgJ3dpZHRoJywgJ2hlaWdodCcsICdib3JkZXInLCAnYm9yZGVyTGVmdFdpZHRoJywgJ2JvcmRlclRvcFdpZHRoJ10sXG4gICAgICAgICAgICAgICAgdGV4dFZhbHVlLFxuICAgICAgICAgICAgICAgIHRleHROb2RlO1xuXG4gICAgICAgICAgICBjc3NQcm9wZXJ0eUFycmF5LmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVXcmFwLnN0eWxlW3Byb3BlcnR5XSA9IGdldENTUyhlbCwgcHJvcGVydHkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gT2xkZXIgSUUgaGFzIGlzc3VlcyB3aXRoIFwiYm9yZGVyXCJcbiAgICAgICAgICAgICAgICAgICAgVXRpbC5sb2coJ2h0bWwyY2FudmFzOiBQYXJzZTogRXhjZXB0aW9uIGNhdWdodCBpbiByZW5kZXJGb3JtVmFsdWU6ICcgKyBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YWx1ZVdyYXAuc3R5bGUuYm9yZGVyQ29sb3IgPSAnYmxhY2snO1xuICAgICAgICAgICAgdmFsdWVXcmFwLnN0eWxlLmJvcmRlclN0eWxlID0gJ3NvbGlkJztcbiAgICAgICAgICAgIHZhbHVlV3JhcC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgIHZhbHVlV3JhcC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG5cbiAgICAgICAgICAgIGlmICgvXihzdWJtaXR8cmVzZXR8YnV0dG9ufHRleHR8cGFzc3dvcmQpJC8udGVzdChlbC50eXBlKSB8fCBlbC5ub2RlTmFtZSA9PT0gJ1NFTEVDVCcpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVdyYXAuc3R5bGUubGluZUhlaWdodCA9IGdldENTUyhlbCwgJ2hlaWdodCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZVdyYXAuc3R5bGUudG9wID0gYm91bmRzLnRvcCArICdweCc7XG4gICAgICAgICAgICB2YWx1ZVdyYXAuc3R5bGUubGVmdCA9IGJvdW5kcy5sZWZ0ICsgJ3B4JztcblxuICAgICAgICAgICAgdGV4dFZhbHVlID0gKGVsLm5vZGVOYW1lID09PSAnU0VMRUNUJykgPyAoZWwub3B0aW9uc1tlbC5zZWxlY3RlZEluZGV4XSB8fCAwKS50ZXh0IDogZWwudmFsdWU7XG4gICAgICAgICAgICBpZiAoIXRleHRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRleHRWYWx1ZSA9IGVsLnBsYWNlaG9sZGVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0ZXh0Tm9kZSA9IGRvYy5jcmVhdGVUZXh0Tm9kZSh0ZXh0VmFsdWUpO1xuXG4gICAgICAgICAgICB2YWx1ZVdyYXAuYXBwZW5kQ2hpbGQodGV4dE5vZGUpO1xuICAgICAgICAgICAgYm9keS5hcHBlbmRDaGlsZCh2YWx1ZVdyYXApO1xuXG4gICAgICAgICAgICByZW5kZXJUZXh0KGVsLCB0ZXh0Tm9kZSwgc3RhY2spO1xuICAgICAgICAgICAgYm9keS5yZW1vdmVDaGlsZCh2YWx1ZVdyYXApO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZHJhd0ltYWdlIChjdHgpIHtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UuYXBwbHkoY3R4LCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICAgICAgICAgIG51bURyYXdzICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRQc2V1ZG9FbGVtZW50IChlbCwgd2hpY2gpIHtcbiAgICAgICAgICAgIHZhciBlbFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwsIHdoaWNoKTtcbiAgICAgICAgICAgIGlmICghZWxTdHlsZSB8fCAhZWxTdHlsZS5jb250ZW50IHx8IGVsU3R5bGUuY29udGVudCA9PT0gJ25vbmUnIHx8IGVsU3R5bGUuY29udGVudCA9PT0gJy1tb3otYWx0LWNvbnRlbnQnIHx8IGVsU3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBlbFN0eWxlLmNvbnRlbnQgKyAnJyxcbiAgICAgICAgICAgICAgICBmaXJzdCA9IGNvbnRlbnQuc3Vic3RyKDAsIDEpO1xuICAgIC8vIHN0cmlwcyBxdW90ZXNcbiAgICAgICAgICAgIGlmIChmaXJzdCA9PT0gY29udGVudC5zdWJzdHIoY29udGVudC5sZW5ndGggLSAxKSAmJiBmaXJzdC5tYXRjaCgvJ3xcIi8pKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuc3Vic3RyKDEsIGNvbnRlbnQubGVuZ3RoIC0gMik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpc0ltYWdlID0gY29udGVudC5zdWJzdHIoMCwgMykgPT09ICd1cmwnLFxuICAgICAgICAgICAgICAgIGVscHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGlzSW1hZ2UgPyAnaW1nJyA6ICdzcGFuJyk7XG5cbiAgICAgICAgICAgIGVscHMuY2xhc3NOYW1lID0gcHNldWRvSGlkZSArICctYmVmb3JlICcgKyBwc2V1ZG9IaWRlICsgJy1hZnRlcic7XG5cbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGVsU3R5bGUpLmZpbHRlcihpbmRleGVkUHJvcGVydHkpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIC8vIFByZXZlbnQgYXNzaWduaW5nIG9mIHJlYWQgb25seSBDU1MgUnVsZXMsIGV4LiBsZW5ndGgsIHBhcmVudFJ1bGVcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBlbHBzLnN0eWxlW3Byb3BdID0gZWxTdHlsZVtwcm9wXTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIFV0aWwubG9nKFsnVHJpZWQgdG8gYXNzaWduIHJlYWRvbmx5IHByb3BlcnR5ICcsIHByb3AsICdFcnJvcjonLCBlXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChpc0ltYWdlKSB7XG4gICAgICAgICAgICAgICAgZWxwcy5zcmMgPSBVdGlsLnBhcnNlQmFja2dyb3VuZEltYWdlKGNvbnRlbnQpWzBdLmFyZ3NbMF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVscHMuaW5uZXJIVE1MID0gY29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlbHBzO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaW5kZXhlZFByb3BlcnR5IChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgcmV0dXJuIChpc05hTih3aW5kb3cucGFyc2VJbnQocHJvcGVydHksIDEwKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaW5qZWN0UHNldWRvRWxlbWVudHMgKGVsLCBzdGFjaykge1xuICAgICAgICAgICAgdmFyIGJlZm9yZSA9IGdldFBzZXVkb0VsZW1lbnQoZWwsICc6YmVmb3JlJyksXG4gICAgICAgICAgICAgICAgYWZ0ZXIgPSBnZXRQc2V1ZG9FbGVtZW50KGVsLCAnOmFmdGVyJyk7XG4gICAgICAgICAgICBpZiAoIWJlZm9yZSAmJiAhYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChiZWZvcmUpIHtcbiAgICAgICAgICAgICAgICBlbC5jbGFzc05hbWUgKz0gJyAnICsgcHNldWRvSGlkZSArICctYmVmb3JlJztcbiAgICAgICAgICAgICAgICBlbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShiZWZvcmUsIGVsKTtcbiAgICAgICAgICAgICAgICBwYXJzZUVsZW1lbnQoYmVmb3JlLCBzdGFjaywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiZWZvcmUpO1xuICAgICAgICAgICAgICAgIGVsLmNsYXNzTmFtZSA9IGVsLmNsYXNzTmFtZS5yZXBsYWNlKHBzZXVkb0hpZGUgKyAnLWJlZm9yZScsICcnKS50cmltKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhZnRlcikge1xuICAgICAgICAgICAgICAgIGVsLmNsYXNzTmFtZSArPSAnICcgKyBwc2V1ZG9IaWRlICsgJy1hZnRlcic7XG4gICAgICAgICAgICAgICAgZWwuYXBwZW5kQ2hpbGQoYWZ0ZXIpO1xuICAgICAgICAgICAgICAgIHBhcnNlRWxlbWVudChhZnRlciwgc3RhY2ssIHRydWUpO1xuICAgICAgICAgICAgICAgIGVsLnJlbW92ZUNoaWxkKGFmdGVyKTtcbiAgICAgICAgICAgICAgICBlbC5jbGFzc05hbWUgPSBlbC5jbGFzc05hbWUucmVwbGFjZShwc2V1ZG9IaWRlICsgJy1hZnRlcicsICcnKS50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZW5kZXJCYWNrZ3JvdW5kUmVwZWF0IChjdHgsIGltYWdlLCBiYWNrZ3JvdW5kUG9zaXRpb24sIGJvdW5kcykge1xuICAgICAgICAgICAgdmFyIG9mZnNldFggPSBNYXRoLnJvdW5kKGJvdW5kcy5sZWZ0ICsgYmFja2dyb3VuZFBvc2l0aW9uLmxlZnQpLFxuICAgICAgICAgICAgICAgIG9mZnNldFkgPSBNYXRoLnJvdW5kKGJvdW5kcy50b3AgKyBiYWNrZ3JvdW5kUG9zaXRpb24udG9wKTtcblxuICAgICAgICAgICAgY3R4LmNyZWF0ZVBhdHRlcm4oaW1hZ2UpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKC1vZmZzZXRYLCAtb2Zmc2V0WSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBiYWNrZ3JvdW5kUmVwZWF0U2hhcGUgKGN0eCwgaW1hZ2UsIGJhY2tncm91bmRQb3NpdGlvbiwgYm91bmRzLCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBhcmdzLnB1c2goWydsaW5lJywgTWF0aC5yb3VuZChsZWZ0KSwgTWF0aC5yb3VuZCh0b3ApXSk7XG4gICAgICAgICAgICBhcmdzLnB1c2goWydsaW5lJywgTWF0aC5yb3VuZChsZWZ0ICsgd2lkdGgpLCBNYXRoLnJvdW5kKHRvcCldKTtcbiAgICAgICAgICAgIGFyZ3MucHVzaChbJ2xpbmUnLCBNYXRoLnJvdW5kKGxlZnQgKyB3aWR0aCksIE1hdGgucm91bmQoaGVpZ2h0ICsgdG9wKV0pO1xuICAgICAgICAgICAgYXJncy5wdXNoKFsnbGluZScsIE1hdGgucm91bmQobGVmdCksIE1hdGgucm91bmQoaGVpZ2h0ICsgdG9wKV0pO1xuICAgICAgICAgICAgY3JlYXRlU2hhcGUoY3R4LCBhcmdzKTtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHguY2xpcCgpO1xuICAgICAgICAgICAgcmVuZGVyQmFja2dyb3VuZFJlcGVhdChjdHgsIGltYWdlLCBiYWNrZ3JvdW5kUG9zaXRpb24sIGJvdW5kcyk7XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVuZGVyQmFja2dyb3VuZENvbG9yIChjdHgsIGJhY2tncm91bmRCb3VuZHMsIGJnY29sb3IpIHtcbiAgICAgICAgICAgIHJlbmRlclJlY3QoXG4gICAgICBjdHgsXG4gICAgICBiYWNrZ3JvdW5kQm91bmRzLmxlZnQsXG4gICAgICBiYWNrZ3JvdW5kQm91bmRzLnRvcCxcbiAgICAgIGJhY2tncm91bmRCb3VuZHMud2lkdGgsXG4gICAgICBiYWNrZ3JvdW5kQm91bmRzLmhlaWdodCxcbiAgICAgIGJnY29sb3JcbiAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZW5kZXJCYWNrZ3JvdW5kUmVwZWF0aW5nIChlbCwgYm91bmRzLCBjdHgsIGltYWdlLCBpbWFnZUluZGV4KSB7XG4gICAgICAgICAgICB2YXIgYmFja2dyb3VuZFNpemUgPSBVdGlsLkJhY2tncm91bmRTaXplKGVsLCBib3VuZHMsIGltYWdlLCBpbWFnZUluZGV4KSxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kUG9zaXRpb24gPSBVdGlsLkJhY2tncm91bmRQb3NpdGlvbihlbCwgYm91bmRzLCBpbWFnZSwgaW1hZ2VJbmRleCwgYmFja2dyb3VuZFNpemUpLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRSZXBlYXQgPSBnZXRDU1MoZWwsICdiYWNrZ3JvdW5kUmVwZWF0Jykuc3BsaXQoJywnKS5tYXAoVXRpbC50cmltVGV4dCk7XG5cbiAgICAgICAgICAgIGltYWdlID0gcmVzaXplSW1hZ2UoaW1hZ2UsIGJhY2tncm91bmRTaXplKTtcblxuICAgICAgICAgICAgYmFja2dyb3VuZFJlcGVhdCA9IGJhY2tncm91bmRSZXBlYXRbaW1hZ2VJbmRleF0gfHwgYmFja2dyb3VuZFJlcGVhdFswXTtcblxuICAgICAgICAgICAgc3dpdGNoIChiYWNrZ3JvdW5kUmVwZWF0KSB7XG4gICAgICAgICAgICBjYXNlICdyZXBlYXQteCc6XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZFJlcGVhdFNoYXBlKGN0eCwgaW1hZ2UsIGJhY2tncm91bmRQb3NpdGlvbiwgYm91bmRzLFxuICAgICAgICAgIGJvdW5kcy5sZWZ0LCBib3VuZHMudG9wICsgYmFja2dyb3VuZFBvc2l0aW9uLnRvcCwgOTk5OTksIGltYWdlLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3JlcGVhdC15JzpcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kUmVwZWF0U2hhcGUoY3R4LCBpbWFnZSwgYmFja2dyb3VuZFBvc2l0aW9uLCBib3VuZHMsXG4gICAgICAgICAgYm91bmRzLmxlZnQgKyBiYWNrZ3JvdW5kUG9zaXRpb24ubGVmdCwgYm91bmRzLnRvcCwgaW1hZ2Uud2lkdGgsIDk5OTk5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnbm8tcmVwZWF0JzpcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kUmVwZWF0U2hhcGUoY3R4LCBpbWFnZSwgYmFja2dyb3VuZFBvc2l0aW9uLCBib3VuZHMsXG4gICAgICAgICAgYm91bmRzLmxlZnQgKyBiYWNrZ3JvdW5kUG9zaXRpb24ubGVmdCwgYm91bmRzLnRvcCArIGJhY2tncm91bmRQb3NpdGlvbi50b3AsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlbmRlckJhY2tncm91bmRSZXBlYXQoY3R4LCBpbWFnZSwgYmFja2dyb3VuZFBvc2l0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgIHRvcDogYm91bmRzLnRvcCxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogYm91bmRzLmxlZnQsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBpbWFnZS53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBpbWFnZS5oZWlnaHRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlbmRlckJhY2tncm91bmRJbWFnZSAoZWxlbWVudCwgYm91bmRzLCBjdHgpIHtcbiAgICAgICAgICAgIHZhciBiYWNrZ3JvdW5kSW1hZ2UgPSBnZXRDU1MoZWxlbWVudCwgJ2JhY2tncm91bmRJbWFnZScpLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZXMgPSBVdGlsLnBhcnNlQmFja2dyb3VuZEltYWdlKGJhY2tncm91bmRJbWFnZSksXG4gICAgICAgICAgICAgICAgaW1hZ2UsXG4gICAgICAgICAgICAgICAgaW1hZ2VJbmRleCA9IGJhY2tncm91bmRJbWFnZXMubGVuZ3RoO1xuXG4gICAgICAgICAgICB3aGlsZSAoaW1hZ2VJbmRleC0tKSB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZEltYWdlID0gYmFja2dyb3VuZEltYWdlc1tpbWFnZUluZGV4XTtcblxuICAgICAgICAgICAgICAgIGlmICghYmFja2dyb3VuZEltYWdlLmFyZ3MgfHwgYmFja2dyb3VuZEltYWdlLmFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBiYWNrZ3JvdW5kSW1hZ2UubWV0aG9kID09PSAndXJsJ1xuICAgICAgPyBiYWNrZ3JvdW5kSW1hZ2UuYXJnc1swXVxuICAgICAgOiBiYWNrZ3JvdW5kSW1hZ2UudmFsdWU7XG5cbiAgICAgICAgICAgICAgICBpbWFnZSA9IGxvYWRJbWFnZShrZXkpO1xuXG4gICAgICAvLyBUT0RPIGFkZCBzdXBwb3J0IGZvciBiYWNrZ3JvdW5kLW9yaWdpblxuICAgICAgICAgICAgICAgIGlmIChpbWFnZSkge1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJCYWNrZ3JvdW5kUmVwZWF0aW5nKGVsZW1lbnQsIGJvdW5kcywgY3R4LCBpbWFnZSwgaW1hZ2VJbmRleCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgVXRpbC5sb2coJ2h0bWwyY2FudmFzOiBFcnJvciBsb2FkaW5nIGJhY2tncm91bmQ6JywgYmFja2dyb3VuZEltYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZXNpemVJbWFnZSAoaW1hZ2UsIGJvdW5kcykge1xuICAgICAgICAgICAgaWYgKGltYWdlLndpZHRoID09PSBib3VuZHMud2lkdGggJiYgaW1hZ2UuaGVpZ2h0ID09PSBib3VuZHMuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGltYWdlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY3R4LCBjYW52YXMgPSBkb2MuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSBib3VuZHMud2lkdGg7XG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gYm91bmRzLmhlaWdodDtcbiAgICAgICAgICAgIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgZHJhd0ltYWdlKGN0eCwgaW1hZ2UsIDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIDAsIDAsIGJvdW5kcy53aWR0aCwgYm91bmRzLmhlaWdodCk7XG4gICAgICAgICAgICByZXR1cm4gY2FudmFzO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc2V0T3BhY2l0eSAoY3R4LCBlbGVtZW50LCBwYXJlbnRTdGFjaykge1xuICAgICAgICAgICAgcmV0dXJuIGN0eC5zZXRWYXJpYWJsZSgnZ2xvYmFsQWxwaGEnLCBnZXRDU1MoZWxlbWVudCwgJ29wYWNpdHknKSAqICgocGFyZW50U3RhY2spID8gcGFyZW50U3RhY2sub3BhY2l0eSA6IDEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZVB4IChzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgncHgnLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdHJhbnNmb3JtUmVnRXhwID0gLyhtYXRyaXgpXFwoKC4rKVxcKS87XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0VHJhbnNmb3JtIChlbGVtZW50LCBwYXJlbnRTdGFjaykge1xuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IGdldENTUyhlbGVtZW50LCAndHJhbnNmb3JtJykgfHwgZ2V0Q1NTKGVsZW1lbnQsICctd2Via2l0LXRyYW5zZm9ybScpIHx8IGdldENTUyhlbGVtZW50LCAnLW1vei10cmFuc2Zvcm0nKSB8fCBnZXRDU1MoZWxlbWVudCwgJy1tcy10cmFuc2Zvcm0nKSB8fCBnZXRDU1MoZWxlbWVudCwgJy1vLXRyYW5zZm9ybScpO1xuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybU9yaWdpbiA9IGdldENTUyhlbGVtZW50LCAndHJhbnNmb3JtLW9yaWdpbicpIHx8IGdldENTUyhlbGVtZW50LCAnLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luJykgfHwgZ2V0Q1NTKGVsZW1lbnQsICctbW96LXRyYW5zZm9ybS1vcmlnaW4nKSB8fCBnZXRDU1MoZWxlbWVudCwgJy1tcy10cmFuc2Zvcm0tb3JpZ2luJykgfHwgZ2V0Q1NTKGVsZW1lbnQsICctby10cmFuc2Zvcm0tb3JpZ2luJykgfHwgJzBweCAwcHgnO1xuXG4gICAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW4gPSB0cmFuc2Zvcm1PcmlnaW4uc3BsaXQoJyAnKS5tYXAocmVtb3ZlUHgpLm1hcChVdGlsLmFzRmxvYXQpO1xuXG4gICAgICAgICAgICB2YXIgbWF0cml4O1xuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybSAmJiB0cmFuc2Zvcm0gIT09ICdub25lJykge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IHRyYW5zZm9ybS5tYXRjaCh0cmFuc2Zvcm1SZWdFeHApO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG1hdGNoWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21hdHJpeCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRyaXggPSBtYXRjaFsyXS5zcGxpdCgnLCcpLm1hcChVdGlsLnRyaW1UZXh0KS5tYXAoVXRpbC5hc0Zsb2F0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG9yaWdpbjogdHJhbnNmb3JtT3JpZ2luLFxuICAgICAgICAgICAgICAgIG1hdHJpeDogbWF0cml4XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlU3RhY2sgKGVsZW1lbnQsIHBhcmVudFN0YWNrLCBib3VuZHMsIHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgdmFyIGN0eCA9IGgyY1JlbmRlckNvbnRleHQoKCFwYXJlbnRTdGFjaykgPyBkb2N1bWVudFdpZHRoKCkgOiBib3VuZHMud2lkdGgsICghcGFyZW50U3RhY2spID8gZG9jdW1lbnRIZWlnaHQoKSA6IGJvdW5kcy5oZWlnaHQpLFxuICAgICAgICAgICAgICAgIHN0YWNrID0ge1xuICAgICAgICAgICAgICAgICAgICBjdHg6IGN0eCxcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogc2V0T3BhY2l0eShjdHgsIGVsZW1lbnQsIHBhcmVudFN0YWNrKSxcbiAgICAgICAgICAgICAgICAgICAgY3NzUG9zaXRpb246IGdldENTUyhlbGVtZW50LCAncG9zaXRpb24nKSxcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyczogZ2V0Qm9yZGVyRGF0YShlbGVtZW50KSxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgICAgICAgICAgICAgICAgIGNsaXA6IChwYXJlbnRTdGFjayAmJiBwYXJlbnRTdGFjay5jbGlwKSA/IFV0aWwuRXh0ZW5kKHt9LCBwYXJlbnRTdGFjay5jbGlwKSA6IG51bGxcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBzZXRaKGVsZW1lbnQsIHN0YWNrLCBwYXJlbnRTdGFjayk7XG5cbiAgICAvLyBUT0RPIGNvcnJlY3Qgb3ZlcmZsb3cgZm9yIGFic29sdXRlIGNvbnRlbnQgcmVzaWRpbmcgdW5kZXIgYSBzdGF0aWMgcG9zaXRpb25cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnVzZU92ZXJmbG93ID09PSB0cnVlICYmIC8oaGlkZGVufHNjcm9sbHxhdXRvKS8udGVzdChnZXRDU1MoZWxlbWVudCwgJ292ZXJmbG93JykpID09PSB0cnVlICYmIC8oQk9EWSkvaS50ZXN0KGVsZW1lbnQubm9kZU5hbWUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHN0YWNrLmNsaXAgPSAoc3RhY2suY2xpcCkgPyBjbGlwQm91bmRzKHN0YWNrLmNsaXAsIGJvdW5kcykgOiBib3VuZHM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzdGFjaztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldEJhY2tncm91bmRCb3VuZHMgKGJvcmRlcnMsIGJvdW5kcywgY2xpcCkge1xuICAgICAgICAgICAgdmFyIGJhY2tncm91bmRCb3VuZHMgPSB7XG4gICAgICAgICAgICAgICAgbGVmdDogYm91bmRzLmxlZnQgKyBib3JkZXJzWzNdLndpZHRoLFxuICAgICAgICAgICAgICAgIHRvcDogYm91bmRzLnRvcCArIGJvcmRlcnNbMF0ud2lkdGgsXG4gICAgICAgICAgICAgICAgd2lkdGg6IGJvdW5kcy53aWR0aCAtIChib3JkZXJzWzFdLndpZHRoICsgYm9yZGVyc1szXS53aWR0aCksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBib3VuZHMuaGVpZ2h0IC0gKGJvcmRlcnNbMF0ud2lkdGggKyBib3JkZXJzWzJdLndpZHRoKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKGNsaXApIHtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQm91bmRzID0gY2xpcEJvdW5kcyhiYWNrZ3JvdW5kQm91bmRzLCBjbGlwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGJhY2tncm91bmRCb3VuZHM7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRCb3VuZHMgKGVsZW1lbnQsIHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgdmFyIGJvdW5kcyA9ICh0cmFuc2Zvcm0ubWF0cml4KSA/IFV0aWwuT2Zmc2V0Qm91bmRzKGVsZW1lbnQpIDogVXRpbC5Cb3VuZHMoZWxlbWVudCk7XG4gICAgICAgICAgICB0cmFuc2Zvcm0ub3JpZ2luWzBdICs9IGJvdW5kcy5sZWZ0O1xuICAgICAgICAgICAgdHJhbnNmb3JtLm9yaWdpblsxXSArPSBib3VuZHMudG9wO1xuICAgICAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlbmRlckVsZW1lbnQgKGVsZW1lbnQsIHBhcmVudFN0YWNrLCBwc2V1ZG9FbGVtZW50LCBpZ25vcmVCYWNrZ3JvdW5kKSB7XG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtID0gZ2V0VHJhbnNmb3JtKGVsZW1lbnQsIHBhcmVudFN0YWNrKSxcbiAgICAgICAgICAgICAgICBib3VuZHMgPSBnZXRCb3VuZHMoZWxlbWVudCwgdHJhbnNmb3JtKSxcbiAgICAgICAgICAgICAgICBpbWFnZSxcbiAgICAgICAgICAgICAgICBzdGFjayA9IGNyZWF0ZVN0YWNrKGVsZW1lbnQsIHBhcmVudFN0YWNrLCBib3VuZHMsIHRyYW5zZm9ybSksXG4gICAgICAgICAgICAgICAgYm9yZGVycyA9IHN0YWNrLmJvcmRlcnMsXG4gICAgICAgICAgICAgICAgY3R4ID0gc3RhY2suY3R4LFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRCb3VuZHMgPSBnZXRCYWNrZ3JvdW5kQm91bmRzKGJvcmRlcnMsIGJvdW5kcywgc3RhY2suY2xpcCksXG4gICAgICAgICAgICAgICAgYm9yZGVyRGF0YSA9IHBhcnNlQm9yZGVycyhlbGVtZW50LCBib3VuZHMsIGJvcmRlcnMpLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvciA9IChpZ25vcmVFbGVtZW50c1JlZ0V4cC50ZXN0KGVsZW1lbnQubm9kZU5hbWUpKSA/ICcjZWZlZmVmJyA6IGdldENTUyhlbGVtZW50LCAnYmFja2dyb3VuZENvbG9yJyk7XG5cbiAgICAgICAgICAgIGNyZWF0ZVNoYXBlKGN0eCwgYm9yZGVyRGF0YS5jbGlwKTtcblxuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGN0eC5jbGlwKCk7XG5cbiAgICAgICAgICAgIGlmIChiYWNrZ3JvdW5kQm91bmRzLmhlaWdodCA+IDAgJiYgYmFja2dyb3VuZEJvdW5kcy53aWR0aCA+IDAgJiYgIWlnbm9yZUJhY2tncm91bmQpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJCYWNrZ3JvdW5kQ29sb3IoY3R4LCBib3VuZHMsIGJhY2tncm91bmRDb2xvcik7XG4gICAgICAgICAgICAgICAgcmVuZGVyQmFja2dyb3VuZEltYWdlKGVsZW1lbnQsIGJhY2tncm91bmRCb3VuZHMsIGN0eCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlnbm9yZUJhY2tncm91bmQpIHtcbiAgICAgICAgICAgICAgICBzdGFjay5iYWNrZ3JvdW5kQ29sb3IgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgICAgICAgIGJvcmRlckRhdGEuYm9yZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChib3JkZXIpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJCb3JkZXJzKGN0eCwgYm9yZGVyLmFyZ3MsIGJvcmRlci5jb2xvcik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFwc2V1ZG9FbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaW5qZWN0UHNldWRvRWxlbWVudHMoZWxlbWVudCwgc3RhY2spO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzd2l0Y2ggKGVsZW1lbnQubm9kZU5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0lNRyc6XG4gICAgICAgICAgICAgICAgaWYgKChpbWFnZSA9IGxvYWRJbWFnZShlbGVtZW50LmdldEF0dHJpYnV0ZSgnc3JjJykpKSkge1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJJbWFnZShjdHgsIGVsZW1lbnQsIGltYWdlLCBib3VuZHMsIGJvcmRlcnMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIFV0aWwubG9nKCdodG1sMmNhbnZhczogRXJyb3IgbG9hZGluZyA8aW1nPjonICsgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3NyYycpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdJTlBVVCc6XG4gICAgICAgIC8vIFRPRE8gYWRkIGFsbCByZWxldmFudCB0eXBlJ3MsIGkuZS4gSFRNTDUgbmV3IHN0dWZmXG4gICAgICAgIC8vIHRvZG8gYWRkIHN1cHBvcnQgZm9yIHBsYWNlaG9sZGVyIGF0dHJpYnV0ZSBmb3IgYnJvd3NlcnMgd2hpY2ggc3VwcG9ydCBpdFxuICAgICAgICAgICAgICAgIGlmICgvXih0ZXh0fHVybHxlbWFpbHxzdWJtaXR8YnV0dG9ufHJlc2V0KSQvLnRlc3QoZWxlbWVudC50eXBlKSAmJiAoZWxlbWVudC52YWx1ZSB8fCBlbGVtZW50LnBsYWNlaG9sZGVyIHx8ICcnKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlckZvcm1WYWx1ZShlbGVtZW50LCBib3VuZHMsIHN0YWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdURVhUQVJFQSc6XG4gICAgICAgICAgICAgICAgaWYgKChlbGVtZW50LnZhbHVlIHx8IGVsZW1lbnQucGxhY2Vob2xkZXIgfHwgJycpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyRm9ybVZhbHVlKGVsZW1lbnQsIGJvdW5kcywgc3RhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1NFTEVDVCc6XG4gICAgICAgICAgICAgICAgaWYgKChlbGVtZW50Lm9wdGlvbnMgfHwgZWxlbWVudC5wbGFjZWhvbGRlciB8fCAnJykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJGb3JtVmFsdWUoZWxlbWVudCwgYm91bmRzLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnTEknOlxuICAgICAgICAgICAgICAgIHJlbmRlckxpc3RJdGVtKGVsZW1lbnQsIHN0YWNrLCBiYWNrZ3JvdW5kQm91bmRzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0NBTlZBUyc6XG4gICAgICAgICAgICAgICAgcmVuZGVySW1hZ2UoY3R4LCBlbGVtZW50LCBlbGVtZW50LCBib3VuZHMsIGJvcmRlcnMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc3RhY2s7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpc0VsZW1lbnRWaXNpYmxlIChlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gKGdldENTUyhlbGVtZW50LCAnZGlzcGxheScpICE9PSAnbm9uZScgJiYgZ2V0Q1NTKGVsZW1lbnQsICd2aXNpYmlsaXR5JykgIT09ICdoaWRkZW4nICYmICFlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZGF0YS1odG1sMmNhbnZhcy1pZ25vcmUnKSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwYXJzZUVsZW1lbnQgKGVsZW1lbnQsIHN0YWNrLCBwc2V1ZG9FbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoaXNFbGVtZW50VmlzaWJsZShlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIHN0YWNrID0gcmVuZGVyRWxlbWVudChlbGVtZW50LCBzdGFjaywgcHNldWRvRWxlbWVudCwgZmFsc2UpIHx8IHN0YWNrO1xuICAgICAgICAgICAgICAgIGlmICghaWdub3JlRWxlbWVudHNSZWdFeHAudGVzdChlbGVtZW50Lm5vZGVOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZUNoaWxkcmVuKGVsZW1lbnQsIHN0YWNrLCBwc2V1ZG9FbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwYXJzZUNoaWxkcmVuIChlbGVtZW50LCBzdGFjaywgcHNldWRvRWxlbWVudCkge1xuICAgICAgICAgICAgVXRpbC5DaGlsZHJlbihlbGVtZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IG5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRWxlbWVudChub2RlLCBzdGFjaywgcHNldWRvRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09PSBub2RlLlRFWFRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJUZXh0KGVsZW1lbnQsIG5vZGUsIHN0YWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGluaXQgKCkge1xuICAgICAgICAgICAgdmFyIGJhY2tncm91bmQgPSBvcHRpb25zLmJhY2tncm91bmQgfHwgZ2V0Q1NTKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgJ2JhY2tncm91bmRDb2xvcicpLCAvLyBNSkQgLSBhZGRlZCBtYW51YWwgYmFja2dyb3VuZCBjb2xvciBvcHRpb25cbiAgICAgICAgICAgICAgICB0cmFuc3BhcmVudEJhY2tncm91bmQgPSAoVXRpbC5pc1RyYW5zcGFyZW50KGJhY2tncm91bmQpICYmIGVsZW1lbnQgPT09IGRvY3VtZW50LmJvZHkpLFxuICAgICAgICAgICAgICAgIHN0YWNrID0gcmVuZGVyRWxlbWVudChlbGVtZW50LCBudWxsLCBmYWxzZSwgdHJhbnNwYXJlbnRCYWNrZ3JvdW5kKTtcbiAgICAgICAgICAgIHBhcnNlQ2hpbGRyZW4oZWxlbWVudCwgc3RhY2spO1xuXG4gICAgICAgICAgICBpZiAodHJhbnNwYXJlbnRCYWNrZ3JvdW5kKSB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZCA9IHN0YWNrLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYm9keS5yZW1vdmVDaGlsZChoaWRlUHNldWRvRWxlbWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGJhY2tncm91bmQsXG4gICAgICAgICAgICAgICAgc3RhY2s6IHN0YWNrXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluaXQoKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaDJjekNvbnRleHQgKHppbmRleCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgemluZGV4OiB6aW5kZXgsXG4gICAgICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBfaHRtbDJjYW52YXMuUHJlbG9hZCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBpbWFnZXMgPSB7XG4gICAgICAgICAgICAgICAgbnVtTG9hZGVkOiAwLCAgIC8vIGFsc28gZmFpbGVkIGFyZSBjb3VudGVkIGhlcmVcbiAgICAgICAgICAgICAgICBudW1GYWlsZWQ6IDAsXG4gICAgICAgICAgICAgICAgbnVtVG90YWw6IDAsXG4gICAgICAgICAgICAgICAgY2xlYW51cERvbmU6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFnZU9yaWdpbixcbiAgICAgICAgICAgIFV0aWwgPSBfaHRtbDJjYW52YXMuVXRpbCxcbiAgICAgICAgICAgIG1ldGhvZHMsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgY291bnQgPSAwLFxuICAgICAgICAgICAgZWxlbWVudCA9IG9wdGlvbnMuZWxlbWVudHNbMF0gfHwgZG9jdW1lbnQuYm9keSxcbiAgICAgICAgICAgIGRvYyA9IGVsZW1lbnQub3duZXJEb2N1bWVudCxcbiAgICAgICAgICAgIGRvbUltYWdlcyA9IGVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2ltZycpLCAvLyBGZXRjaCBpbWFnZXMgb2YgdGhlIHByZXNlbnQgZWxlbWVudCBvbmx5XG4gICAgICAgICAgICBpbWdMZW4gPSBkb21JbWFnZXMubGVuZ3RoLFxuICAgICAgICAgICAgbGluayA9IGRvYy5jcmVhdGVFbGVtZW50KCdhJyksXG4gICAgICAgICAgICBzdXBwb3J0Q09SUyA9IChmdW5jdGlvbiAoaW1nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChpbWcuY3Jvc3NPcmlnaW4gIT09IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9KShuZXcgSW1hZ2UoKSksXG4gICAgICAgICAgICB0aW1lb3V0VGltZXI7XG5cbiAgICAgICAgbGluay5ocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gICAgICAgIHBhZ2VPcmlnaW4gPSBsaW5rLnByb3RvY29sICsgbGluay5ob3N0O1xuXG4gICAgICAgIGZ1bmN0aW9uIGlzU2FtZU9yaWdpbiAodXJsKSB7XG4gICAgICAgICAgICBsaW5rLmhyZWYgPSB1cmw7XG4gICAgICAgICAgICBsaW5rLmhyZWYgPSBsaW5rLmhyZWY7IC8vIFlFUywgQkVMSUVWRSBJVCBPUiBOT1QsIHRoYXQgaXMgcmVxdWlyZWQgZm9yIElFOSAtIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvbmlrbGFzdmgvMmU0OGIvXG4gICAgICAgICAgICB2YXIgb3JpZ2luID0gbGluay5wcm90b2NvbCArIGxpbmsuaG9zdDtcbiAgICAgICAgICAgIHJldHVybiAob3JpZ2luID09PSBwYWdlT3JpZ2luKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHN0YXJ0ICgpIHtcbiAgICAgICAgICAgIFV0aWwubG9nKCdodG1sMmNhbnZhczogc3RhcnQ6IGltYWdlczogJyArIGltYWdlcy5udW1Mb2FkZWQgKyAnIC8gJyArIGltYWdlcy5udW1Ub3RhbCArICcgKGZhaWxlZDogJyArIGltYWdlcy5udW1GYWlsZWQgKyAnKScpO1xuICAgICAgICAgICAgaWYgKCFpbWFnZXMuZmlyc3RSdW4gJiYgaW1hZ2VzLm51bUxvYWRlZCA+PSBpbWFnZXMubnVtVG90YWwpIHtcbiAgICAgICAgICAgICAgICBVdGlsLmxvZygnRmluaXNoZWQgbG9hZGluZyBpbWFnZXM6ICMgJyArIGltYWdlcy5udW1Ub3RhbCArICcgKGZhaWxlZDogJyArIGltYWdlcy5udW1GYWlsZWQgKyAnKScpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmNvbXBsZXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY29tcGxldGUoaW1hZ2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAvLyBUT0RPIG1vZGlmeSBwcm94eSB0byBzZXJ2ZSBpbWFnZXMgd2l0aCBDT1JTIGVuYWJsZWQsIHdoZXJlIGF2YWlsYWJsZVxuICAgICAgICBmdW5jdGlvbiBwcm94eUdldEltYWdlICh1cmwsIGltZywgaW1hZ2VPYmopIHtcbiAgICAgICAgICAgIHZhciBjYWxsYmFja19uYW1lLFxuICAgICAgICAgICAgICAgIHNjcmlwdFVybCA9IG9wdGlvbnMucHJveHksXG4gICAgICAgICAgICAgICAgc2NyaXB0O1xuXG4gICAgICAgICAgICBsaW5rLmhyZWYgPSB1cmw7XG4gICAgICAgICAgICB1cmwgPSBsaW5rLmhyZWY7IC8vIHdvcmsgYXJvdW5kIGZvciBwYWdlcyB3aXRoIGJhc2UgaHJlZj1cIlwiIHNldCAtIFdBUk5JTkc6IHRoaXMgbWF5IGNoYW5nZSB0aGUgdXJsXG5cbiAgICAgICAgICAgIGNhbGxiYWNrX25hbWUgPSAnaHRtbDJjYW52YXNfJyArIChjb3VudCsrKTtcbiAgICAgICAgICAgIGltYWdlT2JqLmNhbGxiYWNrbmFtZSA9IGNhbGxiYWNrX25hbWU7XG5cbiAgICAgICAgICAgIGlmIChzY3JpcHRVcmwuaW5kZXhPZignPycpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBzY3JpcHRVcmwgKz0gJyYnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY3JpcHRVcmwgKz0gJz8nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2NyaXB0VXJsICs9ICd1cmw9JyArIGVuY29kZVVSSUNvbXBvbmVudCh1cmwpICsgJyZjYWxsYmFjaz0nICsgY2FsbGJhY2tfbmFtZTtcbiAgICAgICAgICAgIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblxuICAgICAgICAgICAgd2luZG93W2NhbGxiYWNrX25hbWVdID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoYS5zdWJzdHJpbmcoMCwgNikgPT09ICdlcnJvcjonKSB7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlT2JqLnN1Y2NlZWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpbWFnZXMubnVtTG9hZGVkKys7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlcy5udW1GYWlsZWQrKztcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXRJbWFnZUxvYWRIYW5kbGVycyhpbWcsIGltYWdlT2JqKTtcbiAgICAgICAgICAgICAgICAgICAgaW1nLnNyYyA9IGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdpbmRvd1tjYWxsYmFja19uYW1lXSA9IHVuZGVmaW5lZDsgLy8gdG8gd29yayB3aXRoIElFPDkgIC8vIE5PVEU6IHRoYXQgdGhlIHVuZGVmaW5lZCBjYWxsYmFjayBwcm9wZXJ0eS1uYW1lIHN0aWxsIGV4aXN0cyBvbiB0aGUgd2luZG93IG9iamVjdCAoZm9yIElFPDkpXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHdpbmRvd1tjYWxsYmFja19uYW1lXTsgIC8vIGZvciBhbGwgYnJvd3NlciB0aGF0IHN1cHBvcnQgdGhpc1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7fVxuICAgICAgICAgICAgICAgIHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBkZWxldGUgaW1hZ2VPYmouc2NyaXB0O1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBpbWFnZU9iai5jYWxsYmFja25hbWU7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBzY3JpcHQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvamF2YXNjcmlwdCcpO1xuICAgICAgICAgICAgc2NyaXB0LnNldEF0dHJpYnV0ZSgnc3JjJywgc2NyaXB0VXJsKTtcbiAgICAgICAgICAgIGltYWdlT2JqLnNjcmlwdCA9IHNjcmlwdDtcbiAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBsb2FkUHNldWRvRWxlbWVudCAoZWxlbWVudCwgdHlwZSkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgdHlwZSksXG4gICAgICAgICAgICAgICAgY29udGVudCA9IHN0eWxlLmNvbnRlbnQ7XG4gICAgICAgICAgICBpZiAoY29udGVudC5zdWJzdHIoMCwgMykgPT09ICd1cmwnKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kcy5sb2FkSW1hZ2UoX2h0bWwyY2FudmFzLlV0aWwucGFyc2VCYWNrZ3JvdW5kSW1hZ2UoY29udGVudClbMF0uYXJnc1swXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2FkQmFja2dyb3VuZEltYWdlcyhzdHlsZS5iYWNrZ3JvdW5kSW1hZ2UsIGVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbG9hZFBzZXVkb0VsZW1lbnRJbWFnZXMgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGxvYWRQc2V1ZG9FbGVtZW50KGVsZW1lbnQsICc6YmVmb3JlJyk7XG4gICAgICAgICAgICBsb2FkUHNldWRvRWxlbWVudChlbGVtZW50LCAnOmFmdGVyJyk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBsb2FkR3JhZGllbnRJbWFnZSAoYmFja2dyb3VuZEltYWdlLCBib3VuZHMpIHtcbiAgICAgICAgICAgIHZhciBpbWcgPSBfaHRtbDJjYW52YXMuR2VuZXJhdGUuR3JhZGllbnQoYmFja2dyb3VuZEltYWdlLCBib3VuZHMpO1xuXG4gICAgICAgICAgICBpZiAoaW1nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpbWFnZXNbYmFja2dyb3VuZEltYWdlXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgaW1nOiBpbWcsXG4gICAgICAgICAgICAgICAgICAgIHN1Y2NlZWRlZDogdHJ1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaW1hZ2VzLm51bVRvdGFsKys7XG4gICAgICAgICAgICAgICAgaW1hZ2VzLm51bUxvYWRlZCsrO1xuICAgICAgICAgICAgICAgIHN0YXJ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpbnZhbGlkQmFja2dyb3VuZHMgKGJhY2tncm91bmRfaW1hZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiAoYmFja2dyb3VuZF9pbWFnZSAmJiBiYWNrZ3JvdW5kX2ltYWdlLm1ldGhvZCAmJiBiYWNrZ3JvdW5kX2ltYWdlLmFyZ3MgJiYgYmFja2dyb3VuZF9pbWFnZS5hcmdzLmxlbmd0aCA+IDApO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbG9hZEJhY2tncm91bmRJbWFnZXMgKGJhY2tncm91bmRfaW1hZ2UsIGVsKSB7XG4gICAgICAgICAgICB2YXIgYm91bmRzO1xuXG4gICAgICAgICAgICBfaHRtbDJjYW52YXMuVXRpbC5wYXJzZUJhY2tncm91bmRJbWFnZShiYWNrZ3JvdW5kX2ltYWdlKS5maWx0ZXIoaW52YWxpZEJhY2tncm91bmRzKS5mb3JFYWNoKGZ1bmN0aW9uIChiYWNrZ3JvdW5kX2ltYWdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJhY2tncm91bmRfaW1hZ2UubWV0aG9kID09PSAndXJsJykge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2RzLmxvYWRJbWFnZShiYWNrZ3JvdW5kX2ltYWdlLmFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYmFja2dyb3VuZF9pbWFnZS5tZXRob2QubWF0Y2goL1xcLT9ncmFkaWVudCQvKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYm91bmRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kcyA9IF9odG1sMmNhbnZhcy5VdGlsLkJvdW5kcyhlbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbG9hZEdyYWRpZW50SW1hZ2UoYmFja2dyb3VuZF9pbWFnZS52YWx1ZSwgYm91bmRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldEltYWdlcyAoZWwpIHtcbiAgICAgICAgICAgIHZhciBlbE5vZGVUeXBlID0gZmFsc2U7XG5cbiAgICAvLyBGaXJlZm94IGZhaWxzIHdpdGggcGVybWlzc2lvbiBkZW5pZWQgb24gcGFnZXMgd2l0aCBpZnJhbWVzXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIFV0aWwuQ2hpbGRyZW4oZWwpLmZvckVhY2goZ2V0SW1hZ2VzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZWxOb2RlVHlwZSA9IGVsLm5vZGVUeXBlO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICBlbE5vZGVUeXBlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgVXRpbC5sb2coXCJodG1sMmNhbnZhczogZmFpbGVkIHRvIGFjY2VzcyBzb21lIGVsZW1lbnQncyBub2RlVHlwZSAtIEV4Y2VwdGlvbjogXCIgKyBleC5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVsTm9kZVR5cGUgPT09IDEgfHwgZWxOb2RlVHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9hZFBzZXVkb0VsZW1lbnRJbWFnZXMoZWwpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRCYWNrZ3JvdW5kSW1hZ2VzKFV0aWwuZ2V0Q1NTKGVsLCAnYmFja2dyb3VuZEltYWdlJyksIGVsKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIFV0aWwubG9nKCdodG1sMmNhbnZhczogZmFpbGVkIHRvIGdldCBiYWNrZ3JvdW5kLWltYWdlIC0gRXhjZXB0aW9uOiAnICsgZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9hZEJhY2tncm91bmRJbWFnZXMoZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc2V0SW1hZ2VMb2FkSGFuZGxlcnMgKGltZywgaW1hZ2VPYmopIHtcbiAgICAgICAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGltYWdlT2JqLnRpbWVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gQ09SUyBzdWNjZWVkZWRcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChpbWFnZU9iai50aW1lcik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaW1hZ2VzLm51bUxvYWRlZCsrO1xuICAgICAgICAgICAgICAgIGltYWdlT2JqLnN1Y2NlZWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaW1nLm9uZXJyb3IgPSBpbWcub25sb2FkID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzdGFydCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGltZy5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChpbWcuY3Jvc3NPcmlnaW4gPT09ICdhbm9ueW1vdXMnKSB7XG4gICAgICAgIC8vIENPUlMgZmFpbGVkXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoaW1hZ2VPYmoudGltZXIpO1xuXG4gICAgICAgIC8vIGxldCdzIHRyeSB3aXRoIHByb3h5IGluc3RlYWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucHJveHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcmMgPSBpbWcuc3JjO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZU9iai5pbWcgPSBpbWc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWcuc3JjID0gc3JjO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm94eUdldEltYWdlKGltZy5zcmMsIGltZywgaW1hZ2VPYmopO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaW1hZ2VzLm51bUxvYWRlZCsrO1xuICAgICAgICAgICAgICAgIGltYWdlcy5udW1GYWlsZWQrKztcbiAgICAgICAgICAgICAgICBpbWFnZU9iai5zdWNjZWVkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpbWcub25lcnJvciA9IGltZy5vbmxvYWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHN0YXJ0KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgbWV0aG9kcyA9IHtcbiAgICAgICAgICAgIGxvYWRJbWFnZTogZnVuY3Rpb24gKHNyYykge1xuICAgICAgICAgICAgICAgIHZhciBpbWcsIGltYWdlT2JqO1xuICAgICAgICAgICAgICAgIGlmIChzcmMgJiYgaW1hZ2VzW3NyY10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNyYy5tYXRjaCgvZGF0YTppbWFnZVxcLy4qO2Jhc2U2NCwvaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZy5zcmMgPSBzcmMucmVwbGFjZSgvdXJsXFwoWydcIl17MCx9fFsnXCJdezAsfVxcKSQvaWcsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlT2JqID0gaW1hZ2VzW3NyY10gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1nOiBpbWdcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZXMubnVtVG90YWwrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEltYWdlTG9hZEhhbmRsZXJzKGltZywgaW1hZ2VPYmopO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzU2FtZU9yaWdpbihzcmMpIHx8IG9wdGlvbnMuYWxsb3dUYWludCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VPYmogPSBpbWFnZXNbc3JjXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWc6IGltZ1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlcy5udW1Ub3RhbCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0SW1hZ2VMb2FkSGFuZGxlcnMoaW1nLCBpbWFnZU9iaik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWcuc3JjID0gc3JjO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN1cHBvcnRDT1JTICYmICFvcHRpb25zLmFsbG93VGFpbnQgJiYgb3B0aW9ucy51c2VDT1JTKSB7XG4gICAgICAgICAgLy8gYXR0ZW1wdCB0byBsb2FkIHdpdGggQ09SU1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWcuY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlT2JqID0gaW1hZ2VzW3NyY10gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1nOiBpbWdcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZXMubnVtVG90YWwrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEltYWdlTG9hZEhhbmRsZXJzKGltZywgaW1hZ2VPYmopO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1nLnNyYyA9IHNyYztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnByb3h5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZU9iaiA9IGltYWdlc1tzcmNdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltZzogaW1nXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VzLm51bVRvdGFsKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm94eUdldEltYWdlKHNyYywgaW1nLCBpbWFnZU9iaik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xlYW51cERPTTogZnVuY3Rpb24gKGNhdXNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGltZywgc3JjO1xuICAgICAgICAgICAgICAgIGlmICghaW1hZ2VzLmNsZWFudXBEb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYXVzZSAmJiB0eXBlb2YgY2F1c2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBVdGlsLmxvZygnaHRtbDJjYW52YXM6IENsZWFudXAgYmVjYXVzZTogJyArIGNhdXNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFV0aWwubG9nKCdodG1sMmNhbnZhczogQ2xlYW51cCBhZnRlciB0aW1lb3V0OiAnICsgb3B0aW9ucy50aW1lb3V0ICsgJyBtcy4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoc3JjIGluIGltYWdlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGltYWdlcy5oYXNPd25Qcm9wZXJ0eShzcmMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1nID0gaW1hZ2VzW3NyY107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpbWcgPT09ICdvYmplY3QnICYmIGltZy5jYWxsYmFja25hbWUgJiYgaW1nLnN1Y2NlZWRlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIC8vIGNhbmNlbCBwcm94eSBpbWFnZSByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvd1tpbWcuY2FsbGJhY2tuYW1lXSA9IHVuZGVmaW5lZDsgLy8gdG8gd29yayB3aXRoIElFPDkgIC8vIE5PVEU6IHRoYXQgdGhlIHVuZGVmaW5lZCBjYWxsYmFjayBwcm9wZXJ0eS1uYW1lIHN0aWxsIGV4aXN0cyBvbiB0aGUgd2luZG93IG9iamVjdCAoZm9yIElFPDkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgd2luZG93W2ltZy5jYWxsYmFja25hbWVdOyAgLy8gZm9yIGFsbCBicm93c2VyIHRoYXQgc3VwcG9ydCB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW1nLnNjcmlwdCAmJiBpbWcuc2NyaXB0LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltZy5zY3JpcHQuc2V0QXR0cmlidXRlKCdzcmMnLCAnYWJvdXQ6YmxhbmsnKTsgIC8vIHRyeSB0byBjYW5jZWwgcnVubmluZyByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWcuc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaW1nLnNjcmlwdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VzLm51bUxvYWRlZCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZXMubnVtRmFpbGVkKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFV0aWwubG9nKFwiaHRtbDJjYW52YXM6IENsZWFuZWQgdXAgZmFpbGVkIGltZzogJ1wiICsgc3JjICsgXCInIFN0ZXBzOiBcIiArIGltYWdlcy5udW1Mb2FkZWQgKyAnIC8gJyArIGltYWdlcy5udW1Ub3RhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgLy8gY2FuY2VsIGFueSBwZW5kaW5nIHJlcXVlc3RzXG4gICAgICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuc3RvcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRvY3VtZW50LmV4ZWNDb21tYW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKCdTdG9wJywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5jbG9zZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGltYWdlcy5jbGVhbnVwRG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGNhdXNlICYmIHR5cGVvZiBjYXVzZSA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcmVuZGVyaW5nRG9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0VGltZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0VGltZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAob3B0aW9ucy50aW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgdGltZW91dFRpbWVyID0gd2luZG93LnNldFRpbWVvdXQobWV0aG9kcy5jbGVhbnVwRE9NLCBvcHRpb25zLnRpbWVvdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgVXRpbC5sb2coJ2h0bWwyY2FudmFzOiBQcmVsb2FkIHN0YXJ0czogZmluZGluZyBiYWNrZ3JvdW5kLWltYWdlcycpO1xuICAgICAgICBpbWFnZXMuZmlyc3RSdW4gPSB0cnVlO1xuXG4gICAgICAgIGdldEltYWdlcyhlbGVtZW50KTtcblxuICAgICAgICBVdGlsLmxvZygnaHRtbDJjYW52YXM6IFByZWxvYWQ6IEZpbmRpbmcgaW1hZ2VzJyk7XG4gIC8vIGxvYWQgPGltZz4gaW1hZ2VzXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbWdMZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgbWV0aG9kcy5sb2FkSW1hZ2UoZG9tSW1hZ2VzW2ldLmdldEF0dHJpYnV0ZSgnc3JjJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW1hZ2VzLmZpcnN0UnVuID0gZmFsc2U7XG4gICAgICAgIFV0aWwubG9nKCdodG1sMmNhbnZhczogUHJlbG9hZDogRG9uZS4nKTtcbiAgICAgICAgaWYgKGltYWdlcy5udW1Ub3RhbCA9PT0gaW1hZ2VzLm51bUxvYWRlZCkge1xuICAgICAgICAgICAgc3RhcnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZXRob2RzO1xuICAgIH07XG5cbiAgICBfaHRtbDJjYW52YXMuUmVuZGVyZXIgPSBmdW5jdGlvbiAocGFyc2VRdWV1ZSwgb3B0aW9ucykge1xuICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS96aW5kZXguaHRtbFxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVSZW5kZXJRdWV1ZSAocGFyc2VRdWV1ZSkge1xuICAgICAgICAgICAgdmFyIHF1ZXVlID0gW10sXG4gICAgICAgICAgICAgICAgcm9vdENvbnRleHQ7XG5cbiAgICAgICAgICAgIHJvb3RDb250ZXh0ID0gKGZ1bmN0aW9uIGJ1aWxkU3RhY2tpbmdDb250ZXh0IChyb290Tm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciByb290Q29udGV4dCA9IHt9O1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGluc2VydCAoY29udGV4dCwgbm9kZSwgc3BlY2lhbFBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgemkgPSAobm9kZS56SW5kZXguemluZGV4ID09PSAnYXV0bycpID8gMCA6IE51bWJlcihub2RlLnpJbmRleC56aW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dEZvckNoaWxkcmVuID0gY29udGV4dCwgLy8gdGhlIHN0YWNraW5nIGNvbnRleHQgZm9yIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1Bvc2l0aW9uZWQgPSBub2RlLnpJbmRleC5pc1Bvc2l0aW9uZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0Zsb2F0ZWQgPSBub2RlLnpJbmRleC5pc0Zsb2F0ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHViID0ge25vZGU6IG5vZGV9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5EZXN0ID0gc3BlY2lhbFBhcmVudDsgLy8gd2hlcmUgY2hpbGRyZW4gd2l0aG91dCB6LWluZGV4IHNob3VsZCBiZSBwdXNoZWQgaW50b1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnpJbmRleC5vd25TdGFja2luZykge1xuICAgICAgICAgIC8vICchJyBjb21lcyBiZWZvcmUgbnVtYmVycyBpbiBzb3J0ZWQgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHRGb3JDaGlsZHJlbiA9IHN0dWIuY29udGV4dCA9IHsgJyEnOiBbe25vZGU6IG5vZGUsIGNoaWxkcmVuOiBbXX1dfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuRGVzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc1Bvc2l0aW9uZWQgfHwgaXNGbG9hdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbkRlc3QgPSBzdHViLmNoaWxkcmVuID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoemkgPT09IDAgJiYgc3BlY2lhbFBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3BlY2lhbFBhcmVudC5wdXNoKHN0dWIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250ZXh0W3ppXSkgeyBjb250ZXh0W3ppXSA9IFtdOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0W3ppXS5wdXNoKHN0dWIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbm9kZS56SW5kZXguY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnQoY29udGV4dEZvckNoaWxkcmVuLCBjaGlsZE5vZGUsIGNoaWxkcmVuRGVzdCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnNlcnQocm9vdENvbnRleHQsIHJvb3ROb2RlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcm9vdENvbnRleHQ7XG4gICAgICAgICAgICB9KShwYXJzZVF1ZXVlKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gc29ydFogKGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhjb250ZXh0KS5zb3J0KCkuZm9yRWFjaChmdW5jdGlvbiAoemkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vblBvc2l0aW9uZWQgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0ZWQgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uZWQgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QgPSBbXTtcblxuICAgICAgICAvLyBwb3NpdGlvbmVkIGFmdGVyIHN0YXRpY1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0W3ppXS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodi5ub2RlLnpJbmRleC5pc1Bvc2l0aW9uZWQgfHwgdi5ub2RlLnpJbmRleC5vcGFjaXR5IDwgMSkge1xuICAgICAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1jb2xvci8jdHJhbnNwYXJlbmN5XG4gICAgICAgICAgICAvLyBub24tcG9zaXRpb25lZCBlbGVtZW50IHdpdGggb3BhY3RpeSA8IDEgc2hvdWxkIGJlIHN0YWNrZWQgYXMgaWYgaXQgd2VyZSBhIHBvc2l0aW9uZWQgZWxlbWVudCB3aXRoIOKAmHotaW5kZXg6IDDigJkgYW5kIOKAmG9wYWNpdHk6IDHigJkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25lZC5wdXNoKHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2Lm5vZGUuekluZGV4LmlzRmxvYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0ZWQucHVzaCh2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9uUG9zaXRpb25lZC5wdXNoKHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAoZnVuY3Rpb24gd2FsayAoYXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnIuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QucHVzaCh2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodi5jaGlsZHJlbikgeyB3YWxrKHYuY2hpbGRyZW4pOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSkobm9uUG9zaXRpb25lZC5jb25jYXQoZmxvYXRlZCwgcG9zaXRpb25lZCkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGxpc3QuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYuY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRaKHYuY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2godi5ub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNvcnRaKHJvb3RDb250ZXh0KTtcblxuICAgICAgICAgICAgcmV0dXJuIHF1ZXVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0UmVuZGVyZXIgKHJlbmRlcmVyTmFtZSkge1xuICAgICAgICAgICAgdmFyIHJlbmRlcmVyO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVuZGVyZXIgPT09ICdzdHJpbmcnICYmIF9odG1sMmNhbnZhcy5SZW5kZXJlcltyZW5kZXJlck5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlciA9IF9odG1sMmNhbnZhcy5SZW5kZXJlcltyZW5kZXJlck5hbWVdKG9wdGlvbnMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmVuZGVyZXJOYW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXIgPSByZW5kZXJlck5hbWUob3B0aW9ucyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biByZW5kZXJlcicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlbmRlcmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJlbmRlcmVyIGRlZmluZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZW5kZXJlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZXRSZW5kZXJlcihvcHRpb25zLnJlbmRlcmVyKShwYXJzZVF1ZXVlLCBvcHRpb25zLCBkb2N1bWVudCwgY3JlYXRlUmVuZGVyUXVldWUocGFyc2VRdWV1ZS5zdGFjayksIF9odG1sMmNhbnZhcyk7XG4gICAgfTtcblxuICAgIF9odG1sMmNhbnZhcy5VdGlsLlN1cHBvcnQgPSBmdW5jdGlvbiAob3B0aW9ucywgZG9jKSB7XG4gICAgICAgIGZ1bmN0aW9uIHN1cHBvcnRTVkdSZW5kZXJpbmcgKCkge1xuICAgICAgICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpLFxuICAgICAgICAgICAgICAgIGNhbnZhcyA9IGRvYy5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSxcbiAgICAgICAgICAgICAgICBjdHggPSAoY2FudmFzLmdldENvbnRleHQgPT09IHVuZGVmaW5lZCkgPyBmYWxzZSA6IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgaWYgKGN0eCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSBjYW52YXMuaGVpZ2h0ID0gMTA7XG4gICAgICAgICAgICBpbWcuc3JjID0gW1xuICAgICAgICAgICAgICAgICdkYXRhOmltYWdlL3N2Zyt4bWwsJyxcbiAgICAgICAgICAgICAgICBcIjxzdmcgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB3aWR0aD0nMTAnIGhlaWdodD0nMTAnPlwiLFxuICAgICAgICAgICAgICAgIFwiPGZvcmVpZ25PYmplY3Qgd2lkdGg9JzEwJyBoZWlnaHQ9JzEwJz5cIixcbiAgICAgICAgICAgICAgICBcIjxkaXYgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnIHN0eWxlPSd3aWR0aDoxMDtoZWlnaHQ6MTA7Jz5cIixcbiAgICAgICAgICAgICAgICAnc3VwJyxcbiAgICAgICAgICAgICAgICAnPC9kaXY+JyxcbiAgICAgICAgICAgICAgICAnPC9mb3JlaWduT2JqZWN0PicsXG4gICAgICAgICAgICAgICAgJzwvc3ZnPidcbiAgICAgICAgICAgIF0uam9pbignJyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwKTtcbiAgICAgICAgICAgICAgICBjYW52YXMudG9EYXRhVVJMKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2h0bWwyY2FudmFzLlV0aWwubG9nKCdodG1sMmNhbnZhczogUGFyc2U6IFNWRyBwb3dlcmVkIHJlbmRlcmluZyBhdmFpbGFibGUnKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgLy8gVGVzdCB3aGV0aGVyIHdlIGNhbiB1c2UgcmFuZ2VzIHRvIG1lYXN1cmUgYm91bmRpbmcgYm94ZXNcbiAgLy8gT3BlcmEgZG9lc24ndCBwcm92aWRlIHZhbGlkIGJvdW5kcy5oZWlnaHQvYm90dG9tIGV2ZW4gdGhvdWdoIGl0IHN1cHBvcnRzIHRoZSBtZXRob2QuXG5cbiAgICAgICAgZnVuY3Rpb24gc3VwcG9ydFJhbmdlQm91bmRzICgpIHtcbiAgICAgICAgICAgIHZhciByLCB0ZXN0RWxlbWVudCwgcmFuZ2VCb3VuZHMsIHJhbmdlSGVpZ2h0LCBzdXBwb3J0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChkb2MuY3JlYXRlUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICByID0gZG9jLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRlc3RFbGVtZW50ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2JvdW5kdGVzdCcpO1xuICAgICAgICAgICAgICAgICAgICB0ZXN0RWxlbWVudC5zdHlsZS5oZWlnaHQgPSAnMTIzcHgnO1xuICAgICAgICAgICAgICAgICAgICB0ZXN0RWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgICAgICAgICAgZG9jLmJvZHkuYXBwZW5kQ2hpbGQodGVzdEVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgIHIuc2VsZWN0Tm9kZSh0ZXN0RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlQm91bmRzID0gci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VIZWlnaHQgPSByYW5nZUJvdW5kcy5oZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlSGVpZ2h0ID09PSAxMjMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1cHBvcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRvYy5ib2R5LnJlbW92ZUNoaWxkKHRlc3RFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzdXBwb3J0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhbmdlQm91bmRzOiBzdXBwb3J0UmFuZ2VCb3VuZHMoKSxcbiAgICAgICAgICAgIHN2Z1JlbmRlcmluZzogb3B0aW9ucy5zdmdSZW5kZXJpbmcgJiYgc3VwcG9ydFNWR1JlbmRlcmluZygpXG4gICAgICAgIH07XG4gICAgfTtcbiAgICB3aW5kb3cuaHRtbDJjYW52YXMgPSBmdW5jdGlvbiAoZWxlbWVudHMsIG9wdHMpIHtcbiAgICAgICAgZWxlbWVudHMgPSAoZWxlbWVudHMubGVuZ3RoKSA/IGVsZW1lbnRzIDogW2VsZW1lbnRzXTtcbiAgICAgICAgdmFyIHF1ZXVlLFxuICAgICAgICAgICAgY2FudmFzLFxuICAgICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAvLyBnZW5lcmFsXG4gICAgICAgICAgICAgICAgbG9nZ2luZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6ICcjZmZmJyxcblxuICAgIC8vIHByZWxvYWQgb3B0aW9uc1xuICAgICAgICAgICAgICAgIHByb3h5OiBudWxsLFxuICAgICAgICAgICAgICAgIHRpbWVvdXQ6IDAsICAgIC8vIG5vIHRpbWVvdXRcbiAgICAgICAgICAgICAgICB1c2VDT1JTOiBmYWxzZSwgLy8gdHJ5IHRvIGxvYWQgaW1hZ2VzIGFzIENPUlMgKHdoZXJlIGF2YWlsYWJsZSksIGJlZm9yZSBmYWxsaW5nIGJhY2sgdG8gcHJveHlcbiAgICAgICAgICAgICAgICBhbGxvd1RhaW50OiBmYWxzZSwgLy8gd2hldGhlciB0byBhbGxvdyBpbWFnZXMgdG8gdGFpbnQgdGhlIGNhbnZhcywgd29uJ3QgbmVlZCBwcm94eSBpZiBzZXQgdG8gdHJ1ZVxuXG4gICAgLy8gcGFyc2Ugb3B0aW9uc1xuICAgICAgICAgICAgICAgIHN2Z1JlbmRlcmluZzogZmFsc2UsIC8vIHVzZSBzdmcgcG93ZXJlZCByZW5kZXJpbmcgd2hlcmUgYXZhaWxhYmxlIChGRjExKylcbiAgICAgICAgICAgICAgICBpZ25vcmVFbGVtZW50czogJ0lGUkFNRXxPQkpFQ1R8UEFSQU0nLFxuICAgICAgICAgICAgICAgIHVzZU92ZXJmbG93OiB0cnVlLFxuICAgICAgICAgICAgICAgIGxldHRlclJlbmRlcmluZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgY2hpbmVzZTogZmFsc2UsXG5cbiAgICAvLyByZW5kZXIgb3B0aW9uc1xuXG4gICAgICAgICAgICAgICAgd2lkdGg6IG51bGwsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBudWxsLFxuICAgICAgICAgICAgICAgIHRhaW50VGVzdDogdHJ1ZSwgLy8gZG8gYSB0YWludCB0ZXN0IHdpdGggYWxsIGltYWdlcyBiZWZvcmUgYXBwbHlpbmcgdG8gY2FudmFzXG4gICAgICAgICAgICAgICAgcmVuZGVyZXI6ICdDYW52YXMnXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIG9wdGlvbnMgPSBfaHRtbDJjYW52YXMuVXRpbC5FeHRlbmQob3B0cywgb3B0aW9ucyk7XG5cbiAgICAgICAgX2h0bWwyY2FudmFzLmxvZ2dpbmcgPSBvcHRpb25zLmxvZ2dpbmc7XG4gICAgICAgIG9wdGlvbnMuY29tcGxldGUgPSBmdW5jdGlvbiAoaW1hZ2VzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMub25wcmVsb2FkZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vbnByZWxvYWRlZChpbWFnZXMpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcXVldWUgPSBfaHRtbDJjYW52YXMuUGFyc2UoaW1hZ2VzLCBvcHRpb25zKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm9ucGFyc2VkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub25wYXJzZWQocXVldWUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYW52YXMgPSBfaHRtbDJjYW52YXMuUmVuZGVyZXIocXVldWUsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMub25yZW5kZXJlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMub25yZW5kZXJlZChjYW52YXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gIC8vIGZvciBwYWdlcyB3aXRob3V0IGltYWdlcywgd2Ugc3RpbGwgd2FudCB0aGlzIHRvIGJlIGFzeW5jLCBpLmUuIHJldHVybiBtZXRob2RzIGJlZm9yZSBleGVjdXRpbmdcbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX2h0bWwyY2FudmFzLlByZWxvYWQob3B0aW9ucyk7XG4gICAgICAgIH0sIDApO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIChxdWV1ZSwgb3B0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBfaHRtbDJjYW52YXMuUmVuZGVyZXIocXVldWUsIF9odG1sMmNhbnZhcy5VdGlsLkV4dGVuZChvcHRzLCBvcHRpb25zKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChpbWFnZXMsIG9wdHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2h0bWwyY2FudmFzLlBhcnNlKGltYWdlcywgX2h0bWwyY2FudmFzLlV0aWwuRXh0ZW5kKG9wdHMsIG9wdGlvbnMpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmVsb2FkOiBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBfaHRtbDJjYW52YXMuUHJlbG9hZChfaHRtbDJjYW52YXMuVXRpbC5FeHRlbmQob3B0cywgb3B0aW9ucykpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxvZzogX2h0bWwyY2FudmFzLlV0aWwubG9nXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHdpbmRvdy5odG1sMmNhbnZhcy5sb2cgPSBfaHRtbDJjYW52YXMuVXRpbC5sb2c7IC8vIGZvciByZW5kZXJlcnNcbiAgICB3aW5kb3cuaHRtbDJjYW52YXMuUmVuZGVyZXIgPSB7XG4gICAgICAgIENhbnZhczogdW5kZWZpbmVkIC8vIFdlIGFyZSBhc3N1bWluZyB0aGlzIHdpbGwgYmUgdXNlZFxuICAgIH07XG4gICAgX2h0bWwyY2FudmFzLlJlbmRlcmVyLkNhbnZhcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIHZhciBkb2MgPSBkb2N1bWVudCxcbiAgICAgICAgICAgIHNhZmVJbWFnZXMgPSBbXSxcbiAgICAgICAgICAgIHRlc3RDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSxcbiAgICAgICAgICAgIHRlc3RjdHggPSB0ZXN0Q2FudmFzLmdldENvbnRleHQoJzJkJyksXG4gICAgICAgICAgICBVdGlsID0gX2h0bWwyY2FudmFzLlV0aWwsXG4gICAgICAgICAgICBjYW52YXMgPSBvcHRpb25zLmNhbnZhcyB8fCBkb2MuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlU2hhcGUgKGN0eCwgYXJncykge1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgICAgICBjdHhbYXJnLm5hbWVdLmFwcGx5KGN0eCwgYXJnWydhcmd1bWVudHMnXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNhZmVJbWFnZSAoaXRlbSkge1xuICAgICAgICAgICAgaWYgKHNhZmVJbWFnZXMuaW5kZXhPZihpdGVtWydhcmd1bWVudHMnXVswXS5zcmMpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHRlc3RjdHguZHJhd0ltYWdlKGl0ZW1bJ2FyZ3VtZW50cyddWzBdLCAwLCAwKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0ZXN0Y3R4LmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlc3RDYW52YXMgPSBkb2MuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICAgICAgICAgIHRlc3RjdHggPSB0ZXN0Q2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2FmZUltYWdlcy5wdXNoKGl0ZW1bJ2FyZ3VtZW50cyddWzBdLnNyYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlbmRlckl0ZW0gKGN0eCwgaXRlbSkge1xuICAgICAgICAgICAgc3dpdGNoIChpdGVtLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3ZhcmlhYmxlJzpcbiAgICAgICAgICAgICAgICBjdHhbaXRlbS5uYW1lXSA9IGl0ZW1bJ2FyZ3VtZW50cyddO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgICAgIHN3aXRjaCAoaXRlbS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnY3JlYXRlUGF0dGVybic6XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtWydhcmd1bWVudHMnXVswXS53aWR0aCA+IDAgJiYgaXRlbVsnYXJndW1lbnRzJ11bMF0uaGVpZ2h0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gY3R4LmNyZWF0ZVBhdHRlcm4oaXRlbVsnYXJndW1lbnRzJ11bMF0sICdyZXBlYXQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBVdGlsLmxvZygnaHRtbDJjYW52YXM6IFJlbmRlcmVyOiBFcnJvciBjcmVhdGluZyBwYXR0ZXJuJywgZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdkcmF3U2hhcGUnOlxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVTaGFwZShjdHgsIGl0ZW1bJ2FyZ3VtZW50cyddKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZHJhd0ltYWdlJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1bJ2FyZ3VtZW50cyddWzhdID4gMCAmJiBpdGVtWydhcmd1bWVudHMnXVs3XSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy50YWludFRlc3QgfHwgKG9wdGlvbnMudGFpbnRUZXN0ICYmIHNhZmVJbWFnZShpdGVtKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlLmFwcGx5KGN0eCwgaXRlbVsnYXJndW1lbnRzJ10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGN0eFtpdGVtLm5hbWVdLmFwcGx5KGN0eCwgaXRlbVsnYXJndW1lbnRzJ10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocGFyc2VkRGF0YSwgb3B0aW9ucywgZG9jdW1lbnQsIHF1ZXVlLCBfaHRtbDJjYW52YXMpIHtcbiAgICAgICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgICAgICAgICAgICBuZXdDYW52YXMsXG4gICAgICAgICAgICAgICAgYm91bmRzLFxuICAgICAgICAgICAgICAgIGZzdHlsZSxcbiAgICAgICAgICAgICAgICB6U3RhY2sgPSBwYXJzZWREYXRhLnN0YWNrO1xuXG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSBjYW52YXMuc3R5bGUud2lkdGggPSBvcHRpb25zLndpZHRoIHx8IHpTdGFjay5jdHgud2lkdGg7XG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzLnN0eWxlLmhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0IHx8IHpTdGFjay5jdHguaGVpZ2h0O1xuXG4gICAgICAgICAgICBmc3R5bGUgPSBjdHguZmlsbFN0eWxlO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IChVdGlsLmlzVHJhbnNwYXJlbnQoelN0YWNrLmJhY2tncm91bmRDb2xvcikgJiYgb3B0aW9ucy5iYWNrZ3JvdW5kICE9PSB1bmRlZmluZWQpID8gb3B0aW9ucy5iYWNrZ3JvdW5kIDogcGFyc2VkRGF0YS5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBmc3R5bGU7XG5cbiAgICAgICAgICAgIHF1ZXVlLmZvckVhY2goZnVuY3Rpb24gKHN0b3JhZ2VDb250ZXh0KSB7XG4gICAgICAvLyBzZXQgY29tbW9uIHNldHRpbmdzIGZvciBjYW52YXNcbiAgICAgICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ2JvdHRvbSc7XG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcblxuICAgICAgICAgICAgICAgIGlmIChzdG9yYWdlQ29udGV4dC50cmFuc2Zvcm0ubWF0cml4KSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoc3RvcmFnZUNvbnRleHQudHJhbnNmb3JtLm9yaWdpblswXSwgc3RvcmFnZUNvbnRleHQudHJhbnNmb3JtLm9yaWdpblsxXSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC50cmFuc2Zvcm0uYXBwbHkoY3R4LCBzdG9yYWdlQ29udGV4dC50cmFuc2Zvcm0ubWF0cml4KTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtc3RvcmFnZUNvbnRleHQudHJhbnNmb3JtLm9yaWdpblswXSwgLXN0b3JhZ2VDb250ZXh0LnRyYW5zZm9ybS5vcmlnaW5bMV0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzdG9yYWdlQ29udGV4dC5jbGlwKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnJlY3Qoc3RvcmFnZUNvbnRleHQuY2xpcC5sZWZ0LCBzdG9yYWdlQ29udGV4dC5jbGlwLnRvcCwgc3RvcmFnZUNvbnRleHQuY2xpcC53aWR0aCwgc3RvcmFnZUNvbnRleHQuY2xpcC5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBjdHguY2xpcCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzdG9yYWdlQ29udGV4dC5jdHguc3RvcmFnZSkge1xuICAgICAgICAgICAgICAgICAgICBzdG9yYWdlQ29udGV4dC5jdHguc3RvcmFnZS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJJdGVtKGN0eCwgaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgVXRpbC5sb2coJ2h0bWwyY2FudmFzOiBSZW5kZXJlcjogQ2FudmFzIHJlbmRlcmVyIGRvbmUgLSByZXR1cm5pbmcgY2FudmFzIG9iaicpO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5lbGVtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZWxlbWVudHNbMF0gPT09ICdvYmplY3QnICYmIG9wdGlvbnMuZWxlbWVudHNbMF0ubm9kZU5hbWUgIT09ICdCT0RZJykge1xuICAgICAgICAvLyBjcm9wIGltYWdlIHRvIHRoZSBib3VuZHMgb2Ygc2VsZWN0ZWQgKHNpbmdsZSkgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICBib3VuZHMgPSBfaHRtbDJjYW52YXMuVXRpbC5Cb3VuZHMob3B0aW9ucy5lbGVtZW50c1swXSk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgICAgICAgICBuZXdDYW52YXMud2lkdGggPSBNYXRoLmNlaWwoYm91bmRzLndpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q2FudmFzLmhlaWdodCA9IE1hdGguY2VpbChib3VuZHMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gbmV3Q2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShjYW52YXMsIGJvdW5kcy5sZWZ0LCBib3VuZHMudG9wLCBib3VuZHMud2lkdGgsIGJvdW5kcy5oZWlnaHQsIDAsIDAsIGJvdW5kcy53aWR0aCwgYm91bmRzLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdDYW52YXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY2FudmFzO1xuICAgICAgICB9O1xuICAgIH07XG59KSh3aW5kb3csIGRvY3VtZW50KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BsdWdpbnMvaHRtbDJjYW52YXMuanMiLCIvKmVzbGludC1kaXNhYmxlKi9cbi8vIHRvbyBtYW55IGVzbGludCB2aW9sYXRpb25zLCB0aGlzIGZpbGUgaGFzIGEgaGlnaCByaXNrIG9mIGJlaW5nIGRhbWFnZWQgXG4vLyBieSBlc2xpbnQgbW9kaWZpY2F0aW9uc1xuLyohIHRldGhlciAwLjYuNSAqL1xuXG4vLyBNb2RpZmllZCB0byByZW1vdmUgQU1EIHN1cHBvcnQsIGFuZCBhdHRhY2ggVGV0aGVyIHRvIHRoZSBwZW5kbyBvYmplY3RcbihmdW5jdGlvbiAoKSB7XG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIEV2ZW50ZWQsIGFkZENsYXNzLCBkZWZlciwgZGVmZXJyZWQsIGV4dGVuZCwgZmx1c2gsIGdldEJvdW5kcywgZ2V0Q2xhc3NOYW1lLCBnZXRPZmZzZXRQYXJlbnQsIGdldE9yaWdpbiwgZ2V0U2Nyb2xsQmFyU2l6ZSwgZ2V0U2Nyb2xsUGFyZW50LCBoYXNDbGFzcywgbm9kZSwgcmVtb3ZlQ2xhc3MsIHNldENsYXNzTmFtZSwgdW5pcXVlSWQsIHVwZGF0ZUNsYXNzZXMsIHplcm9Qb3NDYWNoZSxcbiAgICAgICAgICAgIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxuICAgICAgICAgICAgX19pbmRleE9mID0gW10uaW5kZXhPZiB8fCBmdW5jdGlvbiAoaXRlbSkgeyBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7IGlmIChpIGluIHRoaXMgJiYgdGhpc1tpXSA9PT0gaXRlbSkgcmV0dXJuIGk7IH0gcmV0dXJuIC0xOyB9LFxuICAgICAgICAgICAgX19zbGljZSA9IFtdLnNsaWNlO1xuXG4gICAgICAgIGlmICh0aGlzLlRldGhlciA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLlRldGhlciA9IHtcbiAgICAgICAgICAgICAgICBtb2R1bGVzOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBib2R5ID0gKHdpbmRvdy5wZW5kbyAmJiBwZW5kby5kZXNpZ25lcikgPyAocGVuZG8uZGVzaWduZXIuZG9tLmdldEJvZHkgPyBwZW5kby5kZXNpZ25lci5kb20uZ2V0Qm9keSgpIDogZG9jdW1lbnQuYm9keSkgOiBkb2N1bWVudC5ib2R5O1xuXG4gICAgICAgIGdldFNjcm9sbFBhcmVudCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIHBhcmVudCwgcG9zaXRpb24sIHNjcm9sbFBhcmVudCwgc3R5bGUsIF9yZWYsIGlzUmVsYXRpdmU7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGdldENvbXB1dGVkU3R5bGUoZWwpLnBvc2l0aW9uO1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2Nyb2xsUGFyZW50ID0gdm9pZCAwO1xuICAgICAgICAgICAgcGFyZW50ID0gZWw7XG4gICAgICAgICAgICBpc1JlbGF0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSAocGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUocGFyZW50KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlWydwb3NpdGlvbiddID09PSAncmVsYXRpdmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzUmVsYXRpdmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgvKGF1dG98c2Nyb2xsKS8udGVzdChzdHlsZVsnb3ZlcmZsb3cnXSArIHN0eWxlWydvdmVyZmxvd1knXSArIHN0eWxlWydvdmVyZmxvd1gnXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uICE9PSAnYWJzb2x1dGUnIHx8XG4gICAgICAgICAgICAocG9zaXRpb24gPT09ICdhYnNvbHV0ZScgJiYgaXNSZWxhdGl2ZSkgfHxcbiAgICAgICAgICAgICgoX3JlZiA9IHN0eWxlWydwb3NpdGlvbiddKSA9PT0gJ3JlbGF0aXZlJyB8fCBfcmVmID09PSAnYWJzb2x1dGUnIHx8IF9yZWYgPT09ICdmaXhlZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdW5pcXVlSWQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGlkO1xuICAgICAgICAgICAgaWQgPSAwO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWQrKztcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgemVyb1Bvc0NhY2hlID0ge307XG5cbiAgICAgICAgZ2V0T3JpZ2luID0gZnVuY3Rpb24gKGRvYykge1xuICAgICAgICAgICAgdmFyIGlkLCBrLCBub2RlLCB2LCBfcmVmO1xuICAgICAgICAgICAgbm9kZSA9IGRvYy5fdGV0aGVyWmVyb0VsZW1lbnQ7XG4gICAgICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnZGF0YS10ZXRoZXItaWQnLCB1bmlxdWVJZCgpKTtcbiAgICAgICAgICAgICAgICBleHRlbmQobm9kZS5zdHlsZSwge1xuICAgICAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZG9jLmJvZHkuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICAgICAgZG9jLl90ZXRoZXJaZXJvRWxlbWVudCA9IG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZCA9IG5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLXRldGhlci1pZCcpO1xuICAgICAgICAgICAgaWYgKHplcm9Qb3NDYWNoZVtpZF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHplcm9Qb3NDYWNoZVtpZF0gPSB7fTtcbiAgICAgICAgICAgICAgICBfcmVmID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGsgaW4gX3JlZikge1xuICAgICAgICAgICAgICAgICAgICB2ID0gX3JlZltrXTtcbiAgICAgICAgICAgICAgICAgICAgemVyb1Bvc0NhY2hlW2lkXVtrXSA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHplcm9Qb3NDYWNoZVtpZF0gPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gemVyb1Bvc0NhY2hlW2lkXTtcbiAgICAgICAgfTtcblxuICAgICAgICBub2RlID0gbnVsbDtcblxuICAgICAgICBnZXRCb3VuZHMgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHZhciBib3gsIGRvYywgZG9jRWwsIGssIG9yaWdpbiwgdiwgX3JlZjtcbiAgICAgICAgICAgIGlmIChlbCA9PT0gZG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICBkb2MgPSBkb2N1bWVudDtcbiAgICAgICAgICAgICAgICBlbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZG9jID0gZWwub3duZXJEb2N1bWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvY0VsID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICAgIGJveCA9IHt9O1xuICAgICAgICAgICAgX3JlZiA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgZm9yIChrIGluIF9yZWYpIHtcbiAgICAgICAgICAgICAgICB2ID0gX3JlZltrXTtcbiAgICAgICAgICAgICAgICBib3hba10gPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3JpZ2luID0gZ2V0T3JpZ2luKGRvYyk7XG4gICAgICAgICAgICBib3gudG9wIC09IG9yaWdpbi50b3A7XG4gICAgICAgICAgICBib3gubGVmdCAtPSBvcmlnaW4ubGVmdDtcbiAgICAgICAgICAgIGlmIChib3gud2lkdGggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGJveC53aWR0aCA9IGJvZHkuc2Nyb2xsV2lkdGggLSBib3gubGVmdCAtIGJveC5yaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChib3guaGVpZ2h0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBib3guaGVpZ2h0ID0gYm9keS5zY3JvbGxIZWlnaHQgLSBib3gudG9wIC0gYm94LmJvdHRvbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJveC50b3AgPSBib3gudG9wIC0gZG9jRWwuY2xpZW50VG9wO1xuICAgICAgICAgICAgYm94LmxlZnQgPSBib3gubGVmdCAtIGRvY0VsLmNsaWVudExlZnQ7XG4gICAgICAgICAgICBib3gucmlnaHQgPSBkb2MuYm9keS5jbGllbnRXaWR0aCAtIGJveC53aWR0aCAtIGJveC5sZWZ0O1xuICAgICAgICAgICAgYm94LmJvdHRvbSA9IGRvYy5ib2R5LmNsaWVudEhlaWdodCAtIGJveC5oZWlnaHQgLSBib3gudG9wO1xuICAgICAgICAgICAgcmV0dXJuIGJveDtcbiAgICAgICAgfTtcblxuICAgICAgICBnZXRPZmZzZXRQYXJlbnQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBlbC5vZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICB9O1xuXG4gICAgICAgIGdldFNjcm9sbEJhclNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaW5uZXIsIG91dGVyLCB3aWR0aCwgd2lkdGhDb250YWluZWQsIHdpZHRoU2Nyb2xsO1xuICAgICAgICAgICAgaW5uZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGlubmVyLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICAgICAgaW5uZXIuc3R5bGUuaGVpZ2h0ID0gJzIwMHB4JztcbiAgICAgICAgICAgIG91dGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBleHRlbmQob3V0ZXIuc3R5bGUsIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogJ2hpZGRlbicsXG4gICAgICAgICAgICAgICAgd2lkdGg6ICcyMDBweCcsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAnMTUwcHgnLFxuICAgICAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvdXRlci5hcHBlbmRDaGlsZChpbm5lcik7XG4gICAgICAgICAgICBib2R5LmFwcGVuZENoaWxkKG91dGVyKTtcbiAgICAgICAgICAgIHdpZHRoQ29udGFpbmVkID0gaW5uZXIub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICBvdXRlci5zdHlsZS5vdmVyZmxvdyA9ICdzY3JvbGwnO1xuICAgICAgICAgICAgd2lkdGhTY3JvbGwgPSBpbm5lci5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIGlmICh3aWR0aENvbnRhaW5lZCA9PT0gd2lkdGhTY3JvbGwpIHtcbiAgICAgICAgICAgICAgICB3aWR0aFNjcm9sbCA9IG91dGVyLmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYm9keS5yZW1vdmVDaGlsZChvdXRlcik7XG4gICAgICAgICAgICB3aWR0aCA9IHdpZHRoQ29udGFpbmVkIC0gd2lkdGhTY3JvbGw7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHdpZHRoXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIGV4dGVuZCA9IGZ1bmN0aW9uIChvdXQpIHtcbiAgICAgICAgICAgIHZhciBhcmdzLCBrZXksIG9iaiwgdmFsLCBfaSwgX2xlbiwgX3JlZjtcbiAgICAgICAgICAgIGlmIChvdXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG91dCA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJncyA9IFtdO1xuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIF9yZWYgPSBhcmdzLnNsaWNlKDEpO1xuICAgICAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgb2JqID0gX3JlZltfaV07XG4gICAgICAgICAgICAgICAgaWYgKG9iaikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX19oYXNQcm9wLmNhbGwob2JqLCBrZXkpKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IG9ialtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0W2tleV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlbW92ZUNsYXNzID0gZnVuY3Rpb24gKGVsLCBuYW1lKSB7XG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lLCBjbHMsIF9pLCBfbGVuLCBfcmVmLCBfcmVzdWx0cztcbiAgICAgICAgICAgIGlmIChlbC5jbGFzc0xpc3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF9yZWYgPSBuYW1lLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY2xzID0gX3JlZltfaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbHMudHJpbSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVzdWx0cy5wdXNoKGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzc05hbWUoZWwpLnJlcGxhY2UobmV3IFJlZ0V4cCgnKF58ICknICsgKG5hbWUuc3BsaXQoJyAnKS5qb2luKCd8JykpICsgJyggfCQpJywgJ2dpJyksICcgJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldENsYXNzTmFtZShlbCwgY2xhc3NOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBhZGRDbGFzcyA9IGZ1bmN0aW9uIChlbCwgbmFtZSkge1xuICAgICAgICAgICAgdmFyIGNscywgX2ksIF9sZW4sIF9yZWYsIF9yZXN1bHRzO1xuICAgICAgICAgICAgaWYgKGVsLmNsYXNzTGlzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3JlZiA9IG5hbWUuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICBjbHMgPSBfcmVmW19pXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNscy50cmltKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZXN1bHRzLnB1c2goZWwuY2xhc3NMaXN0LmFkZChjbHMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKGVsLCBuYW1lKTtcbiAgICAgICAgICAgICAgICBjbHMgPSBnZXRDbGFzc05hbWUoZWwpICsgKCcgJyArIG5hbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXRDbGFzc05hbWUoZWwsIGNscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaGFzQ2xhc3MgPSBmdW5jdGlvbiAoZWwsIG5hbWUpIHtcbiAgICAgICAgICAgIGlmIChlbC5jbGFzc0xpc3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbC5jbGFzc0xpc3QuY29udGFpbnMobmFtZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKCcoXnwgKScgKyBuYW1lICsgJyggfCQpJywgJ2dpJykudGVzdChnZXRDbGFzc05hbWUoZWwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBnZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGlmIChlbC5jbGFzc05hbWUgaW5zdGFuY2VvZiBTVkdBbmltYXRlZFN0cmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbC5jbGFzc05hbWUuYmFzZVZhbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsLmNsYXNzTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBzZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoZWwsIGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbGFzc05hbWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHVwZGF0ZUNsYXNzZXMgPSBmdW5jdGlvbiAoZWwsIGFkZCwgYWxsKSB7XG4gICAgICAgICAgICB2YXIgY2xzLCBfaSwgX2osIF9sZW4sIF9sZW4xLCBfcmVzdWx0cztcbiAgICAgICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gYWxsLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgY2xzID0gYWxsW19pXTtcbiAgICAgICAgICAgICAgICBpZiAoX19pbmRleE9mLmNhbGwoYWRkLCBjbHMpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzQ2xhc3MoZWwsIGNscykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKGVsLCBjbHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoX2ogPSAwLCBfbGVuMSA9IGFkZC5sZW5ndGg7IF9qIDwgX2xlbjE7IF9qKyspIHtcbiAgICAgICAgICAgICAgICBjbHMgPSBhZGRbX2pdO1xuICAgICAgICAgICAgICAgIGlmICghaGFzQ2xhc3MoZWwsIGNscykpIHtcbiAgICAgICAgICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChhZGRDbGFzcyhlbCwgY2xzKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3Jlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgICAgfTtcblxuICAgICAgICBkZWZlcnJlZCA9IFtdO1xuXG4gICAgICAgIGRlZmVyID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHVzaChmbik7XG4gICAgICAgIH07XG5cbiAgICAgICAgZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZm4sIF9yZXN1bHRzO1xuICAgICAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIHdoaWxlIChmbiA9IGRlZmVycmVkLnBvcCgpKSB7XG4gICAgICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChmbigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgICAgfTtcblxuICAgICAgICBFdmVudGVkID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIEV2ZW50ZWQgKCkge31cblxuICAgICAgICAgICAgRXZlbnRlZC5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnQsIGhhbmRsZXIsIGN0eCwgb25jZSkge1xuICAgICAgICAgICAgICAgIHZhciBfYmFzZTtcbiAgICAgICAgICAgICAgICBpZiAob25jZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYmluZGluZ3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJpbmRpbmdzID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoX2Jhc2UgPSB0aGlzLmJpbmRpbmdzKVtldmVudF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBfYmFzZVtldmVudF0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmluZGluZ3NbZXZlbnRdLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICBjdHg6IGN0eCxcbiAgICAgICAgICAgICAgICAgICAgb25jZTogb25jZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgRXZlbnRlZC5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIChldmVudCwgaGFuZGxlciwgY3R4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub24oZXZlbnQsIGhhbmRsZXIsIGN0eCwgdHJ1ZSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBFdmVudGVkLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSwgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICAgICAgICAgICAgaWYgKCgoX3JlZiA9IHRoaXMuYmluZGluZ3MpICE9IG51bGwgPyBfcmVmW2V2ZW50XSA6IHZvaWQgMCkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZSB0aGlzLmJpbmRpbmdzW2V2ZW50XTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGkgPCB0aGlzLmJpbmRpbmdzW2V2ZW50XS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmJpbmRpbmdzW2V2ZW50XVtpXS5oYW5kbGVyID09PSBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3Jlc3VsdHMucHVzaCh0aGlzLmJpbmRpbmdzW2V2ZW50XS5zcGxpY2UoaSwgMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVzdWx0cy5wdXNoKGkrKyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIEV2ZW50ZWQucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MsIGN0eCwgZXZlbnQsIGhhbmRsZXIsIGksIG9uY2UsIF9yZWYsIF9yZWYxLCBfcmVzdWx0cztcbiAgICAgICAgICAgICAgICBldmVudCA9IGFyZ3VtZW50c1swXSwgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPj0gMiA/IF9fc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpIDogW107XG4gICAgICAgICAgICAgICAgaWYgKChfcmVmID0gdGhpcy5iaW5kaW5ncykgIT0gbnVsbCA/IF9yZWZbZXZlbnRdIDogdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaSA8IHRoaXMuYmluZGluZ3NbZXZlbnRdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjEgPSB0aGlzLmJpbmRpbmdzW2V2ZW50XVtpXSwgaGFuZGxlciA9IF9yZWYxLmhhbmRsZXIsIGN0eCA9IF9yZWYxLmN0eCwgb25jZSA9IF9yZWYxLm9uY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLmFwcGx5KGN0eCAhPSBudWxsID8gY3R4IDogdGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob25jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZXN1bHRzLnB1c2godGhpcy5iaW5kaW5nc1tldmVudF0uc3BsaWNlKGksIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChpKyspO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gRXZlbnRlZDtcbiAgICAgICAgfSkoKTtcblxuICAgICAgICB0aGlzLlRldGhlci5VdGlscyA9IHtcbiAgICAgICAgICAgIGdldFNjcm9sbFBhcmVudDogZ2V0U2Nyb2xsUGFyZW50LFxuICAgICAgICAgICAgZ2V0Qm91bmRzOiBnZXRCb3VuZHMsXG4gICAgICAgICAgICBnZXRPZmZzZXRQYXJlbnQ6IGdldE9mZnNldFBhcmVudCxcbiAgICAgICAgICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgICAgICAgICAgYWRkQ2xhc3M6IGFkZENsYXNzLFxuICAgICAgICAgICAgcmVtb3ZlQ2xhc3M6IHJlbW92ZUNsYXNzLFxuICAgICAgICAgICAgaGFzQ2xhc3M6IGhhc0NsYXNzLFxuICAgICAgICAgICAgdXBkYXRlQ2xhc3NlczogdXBkYXRlQ2xhc3NlcyxcbiAgICAgICAgICAgIGRlZmVyOiBkZWZlcixcbiAgICAgICAgICAgIGZsdXNoOiBmbHVzaCxcbiAgICAgICAgICAgIHVuaXF1ZUlkOiB1bmlxdWVJZCxcbiAgICAgICAgICAgIEV2ZW50ZWQ6IEV2ZW50ZWQsXG4gICAgICAgICAgICBnZXRTY3JvbGxCYXJTaXplOiBnZXRTY3JvbGxCYXJTaXplXG4gICAgICAgIH07XG4gICAgfSkuY2FsbCh0aGlzKTtcblxuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBNSVJST1JfTFIsIE1JUlJPUl9UQiwgT0ZGU0VUX01BUCwgVGV0aGVyLCBhZGRDbGFzcywgYWRkT2Zmc2V0LCBhdHRhY2htZW50VG9PZmZzZXQsIGF1dG9Ub0ZpeGVkQXR0YWNobWVudCwgZGVmZXIsIGV4dGVuZCwgZmx1c2gsIGdldEJvdW5kcywgZ2V0T2Zmc2V0UGFyZW50LCBnZXRPdXRlclNpemUsIGdldFNjcm9sbEJhclNpemUsIGdldFNjcm9sbFBhcmVudCwgZ2V0U2l6ZSwgbm93LCBvZmZzZXRUb1B4LCBwYXJzZUF0dGFjaG1lbnQsIHBhcnNlT2Zmc2V0LCBwb3NpdGlvbiwgcmVtb3ZlQ2xhc3MsIHRldGhlcnMsIHRyYW5zZm9ybUtleSwgdXBkYXRlQ2xhc3Nlcywgd2l0aGluLCBfVGV0aGVyLCBfcmVmLFxuICAgICAgICAgICAgX19zbGljZSA9IFtdLnNsaWNlLFxuICAgICAgICAgICAgX19iaW5kID0gZnVuY3Rpb24gKGZuLCBtZSkgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7IH07IH07XG5cbiAgICAgICAgaWYgKHRoaXMuVGV0aGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgaW5jbHVkZSB0aGUgdXRpbHMuanMgZmlsZSBiZWZvcmUgdGV0aGVyLmpzJyk7XG4gICAgICAgIH1cblxuICAgICAgICBUZXRoZXIgPSB0aGlzLlRldGhlcjtcblxuICAgICAgICBfcmVmID0gVGV0aGVyLlV0aWxzLCBnZXRTY3JvbGxQYXJlbnQgPSBfcmVmLmdldFNjcm9sbFBhcmVudCwgZ2V0U2l6ZSA9IF9yZWYuZ2V0U2l6ZSwgZ2V0T3V0ZXJTaXplID0gX3JlZi5nZXRPdXRlclNpemUsIGdldEJvdW5kcyA9IF9yZWYuZ2V0Qm91bmRzLCBnZXRPZmZzZXRQYXJlbnQgPSBfcmVmLmdldE9mZnNldFBhcmVudCwgZXh0ZW5kID0gX3JlZi5leHRlbmQsIGFkZENsYXNzID0gX3JlZi5hZGRDbGFzcywgcmVtb3ZlQ2xhc3MgPSBfcmVmLnJlbW92ZUNsYXNzLCB1cGRhdGVDbGFzc2VzID0gX3JlZi51cGRhdGVDbGFzc2VzLCBkZWZlciA9IF9yZWYuZGVmZXIsIGZsdXNoID0gX3JlZi5mbHVzaCwgZ2V0U2Nyb2xsQmFyU2l6ZSA9IF9yZWYuZ2V0U2Nyb2xsQmFyU2l6ZTtcblxuICAgICAgICB3aXRoaW4gPSBmdW5jdGlvbiAoYSwgYiwgZGlmZikge1xuICAgICAgICAgICAgaWYgKGRpZmYgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRpZmYgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChhICsgZGlmZiA+PSBiICYmIGIgPj0gYSAtIGRpZmYpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRyYW5zZm9ybUtleSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZWwsIGtleSwgX2ksIF9sZW4sIF9yZWYxO1xuICAgICAgICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIF9yZWYxID0gWyd0cmFuc2Zvcm0nLCAnd2Via2l0VHJhbnNmb3JtJywgJ09UcmFuc2Zvcm0nLCAnTW96VHJhbnNmb3JtJywgJ21zVHJhbnNmb3JtJ107XG4gICAgICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gX3JlZjFbX2ldO1xuICAgICAgICAgICAgICAgIGlmIChlbC5zdHlsZVtrZXldICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgdGV0aGVycyA9IFtdO1xuXG4gICAgICAgIHBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRldGhlciwgX2ksIF9sZW47XG4gICAgICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IHRldGhlcnMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICAgICAgICB0ZXRoZXIgPSB0ZXRoZXJzW19pXTtcbiAgICAgICAgICAgICAgICB0ZXRoZXIucG9zaXRpb24oZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZsdXNoKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgbm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9yZWYxO1xuICAgICAgICAgICAgcmV0dXJuIChfcmVmMSA9IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCcgJiYgcGVyZm9ybWFuY2UgIT09IG51bGwgPyB0eXBlb2YgcGVyZm9ybWFuY2Uubm93ID09PSAnZnVuY3Rpb24nID8gcGVyZm9ybWFuY2Uubm93KCkgOiB2b2lkIDAgOiB2b2lkIDApICE9IG51bGwgPyBfcmVmMSA6ICsobmV3IERhdGUoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBldmVudCwgbGFzdENhbGwsIGxhc3REdXJhdGlvbiwgcGVuZGluZ1RpbWVvdXQsIHRpY2ssIF9pLCBfbGVuLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgICAgICAgICBsYXN0Q2FsbCA9IG51bGw7XG4gICAgICAgICAgICBsYXN0RHVyYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgcGVuZGluZ1RpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgdGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoKGxhc3REdXJhdGlvbiAhPSBudWxsKSAmJiBsYXN0RHVyYXRpb24gPiAxNikge1xuICAgICAgICAgICAgICAgICAgICBsYXN0RHVyYXRpb24gPSBNYXRoLm1pbihsYXN0RHVyYXRpb24gLSAxNiwgMjUwKTtcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KHRpY2ssIDI1MCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChsYXN0Q2FsbCAhPSBudWxsKSAmJiAobm93KCkgLSBsYXN0Q2FsbCkgPCAxMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nVGltZW91dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChwZW5kaW5nVGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFzdENhbGwgPSBub3coKTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBsYXN0RHVyYXRpb24gPSBub3coKSAtIGxhc3RDYWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9yZWYxID0gWydyZXNpemUnLCAnc2Nyb2xsJywgJ3RvdWNobW92ZSddO1xuICAgICAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICAgICAgICBldmVudCA9IF9yZWYxW19pXTtcbiAgICAgICAgICAgICAgICBfcmVzdWx0cy5wdXNoKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCB0aWNrKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgTUlSUk9SX0xSID0ge1xuICAgICAgICAgICAgY2VudGVyOiAnY2VudGVyJyxcbiAgICAgICAgICAgIGxlZnQ6ICdyaWdodCcsXG4gICAgICAgICAgICByaWdodDogJ2xlZnQnXG4gICAgICAgIH07XG5cbiAgICAgICAgTUlSUk9SX1RCID0ge1xuICAgICAgICAgICAgbWlkZGxlOiAnbWlkZGxlJyxcbiAgICAgICAgICAgIHRvcDogJ2JvdHRvbScsXG4gICAgICAgICAgICBib3R0b206ICd0b3AnXG4gICAgICAgIH07XG5cbiAgICAgICAgT0ZGU0VUX01BUCA9IHtcbiAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICBtaWRkbGU6ICc1MCUnLFxuICAgICAgICAgICAgY2VudGVyOiAnNTAlJyxcbiAgICAgICAgICAgIGJvdHRvbTogJzEwMCUnLFxuICAgICAgICAgICAgcmlnaHQ6ICcxMDAlJ1xuICAgICAgICB9O1xuXG4gICAgICAgIGF1dG9Ub0ZpeGVkQXR0YWNobWVudCA9IGZ1bmN0aW9uIChhdHRhY2htZW50LCByZWxhdGl2ZVRvQXR0YWNobWVudCkge1xuICAgICAgICAgICAgdmFyIGxlZnQsIHRvcDtcbiAgICAgICAgICAgIGxlZnQgPSBhdHRhY2htZW50LmxlZnQsIHRvcCA9IGF0dGFjaG1lbnQudG9wO1xuICAgICAgICAgICAgaWYgKGxlZnQgPT09ICdhdXRvJykge1xuICAgICAgICAgICAgICAgIGxlZnQgPSBNSVJST1JfTFJbcmVsYXRpdmVUb0F0dGFjaG1lbnQubGVmdF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9wID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgICAgICB0b3AgPSBNSVJST1JfVEJbcmVsYXRpdmVUb0F0dGFjaG1lbnQudG9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgICAgICB0b3A6IHRvcFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICBhdHRhY2htZW50VG9PZmZzZXQgPSBmdW5jdGlvbiAoYXR0YWNobWVudCkge1xuICAgICAgICAgICAgdmFyIF9yZWYxLCBfcmVmMjtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbGVmdDogKF9yZWYxID0gT0ZGU0VUX01BUFthdHRhY2htZW50LmxlZnRdKSAhPSBudWxsID8gX3JlZjEgOiBhdHRhY2htZW50LmxlZnQsXG4gICAgICAgICAgICAgICAgdG9wOiAoX3JlZjIgPSBPRkZTRVRfTUFQW2F0dGFjaG1lbnQudG9wXSkgIT0gbnVsbCA/IF9yZWYyIDogYXR0YWNobWVudC50b3BcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgYWRkT2Zmc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxlZnQsIG9mZnNldHMsIG91dCwgdG9wLCBfaSwgX2xlbiwgX3JlZjE7XG4gICAgICAgICAgICBvZmZzZXRzID0gYXJndW1lbnRzLmxlbmd0aCA+PSAxID8gX19zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkgOiBbXTtcbiAgICAgICAgICAgIG91dCA9IHtcbiAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgbGVmdDogMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gb2Zmc2V0cy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgICAgICAgIF9yZWYxID0gb2Zmc2V0c1tfaV0sIHRvcCA9IF9yZWYxLnRvcCwgbGVmdCA9IF9yZWYxLmxlZnQ7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcCA9IHBhcnNlRmxvYXQodG9wLCAxMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbGVmdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHBhcnNlRmxvYXQobGVmdCwgMTApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXQudG9wICs9IHRvcDtcbiAgICAgICAgICAgICAgICBvdXQubGVmdCArPSBsZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfTtcblxuICAgICAgICBvZmZzZXRUb1B4ID0gZnVuY3Rpb24gKG9mZnNldCwgc2l6ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQubGVmdCA9PT0gJ3N0cmluZycgJiYgb2Zmc2V0LmxlZnQuaW5kZXhPZignJScpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIG9mZnNldC5sZWZ0ID0gcGFyc2VGbG9hdChvZmZzZXQubGVmdCwgMTApIC8gMTAwICogc2l6ZS53aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0LnRvcCA9PT0gJ3N0cmluZycgJiYgb2Zmc2V0LnRvcC5pbmRleE9mKCclJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0LnRvcCA9IHBhcnNlRmxvYXQob2Zmc2V0LnRvcCwgMTApIC8gMTAwICogc2l6ZS5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHBhcnNlQXR0YWNobWVudCA9IHBhcnNlT2Zmc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgbGVmdCwgdG9wLCBfcmVmMTtcbiAgICAgICAgICAgIF9yZWYxID0gdmFsdWUuc3BsaXQoJyAnKSwgdG9wID0gX3JlZjFbMF0sIGxlZnQgPSBfcmVmMVsxXTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgICAgICAgICAgbGVmdDogbGVmdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICBfVGV0aGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF9UZXRoZXIubW9kdWxlcyA9IFtdO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBfVGV0aGVyIChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IF9fYmluZCh0aGlzLnBvc2l0aW9uLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB2YXIgbW9kdWxlLCBfaSwgX2xlbiwgX3JlZjEsIF9yZWYyO1xuICAgICAgICAgICAgICAgIHRldGhlcnMucHVzaCh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhpc3RvcnkgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIF9yZWYxID0gVGV0aGVyLm1vZHVsZXM7XG4gICAgICAgICAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGUgPSBfcmVmMVtfaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICgoX3JlZjIgPSBtb2R1bGUuaW5pdGlhbGl6ZSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9UZXRoZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciBfcmVmMSwgX3JlZjI7XG4gICAgICAgICAgICAgICAgaWYgKChfcmVmMSA9IHRoaXMub3B0aW9ucy5jbGFzc2VzKSAhPSBudWxsID8gX3JlZjFba2V5XSA6IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmNsYXNzZXNba2V5XTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCgoX3JlZjIgPSB0aGlzLm9wdGlvbnMuY2xhc3NlcykgIT0gbnVsbCA/IF9yZWYyW2tleV0gOiB2b2lkIDApICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNsYXNzUHJlZml4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJycgKyB0aGlzLm9wdGlvbnMuY2xhc3NQcmVmaXggKyAnLScgKyBrZXk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIF9UZXRoZXIucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucywgcG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdHMsIGtleSwgX2ksIF9sZW4sIF9yZWYxLCBfcmVmMjtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogJzAgMCcsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldE9mZnNldDogJzAgMCcsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldEF0dGFjaG1lbnQ6ICdhdXRvIGF1dG8nLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc1ByZWZpeDogJ3RldGhlcidcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IGV4dGVuZChkZWZhdWx0cywgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICBfcmVmMSA9IHRoaXMub3B0aW9ucywgdGhpcy5lbGVtZW50ID0gX3JlZjEuZWxlbWVudCwgdGhpcy50YXJnZXQgPSBfcmVmMS50YXJnZXQsIHRoaXMudGFyZ2V0TW9kaWZpZXIgPSBfcmVmMS50YXJnZXRNb2RpZmllcjtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50YXJnZXQgPT09ICd2aWV3cG9ydCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YXJnZXQgPSBib2R5O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldE1vZGlmaWVyID0gJ3Zpc2libGUnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy50YXJnZXQgPT09ICdzY3JvbGwtaGFuZGxlJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldCA9IGJvZHk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0TW9kaWZpZXIgPSAnc2Nyb2xsLWhhbmRsZSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9yZWYyID0gWydlbGVtZW50JywgJ3RhcmdldCddO1xuICAgICAgICAgICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjIubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gX3JlZjJbX2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpc1trZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGV0aGVyIEVycm9yOiBCb3RoIGVsZW1lbnQgYW5kIHRhcmdldCBtdXN0IGJlIGRlZmluZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpc1trZXldLmpxdWVyeSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSB0aGlzW2tleV1bMF07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXNba2V5XSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5XSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpc1trZXldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRDbGFzcyh0aGlzLmVsZW1lbnQsIHRoaXMuZ2V0Q2xhc3MoJ2VsZW1lbnQnKSk7XG4gICAgICAgICAgICAgICAgYWRkQ2xhc3ModGhpcy50YXJnZXQsIHRoaXMuZ2V0Q2xhc3MoJ3RhcmdldCcpKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5hdHRhY2htZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGV0aGVyIEVycm9yOiBZb3UgbXVzdCBwcm92aWRlIGFuIGF0dGFjaG1lbnQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXRBdHRhY2htZW50ID0gcGFyc2VBdHRhY2htZW50KHRoaXMub3B0aW9ucy50YXJnZXRBdHRhY2htZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaG1lbnQgPSBwYXJzZUF0dGFjaG1lbnQodGhpcy5vcHRpb25zLmF0dGFjaG1lbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gcGFyc2VPZmZzZXQodGhpcy5vcHRpb25zLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXRPZmZzZXQgPSBwYXJzZU9mZnNldCh0aGlzLm9wdGlvbnMudGFyZ2V0T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zY3JvbGxQYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2FibGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudGFyZ2V0TW9kaWZpZXIgPT09ICdzY3JvbGwtaGFuZGxlJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbFBhcmVudCA9IHRoaXMudGFyZ2V0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsUGFyZW50ID0gZ2V0U2Nyb2xsUGFyZW50KHRoaXMudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lbmFibGVkICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmFibGUocG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIF9UZXRoZXIucHJvdG90eXBlLmdldFRhcmdldEJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYm91bmRzLCBmaXRBZGosIGhhc0JvdHRvbVNjcm9sbCwgaGVpZ2h0LCBvdXQsIHNjcm9sbEJvdHRvbSwgc2Nyb2xsUGVyY2VudGFnZSwgc3R5bGUsIHRhcmdldDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50YXJnZXRNb2RpZmllciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy50YXJnZXRNb2RpZmllcikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd2aXNpYmxlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRhcmdldCA9PT0gYm9keSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogcGFnZVlPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHBhZ2VYT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGlubmVySGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogaW5uZXJXaWR0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kcyA9IGdldEJvdW5kcyh0aGlzLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGJvdW5kcy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBib3VuZHMud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogYm91bmRzLnRvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogYm91bmRzLmxlZnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dC5oZWlnaHQgPSBNYXRoLm1pbihvdXQuaGVpZ2h0LCBib3VuZHMuaGVpZ2h0IC0gKHBhZ2VZT2Zmc2V0IC0gYm91bmRzLnRvcCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dC5oZWlnaHQgPSBNYXRoLm1pbihvdXQuaGVpZ2h0LCBib3VuZHMuaGVpZ2h0IC0gKChib3VuZHMudG9wICsgYm91bmRzLmhlaWdodCkgLSAocGFnZVlPZmZzZXQgKyBpbm5lckhlaWdodCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQuaGVpZ2h0ID0gTWF0aC5taW4oaW5uZXJIZWlnaHQsIG91dC5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dC5oZWlnaHQgLT0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQud2lkdGggPSBNYXRoLm1pbihvdXQud2lkdGgsIGJvdW5kcy53aWR0aCAtIChwYWdlWE9mZnNldCAtIGJvdW5kcy5sZWZ0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0LndpZHRoID0gTWF0aC5taW4ob3V0LndpZHRoLCBib3VuZHMud2lkdGggLSAoKGJvdW5kcy5sZWZ0ICsgYm91bmRzLndpZHRoKSAtIChwYWdlWE9mZnNldCArIGlubmVyV2lkdGgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0LndpZHRoID0gTWF0aC5taW4oaW5uZXJXaWR0aCwgb3V0LndpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQud2lkdGggLT0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0LnRvcCA8IHBhZ2VZT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dC50b3AgPSBwYWdlWU9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5sZWZ0IDwgcGFnZVhPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0LmxlZnQgPSBwYWdlWE9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzY3JvbGwtaGFuZGxlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHRoaXMudGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gYm9keSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZHMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHBhZ2VYT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IHBhZ2VZT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGlubmVySGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogaW5uZXJXaWR0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kcyA9IGdldEJvdW5kcyh0YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNCb3R0b21TY3JvbGwgPSB0YXJnZXQuc2Nyb2xsV2lkdGggPiB0YXJnZXQuY2xpZW50V2lkdGggfHwgW3N0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1hdID09PSAnc2Nyb2xsJyB8fCB0aGlzLnRhcmdldCAhPT0gZG9jdW1lbnQuYm9keTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbEJvdHRvbSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzQm90dG9tU2Nyb2xsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsQm90dG9tID0gMTU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBib3VuZHMuaGVpZ2h0IC0gcGFyc2VGbG9hdChzdHlsZS5ib3JkZXJUb3BXaWR0aCkgLSBwYXJzZUZsb2F0KHN0eWxlLmJvcmRlckJvdHRvbVdpZHRoKSAtIHNjcm9sbEJvdHRvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgKiAwLjk3NSAqIChoZWlnaHQgLyB0YXJnZXQuc2Nyb2xsSGVpZ2h0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBib3VuZHMubGVmdCArIGJvdW5kcy53aWR0aCAtIHBhcnNlRmxvYXQoc3R5bGUuYm9yZGVyTGVmdFdpZHRoKSAtIDE1XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgZml0QWRqID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoZWlnaHQgPCA0MDggJiYgdGhpcy50YXJnZXQgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXRBZGogPSAtMC4wMDAxMSAqIE1hdGgucG93KGhlaWdodCwgMikgLSAwLjAwNzI3ICogaGVpZ2h0ICsgMjIuNTg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50YXJnZXQgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQuaGVpZ2h0ID0gTWF0aC5tYXgob3V0LmhlaWdodCwgMjQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsUGVyY2VudGFnZSA9IHRoaXMudGFyZ2V0LnNjcm9sbFRvcCAvICh0YXJnZXQuc2Nyb2xsSGVpZ2h0IC0gaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dC50b3AgPSBzY3JvbGxQZXJjZW50YWdlICogKGhlaWdodCAtIG91dC5oZWlnaHQgLSBmaXRBZGopICsgYm91bmRzLnRvcCArIHBhcnNlRmxvYXQoc3R5bGUuYm9yZGVyVG9wV2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudGFyZ2V0ID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0LmhlaWdodCA9IE1hdGgubWF4KG91dC5oZWlnaHQsIDI0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Qm91bmRzKHRoaXMudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBfVGV0aGVyLnByb3RvdHlwZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZSA9IHt9O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgX1RldGhlci5wcm90b3R5cGUuY2FjaGUgPSBmdW5jdGlvbiAoaywgZ2V0dGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NhY2hlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGUgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NhY2hlW2tdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVba10gPSBnZXR0ZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlW2tdO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgX1RldGhlci5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRDbGFzcyh0aGlzLnRhcmdldCwgdGhpcy5nZXRDbGFzcygnZW5hYmxlZCcpKTtcbiAgICAgICAgICAgICAgICBhZGRDbGFzcyh0aGlzLmVsZW1lbnQsIHRoaXMuZ2V0Q2xhc3MoJ2VuYWJsZWQnKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zY3JvbGxQYXJlbnQgIT09IGRvY3VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsUGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMucG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBfVGV0aGVyLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKHRoaXMudGFyZ2V0LCB0aGlzLmdldENsYXNzKCdlbmFibGVkJykpO1xuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKHRoaXMuZWxlbWVudCwgdGhpcy5nZXRDbGFzcygnZW5hYmxlZCcpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zY3JvbGxQYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5wb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgX1RldGhlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSwgdGV0aGVyLCBfaSwgX2xlbiwgX3Jlc3VsdHM7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgICAgICAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBfaSA9IDAsIF9sZW4gPSB0ZXRoZXJzLmxlbmd0aDsgX2kgPCBfbGVuOyBpID0gKytfaSkge1xuICAgICAgICAgICAgICAgICAgICB0ZXRoZXIgPSB0ZXRoZXJzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGV0aGVyID09PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXRoZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3Jlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIF9UZXRoZXIucHJvdG90eXBlLnVwZGF0ZUF0dGFjaENsYXNzZXMgPSBmdW5jdGlvbiAoZWxlbWVudEF0dGFjaCwgdGFyZ2V0QXR0YWNoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFkZCwgYWxsLCBzaWRlLCBzaWRlcywgX2ksIF9qLCBfbGVuLCBfbGVuMSwgX3JlZjEsXG4gICAgICAgICAgICAgICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudEF0dGFjaCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRBdHRhY2ggPSB0aGlzLmF0dGFjaG1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRBdHRhY2ggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRBdHRhY2ggPSB0aGlzLnRhcmdldEF0dGFjaG1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNpZGVzID0gWydsZWZ0JywgJ3RvcCcsICdib3R0b20nLCAncmlnaHQnLCAnbWlkZGxlJywgJ2NlbnRlciddO1xuICAgICAgICAgICAgICAgIGlmICgoX3JlZjEgPSB0aGlzLl9hZGRBdHRhY2hDbGFzc2VzKSAhPSBudWxsID8gX3JlZjEubGVuZ3RoIDogdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEF0dGFjaENsYXNzZXMuc3BsaWNlKDAsIHRoaXMuX2FkZEF0dGFjaENsYXNzZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkID0gdGhpcy5fYWRkQXR0YWNoQ2xhc3NlcyAhPSBudWxsID8gdGhpcy5fYWRkQXR0YWNoQ2xhc3NlcyA6IHRoaXMuX2FkZEF0dGFjaENsYXNzZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudEF0dGFjaC50b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkLnB1c2goJycgKyAodGhpcy5nZXRDbGFzcygnZWxlbWVudC1hdHRhY2hlZCcpKSArICctJyArIGVsZW1lbnRBdHRhY2gudG9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRBdHRhY2gubGVmdCkge1xuICAgICAgICAgICAgICAgICAgICBhZGQucHVzaCgnJyArICh0aGlzLmdldENsYXNzKCdlbGVtZW50LWF0dGFjaGVkJykpICsgJy0nICsgZWxlbWVudEF0dGFjaC5sZWZ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldEF0dGFjaC50b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkLnB1c2goJycgKyAodGhpcy5nZXRDbGFzcygndGFyZ2V0LWF0dGFjaGVkJykpICsgJy0nICsgdGFyZ2V0QXR0YWNoLnRvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRBdHRhY2gubGVmdCkge1xuICAgICAgICAgICAgICAgICAgICBhZGQucHVzaCgnJyArICh0aGlzLmdldENsYXNzKCd0YXJnZXQtYXR0YWNoZWQnKSkgKyAnLScgKyB0YXJnZXRBdHRhY2gubGVmdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFsbCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gc2lkZXMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc2lkZSA9IHNpZGVzW19pXTtcbiAgICAgICAgICAgICAgICAgICAgYWxsLnB1c2goJycgKyAodGhpcy5nZXRDbGFzcygnZWxlbWVudC1hdHRhY2hlZCcpKSArICctJyArIHNpZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKF9qID0gMCwgX2xlbjEgPSBzaWRlcy5sZW5ndGg7IF9qIDwgX2xlbjE7IF9qKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc2lkZSA9IHNpZGVzW19qXTtcbiAgICAgICAgICAgICAgICAgICAgYWxsLnB1c2goJycgKyAodGhpcy5nZXRDbGFzcygndGFyZ2V0LWF0dGFjaGVkJykpICsgJy0nICsgc2lkZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fYWRkQXR0YWNoQ2xhc3NlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ2xhc3NlcyhfdGhpcy5lbGVtZW50LCBfdGhpcy5fYWRkQXR0YWNoQ2xhc3NlcywgYWxsKTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ2xhc3NlcyhfdGhpcy50YXJnZXQsIF90aGlzLl9hZGRBdHRhY2hDbGFzc2VzLCBhbGwpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2FkZEF0dGFjaENsYXNzZXMgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBfVGV0aGVyLnByb3RvdHlwZS5wb3NpdGlvbiA9IGZ1bmN0aW9uIChmbHVzaENoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudFBvcywgZWxlbWVudFN0eWxlLCBoZWlnaHQsIGxlZnQsIG1hbnVhbE9mZnNldCwgbWFudWFsVGFyZ2V0T2Zmc2V0LCBtb2R1bGUsIG5leHQsIG9mZnNldCwgb2Zmc2V0Qm9yZGVyLCBvZmZzZXRQYXJlbnQsIG9mZnNldFBhcmVudFNpemUsIG9mZnNldFBhcmVudFN0eWxlLCBvZmZzZXRQb3NpdGlvbiwgcmV0LCBzY3JvbGxMZWZ0LCBzY3JvbGxUb3AsIHNjcm9sbGJhclNpemUsIHNpZGUsIHRhcmdldEF0dGFjaG1lbnQsIHRhcmdldE9mZnNldCwgdGFyZ2V0UG9zLCB0YXJnZXRTaXplLCB0b3AsIHdpZHRoLCBfaSwgX2osIF9sZW4sIF9sZW4xLCBfcmVmMSwgX3JlZjIsIF9yZWYzLCBfcmVmNCwgX3JlZjUsIF9yZWY2LFxuICAgICAgICAgICAgICAgICAgICBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgaWYgKGZsdXNoQ2hhbmdlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsdXNoQ2hhbmdlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhckNhY2hlKCk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0QXR0YWNobWVudCA9IGF1dG9Ub0ZpeGVkQXR0YWNobWVudCh0aGlzLnRhcmdldEF0dGFjaG1lbnQsIHRoaXMuYXR0YWNobWVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVBdHRhY2hDbGFzc2VzKHRoaXMuYXR0YWNobWVudCwgdGFyZ2V0QXR0YWNobWVudCk7XG4gICAgICAgICAgICAgICAgZWxlbWVudFBvcyA9IHRoaXMuY2FjaGUoJ2VsZW1lbnQtYm91bmRzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Qm91bmRzKF90aGlzLmVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHdpZHRoID0gZWxlbWVudFBvcy53aWR0aCwgaGVpZ2h0ID0gZWxlbWVudFBvcy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKHdpZHRoID09PSAwICYmIGhlaWdodCA9PT0gMCAmJiAodGhpcy5sYXN0U2l6ZSAhPSBudWxsKSkge1xuICAgICAgICAgICAgICAgICAgICBfcmVmMSA9IHRoaXMubGFzdFNpemUsIHdpZHRoID0gX3JlZjEud2lkdGgsIGhlaWdodCA9IF9yZWYxLmhlaWdodDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RTaXplID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGFyZ2V0U2l6ZSA9IHRhcmdldFBvcyA9IHRoaXMuY2FjaGUoJ3RhcmdldC1ib3VuZHMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZXRUYXJnZXRCb3VuZHMoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBvZmZzZXRUb1B4KGF0dGFjaG1lbnRUb09mZnNldCh0aGlzLmF0dGFjaG1lbnQpLCB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0YXJnZXRPZmZzZXQgPSBvZmZzZXRUb1B4KGF0dGFjaG1lbnRUb09mZnNldCh0YXJnZXRBdHRhY2htZW50KSwgdGFyZ2V0U2l6ZSk7XG4gICAgICAgICAgICAgICAgbWFudWFsT2Zmc2V0ID0gb2Zmc2V0VG9QeCh0aGlzLm9mZnNldCwge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbWFudWFsVGFyZ2V0T2Zmc2V0ID0gb2Zmc2V0VG9QeCh0aGlzLnRhcmdldE9mZnNldCwgdGFyZ2V0U2l6ZSk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gYWRkT2Zmc2V0KG9mZnNldCwgbWFudWFsT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB0YXJnZXRPZmZzZXQgPSBhZGRPZmZzZXQodGFyZ2V0T2Zmc2V0LCBtYW51YWxUYXJnZXRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIGxlZnQgPSB0YXJnZXRQb3MubGVmdCArIHRhcmdldE9mZnNldC5sZWZ0IC0gb2Zmc2V0LmxlZnQ7XG4gICAgICAgICAgICAgICAgdG9wID0gdGFyZ2V0UG9zLnRvcCArIHRhcmdldE9mZnNldC50b3AgLSBvZmZzZXQudG9wO1xuICAgICAgICAgICAgICAgIF9yZWYyID0gVGV0aGVyLm1vZHVsZXM7XG4gICAgICAgICAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGUgPSBfcmVmMltfaV07XG4gICAgICAgICAgICAgICAgICAgIHJldCA9IG1vZHVsZS5wb3NpdGlvbi5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEF0dGFjaG1lbnQ6IHRhcmdldEF0dGFjaG1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRQb3M6IHRhcmdldFBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFjaG1lbnQ6IHRoaXMuYXR0YWNobWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRQb3M6IGVsZW1lbnRQb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldE9mZnNldDogdGFyZ2V0T2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFudWFsT2Zmc2V0OiBtYW51YWxPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYW51YWxUYXJnZXRPZmZzZXQ6IG1hbnVhbFRhcmdldE9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGJhclNpemU6IHNjcm9sbGJhclNpemVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgocmV0ID09IG51bGwpIHx8IHR5cGVvZiByZXQgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AgPSByZXQudG9wLCBsZWZ0ID0gcmV0LmxlZnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgcGFnZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IHRvcCAtIHBhZ2VZT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tOiBwYWdlWU9mZnNldCAtIHRvcCAtIGhlaWdodCArIGlubmVySGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogbGVmdCAtIHBhZ2VYT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHBhZ2VYT2Zmc2V0IC0gbGVmdCAtIHdpZHRoICsgaW5uZXJXaWR0aFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQuYm9keS5zY3JvbGxXaWR0aCA+IHdpbmRvdy5pbm5lcldpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbGJhclNpemUgPSB0aGlzLmNhY2hlKCdzY3JvbGxiYXItc2l6ZScsIGdldFNjcm9sbEJhclNpemUpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0LnZpZXdwb3J0LmJvdHRvbSAtPSBzY3JvbGxiYXJTaXplLmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0ID4gd2luZG93LmlubmVySGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbGJhclNpemUgPSB0aGlzLmNhY2hlKCdzY3JvbGxiYXItc2l6ZScsIGdldFNjcm9sbEJhclNpemUpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0LnZpZXdwb3J0LnJpZ2h0IC09IHNjcm9sbGJhclNpemUud2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoKF9yZWYzID0gZG9jdW1lbnQuYm9keS5zdHlsZS5wb3NpdGlvbikgIT09ICcnICYmIF9yZWYzICE9PSAnc3RhdGljJykgfHwgKChfcmVmNCA9IGRvY3VtZW50LmJvZHkucGFyZW50RWxlbWVudC5zdHlsZS5wb3NpdGlvbikgIT09ICcnICYmIF9yZWY0ICE9PSAnc3RhdGljJykpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dC5wYWdlLmJvdHRvbSA9IGRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0IC0gdG9wIC0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBuZXh0LnBhZ2UucmlnaHQgPSBkb2N1bWVudC5ib2R5LnNjcm9sbFdpZHRoIC0gbGVmdCAtIHdpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKChfcmVmNSA9IHRoaXMub3B0aW9ucy5vcHRpbWl6YXRpb25zKSAhPSBudWxsID8gX3JlZjUubW92ZUVsZW1lbnQgOiB2b2lkIDApICE9PSBmYWxzZSAmJiAodGhpcy50YXJnZXRNb2RpZmllciA9PSBudWxsKSkge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXRQYXJlbnQgPSB0aGlzLmNhY2hlKCd0YXJnZXQtb2Zmc2V0cGFyZW50JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldE9mZnNldFBhcmVudChfdGhpcy50YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0UG9zaXRpb24gPSB0aGlzLmNhY2hlKCd0YXJnZXQtb2Zmc2V0cGFyZW50LWJvdW5kcycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRCb3VuZHMob2Zmc2V0UGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFBhcmVudFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50U3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMuZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFBhcmVudFNpemUgPSBvZmZzZXRQb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0Qm9yZGVyID0ge307XG4gICAgICAgICAgICAgICAgICAgIF9yZWY2ID0gWydUb3AnLCAnTGVmdCcsICdCb3R0b20nLCAnUmlnaHQnXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChfaiA9IDAsIF9sZW4xID0gX3JlZjYubGVuZ3RoOyBfaiA8IF9sZW4xOyBfaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWRlID0gX3JlZjZbX2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0Qm9yZGVyW3NpZGUudG9Mb3dlckNhc2UoKV0gPSBwYXJzZUZsb2F0KG9mZnNldFBhcmVudFN0eWxlWydib3JkZXInICsgc2lkZSArICdXaWR0aCddKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRQb3NpdGlvbi5yaWdodCA9IGRvY3VtZW50LmJvZHkuc2Nyb2xsV2lkdGggLSBvZmZzZXRQb3NpdGlvbi5sZWZ0IC0gb2Zmc2V0UGFyZW50U2l6ZS53aWR0aCArIG9mZnNldEJvcmRlci5yaWdodDtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0UG9zaXRpb24uYm90dG9tID0gZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQgLSBvZmZzZXRQb3NpdGlvbi50b3AgLSBvZmZzZXRQYXJlbnRTaXplLmhlaWdodCArIG9mZnNldEJvcmRlci5ib3R0b207XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0LnBhZ2UudG9wID49IChvZmZzZXRQb3NpdGlvbi50b3AgKyBvZmZzZXRCb3JkZXIudG9wKSAmJiBuZXh0LnBhZ2UuYm90dG9tID49IG9mZnNldFBvc2l0aW9uLmJvdHRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQucGFnZS5sZWZ0ID49IChvZmZzZXRQb3NpdGlvbi5sZWZ0ICsgb2Zmc2V0Qm9yZGVyLmxlZnQpICYmIG5leHQucGFnZS5yaWdodCA+PSBvZmZzZXRQb3NpdGlvbi5yaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFRvcCA9IG9mZnNldFBhcmVudC5zY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsTGVmdCA9IG9mZnNldFBhcmVudC5zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQub2Zmc2V0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IG5leHQucGFnZS50b3AgLSBvZmZzZXRQb3NpdGlvbi50b3AgKyBzY3JvbGxUb3AgLSBvZmZzZXRCb3JkZXIudG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBuZXh0LnBhZ2UubGVmdCAtIG9mZnNldFBvc2l0aW9uLmxlZnQgKyBzY3JvbGxMZWZ0IC0gb2Zmc2V0Qm9yZGVyLmxlZnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubW92ZShuZXh0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmhpc3RvcnkudW5zaGlmdChuZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oaXN0b3J5Lmxlbmd0aCA+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaXN0b3J5LnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZmx1c2hDaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgX1RldGhlci5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBjc3MsIGVsVmFsLCBmb3VuZCwga2V5LCBtb3ZlZCwgb2Zmc2V0UGFyZW50LCBwb2ludCwgc2FtZSwgdHJhbnNjcmliZSwgdHlwZSwgdmFsLCB3cml0ZSwgd3JpdGVDU1MsIF9pLCBfbGVuLCBfcmVmMSwgX3JlZjIsXG4gICAgICAgICAgICAgICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5lbGVtZW50LnBhcmVudE5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNhbWUgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKHR5cGUgaW4gcG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgc2FtZVt0eXBlXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBwb3NpdGlvblt0eXBlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYxID0gdGhpcy5oaXN0b3J5O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ID0gX3JlZjFbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghd2l0aGluKChfcmVmMiA9IHBvaW50W3R5cGVdKSAhPSBudWxsID8gX3JlZjJba2V5XSA6IHZvaWQgMCwgcG9zaXRpb25bdHlwZV1ba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2FtZVt0eXBlXVtrZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjc3MgPSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcDogJycsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6ICcnLFxuICAgICAgICAgICAgICAgICAgICByaWdodDogJycsXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbTogJydcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRyYW5zY3JpYmUgPSBmdW5jdGlvbiAoc2FtZSwgcG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4UG9zLCB5UG9zLCBfcmVmMztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgoX3JlZjMgPSBfdGhpcy5vcHRpb25zLm9wdGltaXphdGlvbnMpICE9IG51bGwgPyBfcmVmMy5ncHUgOiB2b2lkIDApICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNhbWUudG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3NzLnRvcCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeVBvcyA9IHBvcy50b3A7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzcy5ib3R0b20gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlQb3MgPSAtcG9zLmJvdHRvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzYW1lLmxlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3MubGVmdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeFBvcyA9IHBvcy5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3MucmlnaHQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhQb3MgPSAtcG9zLnJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY3NzW3RyYW5zZm9ybUtleV0gPSAndHJhbnNsYXRlWCgnICsgKE1hdGgucm91bmQoeFBvcykpICsgJ3B4KSB0cmFuc2xhdGVZKCcgKyAoTWF0aC5yb3VuZCh5UG9zKSkgKyAncHgpJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1LZXkgIT09ICdtc1RyYW5zZm9ybScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3NzW3RyYW5zZm9ybUtleV0gKz0gJyB0cmFuc2xhdGVaKDApJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzYW1lLnRvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzcy50b3AgPSAnJyArIHBvcy50b3AgKyAncHgnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3MuYm90dG9tID0gJycgKyBwb3MuYm90dG9tICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzYW1lLmxlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3NzLmxlZnQgPSAnJyArIHBvcy5sZWZ0ICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNzcy5yaWdodCA9ICcnICsgcG9zLnJpZ2h0ICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbW92ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoKHNhbWUucGFnZS50b3AgfHwgc2FtZS5wYWdlLmJvdHRvbSkgJiYgKHNhbWUucGFnZS5sZWZ0IHx8IHNhbWUucGFnZS5yaWdodCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3NzLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNjcmliZShzYW1lLnBhZ2UsIHBvc2l0aW9uLnBhZ2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKHNhbWUudmlld3BvcnQudG9wIHx8IHNhbWUudmlld3BvcnQuYm90dG9tKSAmJiAoc2FtZS52aWV3cG9ydC5sZWZ0IHx8IHNhbWUudmlld3BvcnQucmlnaHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNzcy5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zY3JpYmUoc2FtZS52aWV3cG9ydCwgcG9zaXRpb24udmlld3BvcnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKHNhbWUub2Zmc2V0ICE9IG51bGwpICYmIHNhbWUub2Zmc2V0LnRvcCAmJiBzYW1lLm9mZnNldC5sZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNzcy5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFBhcmVudCA9IHRoaXMuY2FjaGUoJ3RhcmdldC1vZmZzZXRwYXJlbnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0T2Zmc2V0UGFyZW50KF90aGlzLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0T2Zmc2V0UGFyZW50KHRoaXMuZWxlbWVudCkgIT09IG9mZnNldFBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChfdGhpcy5lbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2Zmc2V0UGFyZW50LmFwcGVuZENoaWxkKF90aGlzLmVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHJhbnNjcmliZShzYW1lLm9mZnNldCwgcG9zaXRpb24ub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgbW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNzcy5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zY3JpYmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9LCBwb3NpdGlvbi5wYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFtb3ZlZCAmJiB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZS50YWdOYW1lICE9PSAnQk9EWScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5lbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3cml0ZUNTUyA9IHt9O1xuICAgICAgICAgICAgICAgIHdyaXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gY3NzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IGNzc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBlbFZhbCA9IHRoaXMuZWxlbWVudC5zdHlsZVtrZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxWYWwgIT09ICcnICYmIHZhbCAhPT0gJycgJiYgKGtleSA9PT0gJ3RvcCcgfHwga2V5ID09PSAnbGVmdCcgfHwga2V5ID09PSAnYm90dG9tJyB8fCBrZXkgPT09ICdyaWdodCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbFZhbCA9IHBhcnNlRmxvYXQoZWxWYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gcGFyc2VGbG9hdCh2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbFZhbCAhPT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0ZUNTU1trZXldID0gY3NzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHdyaXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXh0ZW5kKF90aGlzLmVsZW1lbnQuc3R5bGUsIHdyaXRlQ1NTKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIF9UZXRoZXI7XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgVGV0aGVyLnBvc2l0aW9uID0gcG9zaXRpb247XG5cbiAgICAgICAgdGhpcy5UZXRoZXIgPSBleHRlbmQoX1RldGhlciwgVGV0aGVyKTtcbiAgICB9KS5jYWxsKHRoaXMpO1xuXG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIEJPVU5EU19GT1JNQVQsIE1JUlJPUl9BVFRBQ0gsIGRlZmVyLCBleHRlbmQsIGdldEJvdW5kaW5nUmVjdCwgZ2V0Qm91bmRzLCBnZXRPdXRlclNpemUsIGdldFNpemUsIHVwZGF0ZUNsYXNzZXMsIF9yZWYsXG4gICAgICAgICAgICBfX2luZGV4T2YgPSBbXS5pbmRleE9mIHx8IGZ1bmN0aW9uIChpdGVtKSB7IGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHsgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKSByZXR1cm4gaTsgfSByZXR1cm4gLTE7IH07XG5cbiAgICAgICAgX3JlZiA9IHRoaXMuVGV0aGVyLlV0aWxzLCBnZXRPdXRlclNpemUgPSBfcmVmLmdldE91dGVyU2l6ZSwgZ2V0Qm91bmRzID0gX3JlZi5nZXRCb3VuZHMsIGdldFNpemUgPSBfcmVmLmdldFNpemUsIGV4dGVuZCA9IF9yZWYuZXh0ZW5kLCB1cGRhdGVDbGFzc2VzID0gX3JlZi51cGRhdGVDbGFzc2VzLCBkZWZlciA9IF9yZWYuZGVmZXI7XG5cbiAgICAgICAgTUlSUk9SX0FUVEFDSCA9IHtcbiAgICAgICAgICAgIGxlZnQ6ICdyaWdodCcsXG4gICAgICAgICAgICByaWdodDogJ2xlZnQnLFxuICAgICAgICAgICAgdG9wOiAnYm90dG9tJyxcbiAgICAgICAgICAgIGJvdHRvbTogJ3RvcCcsXG4gICAgICAgICAgICBtaWRkbGU6ICdtaWRkbGUnXG4gICAgICAgIH07XG5cbiAgICAgICAgQk9VTkRTX0ZPUk1BVCA9IFsnbGVmdCcsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJ107XG5cbiAgICAgICAgZ2V0Qm91bmRpbmdSZWN0ID0gZnVuY3Rpb24gKHRldGhlciwgdG8pIHtcbiAgICAgICAgICAgIHZhciBpLCBwb3MsIHNpZGUsIHNpemUsIHN0eWxlLCBfaSwgX2xlbjtcbiAgICAgICAgICAgIGlmICh0byA9PT0gJ3Njcm9sbFBhcmVudCcpIHtcbiAgICAgICAgICAgICAgICB0byA9IHRldGhlci5zY3JvbGxQYXJlbnQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRvID09PSAnd2luZG93Jykge1xuICAgICAgICAgICAgICAgIHRvID0gW3BhZ2VYT2Zmc2V0LCBwYWdlWU9mZnNldCwgaW5uZXJXaWR0aCArIHBhZ2VYT2Zmc2V0LCBpbm5lckhlaWdodCArIHBhZ2VZT2Zmc2V0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0byA9PT0gZG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0byA9IHRvLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0by5ub2RlVHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcG9zID0gc2l6ZSA9IGdldEJvdW5kcyh0byk7XG4gICAgICAgICAgICAgICAgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHRvKTtcbiAgICAgICAgICAgICAgICB0byA9IFtwb3MubGVmdCwgcG9zLnRvcCwgc2l6ZS53aWR0aCArIHBvcy5sZWZ0LCBzaXplLmhlaWdodCArIHBvcy50b3BdO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IF9pID0gMCwgX2xlbiA9IEJPVU5EU19GT1JNQVQubGVuZ3RoOyBfaSA8IF9sZW47IGkgPSArK19pKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpZGUgPSBCT1VORFNfRk9STUFUW2ldO1xuICAgICAgICAgICAgICAgICAgICBzaWRlID0gc2lkZVswXS50b1VwcGVyQ2FzZSgpICsgc2lkZS5zdWJzdHIoMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWRlID09PSAnVG9wJyB8fCBzaWRlID09PSAnTGVmdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvW2ldICs9IHBhcnNlRmxvYXQoc3R5bGVbJ2JvcmRlcicgKyBzaWRlICsgJ1dpZHRoJ10pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9baV0gLT0gcGFyc2VGbG9hdChzdHlsZVsnYm9yZGVyJyArIHNpZGUgKyAnV2lkdGgnXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG87XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5UZXRoZXIubW9kdWxlcy5wdXNoKHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBmdW5jdGlvbiAoX2FyZykge1xuICAgICAgICAgICAgICAgIHZhciBhZGRDbGFzc2VzLCBhbGxDbGFzc2VzLCBhdHRhY2htZW50LCBib3VuZHMsIGNoYW5nZUF0dGFjaFgsIGNoYW5nZUF0dGFjaFksIGNscywgY29uc3RyYWludCwgZUF0dGFjaG1lbnQsIGhlaWdodCwgbGVmdCwgb29iLCBvb2JDbGFzcywgcCwgcGluLCBwaW5uZWQsIHBpbm5lZENsYXNzLCByZW1vdmVDbGFzcywgc2lkZSwgdEF0dGFjaG1lbnQsIHRhcmdldEF0dGFjaG1lbnQsIHRhcmdldEhlaWdodCwgdGFyZ2V0U2l6ZSwgdGFyZ2V0V2lkdGgsIHRvLCB0b3AsIHdpZHRoLCBfaSwgX2osIF9rLCBfbCwgX2xlbiwgX2xlbjEsIF9sZW4yLCBfbGVuMywgX2xlbjQsIF9sZW41LCBfbSwgX24sIF9yZWYxLCBfcmVmMiwgX3JlZjMsIF9yZWY0LCBfcmVmNSwgX3JlZjYsIF9yZWY3LCBfcmVmOCxcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHRvcCA9IF9hcmcudG9wLCBsZWZ0ID0gX2FyZy5sZWZ0LCB0YXJnZXRBdHRhY2htZW50ID0gX2FyZy50YXJnZXRBdHRhY2htZW50O1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLmNvbnN0cmFpbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyA9IGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpZGUsIF9pLCBfbGVuLCBfcmVzdWx0cztcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVtb3ZlQ2xhc3MocHJlZml4KTtcbiAgICAgICAgICAgICAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBCT1VORFNfRk9STUFULmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWRlID0gQk9VTkRTX0ZPUk1BVFtfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVzdWx0cy5wdXNoKF90aGlzLnJlbW92ZUNsYXNzKCcnICsgcHJlZml4ICsgJy0nICsgc2lkZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIF9yZWYxID0gdGhpcy5jYWNoZSgnZWxlbWVudC1ib3VuZHMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRCb3VuZHMoX3RoaXMuZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfSksIGhlaWdodCA9IF9yZWYxLmhlaWdodCwgd2lkdGggPSBfcmVmMS53aWR0aDtcbiAgICAgICAgICAgICAgICBpZiAod2lkdGggPT09IDAgJiYgaGVpZ2h0ID09PSAwICYmICh0aGlzLmxhc3RTaXplICE9IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgICAgIF9yZWYyID0gdGhpcy5sYXN0U2l6ZSwgd2lkdGggPSBfcmVmMi53aWR0aCwgaGVpZ2h0ID0gX3JlZjIuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0YXJnZXRTaXplID0gdGhpcy5jYWNoZSgndGFyZ2V0LWJvdW5kcycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdldFRhcmdldEJvdW5kcygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRhcmdldEhlaWdodCA9IHRhcmdldFNpemUuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRhcmdldFdpZHRoID0gdGFyZ2V0U2l6ZS53aWR0aDtcbiAgICAgICAgICAgICAgICB0QXR0YWNobWVudCA9IHt9O1xuICAgICAgICAgICAgICAgIGVBdHRhY2htZW50ID0ge307XG4gICAgICAgICAgICAgICAgYWxsQ2xhc3NlcyA9IFt0aGlzLmdldENsYXNzKCdwaW5uZWQnKSwgdGhpcy5nZXRDbGFzcygnb3V0LW9mLWJvdW5kcycpXTtcbiAgICAgICAgICAgICAgICBfcmVmMyA9IHRoaXMub3B0aW9ucy5jb25zdHJhaW50cztcbiAgICAgICAgICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQgPSBfcmVmM1tfaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25zdHJhaW50Lm91dE9mQm91bmRzQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbENsYXNzZXMucHVzaChjb25zdHJhaW50Lm91dE9mQm91bmRzQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25zdHJhaW50LnBpbm5lZENsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxDbGFzc2VzLnB1c2goY29uc3RyYWludC5waW5uZWRDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChfaiA9IDAsIF9sZW4xID0gYWxsQ2xhc3Nlcy5sZW5ndGg7IF9qIDwgX2xlbjE7IF9qKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY2xzID0gYWxsQ2xhc3Nlc1tfal07XG4gICAgICAgICAgICAgICAgICAgIF9yZWY0ID0gWydsZWZ0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChfayA9IDAsIF9sZW4yID0gX3JlZjQubGVuZ3RoOyBfayA8IF9sZW4yOyBfaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWRlID0gX3JlZjRbX2tdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsQ2xhc3Nlcy5wdXNoKCcnICsgY2xzICsgJy0nICsgc2lkZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkQ2xhc3NlcyA9IFtdO1xuICAgICAgICAgICAgICAgIHRBdHRhY2htZW50ID0gZXh0ZW5kKHt9LCB0YXJnZXRBdHRhY2htZW50KTtcbiAgICAgICAgICAgICAgICBlQXR0YWNobWVudCA9IGV4dGVuZCh7fSwgdGhpcy5hdHRhY2htZW50KTtcbiAgICAgICAgICAgICAgICBfcmVmNSA9IHRoaXMub3B0aW9ucy5jb25zdHJhaW50cztcbiAgICAgICAgICAgICAgICBmb3IgKF9sID0gMCwgX2xlbjMgPSBfcmVmNS5sZW5ndGg7IF9sIDwgX2xlbjM7IF9sKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludCA9IF9yZWY1W19sXTtcbiAgICAgICAgICAgICAgICAgICAgdG8gPSBjb25zdHJhaW50LnRvLCBhdHRhY2htZW50ID0gY29uc3RyYWludC5hdHRhY2htZW50LCBwaW4gPSBjb25zdHJhaW50LnBpbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dGFjaG1lbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNobWVudCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChfX2luZGV4T2YuY2FsbChhdHRhY2htZW50LCAnICcpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWY2ID0gYXR0YWNobWVudC5zcGxpdCgnICcpLCBjaGFuZ2VBdHRhY2hZID0gX3JlZjZbMF0sIGNoYW5nZUF0dGFjaFggPSBfcmVmNlsxXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZUF0dGFjaFggPSBjaGFuZ2VBdHRhY2hZID0gYXR0YWNobWVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBib3VuZHMgPSBnZXRCb3VuZGluZ1JlY3QodGhpcywgdG8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlQXR0YWNoWSA9PT0gJ3RhcmdldCcgfHwgY2hhbmdlQXR0YWNoWSA9PT0gJ2JvdGgnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9wIDwgYm91bmRzWzFdICYmIHRBdHRhY2htZW50LnRvcCA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3AgKz0gdGFyZ2V0SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRBdHRhY2htZW50LnRvcCA9ICdib3R0b20nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRvcCArIGhlaWdodCA+IGJvdW5kc1szXSAmJiB0QXR0YWNobWVudC50b3AgPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wIC09IHRhcmdldEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0QXR0YWNobWVudC50b3AgPSAndG9wJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlQXR0YWNoWSA9PT0gJ3RvZ2V0aGVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRvcCA8IGJvdW5kc1sxXSAmJiB0QXR0YWNobWVudC50b3AgPT09ICd0b3AnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVBdHRhY2htZW50LnRvcCA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wICs9IHRhcmdldEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdEF0dGFjaG1lbnQudG9wID0gJ2JvdHRvbSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcCArPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVBdHRhY2htZW50LnRvcCA9ICd0b3AnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZUF0dGFjaG1lbnQudG9wID09PSAndG9wJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3AgKz0gdGFyZ2V0SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0QXR0YWNobWVudC50b3AgPSAnYm90dG9tJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wIC09IGhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZUF0dGFjaG1lbnQudG9wID0gJ2JvdHRvbSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRvcCArIGhlaWdodCA+IGJvdW5kc1szXSAmJiB0QXR0YWNobWVudC50b3AgPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVBdHRhY2htZW50LnRvcCA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wIC09IHRhcmdldEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdEF0dGFjaG1lbnQudG9wID0gJ3RvcCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcCAtPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVBdHRhY2htZW50LnRvcCA9ICdib3R0b20nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZUF0dGFjaG1lbnQudG9wID09PSAnYm90dG9tJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3AgLT0gdGFyZ2V0SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0QXR0YWNobWVudC50b3AgPSAndG9wJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wICs9IGhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZUF0dGFjaG1lbnQudG9wID0gJ3RvcCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRBdHRhY2htZW50LnRvcCA9PT0gJ21pZGRsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9wICsgaGVpZ2h0ID4gYm91bmRzWzNdICYmIGVBdHRhY2htZW50LnRvcCA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wIC09IGhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZUF0dGFjaG1lbnQudG9wID0gJ2JvdHRvbSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b3AgPCBib3VuZHNbMV0gJiYgZUF0dGFjaG1lbnQudG9wID09PSAnYm90dG9tJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3AgKz0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlQXR0YWNobWVudC50b3AgPSAndG9wJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZUF0dGFjaFggPT09ICd0YXJnZXQnIHx8IGNoYW5nZUF0dGFjaFggPT09ICdib3RoJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnQgPCBib3VuZHNbMF0gJiYgdEF0dGFjaG1lbnQubGVmdCA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCArPSB0YXJnZXRXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0QXR0YWNobWVudC5sZWZ0ID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0ICsgd2lkdGggPiBib3VuZHNbMl0gJiYgdEF0dGFjaG1lbnQubGVmdCA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgLT0gdGFyZ2V0V2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdEF0dGFjaG1lbnQubGVmdCA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlQXR0YWNoWCA9PT0gJ3RvZ2V0aGVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnQgPCBib3VuZHNbMF0gJiYgdEF0dGFjaG1lbnQubGVmdCA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVBdHRhY2htZW50LmxlZnQgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCArPSB0YXJnZXRXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdEF0dGFjaG1lbnQubGVmdCA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgKz0gd2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVBdHRhY2htZW50LmxlZnQgPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlQXR0YWNobWVudC5sZWZ0ID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCArPSB0YXJnZXRXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdEF0dGFjaG1lbnQubGVmdCA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVBdHRhY2htZW50LmxlZnQgPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGVmdCArIHdpZHRoID4gYm91bmRzWzJdICYmIHRBdHRhY2htZW50LmxlZnQgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZUF0dGFjaG1lbnQubGVmdCA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgLT0gdGFyZ2V0V2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRBdHRhY2htZW50LmxlZnQgPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVBdHRhY2htZW50LmxlZnQgPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZUF0dGFjaG1lbnQubGVmdCA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0IC09IHRhcmdldFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0QXR0YWNobWVudC5sZWZ0ID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ICs9IHdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlQXR0YWNobWVudC5sZWZ0ID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodEF0dGFjaG1lbnQubGVmdCA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVmdCArIHdpZHRoID4gYm91bmRzWzJdICYmIGVBdHRhY2htZW50LmxlZnQgPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlQXR0YWNobWVudC5sZWZ0ID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxlZnQgPCBib3VuZHNbMF0gJiYgZUF0dGFjaG1lbnQubGVmdCA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ICs9IHdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlQXR0YWNobWVudC5sZWZ0ID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlQXR0YWNoWSA9PT0gJ2VsZW1lbnQnIHx8IGNoYW5nZUF0dGFjaFkgPT09ICdib3RoJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRvcCA8IGJvdW5kc1sxXSAmJiBlQXR0YWNobWVudC50b3AgPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wICs9IGhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlQXR0YWNobWVudC50b3AgPSAndG9wJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b3AgKyBoZWlnaHQgPiBib3VuZHNbM10gJiYgZUF0dGFjaG1lbnQudG9wID09PSAndG9wJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcCAtPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZUF0dGFjaG1lbnQudG9wID0gJ2JvdHRvbSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZUF0dGFjaFggPT09ICdlbGVtZW50JyB8fCBjaGFuZ2VBdHRhY2hYID09PSAnYm90aCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0IDwgYm91bmRzWzBdICYmIGVBdHRhY2htZW50LmxlZnQgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ICs9IHdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVBdHRhY2htZW50LmxlZnQgPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVmdCArIHdpZHRoID4gYm91bmRzWzJdICYmIGVBdHRhY2htZW50LmxlZnQgPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZUF0dGFjaG1lbnQubGVmdCA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwaW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwaW4gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfbGVuNCwgX20sIF9yZWY3LCBfcmVzdWx0cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmNyA9IHBpbi5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChfbSA9IDAsIF9sZW40ID0gX3JlZjcubGVuZ3RoOyBfbSA8IF9sZW40OyBfbSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBfcmVmN1tfbV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZXN1bHRzLnB1c2gocC50cmltKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBpbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGluID0gWyd0b3AnLCAnbGVmdCcsICdyaWdodCcsICdib3R0b20nXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwaW4gfHwgKHBpbiA9IFtdKTtcbiAgICAgICAgICAgICAgICAgICAgcGlubmVkID0gW107XG4gICAgICAgICAgICAgICAgICAgIG9vYiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9wIDwgYm91bmRzWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX19pbmRleE9mLmNhbGwocGluLCAndG9wJykgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcCA9IGJvdW5kc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaW5uZWQucHVzaCgndG9wJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9vYi5wdXNoKCd0b3AnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodG9wICsgaGVpZ2h0ID4gYm91bmRzWzNdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX19pbmRleE9mLmNhbGwocGluLCAnYm90dG9tJykgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcCA9IGJvdW5kc1szXSAtIGhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaW5uZWQucHVzaCgnYm90dG9tJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9vYi5wdXNoKCdib3R0b20nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdCA8IGJvdW5kc1swXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9faW5kZXhPZi5jYWxsKHBpbiwgJ2xlZnQnKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGJvdW5kc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaW5uZWQucHVzaCgnbGVmdCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvb2IucHVzaCgnbGVmdCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0ICsgd2lkdGggPiBib3VuZHNbMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfX2luZGV4T2YuY2FsbChwaW4sICdyaWdodCcpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gYm91bmRzWzJdIC0gd2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGlubmVkLnB1c2goJ3JpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9vYi5wdXNoKCdyaWdodCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwaW5uZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwaW5uZWRDbGFzcyA9IChfcmVmNyA9IHRoaXMub3B0aW9ucy5waW5uZWRDbGFzcykgIT0gbnVsbCA/IF9yZWY3IDogdGhpcy5nZXRDbGFzcygncGlubmVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRDbGFzc2VzLnB1c2gocGlubmVkQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChfbSA9IDAsIF9sZW40ID0gcGlubmVkLmxlbmd0aDsgX20gPCBfbGVuNDsgX20rKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZGUgPSBwaW5uZWRbX21dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZENsYXNzZXMucHVzaCgnJyArIHBpbm5lZENsYXNzICsgJy0nICsgc2lkZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9vYi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9vYkNsYXNzID0gKF9yZWY4ID0gdGhpcy5vcHRpb25zLm91dE9mQm91bmRzQ2xhc3MpICE9IG51bGwgPyBfcmVmOCA6IHRoaXMuZ2V0Q2xhc3MoJ291dC1vZi1ib3VuZHMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZENsYXNzZXMucHVzaChvb2JDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKF9uID0gMCwgX2xlbjUgPSBvb2IubGVuZ3RoOyBfbiA8IF9sZW41OyBfbisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lkZSA9IG9vYltfbl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3Nlcy5wdXNoKCcnICsgb29iQ2xhc3MgKyAnLScgKyBzaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoX19pbmRleE9mLmNhbGwocGlubmVkLCAnbGVmdCcpID49IDAgfHwgX19pbmRleE9mLmNhbGwocGlubmVkLCAncmlnaHQnKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlQXR0YWNobWVudC5sZWZ0ID0gdEF0dGFjaG1lbnQubGVmdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChfX2luZGV4T2YuY2FsbChwaW5uZWQsICd0b3AnKSA+PSAwIHx8IF9faW5kZXhPZi5jYWxsKHBpbm5lZCwgJ2JvdHRvbScpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVBdHRhY2htZW50LnRvcCA9IHRBdHRhY2htZW50LnRvcCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0QXR0YWNobWVudC50b3AgIT09IHRhcmdldEF0dGFjaG1lbnQudG9wIHx8IHRBdHRhY2htZW50LmxlZnQgIT09IHRhcmdldEF0dGFjaG1lbnQubGVmdCB8fCBlQXR0YWNobWVudC50b3AgIT09IHRoaXMuYXR0YWNobWVudC50b3AgfHwgZUF0dGFjaG1lbnQubGVmdCAhPT0gdGhpcy5hdHRhY2htZW50LmxlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQXR0YWNoQ2xhc3NlcyhlQXR0YWNobWVudCwgdEF0dGFjaG1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ2xhc3NlcyhfdGhpcy50YXJnZXQsIGFkZENsYXNzZXMsIGFsbENsYXNzZXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlQ2xhc3NlcyhfdGhpcy5lbGVtZW50LCBhZGRDbGFzc2VzLCBhbGxDbGFzc2VzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogbGVmdFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pLmNhbGwodGhpcyk7XG5cbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGVmZXIsIGdldEJvdW5kcywgdXBkYXRlQ2xhc3NlcywgX3JlZjtcblxuICAgICAgICBfcmVmID0gdGhpcy5UZXRoZXIuVXRpbHMsIGdldEJvdW5kcyA9IF9yZWYuZ2V0Qm91bmRzLCB1cGRhdGVDbGFzc2VzID0gX3JlZi51cGRhdGVDbGFzc2VzLCBkZWZlciA9IF9yZWYuZGVmZXI7XG5cbiAgICAgICAgdGhpcy5UZXRoZXIubW9kdWxlcy5wdXNoKHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBmdW5jdGlvbiAoX2FyZykge1xuICAgICAgICAgICAgICAgIHZhciBhYnV0dGVkLCBhZGRDbGFzc2VzLCBhbGxDbGFzc2VzLCBib3R0b20sIGhlaWdodCwgbGVmdCwgcmlnaHQsIHNpZGUsIHNpZGVzLCB0YXJnZXRQb3MsIHRvcCwgd2lkdGgsIF9pLCBfaiwgX2ssIF9sLCBfbGVuLCBfbGVuMSwgX2xlbjIsIF9sZW4zLCBfcmVmMSwgX3JlZjIsIF9yZWYzLCBfcmVmNCwgX3JlZjUsXG4gICAgICAgICAgICAgICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICB0b3AgPSBfYXJnLnRvcCwgbGVmdCA9IF9hcmcubGVmdDtcbiAgICAgICAgICAgICAgICBfcmVmMSA9IHRoaXMuY2FjaGUoJ2VsZW1lbnQtYm91bmRzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Qm91bmRzKF90aGlzLmVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH0pLCBoZWlnaHQgPSBfcmVmMS5oZWlnaHQsIHdpZHRoID0gX3JlZjEud2lkdGg7XG4gICAgICAgICAgICAgICAgdGFyZ2V0UG9zID0gdGhpcy5nZXRUYXJnZXRCb3VuZHMoKTtcbiAgICAgICAgICAgICAgICBib3R0b20gPSB0b3AgKyBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSBsZWZ0ICsgd2lkdGg7XG4gICAgICAgICAgICAgICAgYWJ1dHRlZCA9IFtdO1xuICAgICAgICAgICAgICAgIGlmICh0b3AgPD0gdGFyZ2V0UG9zLmJvdHRvbSAmJiBib3R0b20gPj0gdGFyZ2V0UG9zLnRvcCkge1xuICAgICAgICAgICAgICAgICAgICBfcmVmMiA9IFsnbGVmdCcsICdyaWdodCddO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYyLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWRlID0gX3JlZjJbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfcmVmMyA9IHRhcmdldFBvc1tzaWRlXSkgPT09IGxlZnQgfHwgX3JlZjMgPT09IHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJ1dHRlZC5wdXNoKHNpZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsZWZ0IDw9IHRhcmdldFBvcy5yaWdodCAmJiByaWdodCA+PSB0YXJnZXRQb3MubGVmdCkge1xuICAgICAgICAgICAgICAgICAgICBfcmVmNCA9IFsndG9wJywgJ2JvdHRvbSddO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKF9qID0gMCwgX2xlbjEgPSBfcmVmNC5sZW5ndGg7IF9qIDwgX2xlbjE7IF9qKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZGUgPSBfcmVmNFtfal07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9yZWY1ID0gdGFyZ2V0UG9zW3NpZGVdKSA9PT0gdG9wIHx8IF9yZWY1ID09PSBib3R0b20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYnV0dGVkLnB1c2goc2lkZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWxsQ2xhc3NlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGFkZENsYXNzZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBzaWRlcyA9IFsnbGVmdCcsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJ107XG4gICAgICAgICAgICAgICAgYWxsQ2xhc3Nlcy5wdXNoKHRoaXMuZ2V0Q2xhc3MoJ2FidXR0ZWQnKSk7XG4gICAgICAgICAgICAgICAgZm9yIChfayA9IDAsIF9sZW4yID0gc2lkZXMubGVuZ3RoOyBfayA8IF9sZW4yOyBfaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpZGUgPSBzaWRlc1tfa107XG4gICAgICAgICAgICAgICAgICAgIGFsbENsYXNzZXMucHVzaCgnJyArICh0aGlzLmdldENsYXNzKCdhYnV0dGVkJykpICsgJy0nICsgc2lkZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhYnV0dGVkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBhZGRDbGFzc2VzLnB1c2godGhpcy5nZXRDbGFzcygnYWJ1dHRlZCcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChfbCA9IDAsIF9sZW4zID0gYWJ1dHRlZC5sZW5ndGg7IF9sIDwgX2xlbjM7IF9sKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc2lkZSA9IGFidXR0ZWRbX2xdO1xuICAgICAgICAgICAgICAgICAgICBhZGRDbGFzc2VzLnB1c2goJycgKyAodGhpcy5nZXRDbGFzcygnYWJ1dHRlZCcpKSArICctJyArIHNpZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUNsYXNzZXMoX3RoaXMudGFyZ2V0LCBhZGRDbGFzc2VzLCBhbGxDbGFzc2VzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUNsYXNzZXMoX3RoaXMuZWxlbWVudCwgYWRkQ2xhc3NlcywgYWxsQ2xhc3Nlcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pLmNhbGwodGhpcyk7XG5cbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLlRldGhlci5tb2R1bGVzLnB1c2goe1xuICAgICAgICAgICAgcG9zaXRpb246IGZ1bmN0aW9uIChfYXJnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxlZnQsIHJlc3VsdCwgc2hpZnQsIHNoaWZ0TGVmdCwgc2hpZnRUb3AsIHRvcCwgX3JlZjtcbiAgICAgICAgICAgICAgICB0b3AgPSBfYXJnLnRvcCwgbGVmdCA9IF9hcmcubGVmdDtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5zaGlmdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWwuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogbGVmdFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzaGlmdCA9IHJlc3VsdCh0aGlzLm9wdGlvbnMuc2hpZnQpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2hpZnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNoaWZ0ID0gc2hpZnQuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgICAgICAgc2hpZnRbMV0gfHwgKHNoaWZ0WzFdID0gc2hpZnRbMF0pO1xuICAgICAgICAgICAgICAgICAgICBzaGlmdFRvcCA9IHNoaWZ0WzBdLCBzaGlmdExlZnQgPSBzaGlmdFsxXTtcbiAgICAgICAgICAgICAgICAgICAgc2hpZnRUb3AgPSBwYXJzZUZsb2F0KHNoaWZ0VG9wLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIHNoaWZ0TGVmdCA9IHBhcnNlRmxvYXQoc2hpZnRMZWZ0LCAxMCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3JlZiA9IFtzaGlmdC50b3AsIHNoaWZ0LmxlZnRdLCBzaGlmdFRvcCA9IF9yZWZbMF0sIHNoaWZ0TGVmdCA9IF9yZWZbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRvcCArPSBzaGlmdFRvcDtcbiAgICAgICAgICAgICAgICBsZWZ0ICs9IHNoaWZ0TGVmdDtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogbGVmdFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pLmNhbGwodGhpcyk7XG59KS5jYWxsKHRoaXMucGVuZG8pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGx1Z2lucy90ZXRoZXIuanMiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0xIS4vc2VsZWN0aW9uLmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0yLTEhLi9zZWxlY3Rpb24uY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0yLTEhLi9zZWxlY3Rpb24uY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BsdWdpbnMvc2VsZWN0aW9uLmNzc1xuLy8gbW9kdWxlIGlkID0gNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyplc2xpbnQtZGlzYWJsZSovXG4vLyB0b28gbWFueSBlc2xpbnQgdmlvbGF0aW9ucywgdGhpcyBmaWxlIGhhcyBhIGhpZ2ggcmlzayBvZiBiZWluZyBkYW1hZ2VkIFxuLy8gYnkgZXNsaW50IG1vZGlmaWNhdGlvbnNcbi8qKiAhXG4gKiBTb3J0YWJsZVxuICogQGF1dGhvclx0UnViYVhhICAgPHRyYXNoQHJ1YmF4YS5vcmc+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBTb3J0YWJsZUZhY3RvcnkoKTtcblxuZnVuY3Rpb24gU29ydGFibGVGYWN0b3J5ICgpIHtcbiAgICB2YXIgZHJhZ0VsLFxuICAgICAgICBnaG9zdEVsLFxuICAgICAgICBjbG9uZUVsLFxuICAgICAgICByb290RWwsXG4gICAgICAgIG5leHRFbCxcblxuICAgICAgICBzY3JvbGxFbCxcbiAgICAgICAgc2Nyb2xsUGFyZW50RWwsXG5cbiAgICAgICAgbGFzdEVsLFxuICAgICAgICBsYXN0Q1NTLFxuXG4gICAgICAgIG9sZEluZGV4LFxuICAgICAgICBuZXdJbmRleCxcblxuICAgICAgICBhY3RpdmVHcm91cCxcbiAgICAgICAgYXV0b1Njcm9sbCA9IHt9LFxuXG4gICAgICAgIHRhcEV2dCxcbiAgICAgICAgdG91Y2hFdnQsXG5cblx0XHQvKiogQGNvbnN0ICovXG4gICAgICAgIFJTUEFDRSA9IC9cXHMrL2csXG5cbiAgICAgICAgZXhwYW5kbyA9ICdTb3J0YWJsZScgKyAobmV3IERhdGUoKSkuZ2V0VGltZSgpLFxuXG4gICAgICAgIHdpbiA9IHdpbmRvdyxcbiAgICAgICAgZG9jdW1lbnQgPSB3aW4uZG9jdW1lbnQsXG4gICAgICAgIHBhcnNlSW50ID0gd2luLnBhcnNlSW50LFxuXG4gICAgICAgIHN1cHBvcnREcmFnZ2FibGUgPSAhISgnZHJhZ2dhYmxlJyBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSksXG5cbiAgICAgICAgX3NpbGVudCA9IGZhbHNlLFxuXG4gICAgICAgIF9kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24gKHNvcnRhYmxlLCByb290RWwsIG5hbWUsIHRhcmdldEVsLCBmcm9tRWwsIHN0YXJ0SW5kZXgsIG5ld0luZGV4KSB7XG4gICAgICAgICAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50JyksXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IChzb3J0YWJsZSB8fCByb290RWxbZXhwYW5kb10pLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgb25OYW1lID0gJ29uJyArIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnN1YnN0cigxKTtcblxuICAgICAgICAgICAgZXZ0LmluaXRFdmVudChuYW1lLCB0cnVlLCB0cnVlKTtcblxuICAgICAgICAgICAgZXZ0Lml0ZW0gPSB0YXJnZXRFbCB8fCByb290RWw7XG4gICAgICAgICAgICBldnQuZnJvbSA9IGZyb21FbCB8fCByb290RWw7XG4gICAgICAgICAgICBldnQuY2xvbmUgPSBjbG9uZUVsO1xuXG4gICAgICAgICAgICBldnQub2xkSW5kZXggPSBzdGFydEluZGV4O1xuICAgICAgICAgICAgZXZ0Lm5ld0luZGV4ID0gbmV3SW5kZXg7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zW29uTmFtZV0pIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zW29uTmFtZV0uY2FsbChzb3J0YWJsZSwgZXZ0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcm9vdEVsLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBhYnMgPSBNYXRoLmFicyxcbiAgICAgICAgc2xpY2UgPSBbXS5zbGljZSxcblxuICAgICAgICB0b3VjaERyYWdPdmVyTGlzdGVuZXJzID0gW10sXG5cbiAgICAgICAgX2F1dG9TY3JvbGwgPSBfdGhyb3R0bGUoZnVuY3Rpb24gKC8qKiBFdmVudCovZXZ0LCAvKiogT2JqZWN0Ki9vcHRpb25zLCAvKiogSFRNTEVsZW1lbnQqL3Jvb3RFbCkge1xuXHRcdFx0Ly8gQnVnOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD01MDU1MjFcbiAgICAgICAgICAgIGlmIChyb290RWwgJiYgb3B0aW9ucy5zY3JvbGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwsXG4gICAgICAgICAgICAgICAgICAgIHJlY3QsXG4gICAgICAgICAgICAgICAgICAgIHNlbnMgPSBvcHRpb25zLnNjcm9sbFNlbnNpdGl2aXR5LFxuICAgICAgICAgICAgICAgICAgICBzcGVlZCA9IG9wdGlvbnMuc2Nyb2xsU3BlZWQsXG5cbiAgICAgICAgICAgICAgICAgICAgeCA9IGV2dC5jbGllbnRYLFxuICAgICAgICAgICAgICAgICAgICB5ID0gZXZ0LmNsaWVudFksXG5cbiAgICAgICAgICAgICAgICAgICAgd2luV2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgd2luSGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0LFxuXG4gICAgICAgICAgICAgICAgICAgIHZ4LFxuICAgICAgICAgICAgICAgICAgICB2eVxuICAgICAgICAgICAgICAgICAgICA7XG5cblx0XHRcdFx0Ly8gRGVsZWN0IHNjcm9sbEVsXG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbFBhcmVudEVsICE9PSByb290RWwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsRWwgPSBvcHRpb25zLnNjcm9sbDtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsUGFyZW50RWwgPSByb290RWw7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjcm9sbEVsID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxFbCA9IHJvb3RFbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoc2Nyb2xsRWwub2Zmc2V0V2lkdGggPCBzY3JvbGxFbC5zY3JvbGxXaWR0aCkgfHxcblx0XHRcdFx0XHRcdFx0XHQoc2Nyb2xsRWwub2Zmc2V0SGVpZ2h0IDwgc2Nyb2xsRWwuc2Nyb2xsSGVpZ2h0KVxuXHRcdFx0XHRcdFx0XHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHRcdFx0XHRcdFx0XHQvKiBqc2hpbnQgYm9zczp0cnVlICovXG4gICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChzY3JvbGxFbCA9IHNjcm9sbEVsLnBhcmVudE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbEVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsID0gc2Nyb2xsRWw7XG4gICAgICAgICAgICAgICAgICAgIHJlY3QgPSBzY3JvbGxFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgdnggPSAoYWJzKHJlY3QucmlnaHQgLSB4KSA8PSBzZW5zKSAtIChhYnMocmVjdC5sZWZ0IC0geCkgPD0gc2Vucyk7XG4gICAgICAgICAgICAgICAgICAgIHZ5ID0gKGFicyhyZWN0LmJvdHRvbSAtIHkpIDw9IHNlbnMpIC0gKGFicyhyZWN0LnRvcCAtIHkpIDw9IHNlbnMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghKHZ4IHx8IHZ5KSkge1xuICAgICAgICAgICAgICAgICAgICB2eCA9ICh3aW5XaWR0aCAtIHggPD0gc2VucykgLSAoeCA8PSBzZW5zKTtcbiAgICAgICAgICAgICAgICAgICAgdnkgPSAod2luSGVpZ2h0IC0geSA8PSBzZW5zKSAtICh5IDw9IHNlbnMpO1xuXG5cdFx0XHRcdFx0LyoganNoaW50IGV4cHI6dHJ1ZSAqL1xuICAgICAgICAgICAgICAgICAgICAodnggfHwgdnkpICYmIChlbCA9IHdpbik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGF1dG9TY3JvbGwudnggIT09IHZ4IHx8IGF1dG9TY3JvbGwudnkgIT09IHZ5IHx8IGF1dG9TY3JvbGwuZWwgIT09IGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGF1dG9TY3JvbGwuZWwgPSBlbDtcbiAgICAgICAgICAgICAgICAgICAgYXV0b1Njcm9sbC52eCA9IHZ4O1xuICAgICAgICAgICAgICAgICAgICBhdXRvU2Nyb2xsLnZ5ID0gdnk7XG5cbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChhdXRvU2Nyb2xsLnBpZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRvU2Nyb2xsLnBpZCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWwgPT09IHdpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW4uc2Nyb2xsVG8od2luLnBhZ2VYT2Zmc2V0ICsgdnggKiBzcGVlZCwgd2luLnBhZ2VZT2Zmc2V0ICsgdnkgKiBzcGVlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdnkgJiYgKGVsLnNjcm9sbFRvcCArPSB2eSAqIHNwZWVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdnggJiYgKGVsLnNjcm9sbExlZnQgKz0gdnggKiBzcGVlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgMjQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCAzMClcbiAgICAgICAgO1xuXG5cdC8qKlxuXHQgKiBAY2xhc3MgIFNvcnRhYmxlXG5cdCAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSAgZWxcblx0ICogQHBhcmFtICB7T2JqZWN0fSAgICAgICBbb3B0aW9uc11cblx0ICovXG4gICAgZnVuY3Rpb24gU29ydGFibGUgKGVsLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuZWwgPSBlbDsgLy8gcm9vdCBlbGVtZW50XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgPSBfZXh0ZW5kKHt9LCBvcHRpb25zKTtcblxuXHRcdC8vIEV4cG9ydCBpbnN0YW5jZVxuICAgICAgICBlbFtleHBhbmRvXSA9IHRoaXM7XG5cblx0XHQvLyBEZWZhdWx0IG9wdGlvbnNcbiAgICAgICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICAgICAgZ3JvdXA6IE1hdGgucmFuZG9tKCksXG4gICAgICAgICAgICBzb3J0OiB0cnVlLFxuICAgICAgICAgICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgc3RvcmU6IG51bGwsXG4gICAgICAgICAgICBoYW5kbGU6IG51bGwsXG4gICAgICAgICAgICBzY3JvbGw6IHRydWUsXG4gICAgICAgICAgICBzY3JvbGxTZW5zaXRpdml0eTogMzAsXG4gICAgICAgICAgICBzY3JvbGxTcGVlZDogMTAsXG4gICAgICAgICAgICBkcmFnZ2FibGU6IC9bdW9dbC9pLnRlc3QoZWwubm9kZU5hbWUpID8gJ2xpJyA6ICc+KicsXG4gICAgICAgICAgICBnaG9zdENsYXNzOiAnc29ydGFibGUtZ2hvc3QnLFxuICAgICAgICAgICAgaWdub3JlOiAnYSwgaW1nJyxcbiAgICAgICAgICAgIGZpbHRlcjogbnVsbCxcbiAgICAgICAgICAgIGFuaW1hdGlvbjogMCxcbiAgICAgICAgICAgIHNldERhdGE6IGZ1bmN0aW9uIChkYXRhVHJhbnNmZXIsIGRyYWdFbCkge1xuICAgICAgICAgICAgICAgIGRhdGFUcmFuc2Zlci5zZXREYXRhKCdUZXh0JywgZHJhZ0VsLnRleHRDb250ZW50KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkcm9wQnViYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGRyYWdvdmVyQnViYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGRhdGFJZEF0dHI6ICdkYXRhLWlkJyxcbiAgICAgICAgICAgIGRlbGF5OiAwXG4gICAgICAgIH07XG5cblx0XHQvLyBTZXQgZGVmYXVsdCBvcHRpb25zXG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICEobmFtZSBpbiBvcHRpb25zKSAmJiAob3B0aW9uc1tuYW1lXSA9IGRlZmF1bHRzW25hbWVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBncm91cCA9IG9wdGlvbnMuZ3JvdXA7XG5cbiAgICAgICAgaWYgKCFncm91cCB8fCB0eXBlb2YgZ3JvdXAgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBncm91cCA9IG9wdGlvbnMuZ3JvdXAgPSB7IG5hbWU6IGdyb3VwIH07XG4gICAgICAgIH1cblxuICAgICAgICBbJ3B1bGwnLCAncHV0J10uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAoIShrZXkgaW4gZ3JvdXApKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXBba2V5XSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9wdGlvbnMuZ3JvdXBzID0gJyAnICsgZ3JvdXAubmFtZSArIChncm91cC5wdXQuam9pbiA/ICcgJyArIGdyb3VwLnB1dC5qb2luKCcgJykgOiAnJykgKyAnICc7XG5cblx0XHQvLyBCaW5kIGFsbCBwcml2YXRlIG1ldGhvZHNcbiAgICAgICAgZm9yICh2YXIgZm4gaW4gdGhpcykge1xuICAgICAgICAgICAgaWYgKGZuLmNoYXJBdCgwKSA9PT0gJ18nKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tmbl0gPSBfYmluZCh0aGlzLCB0aGlzW2ZuXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXHRcdC8vIEJpbmQgZXZlbnRzXG4gICAgICAgIF9vbihlbCwgJ21vdXNlZG93bicsIHRoaXMuX29uVGFwU3RhcnQpO1xuICAgICAgICBfb24oZWwsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25UYXBTdGFydCk7XG5cbiAgICAgICAgX29uKGVsLCAnZHJhZ292ZXInLCB0aGlzKTtcbiAgICAgICAgX29uKGVsLCAnZHJhZ2VudGVyJywgdGhpcyk7XG5cbiAgICAgICAgdG91Y2hEcmFnT3Zlckxpc3RlbmVycy5wdXNoKHRoaXMuX29uRHJhZ092ZXIpO1xuXG5cdFx0Ly8gUmVzdG9yZSBzb3J0aW5nXG4gICAgICAgIG9wdGlvbnMuc3RvcmUgJiYgdGhpcy5zb3J0KG9wdGlvbnMuc3RvcmUuZ2V0KHRoaXMpKTtcbiAgICB9XG5cbiAgICBTb3J0YWJsZS5wcm90b3R5cGUgPSAvKiogQGxlbmRzIFNvcnRhYmxlLnByb3RvdHlwZSAqLyB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiBTb3J0YWJsZSxcblxuICAgICAgICBfb25UYXBTdGFydDogZnVuY3Rpb24gKC8qKiBFdmVudHxUb3VjaEV2ZW50ICovZXZ0KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGVsID0gdGhpcy5lbCxcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgICAgIHR5cGUgPSBldnQudHlwZSxcbiAgICAgICAgICAgICAgICB0b3VjaCA9IGV2dC50b3VjaGVzICYmIGV2dC50b3VjaGVzWzBdLFxuICAgICAgICAgICAgICAgIHRhcmdldCA9ICh0b3VjaCB8fCBldnQpLnRhcmdldCxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbFRhcmdldCA9IHRhcmdldCxcbiAgICAgICAgICAgICAgICBmaWx0ZXIgPSBvcHRpb25zLmZpbHRlcjtcblxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdtb3VzZWRvd24nICYmIGV2dC5idXR0b24gIT09IDAgfHwgb3B0aW9ucy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gb25seSBsZWZ0IGJ1dHRvbiBvciBlbmFibGVkXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRhcmdldCA9IF9jbG9zZXN0KHRhcmdldCwgb3B0aW9ucy5kcmFnZ2FibGUsIGVsKTtcblxuICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cblx0XHRcdC8vIGdldCB0aGUgaW5kZXggb2YgdGhlIGRyYWdnZWQgZWxlbWVudCB3aXRoaW4gaXRzIHBhcmVudFxuICAgICAgICAgICAgb2xkSW5kZXggPSBfaW5kZXgodGFyZ2V0KTtcblxuXHRcdFx0Ly8gQ2hlY2sgZmlsdGVyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIuY2FsbCh0aGlzLCBldnQsIHRhcmdldCwgdGhpcykpIHtcbiAgICAgICAgICAgICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoX3RoaXMsIG9yaWdpbmFsVGFyZ2V0LCAnZmlsdGVyJywgdGFyZ2V0LCBlbCwgb2xkSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBjYW5jZWwgZG5kXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChmaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIgPSBmaWx0ZXIuc3BsaXQoJywnKS5zb21lKGZ1bmN0aW9uIChjcml0ZXJpYSkge1xuICAgICAgICAgICAgICAgICAgICBjcml0ZXJpYSA9IF9jbG9zZXN0KG9yaWdpbmFsVGFyZ2V0LCBjcml0ZXJpYS50cmltKCksIGVsKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY3JpdGVyaWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KF90aGlzLCBjcml0ZXJpYSwgJ2ZpbHRlcicsIHRhcmdldCwgZWwsIG9sZEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIGNhbmNlbCBkbmRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmhhbmRsZSAmJiAhX2Nsb3Nlc3Qob3JpZ2luYWxUYXJnZXQsIG9wdGlvbnMuaGFuZGxlLCBlbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cblx0XHRcdC8vIFByZXBhcmUgYGRyYWdzdGFydGBcbiAgICAgICAgICAgIHRoaXMuX3ByZXBhcmVEcmFnU3RhcnQoZXZ0LCB0b3VjaCwgdGFyZ2V0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBfcHJlcGFyZURyYWdTdGFydDogZnVuY3Rpb24gKC8qKiBFdmVudCAqL2V2dCwgLyoqIFRvdWNoICovdG91Y2gsIC8qKiBIVE1MRWxlbWVudCAqL3RhcmdldCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgICAgICAgICBlbCA9IF90aGlzLmVsLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBfdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgICAgIG93bmVyRG9jdW1lbnQgPSBlbC5vd25lckRvY3VtZW50LFxuICAgICAgICAgICAgICAgIGRyYWdTdGFydEZuO1xuXG4gICAgICAgICAgICBpZiAodGFyZ2V0ICYmICFkcmFnRWwgJiYgKHRhcmdldC5wYXJlbnROb2RlID09PSBlbCkpIHtcbiAgICAgICAgICAgICAgICB0YXBFdnQgPSBldnQ7XG5cbiAgICAgICAgICAgICAgICByb290RWwgPSBlbDtcbiAgICAgICAgICAgICAgICBkcmFnRWwgPSB0YXJnZXQ7XG4gICAgICAgICAgICAgICAgbmV4dEVsID0gZHJhZ0VsLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIGFjdGl2ZUdyb3VwID0gb3B0aW9ucy5ncm91cDtcblxuICAgICAgICAgICAgICAgIGRyYWdTdGFydEZuID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdC8vIERlbGF5ZWQgZHJhZyBoYXMgYmVlbiB0cmlnZ2VyZWRcblx0XHRcdFx0XHQvLyB3ZSBjYW4gcmUtZW5hYmxlIHRoZSBldmVudHM6IHRvdWNobW92ZS9tb3VzZW1vdmVcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2Rpc2FibGVEZWxheWVkRHJhZygpO1xuXG5cdFx0XHRcdFx0Ly8gTWFrZSB0aGUgZWxlbWVudCBkcmFnZ2FibGVcbiAgICAgICAgICAgICAgICAgICAgZHJhZ0VsLmRyYWdnYWJsZSA9IHRydWU7XG5cblx0XHRcdFx0XHQvLyBEaXNhYmxlIFwiZHJhZ2dhYmxlXCJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5pZ25vcmUuc3BsaXQoJywnKS5mb3JFYWNoKGZ1bmN0aW9uIChjcml0ZXJpYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2ZpbmQoZHJhZ0VsLCBjcml0ZXJpYS50cmltKCksIF9kaXNhYmxlRHJhZ2dhYmxlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cblx0XHRcdFx0XHQvLyBCaW5kIHRoZSBldmVudHM6IGRyYWdzdGFydC9kcmFnZW5kXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl90cmlnZ2VyRHJhZ1N0YXJ0KHRvdWNoKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgX29uKG93bmVyRG9jdW1lbnQsICdtb3VzZXVwJywgX3RoaXMuX29uRHJvcCk7XG4gICAgICAgICAgICAgICAgX29uKG93bmVyRG9jdW1lbnQsICd0b3VjaGVuZCcsIF90aGlzLl9vbkRyb3ApO1xuICAgICAgICAgICAgICAgIF9vbihvd25lckRvY3VtZW50LCAndG91Y2hjYW5jZWwnLCBfdGhpcy5fb25Ecm9wKTtcblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRlbGF5KSB7XG5cdFx0XHRcdFx0Ly8gSWYgdGhlIHVzZXIgbW92ZXMgdGhlIHBvaW50ZXIgYmVmb3JlIHRoZSBkZWxheSBoYXMgYmVlbiByZWFjaGVkOlxuXHRcdFx0XHRcdC8vIGRpc2FibGUgdGhlIGRlbGF5ZWQgZHJhZ1xuICAgICAgICAgICAgICAgICAgICBfb24ob3duZXJEb2N1bWVudCwgJ21vdXNlbW92ZScsIF90aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xuICAgICAgICAgICAgICAgICAgICBfb24ob3duZXJEb2N1bWVudCwgJ3RvdWNobW92ZScsIF90aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xuXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9kcmFnU3RhcnRUaW1lciA9IHNldFRpbWVvdXQoZHJhZ1N0YXJ0Rm4sIG9wdGlvbnMuZGVsYXkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdTdGFydEZuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9kaXNhYmxlRGVsYXllZERyYWc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvd25lckRvY3VtZW50ID0gdGhpcy5lbC5vd25lckRvY3VtZW50O1xuXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fZHJhZ1N0YXJ0VGltZXIpO1xuXG4gICAgICAgICAgICBfb2ZmKG93bmVyRG9jdW1lbnQsICdtb3VzZW1vdmUnLCB0aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xuICAgICAgICAgICAgX29mZihvd25lckRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfdHJpZ2dlckRyYWdTdGFydDogZnVuY3Rpb24gKC8qKiBUb3VjaCAqL3RvdWNoKSB7XG4gICAgICAgICAgICBpZiAodG91Y2gpIHtcblx0XHRcdFx0Ly8gVG91Y2ggZGV2aWNlIHN1cHBvcnRcbiAgICAgICAgICAgICAgICB0YXBFdnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogZHJhZ0VsLFxuICAgICAgICAgICAgICAgICAgICBjbGllbnRYOiB0b3VjaC5jbGllbnRYLFxuICAgICAgICAgICAgICAgICAgICBjbGllbnRZOiB0b3VjaC5jbGllbnRZXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX29uRHJhZ1N0YXJ0KHRhcEV2dCwgJ3RvdWNoJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzdXBwb3J0RHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25EcmFnU3RhcnQodGFwRXZ0LCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX29uKGRyYWdFbCwgJ2RyYWdlbmQnLCB0aGlzKTtcbiAgICAgICAgICAgICAgICBfb24ocm9vdEVsLCAnZHJhZ3N0YXJ0JywgdGhpcy5fb25EcmFnU3RhcnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuc2VsZWN0aW9uLmVtcHR5KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmdldFNlbGVjdGlvbigpLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9kcmFnU3RhcnRlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHJvb3RFbCAmJiBkcmFnRWwpIHtcblx0XHRcdFx0Ly8gQXBwbHkgZWZmZWN0XG4gICAgICAgICAgICAgICAgX3RvZ2dsZUNsYXNzKGRyYWdFbCwgdGhpcy5vcHRpb25zLmdob3N0Q2xhc3MsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgU29ydGFibGUuYWN0aXZlID0gdGhpcztcblxuXHRcdFx0XHQvLyBEcmFnIHN0YXJ0IGV2ZW50XG4gICAgICAgICAgICAgICAgX2Rpc3BhdGNoRXZlbnQodGhpcywgcm9vdEVsLCAnc3RhcnQnLCBkcmFnRWwsIHJvb3RFbCwgb2xkSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9lbXVsYXRlRHJhZ092ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0b3VjaEV2dCkge1xuICAgICAgICAgICAgICAgIF9jc3MoZ2hvc3RFbCwgJ2Rpc3BsYXknLCAnbm9uZScpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQodG91Y2hFdnQuY2xpZW50WCwgdG91Y2hFdnQuY2xpZW50WSksXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBOYW1lID0gJyAnICsgdGhpcy5vcHRpb25zLmdyb3VwLm5hbWUgKyAnJyxcbiAgICAgICAgICAgICAgICAgICAgaSA9IHRvdWNoRHJhZ092ZXJMaXN0ZW5lcnMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50W2V4cGFuZG9dICYmIHBhcmVudFtleHBhbmRvXS5vcHRpb25zLmdyb3Vwcy5pbmRleE9mKGdyb3VwTmFtZSkgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG91Y2hEcmFnT3Zlckxpc3RlbmVyc1tpXSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRYOiB0b3VjaEV2dC5jbGllbnRYLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50WTogdG91Y2hFdnQuY2xpZW50WSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9vdEVsOiBwYXJlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHBhcmVudDsgLy8gc3RvcmUgbGFzdCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIH1cblx0XHRcdFx0XHQvKiBqc2hpbnQgYm9zczp0cnVlICovXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2NzcyhnaG9zdEVsLCAnZGlzcGxheScsICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfb25Ub3VjaE1vdmU6IGZ1bmN0aW9uICgvKiogVG91Y2hFdmVudCovZXZ0KSB7XG4gICAgICAgICAgICBpZiAodGFwRXZ0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvdWNoID0gZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXSA6IGV2dCxcbiAgICAgICAgICAgICAgICAgICAgZHggPSB0b3VjaC5jbGllbnRYIC0gdGFwRXZ0LmNsaWVudFgsXG4gICAgICAgICAgICAgICAgICAgIGR5ID0gdG91Y2guY2xpZW50WSAtIHRhcEV2dC5jbGllbnRZLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGUzZCA9IGV2dC50b3VjaGVzID8gJ3RyYW5zbGF0ZTNkKCcgKyBkeCArICdweCwnICsgZHkgKyAncHgsMCknIDogJ3RyYW5zbGF0ZSgnICsgZHggKyAncHgsJyArIGR5ICsgJ3B4KSc7XG5cbiAgICAgICAgICAgICAgICB0b3VjaEV2dCA9IHRvdWNoO1xuXG4gICAgICAgICAgICAgICAgX2NzcyhnaG9zdEVsLCAnd2Via2l0VHJhbnNmb3JtJywgdHJhbnNsYXRlM2QpO1xuICAgICAgICAgICAgICAgIF9jc3MoZ2hvc3RFbCwgJ21velRyYW5zZm9ybScsIHRyYW5zbGF0ZTNkKTtcbiAgICAgICAgICAgICAgICBfY3NzKGdob3N0RWwsICdtc1RyYW5zZm9ybScsIHRyYW5zbGF0ZTNkKTtcbiAgICAgICAgICAgICAgICBfY3NzKGdob3N0RWwsICd0cmFuc2Zvcm0nLCB0cmFuc2xhdGUzZCk7XG5cbiAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfb25EcmFnU3RhcnQ6IGZ1bmN0aW9uICgvKiogRXZlbnQqL2V2dCwgLyoqIGJvb2xlYW4qL3VzZUZhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgZGF0YVRyYW5zZmVyID0gZXZ0LmRhdGFUcmFuc2ZlcixcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgICAgICAgICB0aGlzLl9vZmZVcEV2ZW50cygpO1xuXG4gICAgICAgICAgICBpZiAoYWN0aXZlR3JvdXAucHVsbCA9PSAnY2xvbmUnKSB7XG4gICAgICAgICAgICAgICAgY2xvbmVFbCA9IGRyYWdFbC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgX2NzcyhjbG9uZUVsLCAnZGlzcGxheScsICdub25lJyk7XG4gICAgICAgICAgICAgICAgcm9vdEVsLmluc2VydEJlZm9yZShjbG9uZUVsLCBkcmFnRWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodXNlRmFsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IGRyYWdFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgICAgICAgICAgY3NzID0gX2NzcyhkcmFnRWwpLFxuICAgICAgICAgICAgICAgICAgICBnaG9zdFJlY3Q7XG5cbiAgICAgICAgICAgICAgICBnaG9zdEVsID0gZHJhZ0VsLmNsb25lTm9kZSh0cnVlKTtcblxuICAgICAgICAgICAgICAgIF9jc3MoZ2hvc3RFbCwgJ3RvcCcsIHJlY3QudG9wIC0gcGFyc2VJbnQoY3NzLm1hcmdpblRvcCwgMTApKTtcbiAgICAgICAgICAgICAgICBfY3NzKGdob3N0RWwsICdsZWZ0JywgcmVjdC5sZWZ0IC0gcGFyc2VJbnQoY3NzLm1hcmdpbkxlZnQsIDEwKSk7XG4gICAgICAgICAgICAgICAgX2NzcyhnaG9zdEVsLCAnd2lkdGgnLCByZWN0LndpZHRoKTtcbiAgICAgICAgICAgICAgICBfY3NzKGdob3N0RWwsICdoZWlnaHQnLCByZWN0LmhlaWdodCk7XG4gICAgICAgICAgICAgICAgX2NzcyhnaG9zdEVsLCAnb3BhY2l0eScsICcwLjgnKTtcbiAgICAgICAgICAgICAgICBfY3NzKGdob3N0RWwsICdwb3NpdGlvbicsICdmaXhlZCcpO1xuICAgICAgICAgICAgICAgIF9jc3MoZ2hvc3RFbCwgJ3pJbmRleCcsICcxMDAwMDAnKTtcblxuICAgICAgICAgICAgICAgIHJvb3RFbC5hcHBlbmRDaGlsZChnaG9zdEVsKTtcblxuXHRcdFx0XHQvLyBGaXhpbmcgZGltZW5zaW9ucy5cbiAgICAgICAgICAgICAgICBnaG9zdFJlY3QgPSBnaG9zdEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIF9jc3MoZ2hvc3RFbCwgJ3dpZHRoJywgcmVjdC53aWR0aCAqIDIgLSBnaG9zdFJlY3Qud2lkdGgpO1xuICAgICAgICAgICAgICAgIF9jc3MoZ2hvc3RFbCwgJ2hlaWdodCcsIHJlY3QuaGVpZ2h0ICogMiAtIGdob3N0UmVjdC5oZWlnaHQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHVzZUZhbGxiYWNrID09PSAndG91Y2gnKSB7XG5cdFx0XHRcdFx0Ly8gQmluZCB0b3VjaCBldmVudHNcbiAgICAgICAgICAgICAgICAgICAgX29uKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xuICAgICAgICAgICAgICAgICAgICBfb24oZG9jdW1lbnQsICd0b3VjaGVuZCcsIHRoaXMuX29uRHJvcCk7XG4gICAgICAgICAgICAgICAgICAgIF9vbihkb2N1bWVudCwgJ3RvdWNoY2FuY2VsJywgdGhpcy5fb25Ecm9wKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIE9sZCBicndvc2VyXG4gICAgICAgICAgICAgICAgICAgIF9vbihkb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlKTtcbiAgICAgICAgICAgICAgICAgICAgX29uKGRvY3VtZW50LCAnbW91c2V1cCcsIHRoaXMuX29uRHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9vcElkID0gc2V0SW50ZXJ2YWwodGhpcy5fZW11bGF0ZURyYWdPdmVyLCAxNTApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkID0gJ21vdmUnO1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnNldERhdGEgJiYgb3B0aW9ucy5zZXREYXRhLmNhbGwodGhpcywgZGF0YVRyYW5zZmVyLCBkcmFnRWwpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9vbihkb2N1bWVudCwgJ2Ryb3AnLCB0aGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2V0VGltZW91dCh0aGlzLl9kcmFnU3RhcnRlZCwgMCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX29uRHJhZ092ZXI6IGZ1bmN0aW9uICgvKiogRXZlbnQqL2V2dCkge1xuICAgICAgICAgICAgdmFyIGVsID0gdGhpcy5lbCxcbiAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgZHJhZ1JlY3QsXG4gICAgICAgICAgICAgICAgcmV2ZXJ0LFxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgZ3JvdXAgPSBvcHRpb25zLmdyb3VwLFxuICAgICAgICAgICAgICAgIGdyb3VwUHV0ID0gZ3JvdXAucHV0LFxuICAgICAgICAgICAgICAgIGlzT3duZXIgPSAoYWN0aXZlR3JvdXAgPT09IGdyb3VwKSxcbiAgICAgICAgICAgICAgICBjYW5Tb3J0ID0gb3B0aW9ucy5zb3J0O1xuXG4gICAgICAgICAgICBpZiAoZXZ0LnByZXZlbnREZWZhdWx0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAhb3B0aW9ucy5kcmFnb3ZlckJ1YmJsZSAmJiBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhY3RpdmVHcm91cCAmJiAhb3B0aW9ucy5kaXNhYmxlZCAmJlxuXHRcdFx0XHQoaXNPd25lclxuXHRcdFx0XHRcdD8gY2FuU29ydCB8fCAocmV2ZXJ0ID0gIXJvb3RFbC5jb250YWlucyhkcmFnRWwpKVxuXHRcdFx0XHRcdDogYWN0aXZlR3JvdXAucHVsbCAmJiBncm91cFB1dCAmJiAoXG5cdFx0XHRcdFx0XHQoYWN0aXZlR3JvdXAubmFtZSA9PT0gZ3JvdXAubmFtZSkgfHwgLy8gYnkgTmFtZVxuXHRcdFx0XHRcdFx0KGdyb3VwUHV0LmluZGV4T2YgJiYgfmdyb3VwUHV0LmluZGV4T2YoYWN0aXZlR3JvdXAubmFtZSkpIC8vIGJ5IEFycmF5XG5cdFx0XHRcdFx0KVxuXHRcdFx0XHQpICYmXG5cdFx0XHRcdChldnQucm9vdEVsID09PSB2b2lkIDAgfHwgZXZ0LnJvb3RFbCA9PT0gdGhpcy5lbClcblx0XHRcdCkge1xuXHRcdFx0XHQvLyBTbWFydCBhdXRvLXNjcm9sbGluZ1xuICAgICAgICAgICAgICAgIF9hdXRvU2Nyb2xsKGV2dCwgb3B0aW9ucywgdGhpcy5lbCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoX3NpbGVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gX2Nsb3Nlc3QoZXZ0LnRhcmdldCwgb3B0aW9ucy5kcmFnZ2FibGUsIGVsKTtcbiAgICAgICAgICAgICAgICBkcmFnUmVjdCA9IGRyYWdFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICAgICAgICAgIGlmIChyZXZlcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgX2Nsb25lSGlkZSh0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY2xvbmVFbCB8fCBuZXh0RWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RFbC5pbnNlcnRCZWZvcmUoZHJhZ0VsLCBjbG9uZUVsIHx8IG5leHRFbCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWNhblNvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RFbC5hcHBlbmRDaGlsZChkcmFnRWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICgoZWwuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB8fCAoZWwuY2hpbGRyZW5bMF0gPT09IGdob3N0RWwpIHx8XG5cdFx0XHRcdFx0KGVsID09PSBldnQudGFyZ2V0KSAmJiAodGFyZ2V0ID0gX2dob3N0SW5Cb3R0b20oZWwsIGV2dCkpXG5cdFx0XHRcdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmFuaW1hdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0UmVjdCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIF9jbG9uZUhpZGUoaXNPd25lcik7XG5cbiAgICAgICAgICAgICAgICAgICAgZWwuYXBwZW5kQ2hpbGQoZHJhZ0VsKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0ZShkcmFnUmVjdCwgZHJhZ0VsKTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ICYmIHRoaXMuX2FuaW1hdGUodGFyZ2V0UmVjdCwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldCAmJiAhdGFyZ2V0LmFuaW1hdGVkICYmIHRhcmdldCAhPT0gZHJhZ0VsICYmICh0YXJnZXQucGFyZW50Tm9kZVtleHBhbmRvXSAhPT0gdm9pZCAwKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdEVsICE9PSB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RFbCA9IHRhcmdldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RDU1MgPSBfY3NzKHRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0UmVjdCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gdGFyZ2V0UmVjdC5yaWdodCAtIHRhcmdldFJlY3QubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IHRhcmdldFJlY3QuYm90dG9tIC0gdGFyZ2V0UmVjdC50b3AsXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdGluZyA9IC9sZWZ0fHJpZ2h0fGlubGluZS8udGVzdChsYXN0Q1NTLmNzc0Zsb2F0ICsgbGFzdENTUy5kaXNwbGF5KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzV2lkZSA9ICh0YXJnZXQub2Zmc2V0V2lkdGggPiBkcmFnRWwub2Zmc2V0V2lkdGgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNMb25nID0gKHRhcmdldC5vZmZzZXRIZWlnaHQgPiBkcmFnRWwub2Zmc2V0SGVpZ2h0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbGZ3YXkgPSAoZmxvYXRpbmcgPyAoZXZ0LmNsaWVudFggLSB0YXJnZXRSZWN0LmxlZnQpIC8gd2lkdGggOiAoZXZ0LmNsaWVudFkgLSB0YXJnZXRSZWN0LnRvcCkgLyBoZWlnaHQpID4gMC41LFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFNpYmxpbmcgPSB0YXJnZXQubmV4dEVsZW1lbnRTaWJsaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIDtcblxuICAgICAgICAgICAgICAgICAgICBfc2lsZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChfdW5zaWxlbnQsIDMwKTtcblxuICAgICAgICAgICAgICAgICAgICBfY2xvbmVIaWRlKGlzT3duZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChmbG9hdGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgPSAodGFyZ2V0LnByZXZpb3VzRWxlbWVudFNpYmxpbmcgPT09IGRyYWdFbCkgJiYgIWlzV2lkZSB8fCBoYWxmd2F5ICYmIGlzV2lkZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyID0gKG5leHRTaWJsaW5nICE9PSBkcmFnRWwpICYmICFpc0xvbmcgfHwgaGFsZndheSAmJiBpc0xvbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoYWZ0ZXIgJiYgIW5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChkcmFnRWwpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGRyYWdFbCwgYWZ0ZXIgPyBuZXh0U2libGluZyA6IHRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hbmltYXRlKGRyYWdSZWN0LCBkcmFnRWwpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hbmltYXRlKHRhcmdldFJlY3QsIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9hbmltYXRlOiBmdW5jdGlvbiAocHJldlJlY3QsIHRhcmdldCkge1xuICAgICAgICAgICAgdmFyIG1zID0gdGhpcy5vcHRpb25zLmFuaW1hdGlvbjtcblxuICAgICAgICAgICAgaWYgKG1zKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRSZWN0ID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgICAgICAgICAgX2Nzcyh0YXJnZXQsICd0cmFuc2l0aW9uJywgJ25vbmUnKTtcbiAgICAgICAgICAgICAgICBfY3NzKHRhcmdldCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUzZCgnICtcblx0XHRcdFx0XHQocHJldlJlY3QubGVmdCAtIGN1cnJlbnRSZWN0LmxlZnQpICsgJ3B4LCcgK1xuXHRcdFx0XHRcdChwcmV2UmVjdC50b3AgLSBjdXJyZW50UmVjdC50b3ApICsgJ3B4LDApJ1xuXHRcdFx0XHQpO1xuXG4gICAgICAgICAgICAgICAgdGFyZ2V0Lm9mZnNldFdpZHRoOyAvLyByZXBhaW50XG5cbiAgICAgICAgICAgICAgICBfY3NzKHRhcmdldCwgJ3RyYW5zaXRpb24nLCAnYWxsICcgKyBtcyArICdtcycpO1xuICAgICAgICAgICAgICAgIF9jc3ModGFyZ2V0LCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZTNkKDAsMCwwKScpO1xuXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRhcmdldC5hbmltYXRlZCk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LmFuaW1hdGVkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jc3ModGFyZ2V0LCAndHJhbnNpdGlvbicsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgX2Nzcyh0YXJnZXQsICd0cmFuc2Zvcm0nLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5hbmltYXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0sIG1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfb2ZmVXBFdmVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvd25lckRvY3VtZW50ID0gdGhpcy5lbC5vd25lckRvY3VtZW50O1xuXG4gICAgICAgICAgICBfb2ZmKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xuICAgICAgICAgICAgX29mZihvd25lckRvY3VtZW50LCAnbW91c2V1cCcsIHRoaXMuX29uRHJvcCk7XG4gICAgICAgICAgICBfb2ZmKG93bmVyRG9jdW1lbnQsICd0b3VjaGVuZCcsIHRoaXMuX29uRHJvcCk7XG4gICAgICAgICAgICBfb2ZmKG93bmVyRG9jdW1lbnQsICd0b3VjaGNhbmNlbCcsIHRoaXMuX29uRHJvcCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX29uRHJvcDogZnVuY3Rpb24gKC8qKiBFdmVudCovZXZ0KSB7XG4gICAgICAgICAgICB2YXIgZWwgPSB0aGlzLmVsLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fbG9vcElkKTtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoYXV0b1Njcm9sbC5waWQpO1xuXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kcmFnU3RhcnRUaW1lcik7XG5cblx0XHRcdC8vIFVuYmluZCBldmVudHNcbiAgICAgICAgICAgIF9vZmYoZG9jdW1lbnQsICdkcm9wJywgdGhpcyk7XG4gICAgICAgICAgICBfb2ZmKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xuICAgICAgICAgICAgX29mZihlbCwgJ2RyYWdzdGFydCcsIHRoaXMuX29uRHJhZ1N0YXJ0KTtcblxuICAgICAgICAgICAgdGhpcy5fb2ZmVXBFdmVudHMoKTtcblxuICAgICAgICAgICAgaWYgKGV2dCkge1xuICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICFvcHRpb25zLmRyb3BCdWJibGUgJiYgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICAgICAgZ2hvc3RFbCAmJiBnaG9zdEVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZ2hvc3RFbCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZHJhZ0VsKSB7XG4gICAgICAgICAgICAgICAgICAgIF9vZmYoZHJhZ0VsLCAnZHJhZ2VuZCcsIHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgICAgIF9kaXNhYmxlRHJhZ2dhYmxlKGRyYWdFbCk7XG4gICAgICAgICAgICAgICAgICAgIF90b2dnbGVDbGFzcyhkcmFnRWwsIHRoaXMub3B0aW9ucy5naG9zdENsYXNzLCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvb3RFbCAhPT0gZHJhZ0VsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0luZGV4ID0gX2luZGV4KGRyYWdFbCk7XG5cblx0XHRcdFx0XHRcdC8vIGRyYWcgZnJvbSBvbmUgbGlzdCBhbmQgZHJvcCBpbnRvIGFub3RoZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KG51bGwsIGRyYWdFbC5wYXJlbnROb2RlLCAnc29ydCcsIGRyYWdFbCwgcm9vdEVsLCBvbGRJbmRleCwgbmV3SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2Rpc3BhdGNoRXZlbnQodGhpcywgcm9vdEVsLCAnc29ydCcsIGRyYWdFbCwgcm9vdEVsLCBvbGRJbmRleCwgbmV3SW5kZXgpO1xuXG5cdFx0XHRcdFx0XHQvLyBBZGQgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KG51bGwsIGRyYWdFbC5wYXJlbnROb2RlLCAnYWRkJywgZHJhZ0VsLCByb290RWwsIG9sZEluZGV4LCBuZXdJbmRleCk7XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSBldmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgX2Rpc3BhdGNoRXZlbnQodGhpcywgcm9vdEVsLCAncmVtb3ZlJywgZHJhZ0VsLCByb290RWwsIG9sZEluZGV4LCBuZXdJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgY2xvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lRWwgJiYgY2xvbmVFbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNsb25lRWwpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHJhZ0VsLm5leHRTaWJsaW5nICE9PSBuZXh0RWwpIHtcblx0XHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSBpbmRleCBvZiB0aGUgZHJhZ2dlZCBlbGVtZW50IHdpdGhpbiBpdHMgcGFyZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3SW5kZXggPSBfaW5kZXgoZHJhZ0VsKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBkcmFnICYgZHJvcCB3aXRoaW4gdGhlIHNhbWUgbGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KHRoaXMsIHJvb3RFbCwgJ3VwZGF0ZScsIGRyYWdFbCwgcm9vdEVsLCBvbGRJbmRleCwgbmV3SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KHRoaXMsIHJvb3RFbCwgJ3NvcnQnLCBkcmFnRWwsIHJvb3RFbCwgb2xkSW5kZXgsIG5ld0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG5cdFx0XHRcdFx0Ly8gRHJhZyBlbmQgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgU29ydGFibGUuYWN0aXZlICYmIF9kaXNwYXRjaEV2ZW50KHRoaXMsIHJvb3RFbCwgJ2VuZCcsIGRyYWdFbCwgcm9vdEVsLCBvbGRJbmRleCwgbmV3SW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cblxuXHRcdFx0XHQvLyBOdWxsaW5nXG4gICAgICAgICAgICAgICAgcm9vdEVsID1cblx0XHRcdFx0ZHJhZ0VsID1cblx0XHRcdFx0Z2hvc3RFbCA9XG5cdFx0XHRcdG5leHRFbCA9XG5cdFx0XHRcdGNsb25lRWwgPVxuXG5cdFx0XHRcdHNjcm9sbEVsID1cblx0XHRcdFx0c2Nyb2xsUGFyZW50RWwgPVxuXG5cdFx0XHRcdHRhcEV2dCA9XG5cdFx0XHRcdHRvdWNoRXZ0ID1cblxuXHRcdFx0XHRsYXN0RWwgPVxuXHRcdFx0XHRsYXN0Q1NTID1cblxuXHRcdFx0XHRhY3RpdmVHcm91cCA9XG5cdFx0XHRcdFNvcnRhYmxlLmFjdGl2ZSA9IG51bGw7XG5cblx0XHRcdFx0Ly8gU2F2ZSBzb3J0aW5nXG4gICAgICAgICAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlRXZlbnQ6IGZ1bmN0aW9uICgvKiogRXZlbnQqL2V2dCkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBldnQudHlwZTtcblxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdkcmFnb3ZlcicgfHwgdHlwZSA9PT0gJ2RyYWdlbnRlcicpIHtcbiAgICAgICAgICAgICAgICBpZiAoZHJhZ0VsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uRHJhZ092ZXIoZXZ0KTtcbiAgICAgICAgICAgICAgICAgICAgX2dsb2JhbERyYWdPdmVyKGV2dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnZHJvcCcgfHwgdHlwZSA9PT0gJ2RyYWdlbmQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25Ecm9wKGV2dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cblx0XHQvKipcblx0XHQgKiBTZXJpYWxpemVzIHRoZSBpdGVtIGludG8gYW4gYXJyYXkgb2Ygc3RyaW5nLlxuXHRcdCAqIEByZXR1cm5zIHtTdHJpbmdbXX1cblx0XHQgKi9cbiAgICAgICAgdG9BcnJheTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9yZGVyID0gW10sXG4gICAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gPSB0aGlzLmVsLmNoaWxkcmVuLFxuICAgICAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgICAgIG4gPSBjaGlsZHJlbi5sZW5ndGgsXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgICAgICAgICAgZm9yICg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBlbCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmIChfY2xvc2VzdChlbCwgb3B0aW9ucy5kcmFnZ2FibGUsIHRoaXMuZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9yZGVyLnB1c2goZWwuZ2V0QXR0cmlidXRlKG9wdGlvbnMuZGF0YUlkQXR0cikgfHwgX2dlbmVyYXRlSWQoZWwpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvcmRlcjtcbiAgICAgICAgfSxcblxuXHRcdC8qKlxuXHRcdCAqIFNvcnRzIHRoZSBlbGVtZW50cyBhY2NvcmRpbmcgdG8gdGhlIGFycmF5LlxuXHRcdCAqIEBwYXJhbSAge1N0cmluZ1tdfSAgb3JkZXIgIG9yZGVyIG9mIHRoZSBpdGVtc1xuXHRcdCAqL1xuICAgICAgICBzb3J0OiBmdW5jdGlvbiAob3JkZXIpIHtcbiAgICAgICAgICAgIHZhciBpdGVtcyA9IHt9LCByb290RWwgPSB0aGlzLmVsO1xuXG4gICAgICAgICAgICB0aGlzLnRvQXJyYXkoKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCwgaSkge1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IHJvb3RFbC5jaGlsZHJlbltpXTtcblxuICAgICAgICAgICAgICAgIGlmIChfY2xvc2VzdChlbCwgdGhpcy5vcHRpb25zLmRyYWdnYWJsZSwgcm9vdEVsKSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtc1tpZF0gPSBlbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgb3JkZXIuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbXNbaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RFbC5yZW1vdmVDaGlsZChpdGVtc1tpZF0pO1xuICAgICAgICAgICAgICAgICAgICByb290RWwuYXBwZW5kQ2hpbGQoaXRlbXNbaWRdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuXHRcdC8qKlxuXHRcdCAqIFNhdmUgdGhlIGN1cnJlbnQgc29ydGluZ1xuXHRcdCAqL1xuICAgICAgICBzYXZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3RvcmUgPSB0aGlzLm9wdGlvbnMuc3RvcmU7XG4gICAgICAgICAgICBzdG9yZSAmJiBzdG9yZS5zZXQodGhpcyk7XG4gICAgICAgIH0sXG5cblx0XHQvKipcblx0XHQgKiBGb3IgZWFjaCBlbGVtZW50IGluIHRoZSBzZXQsIGdldCB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IG1hdGNoZXMgdGhlIHNlbGVjdG9yIGJ5IHRlc3RpbmcgdGhlIGVsZW1lbnQgaXRzZWxmIGFuZCB0cmF2ZXJzaW5nIHVwIHRocm91Z2ggaXRzIGFuY2VzdG9ycyBpbiB0aGUgRE9NIHRyZWUuXG5cdFx0ICogQHBhcmFtICAge0hUTUxFbGVtZW50fSAgZWxcblx0XHQgKiBAcGFyYW0gICB7U3RyaW5nfSAgICAgICBbc2VsZWN0b3JdICBkZWZhdWx0OiBgb3B0aW9ucy5kcmFnZ2FibGVgXG5cdFx0ICogQHJldHVybnMge0hUTUxFbGVtZW50fG51bGx9XG5cdFx0ICovXG4gICAgICAgIGNsb3Nlc3Q6IGZ1bmN0aW9uIChlbCwgc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBfY2xvc2VzdChlbCwgc2VsZWN0b3IgfHwgdGhpcy5vcHRpb25zLmRyYWdnYWJsZSwgdGhpcy5lbCk7XG4gICAgICAgIH0sXG5cblx0XHQvKipcblx0XHQgKiBTZXQvZ2V0IG9wdGlvblxuXHRcdCAqIEBwYXJhbSAgIHtzdHJpbmd9IG5hbWVcblx0XHQgKiBAcGFyYW0gICB7Kn0gICAgICBbdmFsdWVdXG5cdFx0ICogQHJldHVybnMgeyp9XG5cdFx0ICovXG4gICAgICAgIG9wdGlvbjogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9uc1tuYW1lXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG5cdFx0LyoqXG5cdFx0ICogRGVzdHJveVxuXHRcdCAqL1xuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZWwgPSB0aGlzLmVsO1xuXG4gICAgICAgICAgICBlbFtleHBhbmRvXSA9IG51bGw7XG5cbiAgICAgICAgICAgIF9vZmYoZWwsICdtb3VzZWRvd24nLCB0aGlzLl9vblRhcFN0YXJ0KTtcbiAgICAgICAgICAgIF9vZmYoZWwsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25UYXBTdGFydCk7XG5cbiAgICAgICAgICAgIF9vZmYoZWwsICdkcmFnb3ZlcicsIHRoaXMpO1xuICAgICAgICAgICAgX29mZihlbCwgJ2RyYWdlbnRlcicsIHRoaXMpO1xuXG5cdFx0XHQvLyBSZW1vdmUgZHJhZ2dhYmxlIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoZWwucXVlcnlTZWxlY3RvckFsbCgnW2RyYWdnYWJsZV0nKSwgZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdkcmFnZ2FibGUnKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0b3VjaERyYWdPdmVyTGlzdGVuZXJzLnNwbGljZSh0b3VjaERyYWdPdmVyTGlzdGVuZXJzLmluZGV4T2YodGhpcy5fb25EcmFnT3ZlciksIDEpO1xuXG4gICAgICAgICAgICB0aGlzLl9vbkRyb3AoKTtcblxuICAgICAgICAgICAgdGhpcy5lbCA9IGVsID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfY2xvbmVIaWRlIChzdGF0ZSkge1xuICAgICAgICBpZiAoY2xvbmVFbCAmJiAoY2xvbmVFbC5zdGF0ZSAhPT0gc3RhdGUpKSB7XG4gICAgICAgICAgICBfY3NzKGNsb25lRWwsICdkaXNwbGF5Jywgc3RhdGUgPyAnbm9uZScgOiAnJyk7XG4gICAgICAgICAgICAhc3RhdGUgJiYgY2xvbmVFbC5zdGF0ZSAmJiByb290RWwuaW5zZXJ0QmVmb3JlKGNsb25lRWwsIGRyYWdFbCk7XG4gICAgICAgICAgICBjbG9uZUVsLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfYmluZCAoY3R4LCBmbikge1xuICAgICAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICAgICAgcmV0dXJuXHRmbi5iaW5kID8gZm4uYmluZC5hcHBseShmbiwgW2N0eF0uY29uY2F0KGFyZ3MpKSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShjdHgsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9jbG9zZXN0ICgvKiogSFRNTEVsZW1lbnQqL2VsLCAvKiogU3RyaW5nKi9zZWxlY3RvciwgLyoqIEhUTUxFbGVtZW50Ki9jdHgpIHtcbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICBjdHggPSBjdHggfHwgZG9jdW1lbnQ7XG4gICAgICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnNwbGl0KCcuJyk7XG5cbiAgICAgICAgICAgIHZhciB0YWcgPSBzZWxlY3Rvci5zaGlmdCgpLnRvVXBwZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgcmUgPSBuZXcgUmVnRXhwKCdcXFxccygnICsgc2VsZWN0b3Iuam9pbignfCcpICsgJylcXFxccycsICdnJyk7XG5cbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBpZiAoXG5cdFx0XHRcdFx0KHRhZyA9PT0gJz4qJyAmJiBlbC5wYXJlbnROb2RlID09PSBjdHgpIHx8IChcblx0XHRcdFx0XHRcdCh0YWcgPT09ICcnIHx8IGVsLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT0gdGFnKSAmJlxuXHRcdFx0XHRcdFx0KCFzZWxlY3Rvci5sZW5ndGggfHwgKCgnICcgKyBlbC5jbGFzc05hbWUgKyAnICcpLm1hdGNoKHJlKSB8fCBbXSkubGVuZ3RoID09IHNlbGVjdG9yLmxlbmd0aClcblx0XHRcdFx0XHQpXG5cdFx0XHRcdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGVsICE9PSBjdHggJiYgKGVsID0gZWwucGFyZW50Tm9kZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2dsb2JhbERyYWdPdmVyICgvKiogRXZlbnQqL2V2dCkge1xuICAgICAgICBldnQuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSAnbW92ZSc7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9vbiAoZWwsIGV2ZW50LCBmbikge1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBmbiwgZmFsc2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9vZmYgKGVsLCBldmVudCwgZm4pIHtcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgZm4sIGZhbHNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfdG9nZ2xlQ2xhc3MgKGVsLCBuYW1lLCBzdGF0ZSkge1xuICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICAgICAgICAgICAgICBlbC5jbGFzc0xpc3Rbc3RhdGUgPyAnYWRkJyA6ICdyZW1vdmUnXShuYW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9ICgnICcgKyBlbC5jbGFzc05hbWUgKyAnICcpLnJlcGxhY2UoUlNQQUNFLCAnICcpLnJlcGxhY2UoJyAnICsgbmFtZSArICcgJywgJyAnKTtcbiAgICAgICAgICAgICAgICBlbC5jbGFzc05hbWUgPSAoY2xhc3NOYW1lICsgKHN0YXRlID8gJyAnICsgbmFtZSA6ICcnKSkucmVwbGFjZShSU1BBQ0UsICcgJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfY3NzIChlbCwgcHJvcCwgdmFsKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IGVsICYmIGVsLnN0eWxlO1xuXG4gICAgICAgIGlmIChzdHlsZSkge1xuICAgICAgICAgICAgaWYgKHZhbCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LmRlZmF1bHRWaWV3ICYmIGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgJycpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZWwuY3VycmVudFN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IGVsLmN1cnJlbnRTdHlsZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcCA9PT0gdm9pZCAwID8gdmFsIDogdmFsW3Byb3BdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIShwcm9wIGluIHN0eWxlKSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9wID0gJy13ZWJraXQtJyArIHByb3A7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3R5bGVbcHJvcF0gPSB2YWwgKyAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyAnJyA6ICdweCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2ZpbmQgKGN0eCwgdGFnTmFtZSwgaXRlcmF0b3IpIHtcbiAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgdmFyIGxpc3QgPSBjdHguZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnTmFtZSksIGkgPSAwLCBuID0gbGlzdC5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmIChpdGVyYXRvcikge1xuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yKGxpc3RbaV0sIGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2Rpc2FibGVEcmFnZ2FibGUgKGVsKSB7XG4gICAgICAgIGVsLmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF91bnNpbGVudCAoKSB7XG4gICAgICAgIF9zaWxlbnQgPSBmYWxzZTtcbiAgICB9XG5cblx0LyoqIEByZXR1cm5zIHtIVE1MRWxlbWVudHxmYWxzZX0gKi9cbiAgICBmdW5jdGlvbiBfZ2hvc3RJbkJvdHRvbSAoZWwsIGV2dCkge1xuICAgICAgICB2YXIgbGFzdEVsID0gZWwubGFzdEVsZW1lbnRDaGlsZCwgcmVjdCA9IGxhc3RFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgcmV0dXJuIChldnQuY2xpZW50WSAtIChyZWN0LnRvcCArIHJlY3QuaGVpZ2h0KSA+IDUpICYmIGxhc3RFbDsgLy8gbWluIGRlbHRhXG4gICAgfVxuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSBpZFxuXHQgKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9IGVsXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICAgIGZ1bmN0aW9uIF9nZW5lcmF0ZUlkIChlbCkge1xuICAgICAgICB2YXIgc3RyID0gZWwudGFnTmFtZSArIGVsLmNsYXNzTmFtZSArIGVsLnNyYyArIGVsLmhyZWYgKyBlbC50ZXh0Q29udGVudCxcbiAgICAgICAgICAgIGkgPSBzdHIubGVuZ3RoLFxuICAgICAgICAgICAgc3VtID0gMDtcblxuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBzdW0gKz0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3VtLnRvU3RyaW5nKDM2KTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGluZGV4IG9mIGFuIGVsZW1lbnQgd2l0aGluIGl0cyBwYXJlbnRcblx0ICogQHBhcmFtIGVsXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICAgIGZ1bmN0aW9uIF9pbmRleCAoLyoqIEhUTUxFbGVtZW50Ki9lbCkge1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAoZWwgJiYgKGVsID0gZWwucHJldmlvdXNFbGVtZW50U2libGluZykpIHtcbiAgICAgICAgICAgIGlmIChlbC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpICE9PSAnVEVNUExBVEUnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3Rocm90dGxlIChjYWxsYmFjaywgbXMpIHtcbiAgICAgICAgdmFyIGFyZ3MsIF90aGlzO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoYXJncyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKF90aGlzLCBhcmdzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KF90aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgfSwgbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9leHRlbmQgKGRzdCwgc3JjKSB7XG4gICAgICAgIGlmIChkc3QgJiYgc3JjKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNyYy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRzdFtrZXldID0gc3JjW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRzdDtcbiAgICB9XG5cblx0Ly8gRXhwb3J0IHV0aWxzXG4gICAgU29ydGFibGUudXRpbHMgPSB7XG4gICAgICAgIG9uOiBfb24sXG4gICAgICAgIG9mZjogX29mZixcbiAgICAgICAgY3NzOiBfY3NzLFxuICAgICAgICBmaW5kOiBfZmluZCxcbiAgICAgICAgYmluZDogX2JpbmQsXG4gICAgICAgIGlzOiBmdW5jdGlvbiAoZWwsIHNlbGVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gISFfY2xvc2VzdChlbCwgc2VsZWN0b3IsIGVsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXh0ZW5kOiBfZXh0ZW5kLFxuICAgICAgICB0aHJvdHRsZTogX3Rocm90dGxlLFxuICAgICAgICBjbG9zZXN0OiBfY2xvc2VzdCxcbiAgICAgICAgdG9nZ2xlQ2xhc3M6IF90b2dnbGVDbGFzcyxcbiAgICAgICAgaW5kZXg6IF9pbmRleFxuICAgIH07XG5cbiAgICBTb3J0YWJsZS52ZXJzaW9uID0gJzEuMi4wJztcblxuXHQvKipcblx0ICogQ3JlYXRlIHNvcnRhYmxlIGluc3RhbmNlXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9ICBlbFxuXHQgKiBAcGFyYW0ge09iamVjdH0gICAgICBbb3B0aW9uc11cblx0ICovXG4gICAgU29ydGFibGUuY3JlYXRlID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgU29ydGFibGUoZWwsIG9wdGlvbnMpO1xuICAgIH07XG5cblx0Ly8gRXhwb3J0XG4gICAgcmV0dXJuIFNvcnRhYmxlO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGx1Z2lucy9Tb3J0YWJsZS5qcyIsIi8qZXNsaW50LWRpc2FibGUqL1xuLy8gdG9vIG1hbnkgZXNsaW50IHZpb2xhdGlvbnMsIHRoaXMgZmlsZSBoYXMgYSBoaWdoIHJpc2sgb2YgYmVpbmcgZGFtYWdlZFxuLy8gYnkgZXNsaW50IG1vZGlmaWNhdGlvbnNcbmltcG9ydCBTb3J0YWJsZSBmcm9tICcuL1NvcnRhYmxlJztcbmltcG9ydCAqIGFzIHNvdXJjZXMgZnJvbSAnLi9zb3VyY2VzJztcblxuZnVuY3Rpb24gdGVsbE1hc3RlclNoaW0gKG1lc3NhZ2UpIHtcbiAgICB3aW5kb3cudG9wLnBvc3RNZXNzYWdlKE9iamVjdC5hc3NpZ24obWVzc2FnZSwge1xuICAgICAgICBzb3VyY2U6IHNvdXJjZXMucGx1Z2luLFxuICAgICAgICBkZXN0aW5hdGlvbjogc291cmNlcy5kZXNpZ25lclxuICAgIH0pLCAnKicpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzZWxlY3Rpb24gKHdpbmRvdywgZG9jdW1lbnQpIHtcbiAgICB2YXIgc2VsbW8gPSB3aW5kb3cuc2VsbW8gPSB7fTtcblxuICAgIC8vIFRPRE86IFN1cHBvcnQgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICB2YXIgYXR0YWNoRXZlbnQgPSBwZW5kby5kZXNpZ25lci5hdHRhY2hFdmVudDtcbiAgICB2YXIgU2l6emxlID0gcGVuZG8uZGVzaWduZXIuc2l6emxlO1xuICAgIHZhciB0ZWxsTWFzdGVyID0gdGVsbE1hc3RlclNoaW07XG4gICAgdmFyIHJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIgPSBwZW5kby5kZXNpZ25lci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyO1xuICAgIHZhciBwbGFjZUJhZGdlID0gcGVuZG8uZGVzaWduZXIucGxhY2VCYWRnZTtcbiAgICB2YXIgZG9tID0gcGVuZG8uZGVzaWduZXIuZG9tO1xuICAgIHZhciBfID0gcGVuZG8uZGVzaWduZXIuXyB8fCBwZW5kby5fO1xuICAgIHZhciBsb2cgPSBwZW5kby5kZXNpZ25lci5sb2c7XG4gICAgdmFyIHN0b3BHdWlkZXMgPSBwZW5kby5kZXNpZ25lci5zdG9wR3VpZGVzO1xuICAgIHZhciByZW1vdmVBbGxCYWRnZXMgPSBwZW5kby5kZXNpZ25lci5yZW1vdmVBbGxCYWRnZXM7XG4gICAgdmFyIERFRkFVTFRfVElNRVJfTEVOR1RIID0gcGVuZG8uZGVzaWduZXIuREVGQVVMVF9USU1FUl9MRU5HVEg7XG4gICAgdmFyIHJlbW92ZUxhdW5jaGVyID0gcGVuZG8uZGVzaWduZXIucmVtb3ZlTGF1bmNoZXI7XG4gICAgdmFyIGNyZWF0ZUxhdW5jaGVyID0gcGVuZG8uZGVzaWduZXIuY3JlYXRlTGF1bmNoZXI7XG4gICAgdmFyIGFkZEd1aWRlVG9MYXVuY2hlciA9IHBlbmRvLmRlc2lnbmVyLmFkZEd1aWRlVG9MYXVuY2hlciB8fCBwZW5kby5fYWRkR3VpZGVUb0xhdW5jaGVyO1xuICAgIHZhciB1cGRhdGVMYXVuY2hlckNvbnRlbnQgPSBwZW5kby5kZXNpZ25lci51cGRhdGVMYXVuY2hlckNvbnRlbnQ7XG4gICAgdmFyIGdldE9mZnNldFBvc2l0aW9uID0gcGVuZG8uZGVzaWduZXIuZ2V0T2Zmc2V0UG9zaXRpb247XG4gICAgdmFyIGdldFNjcmVlbkRpbWVuc2lvbnMgPSBwZW5kby5kZXNpZ25lci5nZXRTY3JlZW5EaW1lbnNpb25zO1xuICAgIHZhciB3aGVuTG9hZGVkQ2FsbCA9IHBlbmRvLmRlc2lnbmVyLndoZW5Mb2FkZWRDYWxsO1xuICAgIHZhciBHdWlkZUZhY3RvcnkgPSBwZW5kby5kZXNpZ25lci5HdWlkZUZhY3Rvcnk7XG4gICAgdmFyIEd1aWRlU3RlcCA9IHBlbmRvLmRlc2lnbmVyLkd1aWRlU3RlcDtcbiAgICB2YXIgbG9hZEd1aWRlQ3NzID0gcGVuZG8uZGVzaWduZXIubG9hZEd1aWRlQ3NzIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgIHZhciBhcmVHdWlkZXNFbmFibGVkID0gcGVuZG8uZGVzaWduZXIuYXJlR3VpZGVzRW5hYmxlZDtcbiAgICB2YXIgc2hvd0xhdW5jaGVyID0gcGVuZG8uc2hvd0xhdW5jaGVyO1xuICAgIHZhciBoaWRlTGF1bmNoZXIgPSBwZW5kby5oaWRlTGF1bmNoZXI7XG4gICAgdmFyIGdldFZpc2l0b3JJZCA9IHBlbmRvLmdldFZpc2l0b3JJZDtcblxuICAgIHZhciBleHRyYWN0RWxlbWVudFRyZWVDb250ZXh0ID0gcGVuZG8uZGVzaWduZXIuZXh0cmFjdEVsZW1lbnRUcmVlQ29udGV4dCB8fCBleHRyYWN0RWxlbWVudFRyZWVDb250ZXh0QmFja0ZpbGw7XG5cbiAgICAvLyBBZGQgb250aC1jaGlsZCBwc2V1ZG8gc2VsZWN0b3IgdG8gc3VwcG9ydCBvbGQgKGJyb2tlbikgbnRoLWNoaWxkIGltcGxlbWVudGF0aW9uXG4gICAgU2l6emxlLnNlbGVjdG9ycy5wc2V1ZG9zWydvbnRoLWNoaWxkJ10gPSBTaXp6bGUuc2VsZWN0b3JzLmNyZWF0ZVBzZXVkbyhmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdmFyIGkgPSBwYXJzZUludChpbmRleCwgMTApO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBpZiAoaXNOYU4oaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWxlbSA9PT0gcGFyZW50LmNoaWxkTm9kZXNbaV07XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICB2YXIgZ2V0Qm9keSA9IGRvbS5nZXRCb2R5IHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmJvZHk7XG4gICAgfTtcblxuICAgIGlmIChHdWlkZVN0ZXApIHtcbiAgICAgICAgR3VpZGVTdGVwLmJlaGF2aW9ycy5wdXNoKGZ1bmN0aW9uIFByZXZpZXcgKCkge1xuICAgICAgICAgICAgdmFyIHN0ZXAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGZpeGVkVGFyZ2V0LFxuICAgICAgICAgICAgICAgIHdhcm5pbmdSZWFzb247XG5cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICBUaGlzIGlzIHRvIFwidHJpY2tcIiB0aGUgdG9vbHRpcCByZW5kZXJlciBpbnRvIHNob3dpbmcgdGhlIHRvb2x0aXBcbiAgICAgICAgICAgIHdpdGggZml4ZWQgcG9zaXRpb24gc28gdGhhdCB0aGUgYm9keSBkb2Vzbid0IHNjcm9sbC5cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBmaXhlZFRhcmdldCA9IGRvbSgnPGRpdj4nKS5jc3Moe1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICAgICAgICAgICdwb2ludGVyLWV2ZW50cyc6ICdub25lJ1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBjZW50ZXJGbG9hdGluZ1Rvb2x0aXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdhcm5pbmdSZWFzb24gJiYgc3RlcC5pc1Nob3duKCkgJiYgc3RlcC50eXBlID09ICd0b29sdGlwJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBDZW50ZXIgYW5kIGZpeGVkIHBvc2l0aW9uIHRoZSBndWlkZVxuICAgICAgICAgICAgICAgICAgICB2YXIgc2NyZWVuID0gZ2V0U2NyZWVuRGltZW5zaW9ucygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ3VpZGUgPSBkb20oJy5fcGVuZG8tZ3VpZGVfJyk7XG4gICAgICAgICAgICAgICAgICAgIGd1aWRlLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IE1hdGguZmxvb3IoKHNjcmVlbi53aWR0aCAtIGd1aWRlLndpZHRoKCkpIC8gMiksXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IE1hdGguZmxvb3IoKHNjcmVlbi5oZWlnaHQgLSBndWlkZS5oZWlnaHQoKSkgLyAyKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBzdGVwLmNhblNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7Ly8gUHJldmlld3MgY2FuIGFsd2F5cyBzaG93XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBzdGVwLmJlZm9yZSgncmVuZGVyJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHdhcm5pbmdSZWFzb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghc3RlcC5jYW5TaG93T25QYWdlKHBlbmRvLmdldEN1cnJlbnRVcmwoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gR3VpZGUgbm90IG1lYW50IGZvciB0aGlzIHBhZ2VcbiAgICAgICAgICAgICAgICAgICAgd2FybmluZ1JlYXNvbiA9ICdwYWdlJztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0ZXAuZWxlbWVudFBhdGhSdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IFNpenpsZShzdGVwLmVsZW1lbnRQYXRoUnVsZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBtYXRjaGVzIGZvdW5kXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuaW5nUmVhc29uID0gJ2VsZW1lbnROb3RGb3VuZCc7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIV8uYW55KGVsZW1lbnRzLCBzZWxtby5pc0VsZW1lbnRWaXNpYmxlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2hlcyBmb3VuZCwgYnV0IG5vIG1hdGNoZXMgYXJlIHZpc2libGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5pbmdSZWFzb24gPSAnZWxlbWVudE5vdFZpc2libGUnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHdhcm5pbmdSZWFzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHN0ZXAuZWxlbWVudFBhdGhSdWxlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGVwLnR5cGUgPT0gJ3Rvb2x0aXAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXhlZFRhcmdldC5hcHBlbmRUbygnYm9keScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RlcC5vdmVycmlkZUVsZW1lbnQgPSBmaXhlZFRhcmdldFswXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBzdGVwLmFmdGVyKCdyZW5kZXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdhcm5pbmdSZWFzb24gJiYgc3RlcC5pc1Nob3duKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVsbE1hc3Rlcih7IHR5cGU6ICdwcmV2aWV3LXdhcm5pbmcnLCByZWFzb246IHdhcm5pbmdSZWFzb24gfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgY2VudGVyRmxvYXRpbmdUb29sdGlwKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHN0ZXAuYWZ0ZXIoJ2hpZGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZml4ZWRUYXJnZXQucmVtb3ZlKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgc3RlcC5hZnRlcigncmVwb3NpdGlvbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjZW50ZXJGbG9hdGluZ1Rvb2x0aXAoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gTk9URTogIFRoZXNlIG5leHQgdHdvIGZ1bmN0aW9uczogZ2V0U2Nyb2xsUGFyZW50IGFuZCBpc0VsZW1lbnRWaXNpYmxlXG4gICAgLy8gICAgICAgIGFyZSBub3cgYnVpbGQgaW50byB0aGUgQWdlbnQgYXMgb2YgdmVyc2lvbiAxLjIuMS4gIEZyb21cbiAgICAvLyAgICAgICAgdGhhdCBwb2ludCBvbiB0aGlzIGRlc2lnbmVyIHBsdWdpbiB3aWxsIHVzZSB0aGVcbiAgICAvLyAgICAgICAgZnVuY3Rpb25zIHByb3ZpZGVkIGJ5IHRoZSBhZ2VudCBpbnN0ZWFkIG9mIHJlZGVmaW5pbmdcbiAgICAvLyAgICAgICAgaXRzIG93bi4gIEZvciBub3csIHVudGlsIGl0J3MgcmVhZHkgdGhleSB3aWxsIGJlXG4gICAgLy8gICAgICAgIGF2YWlsYWJsZSBsb2NhbGx5IGRlZmluZWQganVzdCB0byBiZSBzYWZlLlxuXG4gICAgLy8gQmFzaWNhbGx5IHRoZSBzYW1lIHNjcm9sbCBwYXJlbnQgdXRpbGl0eSBzZWVuIHRocm91Z2hvdXQgdGhlIGludGVybmV0Li4uIGJ1dCB0aGlzXG4gICAgLy8gaW5jbHVkZXMgb3ZlcmZsb3c6aGlkZGVuIGFzIGEgXCJzY3JvbGxhYmxlXCIgZWxlbWVudCBmb3IgdGhlIHB1cnBvc2VzIG9mIHZpc2liaWxpdHkgdGVzdGluZ1xuICAgIHNlbG1vLmdldFNjcm9sbFBhcmVudCA9IGRvbS5nZXRTY3JvbGxQYXJlbnQgfHwgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHN0eWxlLCBwYXJlbnRQb3NpdGlvbjtcbiAgICAgICAgc3R5bGUgPSBzZWxtby5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgICAgICB2YXIgZWxlbWVudFBvc2l0aW9uID0gc3R5bGUgJiYgc3R5bGUucG9zaXRpb247XG4gICAgICAgIGlmIChlbGVtZW50UG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJlbnQgPSBlbGVtZW50O1xuICAgICAgICB3aGlsZSAocGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHN0eWxlID0gc2VsbW8uZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnQpO1xuICAgICAgICAgICAgaWYgKHN0eWxlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKC8oYXV0b3xzY3JvbGx8aGlkZGVuKS8udGVzdChzdHlsZVsnb3ZlcmZsb3cnXSArIHN0eWxlWydvdmVyZmxvd1knXSArIHN0eWxlWydvdmVyZmxvd1gnXSkpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRQb3NpdGlvbiA9IHN0eWxlLnBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50UG9zaXRpb24gIT09ICdhYnNvbHV0ZScgfHwgKHBhcmVudFBvc2l0aW9uID09PSAncmVsYXRpdmUnIHx8IHBhcmVudFBvc2l0aW9uID09PSAnYWJzb2x1dGUnIHx8IHBhcmVudFBvc2l0aW9uID09PSAnZml4ZWQnKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0Qm9keSgpO1xuICAgIH07XG5cbiAgICBzZWxtby5pc0VsZW1lbnRWaXNpYmxlID0gZG9tLmlzRWxlbWVudFZpc2libGUgfHwgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGVsZW1lbnQgaGFzIG5vIGNsaWVudCB3aWR0aC9oZWlnaHQgKGRpc3BsYXk6IG5vbmUgb3IgcmVtb3ZlZCBmcm9tIGRvbSlcbiAgICAgICAgaWYgKGVsZW1lbnQub2Zmc2V0V2lkdGggPT09IDAgfHwgZWxlbWVudC5vZmZzZXRIZWlnaHQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBlbGVtZW50IGlzIG91dHNpZGUgb2YgdGhlIHZpZXdwb3J0XG4gICAgICAgIHZhciBjbGllbnRSZWN0ID0gc2VsbW8uZ2V0Q2xpZW50UmVjdChlbGVtZW50KTtcbiAgICAgICAgdmFyIHZpZXdwb3J0UmVjdCA9IHNlbG1vLmdldENsaWVudFJlY3Qod2luZG93KTtcbiAgICAgICAgaWYgKCFzZWxtby5pbnRlcnNlY3RSZWN0KGNsaWVudFJlY3QsIHZpZXdwb3J0UmVjdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBlbGVtZW50IG9yIGFueSBwYXJlbnQgaXMgaW52aXNpYmxlLCBidXQgc3RpbGwgaGFzIGNsaWVudCB3aWR0aC9oZWlnaHRcbiAgICAgICAgdmFyIHN0eWxlLCBwYXJlbnROb2RlID0gZWxlbWVudDtcbiAgICAgICAgd2hpbGUgKHBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHBhcmVudE5vZGUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHt9XG4gICAgICAgICAgICBpZiAoIXN0eWxlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoTnVtYmVyKHN0eWxlLm9wYWNpdHkpIDw9IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3R5bGUudmlzaWJpbGl0eSA9PT0gJ2hpZGRlbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgZWxlbWVudCBpcyB2aXNpYmxlIHdpdGhpbiBhbnkgc2Nyb2xsYWJsZSBhcmVhcyB0aGF0IGFyZSBub3QgdGhlIG92ZXJhbGwgdmlld3BvcnRcbiAgICAgICAgdmFyIHNjcm9sbFBhcmVudCA9IHNlbG1vLmdldFNjcm9sbFBhcmVudChlbGVtZW50KTtcbiAgICAgICAgdmFyIGJvZHkgPSBnZXRCb2R5KCk7XG4gICAgICAgIHZhciBwcmV2U2Nyb2xsUGFyZW50ID0gbnVsbDtcblxuICAgICAgICB3aGlsZSAoc2Nyb2xsUGFyZW50ICE9PSBib2R5ICYmIHNjcm9sbFBhcmVudCAhPT0gZG9jdW1lbnQgJiYgc2Nyb2xsUGFyZW50ICE9PSBwcmV2U2Nyb2xsUGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgc2Nyb2xsUmVjdCA9IHNlbG1vLmdldENsaWVudFJlY3Qoc2Nyb2xsUGFyZW50KTtcbiAgICAgICAgICAgIGlmICghc2VsbW8uaW50ZXJzZWN0UmVjdChjbGllbnRSZWN0LCBzY3JvbGxSZWN0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJldlNjcm9sbFBhcmVudCA9IHNjcm9sbFBhcmVudDtcbiAgICAgICAgICAgIHNjcm9sbFBhcmVudCA9IHNlbG1vLmdldFNjcm9sbFBhcmVudChzY3JvbGxQYXJlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTXVzdCBiZSB2aXNpYmxlLi4uXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBpZiAoIWRvbS5yZW1vdmVOb2RlKSB7XG4gICAgICAgIGRvbS5yZW1vdmVOb2RlID0gZnVuY3Rpb24gKGRvbU5vZGUpIHtcbiAgICAgICAgICAgIGRvbU5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkb21Ob2RlKTtcbiAgICAgICAgfTtcblxuICAgICAgICBkb20ucmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIGNsYXNzbmFtZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbXMgPSBwZW5kby5TaXp6bGUoc2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgIGVsZW1zLm1hcChmdW5jdGlvbiAoZWxlbSkgeyBkb20uX3JlbW92ZUNsYXNzKGVsZW0sIGNsYXNzbmFtZSk7IH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkb20uX3JlbW92ZUNsYXNzKHNlbGVjdG9yLCBjbGFzc25hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGRvbS5hZGRDbGFzcyA9IGZ1bmN0aW9uIChzZWxlY3RvciwgY2xhc3NuYW1lKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtcyA9IHBlbmRvLlNpenpsZShzZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgZWxlbXMubWFwKGZ1bmN0aW9uIChlbGVtKSB7IGRvbS5fYWRkQ2xhc3MoZWxlbSwgY2xhc3NuYW1lKTsgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvbS5fYWRkQ2xhc3Moc2VsZWN0b3IsIGNsYXNzbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gZnJvbSBodHRwOi8vd3d3Lm9wZW5qcy5jb20vc2NyaXB0cy9kb20vY2xhc3NfbWFuaXB1bGF0aW9uLnBocFxuICAgICAgICBkb20uaGFzQ2xhc3MgPSBmdW5jdGlvbiAoZWxlLCBjbHMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZS5jbGFzc05hbWUubWF0Y2gobmV3IFJlZ0V4cCgnKFxcXFxzfF4pJyArIGNscyArICcoXFxcXHN8JCknKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBkb20uX2FkZENsYXNzID0gZnVuY3Rpb24gKGVsZSwgY2xzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICghZG9tLmhhc0NsYXNzKGVsZSwgY2xzKSkgZWxlLmNsYXNzTmFtZSArPSAnICcgKyBjbHM7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGRvbS5fcmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiAoZWxlLCBjbHMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvbS5oYXNDbGFzcyhlbGUsIGNscykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZyA9IG5ldyBSZWdFeHAoJyhcXFxcc3xeKScgKyBjbHMgKyAnKFxcXFxzfCQpJyk7XG4gICAgICAgICAgICAgICAgICAgIGVsZS5jbGFzc05hbWUgPSBlbGUuY2xhc3NOYW1lLnJlcGxhY2UocmVnLCAnICcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBcIkNvbnN0YW50c1wiXG4gICAgdmFyIE5BVklHQVRJT05fTU9ERSA9ICduYXYnO1xuICAgIHZhciBTRUxFQ1RJT05fTU9ERSA9ICdzZWwnO1xuICAgIHZhciBPVkVSTEFZX01PREUgPSAnb3ZlcmxheSc7XG5cbiAgICB2YXIgX1BFTkRPX1RFVEhFUl9DTEFTU19QUkVGSVggPSAncGVuZG8tdGV0aGVyJztcbiAgICB2YXIgX1BFTkRPX09WRVJMQVlfQ0xBU1MgPSAncGVuZG8tb3ZlcmxheSc7XG4gICAgdmFyIF9QRU5ET19PVkVSTEFZX1RBUkdFVF9DTEFTUyA9ICdwZW5kby1vdmVybGF5LXRhcmdldCc7XG4gICAgdmFyIF9QRU5ET19UT09MVElQX0NMQVNTID0gJ3BlbmRvLXRvb2x0aXAnO1xuICAgIHZhciBfUEVORE9fVE9PTFRJUF9DT05URU5UX0NMQVNTID0gJ3BlbmRvLXRvb2x0aXAtY29udGVudCc7XG4gICAgdmFyIF9QRU5ET19TRUxFQ1RJT05fQ0xBU1MgPSAncGVuZG8tc2VsZWN0aW9uJztcbiAgICB2YXIgX1BFTkRPX1NFTEVDVElPTl9ISUdITElHSFRfQ0xBU1MgPSAncGVuZG8tc2VsZWN0aW9uLUhMJzsgLy8gVE9ETyBjb25zaWRlciBtYWtpbmcgdGhpcyBtb3JlIG9ic2N1cmUgdG8gcHJldmVudCBhY2NpZGVudGFsIGNvbGxpc2lvblxuICAgIHZhciBfUEVORE9fVEFHR0VEX0NMQVNTID0gJ3BlbmRvLXRhZ2dlZC1ITCc7XG5cbiAgICB2YXIgSUdOT1JFX0NMQVNTRVMgPSBbXG4gICAgICAgIF9QRU5ET19TRUxFQ1RJT05fSElHSExJR0hUX0NMQVNTLFxuICAgICAgICAnb3JpZy0nICsgX1BFTkRPX1NFTEVDVElPTl9ISUdITElHSFRfQ0xBU1MsXG4gICAgICAgIF9QRU5ET19TRUxFQ1RJT05fQ0xBU1MsXG4gICAgICAgIF9QRU5ET19UQUdHRURfQ0xBU1MsXG4gICAgICAgIF9QRU5ET19PVkVSTEFZX0NMQVNTLFxuICAgICAgICBfUEVORE9fVE9PTFRJUF9DTEFTUyxcbiAgICAgICAgX1BFTkRPX09WRVJMQVlfVEFSR0VUX0NMQVNTLFxuXG4gICAgICAgIC8vIElnbm9yZSBtZWFuaW5nbGVzcyBjbGFzc2VzIGJhc2VkIG9uIGZyYW1ld29yay4uLlxuICAgICAgICAvLyBBbmd1bGFyXG4gICAgICAgICduZy1pc29sYXRlLXNjb3BlJyxcbiAgICAgICAgJ25nLXNjb3BlJyxcbiAgICAgICAgJ25nLWhpZGUnLFxuICAgICAgICAnbmctc2hvdycsXG4gICAgICAgICduZy1iaW5kaW5nJyxcblxuICAgICAgICAvLyBCb290c3RyYXBcbiAgICAgICAgJ3B1bGwtbGVmdCcsXG4gICAgICAgICdwdWxsLXJpZ2h0J1xuICAgIF07XG5cbiAgICB2YXIgaGFuZGxlTW9kZUNoYW5nZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmIChzZWxtby5jdXJyZW50TW9kZSAhPT0gZGF0YS5tb2RlKSB7XG4gICAgICAgICAgICBzZWxtby5jdXJyZW50TW9kZSA9IGRhdGEubW9kZTtcbiAgICAgICAgICAgIHNlbG1vLk1PREVTW2RhdGEubW9kZV0oKTtcblxuICAgICAgICAgICAgdGVsbE1hc3Rlcih7dHlwZTogJ21vZGUnLCBtc2c6ICdzdGFydGVkICcgKyBkYXRhLm1vZGV9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRlbGxNYXN0ZXIoe21zZzogJ3NlbnQgbWVzc2FnZSB0byBjaGFuZ2UgbW9kZSB0byAnICsgZGF0YS5tb2RlICsgJyBidXQgYWxyZWFkeSBpbiB0aGF0IG1vZGUuJ30pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciB0YWdnZWRGZWF0dXJlcyA9IG5ldyBUYWdnZWRGZWF0dXJlcygpO1xuICAgIHNlbG1vLnVwZGF0ZVRhZ2dlZEZlYXR1cmVzID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdGFnZ2VkRmVhdHVyZXMudXBkYXRlKGRhdGEuZmVhdHVyZXMsIGRhdGEucGFnZXMsIGRhdGEuaXNSZWFkT25seSk7XG4gICAgICAgIGlmIChzZWxtby5pc0luU3RhdGUoU0VMRUNUSU9OX01PREUpKSB7XG4gICAgICAgICAgICB0YWdnZWRGZWF0dXJlcy5zaG93T3V0bGluZXMoKTtcbiAgICAgICAgfSBlbHNlIGlmIChzZWxtby5pc0luU3RhdGUoT1ZFUkxBWV9NT0RFKSkge1xuICAgICAgICAgICAgdGFnZ2VkRmVhdHVyZXMuc2hvd092ZXJsYXlzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0YWdnZWRGZWF0dXJlcy5oaWRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGlzQmFkZ2UgPSBmdW5jdGlvbiAoZ3VpZGUpIHtcbiAgICAgICAgcmV0dXJuIGd1aWRlLmxhdW5jaE1ldGhvZC5pbmRleE9mKCdiYWRnZScpICE9IC0xO1xuICAgIH07XG5cbiAgICB2YXIgc2hvd0JhZGdlID0gZnVuY3Rpb24gKGd1aWRlKSB7XG4gICAgICAgIC8vIHJlbW92aW5nIGZvciBub3dcbiAgICAgICAgLy8gcGxhY2VCYWRnZShndWlkZSwgW10pO1xuICAgIH07XG5cbiAgICB2YXIgaXNJbkxhdW5jaGVyID0gZnVuY3Rpb24gKGd1aWRlKSB7XG4gICAgICAgIHJldHVybiBndWlkZS5sYXVuY2hNZXRob2QuaW5kZXhPZignbGF1bmNoZXInKSAhPSAtMTtcbiAgICB9O1xuXG4gICAgc2VsbW8udXBkYXRlQWN0aXZlR3VpZGVzID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmd1aWRlcykge1xuICAgICAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICBndWlkZXM6IHBlbmRvLmd1aWRlc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBwZW5kby5ndWlkZXMgPSBfLm1hcChkYXRhLmd1aWRlcywgR3VpZGVGYWN0b3J5KTtcblxuICAgICAgICAvLyB1cGRhdGUgYmFkZ2VzXG4gICAgICAgIF8ubWFwKFNpenpsZSgnLl9wZW5kby1iYWRnZV8nKSwgZG9tLnJlbW92ZU5vZGUpO1xuICAgICAgICBfLm1hcChfLmZpbHRlcihwZW5kby5ndWlkZXMsIGlzQmFkZ2UpLCBzaG93QmFkZ2UpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBsYXVuY2hlclxuICAgICAgICB2YXIgbGF1bmNoZXJHdWlkZXMgPSBzZWxtby5sYXVuY2hlckd1aWRlcyA9IF8uZmlsdGVyKHBlbmRvLmd1aWRlcywgaXNJbkxhdW5jaGVyKTtcbiAgICAgICAgaWYgKF8uaXNGdW5jdGlvbih1cGRhdGVMYXVuY2hlckNvbnRlbnQpKSB7XG4gICAgICAgICAgICAvLyBBZ2VudCBzdXBwb3J0cyBjdXN0b20gbGF1bmNoZXJcbiAgICAgICAgICAgIGlmIChwZW5kby5ndWlkZVdpZGdldCAmJiBwZW5kby5ndWlkZVdpZGdldC5kYXRhICYmIHBlbmRvLmd1aWRlV2lkZ2V0LmRhdGEuZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHJlbW92ZUxhdW5jaGVyKCk7XG4gICAgICAgICAgICAgICAgY3JlYXRlTGF1bmNoZXIocGVuZG8uZ3VpZGVXaWRnZXQuZGF0YSk7XG4gICAgICAgICAgICAgICAgdXBkYXRlTGF1bmNoZXJDb250ZW50KGxhdW5jaGVyR3VpZGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF8ubWFwKFNpenpsZSgnLl9wZW5kby1sYXVuY2hlci1pdGVtXycpLCBkb20ucmVtb3ZlTm9kZSk7XG4gICAgICAgICAgICBfLm1hcChsYXVuY2hlckd1aWRlcywgYWRkR3VpZGVUb0xhdW5jaGVyKTtcblxuICAgICAgICAgICAgXy5tYXAoU2l6emxlKCcuX3BlbmRvLWxhdW5jaGVyLWl0ZW1fID4gYScpLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgIGEub25jbGljayA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxpc3RpbmcgPSBTaXp6bGUoJy5fcGVuZG8tbGF1bmNoZXItZ3VpZGUtbGlzdGluZ18nKVswXTtcbiAgICAgICAgaWYgKGxpc3RpbmcpIHtcbiAgICAgICAgICAgIHBlbmRvLlNvcnRhYmxlLmNyZWF0ZShsaXN0aW5nLCB7XG4gICAgICAgICAgICAgICAgb25VcGRhdGU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBndWlkZSA9IHNlbG1vLmxhdW5jaGVyR3VpZGVzW2Uub2xkSW5kZXhdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxhY2VkR3VpZGUgPSBzZWxtby5sYXVuY2hlckd1aWRlc1tlLm5ld0luZGV4XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ByaW9yaXR5ID0gZGlzcGxhY2VkR3VpZGUuYXR0cmlidXRlcy5wcmlvcml0eTtcblxuICAgICAgICAgICAgICAgICAgICB0ZWxsTWFzdGVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1cGRhdGUtZ3VpZGUtcHJpb3JpdHknLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ3VpZGVJZDogZ3VpZGUuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmlvcml0eTogbmV3UHJpb3JpdHlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbmRHdWlkZUNzcygpO1xuICAgICAgICB9LCAyMDAwKTtcbiAgICB9O1xuXG4gICAgLy8gVE9ETzogaW1wbGVtZW50IHRoaXMgZm9yIGxpdmUgZWRpdHMgb2YgZ3VpZGVzXG4gICAgdmFyIGRpcnR5RWRpdEd1aWRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB9O1xuICAgIHZhciBjbGVhckRpcnR5RWRpdHMgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIHNlbG1vLmdldENvbXB1dGVkU3R5bGUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7fVxuICAgIH07XG5cbiAgICBzZWxtby5nZXRDbGllbnRSZWN0ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGJvZHkgPSBnZXRCb2R5KCk7XG4gICAgICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50ID09PSBib2R5IHx8IGVsZW1lbnQgPT09IGRvY3VtZW50IHx8IGVsZW1lbnQgPT09IHdpbmRvdykge1xuICAgICAgICAgICAgdmFyIHZpZXdwb3J0ID0ge1xuICAgICAgICAgICAgICAgIGxlZnQ6IHdpbmRvdy5wYWdlWE9mZnNldCB8fCBib2R5LnNjcm9sbExlZnQsXG4gICAgICAgICAgICAgICAgdG9wOiB3aW5kb3cucGFnZVlPZmZzZXQgfHwgYm9keS5zY3JvbGxUb3AsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmlld3BvcnQucmlnaHQgPSB2aWV3cG9ydC5sZWZ0ICsgdmlld3BvcnQud2lkdGg7XG4gICAgICAgICAgICB2aWV3cG9ydC5ib3R0b20gPSB2aWV3cG9ydC50b3AgKyB2aWV3cG9ydC5oZWlnaHQ7XG4gICAgICAgICAgICByZXR1cm4gdmlld3BvcnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gICAgICAgICAgICB2YXIgY2xpZW50UmVjdCA9IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogbm9kZS5vZmZzZXRXaWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IG5vZGUub2Zmc2V0SGVpZ2h0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2xpZW50UmVjdC5sZWZ0ID0gMDtcbiAgICAgICAgICAgIGNsaWVudFJlY3QudG9wID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChub2RlICYmICFpc05hTihub2RlLm9mZnNldExlZnQpICYmICFpc05hTihub2RlLm9mZnNldFRvcCkpIHtcbiAgICAgICAgICAgICAgICBjbGllbnRSZWN0LmxlZnQgKz0gbm9kZS5vZmZzZXRMZWZ0O1xuICAgICAgICAgICAgICAgIGNsaWVudFJlY3QudG9wICs9IG5vZGUub2Zmc2V0VG9wO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLm9mZnNldFBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsaWVudFJlY3QucmlnaHQgPSBjbGllbnRSZWN0LmxlZnQgKyBjbGllbnRSZWN0LndpZHRoO1xuICAgICAgICAgICAgY2xpZW50UmVjdC5ib3R0b20gPSBjbGllbnRSZWN0LnRvcCArIGNsaWVudFJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgcmV0dXJuIGNsaWVudFJlY3Q7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgc2VsbW8uaW50ZXJzZWN0UmVjdCA9IGZ1bmN0aW9uIChyZWN0MSwgcmVjdDIpIHtcbiAgICAgICAgaWYgKHJlY3QxLnRvcCA+PSByZWN0Mi5ib3R0b20pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVjdDEuYm90dG9tIDw9IHJlY3QyLnRvcCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWN0MS5sZWZ0ID49IHJlY3QyLnJpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlY3QxLnJpZ2h0IDw9IHJlY3QyLmxlZnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLy8gZnVuY3Rpb25hbGl0eSBleHRyYWN0ZWQgZnJvbSB0aGUgdGhlbWUtcGx1Y2tlciBwcm9qZWN0XG4gICAgc2VsbW8uZ2V0U2l0ZVRoZW1lID0gZnVuY3Rpb24gZ2V0U2l0ZVRoZW1lICgpIHtcbiAgICAgICAgZnVuY3Rpb24gc3R5bGVzRnJvbU5vZGVzIChub2Rlcykge1xuICAgICAgICAgICAgdmFyIGxvb2t1cFRhYmxlID0ge1xuICAgICAgICAgICAgICAgICdmb250LWZhbWlseSc6IHt9LFxuICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzoge31cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xuICAgICAgICAgICAgICAgIHZhciBmb250TGlzdCA9IGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnZm9udC1mYW1pbHknKSB8fCAnJztcblxuICAgICAgICAgICAgICAgIGZvbnRMaXN0LnNwbGl0KCcsJykuZm9yRWFjaChmdW5jdGlvbiAoZm9udCkge1xuICAgICAgICAgICAgICAgICAgICBsb29rdXBUYWJsZVsnZm9udC1mYW1pbHknXVtmb250LnRyaW0oKV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdiYWNrZ3JvdW5kLWNvbG9yJyk7XG4gICAgICAgICAgICAgICAgbG9va3VwVGFibGVbJ2JhY2tncm91bmQtY29sb3InXVtjb2xvcl0gPSByZ2IyaGV4KGNvbG9yKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gbG9va3VwVGFibGU7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBidWlsZFRoZW1lTGlzdCAoKSB7XG4gICAgICAgICAgICB2YXIgd2hpdGVsaXN0ID0gJ2JvZHksIGxhYmVsLCBkaXYsIHNwYW4sIGgxLCBoMiwgaDMsIGg0LCBoNSwgcHJlLCBjb2RlLCBwLCBidXR0b24sIGEnO1xuICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh3aGl0ZWxpc3QpO1xuICAgICAgICAgICAgdmFyIHN0eWxlcyA9IHN0eWxlc0Zyb21Ob2RlcyhlbGVtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gc3R5bGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmdiMmhleCAoaW5wdXRSZ2IpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dFJnYi5pbmRleE9mKCdyZ2IoJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmdiID0gaW5wdXRSZ2IubWF0Y2goL15yZ2JcXCgoXFxkKyksXFxzKihcXGQrKSxcXHMqKFxcZCspXFwpJC8pO1xuICAgICAgICAgICAgICAgIHJldHVybiBgIyR7aGV4KHJnYlsxXSl9JHtoZXgocmdiWzJdKX0ke2hleChyZ2JbM10pfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBoZXggKHgpIHtcbiAgICAgICAgICAgIGNvbnN0IGhleERpZ2l0cyA9IG5ldyBBcnJheSgnMCcsICcxJywgJzInLCAnMycsICc0JywgJzUnLCAnNicsICc3JywgJzgnLCAnOScsICdhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicpO1xuICAgICAgICAgICAgcmV0dXJuIGlzTmFOKHgpID8gJzAwJyA6IGhleERpZ2l0c1soeCAtIHggJSAxNikgLyAxNl0gKyBoZXhEaWdpdHNbeCAlIDE2XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBidWlsZFRoZW1lTGlzdCgpO1xuICAgIH07XG5cbiAgICBzZWxtby5lbGVtZW50Q29udGFpbnMgPSBmdW5jdGlvbiAoY29udGFpbmVyLCBjb250YWluZWUpIHtcbiAgICAgICAgZm9yICh2YXIgcGFyZW50Tm9kZSA9IGNvbnRhaW5lZTsgcGFyZW50Tm9kZSAhPSBudWxsOyBwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBpZiAocGFyZW50Tm9kZSA9PT0gY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBUYWdnZWRGZWF0dXJlcyAoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgc2VsZi5vdmVybGF5cyA9IFtdO1xuICAgICAgICBzZWxmLmFjdGl2ZVBhZ2VzID0ge307XG4gICAgICAgIHNlbGYuZmVhdHVyZXMgPSBbXTtcbiAgICAgICAgc2VsZi5tYXhOdW1FdmVudHMgPSAwO1xuXG4gICAgICAgIGF0dGFjaEV2ZW50KGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBzZWxmLmhvdmVyKGV2ZW50KTtcbiAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgYXR0YWNoRXZlbnQoZG9jdW1lbnQsICdjbGljaycsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgc2VsZi5jbGljayhldmVudCk7XG4gICAgICAgIH0sIHRydWUpO1xuICAgIH1cblxuICAgIFRhZ2dlZEZlYXR1cmVzLnByb3RvdHlwZS5zdGFydFdhdGNoaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pbnRlcnZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgcmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnJlZnJlc2goKTtcbiAgICAgICAgICAgICAgICBzZWxmLmludGVydmFsID0gc2V0VGltZW91dChyZWZyZXNoLCAyMDApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlZnJlc2goKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBUYWdnZWRGZWF0dXJlcy5wcm90b3R5cGUuc3RvcFdhdGNoaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pbnRlcnZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5pbnRlcnZhbCk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5pbnRlcnZhbDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBUYWdnZWRGZWF0dXJlcy5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVmcmVzaFBvc2l0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaFBvc2l0aW9uID0gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgICBiYXRjaFNpemUgPSAxMCxcbiAgICAgICAgICAgIGxlbiA9IHRoaXMub3ZlcmxheXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaSsrIDwgYmF0Y2hTaXplICYmIGkgPCBsZW4pIHtcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheXNbdGhpcy5yZWZyZXNoUG9zaXRpb25dLnJlZnJlc2goKTtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaFBvc2l0aW9uID0gKHRoaXMucmVmcmVzaFBvc2l0aW9uICsgMSkgJSBsZW47XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgVGFnZ2VkRmVhdHVyZXMucHJvdG90eXBlLmlzRmVhdHVyZU9uUGFnZSA9IGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICAgIGlmICghZmVhdHVyZS5wYWdlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBGZWF0dXJlIGlzIGRlZmluZWQgb24gYWxsIHBhZ2VzXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICEhdGhpcy5hY3RpdmVQYWdlc1tmZWF0dXJlLnBhZ2VJZF07XG4gICAgfTtcblxuICAgIFRhZ2dlZEZlYXR1cmVzLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZmVhdHVyZXMsIHBhZ2VzLCBpc1JlYWRPbmx5KSB7XG4gICAgICAgIHZhciBpLCBpaSwgZmVhdHVyZSwgb3ZlcmxheXMgPSB0aGlzLm92ZXJsYXlzO1xuXG4gICAgICAgIHRoaXMuZmVhdHVyZXMgPSBmZWF0dXJlcztcblxuICAgICAgICAvLyBSYW5rIGZlYXR1cmVzXG4gICAgICAgIGZlYXR1cmVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhLm51bUV2ZW50cyAtIGIubnVtRXZlbnRzO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHJhbmsgPSAwO1xuICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IGZlYXR1cmVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChpID4gMCAmJiBmZWF0dXJlc1tpXS5udW1FdmVudHMgPiBmZWF0dXJlc1tpIC0gMV0ubnVtRXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgcmFuaysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmVhdHVyZXNbaV0ucmFuayA9IHJhbms7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgbWF4IHZhbHVlcyAoZ2xvYmFsLCBub3QganVzdCBmZWF0dXJlcyBmb3IgdGhpcyBwYWdlKVxuICAgICAgICB2YXIgbWF4aW11bXMgPSB7XG4gICAgICAgICAgICByYW5rOiB0aGlzLm1heChmZWF0dXJlcywgJ3JhbmsnKSxcbiAgICAgICAgICAgIG51bUV2ZW50czogdGhpcy5tYXgoZmVhdHVyZXMsICdudW1FdmVudHMnKSxcbiAgICAgICAgICAgIG51bVZpc2l0b3JzOiB0aGlzLm1heChmZWF0dXJlcywgJ251bVZpc2l0b3JzJyksXG4gICAgICAgICAgICBudW1BY2NvdW50czogdGhpcy5tYXgoZmVhdHVyZXMsICdudW1BY2NvdW50cycpXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gTG9va3VwIHRhYmxlIGZvciBhY3RpdmUgcGFnZXMgKG9ubHkgdGhlIGFjdGl2ZSBwYWdlcyBhcmUgc2VudClcbiAgICAgICAgdmFyIGFjdGl2ZVBhZ2VzID0gdGhpcy5hY3RpdmVQYWdlcyA9IHt9O1xuICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IHBhZ2VzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBwYWdlID0gcGFnZXNbaV07XG4gICAgICAgICAgICBhY3RpdmVQYWdlc1twYWdlLmlkXSA9IHBhZ2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaWx0ZXIgdG8gb25seSBmZWF0dXJlcyBvbiB0aGlzIHBhZ2UocylcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGZlYXR1cmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNGZWF0dXJlT25QYWdlKGZlYXR1cmVzW2ldKSkge1xuICAgICAgICAgICAgICAgIGZlYXR1cmVzLnNwbGljZShpLS0sIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGVzdHJveSBjdXJyZW50IG92ZXJsYXlzIChpZiBhbnkpXG4gICAgICAgIHRoaXMuY2xlYXIoKTtcblxuICAgICAgICAvLyBhZGQgbmV3IG92ZXJsYXlzXG4gICAgICAgIGZvciAoaSA9IDAsIGlpID0gZmVhdHVyZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgZmVhdHVyZSA9IGZlYXR1cmVzW2ldO1xuICAgICAgICAgICAgdmFyIG92ZXJsYXkgPSBuZXcgRmVhdHVyZU92ZXJsYXkoZmVhdHVyZSwgbWF4aW11bXMsIGlzUmVhZE9ubHkpO1xuICAgICAgICAgICAgb3ZlcmxheXMucHVzaChvdmVybGF5KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBUYWdnZWRGZWF0dXJlcy5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHRoaXMub3ZlcmxheXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5vdmVybGF5c1tpXS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdmVybGF5cy5sZW5ndGggPSAwO1xuICAgIH07XG5cbiAgICBUYWdnZWRGZWF0dXJlcy5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdG9wV2F0Y2hpbmcoKTtcbiAgICAgICAgdGhpcy5oaWRlT3ZlcmxheXMoKTtcbiAgICAgICAgdGhpcy5oaWRlT3V0bGluZXMoKTtcbiAgICB9O1xuXG4gICAgVGFnZ2VkRmVhdHVyZXMucHJvdG90eXBlLmhpZGVPdmVybGF5cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gdGhpcy5vdmVybGF5cy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXlzW2ldLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFRhZ2dlZEZlYXR1cmVzLnByb3RvdHlwZS5zaG93T3ZlcmxheXMgPSBmdW5jdGlvbiAoaXNSZWFkT25seSkge1xuICAgICAgICB0aGlzLmhpZGVPdXRsaW5lcygpO1xuICAgICAgICB0aGlzLnN0YXJ0V2F0Y2hpbmcoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gdGhpcy5vdmVybGF5cy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXlzW2ldLnNob3coaXNSZWFkT25seSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgVGFnZ2VkRmVhdHVyZXMucHJvdG90eXBlLmhpZGVPdXRsaW5lcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gdGhpcy5vdmVybGF5cy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXlzW2ldLmhpZGVPdXRsaW5lKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgVGFnZ2VkRmVhdHVyZXMucHJvdG90eXBlLnNob3dPdXRsaW5lcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5oaWRlT3ZlcmxheXMoKTtcbiAgICAgICAgdGhpcy5zdGFydFdhdGNoaW5nKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHRoaXMub3ZlcmxheXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5vdmVybGF5c1tpXS5zaG93T3V0bGluZSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFRhZ2dlZEZlYXR1cmVzLnByb3RvdHlwZS5ob3ZlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLm92ZXJsYXlzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheXNbaV0uaG92ZXIoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFRhZ2dlZEZlYXR1cmVzLnByb3RvdHlwZS5jbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLm92ZXJsYXlzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheXNbaV0uY2xpY2soZXZlbnQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFRhZ2dlZEZlYXR1cmVzLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbiAoYXJyYXksIHByb3BlcnR5KSB7XG4gICAgICAgIHZhciBtYXg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGFycmF5Lmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2ldW3Byb3BlcnR5XTtcbiAgICAgICAgICAgIGlmIChtYXggPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA+IG1heCkge1xuICAgICAgICAgICAgICAgIG1heCA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfTtcblxuICAgIC8vIFdyYXBzIGFuIGVsZW1lbnQgb3ZlcmxheSB3aXRoIGEgdG9vbHRpcFxuICAgIGZ1bmN0aW9uIEZlYXR1cmVPdmVybGF5IChmZWF0dXJlLCBtYXgsIGlzUmVhZE9ubHkpIHtcbiAgICAgICAgdGhpcy5tYXggPSBtYXg7XG4gICAgICAgIHRoaXMuZmVhdHVyZSA9IGZlYXR1cmU7XG4gICAgICAgIHRoaXMudG9vbHRpcCA9IG5ldyBUb29sdGlwKHRoaXMuY29udGVudChpc1JlYWRPbmx5KSk7XG4gICAgICAgIHRoaXMub3ZlcmxheXMgPSBbXTtcbiAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm91dGxpbmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZWRpdEJ1dHRvbiA9IFNpenpsZSgnLnBlbmRvLWVkaXQtZmVhdHVyZSA+IGEnLCB0aGlzLnRvb2x0aXAuZWxlbWVudClbMF07XG4gICAgfVxuXG4gICAgRmVhdHVyZU92ZXJsYXkucHJvdG90eXBlLmhhc092ZXJsYXkgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gISFkb20uaGFzQ2xhc3MoZWxlbWVudCwgX1BFTkRPX09WRVJMQVlfVEFSR0VUX0NMQVNTKTtcbiAgICB9O1xuXG4gICAgRmVhdHVyZU92ZXJsYXkucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpLCBpaSwgb3ZlcmxheTtcbiAgICAgICAgdmFyIG92ZXJsYXlzID0gdGhpcy5vdmVybGF5cztcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG92ZXJsYXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBvdmVybGF5ID0gb3ZlcmxheXNbaV07XG4gICAgICAgICAgICBpZiAoc2VsbW8uaXNFbGVtZW50VmlzaWJsZShvdmVybGF5LnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAvLyBSZWZyZXNoIG92ZXJsYXlzIHRoYXQgYXJlIHN0aWxsIHZpc2libGVcbiAgICAgICAgICAgICAgICBvdmVybGF5LnJlZnJlc2goKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIG92ZXJsYXlzIHRoYXQgbm8gbG9uZ2VyIGhhdmUgdmFsaWQgdGFyZ2V0c1xuICAgICAgICAgICAgICAgIG92ZXJsYXkuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIG92ZXJsYXlzLnNwbGljZShpLS0sIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIG92ZXJsYXlzIGZvciBuZXcgZWxlbWVudHNcbiAgICAgICAgdmFyIGZlYXR1cmUgPSB0aGlzLmZlYXR1cmU7XG4gICAgICAgIGZvciAoaSA9IDAsIGlpID0gZmVhdHVyZS5lbGVtZW50UGF0aFJ1bGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RvciA9IGZlYXR1cmUuZWxlbWVudFBhdGhSdWxlc1tpXTtcbiAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IFNpenpsZShzZWxlY3Rvcik7XG5cbiAgICAgICAgICAgIC8vIFRPRE8gLSBoYW5kbGUgZHVwbGljYXRlcyB3aXRoaW4gYW5kIGFjcm9zcyBmZWF0dXJlcz9cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBqaiA9IGVsZW1lbnRzLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IGVsZW1lbnRzW2pdO1xuICAgICAgICAgICAgICAgIGlmIChzZWxtby5pc0VsZW1lbnRWaXNpYmxlKGVsZW1lbnQpICYmICF0aGlzLmhhc092ZXJsYXkoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheSA9IG5ldyBFbGVtZW50T3ZlcmxheShlbGVtZW50LCBzZWxlY3RvciwgdGhpcy5jb2xvcigpLCBmZWF0dXJlLmNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3V0bGluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXkuc2hvd091dGxpbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGF5LnNob3coKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm92ZXJsYXlzLnB1c2gob3ZlcmxheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIEZlYXR1cmVPdmVybGF5LnByb3RvdHlwZS5jb250ZW50ID0gZnVuY3Rpb24gKGlzUmVhZE9ubHkpIHtcbiAgICAgICAgdmFyIGZlYXR1cmUgPSB0aGlzLmZlYXR1cmU7XG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9IFtdO1xuICAgICAgICBpZiAoZmVhdHVyZS5kaXJ0eSkge1xuICAgICAgICAgICAgdGVtcGxhdGUucHVzaChcbiAgICAgICAgICAgICAgICAnPHRhYmxlPicsXG4gICAgICAgICAgICAgICAgJzx0cj48dGQgY29sc3Bhbj1cIjNcIj4nLCBmZWF0dXJlLm5hbWUsICc8L3RkPjwvdHI+JyxcbiAgICAgICAgICAgICAgICAnPHRyPjx0ZCBjb2xzcGFuPVwiM1wiIGNsYXNzPVwicGVuZG8tcHJvY2Vzc2luZy1mZWF0dXJlXCI+UHJvY2Vzc2luZzwvdGQ+PC90cj4nLFxuICAgICAgICAgICAgICAgICc8L3RhYmxlPidcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZW1wbGF0ZS5wdXNoKFxuICAgICAgICAgICAgICAgICc8dGFibGU+JyxcbiAgICAgICAgICAgICAgICAnPHRyPjx0ZCBjb2xzcGFuPVwiM1wiPicsIGZlYXR1cmUubmFtZSwgJzwvdGQ+PC90cj4nLFxuICAgICAgICAgICAgICAgICc8dHI+JyxcbiAgICAgICAgICAgICAgICAnPHRkPjxkaXYgY2xhc3M9XCJwZW5kby1wcm9ncmVzc2JhclwiPjxkaXYgc3R5bGU9XCJ3aWR0aDonLCB0aGlzLnBlcmNlbnRhZ2UoJ251bUV2ZW50cycpLCAnJVwiPjwvZGl2PjwvZGl2PjwvdGQ+JyxcbiAgICAgICAgICAgICAgICAnPHRkPjxzdHJvbmc+JywgZmVhdHVyZS5udW1FdmVudHMsICc8L3N0cm9uZz48L3RkPicsXG4gICAgICAgICAgICAgICAgJzx0ZD50b3RhbCBjbGlja3M8L3RkPicsXG4gICAgICAgICAgICAgICAgJzwvdHI+JyxcbiAgICAgICAgICAgICAgICAnPHRyPicsXG4gICAgICAgICAgICAgICAgJzx0ZD48ZGl2IGNsYXNzPVwicGVuZG8tcHJvZ3Jlc3NiYXJcIj48ZGl2IHN0eWxlPVwid2lkdGg6JywgdGhpcy5wZXJjZW50YWdlKCdudW1WaXNpdG9ycycpLCAnJVwiPjwvZGl2PjwvZGl2PjwvdGQ+JyxcbiAgICAgICAgICAgICAgICAnPHRkPjxzdHJvbmc+JywgZmVhdHVyZS5udW1WaXNpdG9ycywgJzwvc3Ryb25nPjwvdGQ+JyxcbiAgICAgICAgICAgICAgICAnPHRkPnZpc2l0b3JzPC90ZD4nLFxuICAgICAgICAgICAgICAgICc8L3RyPicsXG4gICAgICAgICAgICAgICAgJzx0cj4nLFxuICAgICAgICAgICAgICAgICc8dGQ+PGRpdiBjbGFzcz1cInBlbmRvLXByb2dyZXNzYmFyXCI+PGRpdiBzdHlsZT1cIndpZHRoOicsIHRoaXMucGVyY2VudGFnZSgnbnVtQWNjb3VudHMnKSwgJyVcIj48L2Rpdj48L2Rpdj48L3RkPicsXG4gICAgICAgICAgICAgICAgJzx0ZD48c3Ryb25nPicsIGZlYXR1cmUubnVtQWNjb3VudHMsICc8L3N0cm9uZz48L3RkPicsXG4gICAgICAgICAgICAgICAgJzx0ZD5hY2NvdW50czwvdGQ+JyxcbiAgICAgICAgICAgICAgICAnPC90cj4nLFxuICAgICAgICAgICAgICAgICc8L3RhYmxlPidcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzUmVhZE9ubHkpIHtcbiAgICAgICAgICAgIHRlbXBsYXRlLnB1c2goJzxkaXYgY2xhc3M9XCJwZW5kby1lZGl0LWZlYXR1cmVcIj48YSBocmVmPVwiamF2YXNjcmlwdDp2b2lkKDApO1wiPkVkaXQ8L2E+PC9kaXY+Jyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGVtcGxhdGUuam9pbignJyk7XG4gICAgfTtcblxuICAgIEZlYXR1cmVPdmVybGF5LnByb3RvdHlwZS5wZXJjZW50YWdlID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgIHZhciBtYXggPSB0aGlzLm1heFtwcm9wZXJ0eV07XG4gICAgICAgIHJldHVybiBtYXggPiAwID8gTWF0aC5yb3VuZCgodGhpcy5mZWF0dXJlW3Byb3BlcnR5XSAvIG1heCkgKiAxMDApIDogMDtcbiAgICB9O1xuXG4gICAgRmVhdHVyZU92ZXJsYXkucHJvdG90eXBlLmNvbG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlLmRpcnR5KSB7XG4gICAgICAgICAgICByZXR1cm4gJyM5YTljYTUnO1xuICAgICAgICB9XG4gICAgICAgIC8vIEh1ZSBzaG91bGQgZ28gZnJvbSAyNDAgKGJsdWUsIGxlYXN0IHVzZWQpIHRvIDAgKHJlZCwgbW9zdCB1c2VkKVxuICAgICAgICB2YXIgbWF4UmFuayA9IHRoaXMubWF4LnJhbms7XG4gICAgICAgIHZhciBodWUgPSAobWF4UmFuayA+IDApID8gTWF0aC5mbG9vcigyNDAgLSAyNDAgKiAodGhpcy5mZWF0dXJlLnJhbmsgLyBtYXhSYW5rKSkgOiAyNDA7XG4gICAgICAgIHJldHVybiAnaHNsKCcgKyBodWUgKyAnLDEwMCUsNTAlKSc7XG4gICAgfTtcblxuICAgIEZlYXR1cmVPdmVybGF5LnByb3RvdHlwZS5oaWRlT3V0bGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vdXRsaW5lZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLm92ZXJsYXlzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheXNbaV0uaGlkZU91dGxpbmUoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBGZWF0dXJlT3ZlcmxheS5wcm90b3R5cGUuc2hvd091dGxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMub3V0bGluZWQgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLm92ZXJsYXlzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheXNbaV0uc2hvd091dGxpbmUoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBGZWF0dXJlT3ZlcmxheS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gdGhpcy5vdmVybGF5cy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXlzW2ldLnNob3coKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBGZWF0dXJlT3ZlcmxheS5wcm90b3R5cGUuaG92ZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMudmlzaWJsZSkge1xuICAgICAgICAgICAgaWYgKHNlbG1vLmVsZW1lbnRDb250YWlucyh0aGlzLnRvb2x0aXAuZWxlbWVudCwgZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIGhvdmVyaW5nIHRoZSB0b29sdGlwLCBsZWF2ZSBpdCB2aXNpYmxlXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gdGhpcy5vdmVybGF5cy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG92ZXJsYXkgPSB0aGlzLm92ZXJsYXlzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChldmVudC50YXJnZXQgPT09IG92ZXJsYXkuZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBob3ZlcmluZyBhbiBvdmVybGF5LCBzaG93IGFuZCByZXBvc2l0aW9uIHRoZSB0b29sdGlwXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlT3ZlcmxheSA9IG92ZXJsYXk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9vbHRpcC5zaG93KG92ZXJsYXkuZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBObyBvdmVybGF5IG9yIHRvb2x0aXAgd2FzIGhvdmVyZWQsIHNvIHJlbW92ZSB0aGUgdG9vbHRpcFxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuYWN0aXZlT3ZlcmxheTtcbiAgICAgICAgICAgIHRoaXMudG9vbHRpcC5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBGZWF0dXJlT3ZlcmxheS5wcm90b3R5cGUuY2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMudmlzaWJsZSAmJiBldmVudC50YXJnZXQgPT09IHRoaXMuZWRpdEJ1dHRvbikge1xuICAgICAgICAgICAgdGVsbE1hc3Rlcih7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2VkaXQtZmVhdHVyZScsXG4gICAgICAgICAgICAgICAgZmVhdHVyZUlkOiB0aGlzLmZlYXR1cmUuaWQsXG4gICAgICAgICAgICAgICAgdXJsOiBsb2NhdGlvbi50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIHRhcmdldDoge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50UGF0aFJ1bGU6IHRoaXMuYWN0aXZlT3ZlcmxheS5zZWxlY3RvclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEZlYXR1cmVPdmVybGF5LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLm92ZXJsYXlzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheXNbaV0ucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXMuYWN0aXZlT3ZlcmxheTtcbiAgICAgICAgdGhpcy50b29sdGlwLnJlbW92ZSgpO1xuICAgIH07XG5cbiAgICBGZWF0dXJlT3ZlcmxheS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHRoaXMub3ZlcmxheXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5vdmVybGF5c1tpXS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdmVybGF5cy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnRvb2x0aXAuZGVzdHJveSgpO1xuICAgIH07XG5cbiAgICAvLyBUb29sdGlwXG4gICAgZnVuY3Rpb24gVG9vbHRpcCAoY29udGVudCkge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB2YXIgdG9vbHRpcENvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdG9vbHRpcENvbnRlbnQuaW5uZXJIVE1MID0gY29udGVudDtcbiAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZCh0b29sdGlwQ29udGVudCk7XG4gICAgICAgIGRvbS5hZGRDbGFzcyhlbGVtZW50LCBfUEVORE9fVE9PTFRJUF9DTEFTUyk7XG4gICAgICAgIGRvbS5hZGRDbGFzcyh0b29sdGlwQ29udGVudCwgX1BFTkRPX1RPT0xUSVBfQ09OVEVOVF9DTEFTUyk7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIFRvb2x0aXAucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIGlmICghdGhpcy52aXNpYmxlKSB7XG4gICAgICAgICAgICBnZXRCb2R5KCkuYXBwZW5kQ2hpbGQodGhpcy5lbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50ZXRoZXIgPSBuZXcgcGVuZG8uVGV0aGVyKHtcbiAgICAgICAgICAgIGNsYXNzUHJlZml4OiBfUEVORE9fVEVUSEVSX0NMQVNTX1BSRUZJWCxcbiAgICAgICAgICAgIGVsZW1lbnQ6IHRoaXMuZWxlbWVudCxcbiAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgYXR0YWNobWVudDogJ3RvcCBjZW50ZXInLFxuICAgICAgICAgICAgdGFyZ2V0QXR0YWNobWVudDogJ2JvdHRvbSBjZW50ZXInLFxuICAgICAgICAgICAgY29uc3RyYWludHM6IFtcbiAgICAgICAgICAgICAgICB7IHRvOiAnc2Nyb2xsUGFyZW50JywgYXR0YWNobWVudDogJ3RvZ2V0aGVyJyB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBUb29sdGlwLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudGV0aGVyKSB7XG4gICAgICAgICAgICB0aGlzLnRldGhlci5kZXN0cm95KCk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy50ZXRoZXI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aXNpYmxlID0gZmFsc2U7XG4gICAgfTtcblxuICAgIFRvb2x0aXAucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfTtcblxuICAgIC8vIE92ZXJsYXlzIGEgdHJhbnNwYXJlbnQgZGl2IG9uIHRvcCBvZiBhbiBlbGVtZW50XG4gICAgZnVuY3Rpb24gRWxlbWVudE92ZXJsYXkgKHRhcmdldCwgc2VsZWN0b3IsIGNvbG9yLCBvdXRsaW5lQ29sb3IpIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGRvbS5hZGRDbGFzcyhlbGVtZW50LCBfUEVORE9fT1ZFUkxBWV9DTEFTUyk7XG4gICAgICAgIGRvbS5hZGRDbGFzcyh0YXJnZXQsIF9QRU5ET19PVkVSTEFZX1RBUkdFVF9DTEFTUyk7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY29sb3I7XG4gICAgICAgIHRoaXMub3V0bGluZUNvbG9yID0gb3V0bGluZUNvbG9yIHx8IGNvbG9yO1xuICAgICAgICB0aGlzLnRldGhlciA9IG5ldyBwZW5kby5UZXRoZXIoe1xuICAgICAgICAgICAgY2xhc3NQcmVmaXg6IF9QRU5ET19URVRIRVJfQ0xBU1NfUFJFRklYLFxuICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgYXR0YWNobWVudDogJ21pZGRsZSBjZW50ZXInLFxuICAgICAgICAgICAgdGFyZ2V0QXR0YWNobWVudDogJ21pZGRsZSBjZW50ZXInLFxuICAgICAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgfVxuXG4gICAgRWxlbWVudE92ZXJsYXkucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIGRvbS5yZW1vdmVDbGFzcyh0aGlzLnRhcmdldCwgX1BFTkRPX09WRVJMQVlfVEFSR0VUX0NMQVNTKTtcbiAgICAgICAgdGhpcy50ZXRoZXIuZGVzdHJveSgpO1xuICAgIH07XG5cbiAgICBFbGVtZW50T3ZlcmxheS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgZ2V0Qm9keSgpLmFwcGVuZENoaWxkKHRoaXMuZWxlbWVudCk7XG4gICAgICAgIHRoaXMudGV0aGVyLmVuYWJsZSgpO1xuICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICB9O1xuXG4gICAgRWxlbWVudE92ZXJsYXkucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy52aXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLnRhcmdldDtcbiAgICAgICAgZWxlbWVudC5zdHlsZS53aWR0aCA9IHRhcmdldC5vZmZzZXRXaWR0aCArICdweCc7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gdGFyZ2V0Lm9mZnNldEhlaWdodCArICdweCc7XG4gICAgICAgIHRoaXMudGV0aGVyLnBvc2l0aW9uKCk7XG4gICAgfTtcblxuICAgIEVsZW1lbnRPdmVybGF5LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRldGhlci5kaXNhYmxlKCk7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgRWxlbWVudE92ZXJsYXkucHJvdG90eXBlLmhpZGVPdXRsaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkb20ucmVtb3ZlQ2xhc3ModGhpcy50YXJnZXQsIF9QRU5ET19UQUdHRURfQ0xBU1MpO1xuICAgICAgICBpZiAodGhpcy5vcmlnaW5hbE91dGxpbmVDb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnRhcmdldC5zdHlsZS5vdXRsaW5lQ29sb3IgPSB0aGlzLm9yaWdpbmFsT3V0bGluZUNvbG9yO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMub3JpZ2luYWxPdXRsaW5lQ29sb3I7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgRWxlbWVudE92ZXJsYXkucHJvdG90eXBlLnNob3dPdXRsaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm9yaWdpbmFsT3V0bGluZUNvbG9yID0gdGhpcy50YXJnZXQuc3R5bGUub3V0bGluZUNvbG9yO1xuICAgICAgICBkb20uYWRkQ2xhc3ModGhpcy50YXJnZXQsIF9QRU5ET19UQUdHRURfQ0xBU1MpO1xuICAgICAgICB0aGlzLnRhcmdldC5zdHlsZS5vdXRsaW5lQ29sb3IgPSB0aGlzLm91dGxpbmVDb2xvcjtcbiAgICB9O1xuXG4gICAgc2VsbW8uc3RvcEV2ZW50QnViYmxpbmcgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLy8gd2UncmUgdHJhY2tpbmcgc2VsZWN0aW9uIHZzIG5hdmlnYXRpb25cbiAgICAvLyBhbmQgbG9ja2VkIG9uIHRhcmdldCB2cyB1bmxvY2tlZCAod2hlbiBpbiBzZWxlY3Rpb24pXG4gICAgc2VsbW8uaGFzTG9jayA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbG1vLl9zdGF0ZS5sZW5ndGggPT0gMjsgfTtcbiAgICBzZWxtby5hZGRMb2NrID0gZnVuY3Rpb24gKCkgeyBzZWxtby5fc3RhdGUucHVzaCgnbG9jaycpOyB9O1xuICAgIHZhciBjbGVhckxvY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbG1vLl9zdGF0ZS5zcGxpY2UoMSwgMSk7XG4gICAgICAgIGRvbS5yZW1vdmVDbGFzcygnLm9yaWctJyArIF9QRU5ET19TRUxFQ1RJT05fSElHSExJR0hUX0NMQVNTLCAnb3JpZy0nICsgX1BFTkRPX1NFTEVDVElPTl9ISUdITElHSFRfQ0xBU1MpO1xuICAgICAgICBkb20ucmVtb3ZlQ2xhc3MoJy4nICsgX1BFTkRPX1NFTEVDVElPTl9ISUdITElHSFRfQ0xBU1MsIF9QRU5ET19TRUxFQ1RJT05fSElHSExJR0hUX0NMQVNTKTtcbiAgICB9O1xuXG4gICAgc2VsbW8uX3N0YXRlID0gW251bGxdO1xuICAgIHNlbG1vLmlzSW5TdGF0ZSA9IGZ1bmN0aW9uIChzdCkgeyByZXR1cm4gc2VsbW8uX3N0YXRlWzBdID09PSBzdDsgfTtcblxuICAgIHNlbG1vLnNldFN0YXRlID0gZnVuY3Rpb24gKHN0KSB7XG4gICAgICAgIGlmIChzdCAhPT0gTkFWSUdBVElPTl9NT0RFICYmIHN0ICE9PSBTRUxFQ1RJT05fTU9ERSAmJiBzdCAhPT0gT1ZFUkxBWV9NT0RFKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsbW8uaXNJblN0YXRlKHN0KSkge1xuICAgICAgICAgICAgLy8gQWxyZWFkeSBpbiBzdGF0ZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0ID09PSBTRUxFQ1RJT05fTU9ERSkgeyAvLyBjaGFuZ2UgZnJvbSBuYXYvb3ZlcmxheSB0byBzZWxlY3Rpb25cbiAgICAgICAgICAgIGNsZWFyTG9jaygpO1xuICAgICAgICAgICAgZG9tLmFkZENsYXNzKCdib2R5JywgX1BFTkRPX1NFTEVDVElPTl9DTEFTUyk7XG4gICAgICAgICAgICBkb20ucmVtb3ZlQ2xhc3MoJy5vcmlnLScgKyBfUEVORE9fU0VMRUNUSU9OX0hJR0hMSUdIVF9DTEFTUywgJ29yaWctJyArIF9QRU5ET19TRUxFQ1RJT05fSElHSExJR0hUX0NMQVNTKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gY2hhbmdlIGZyb20gc2VsZWN0aW9uIHRvIG5hdi9vdmVybGF5XG4gICAgICAgICAgICBkb20ucmVtb3ZlQ2xhc3MoJ2JvZHknLCBfUEVORE9fU0VMRUNUSU9OX0NMQVNTKTtcbiAgICAgICAgICAgIGRvbS5yZW1vdmVDbGFzcygnLicgKyBfUEVORE9fU0VMRUNUSU9OX0hJR0hMSUdIVF9DTEFTUywgX1BFTkRPX1NFTEVDVElPTl9ISUdITElHSFRfQ0xBU1MpO1xuICAgICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKCcub3JpZy0nICsgX1BFTkRPX1NFTEVDVElPTl9ISUdITElHSFRfQ0xBU1MsICdvcmlnLScgKyBfUEVORE9fU0VMRUNUSU9OX0hJR0hMSUdIVF9DTEFTUyk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxtby5fc3RhdGVbMF0gPSBzdDtcbiAgICB9O1xuXG4gICAgc2VsbW8uc3RhcnROYXZpZ2F0aW9uTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsbW8uc2V0U3RhdGUoTkFWSUdBVElPTl9NT0RFKTtcbiAgICAgICAgdGFnZ2VkRmVhdHVyZXMuaGlkZSgpO1xuICAgIH07XG5cbiAgICBzZWxtby5zdGFydFNlbGVjdGlvbk1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbG1vLnNldFN0YXRlKFNFTEVDVElPTl9NT0RFKTtcbiAgICAgICAgdGFnZ2VkRmVhdHVyZXMuc2hvd091dGxpbmVzKCk7XG4gICAgfTtcblxuICAgIHNlbG1vLnN0YXJ0T3ZlcmxheU1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbG1vLnNldFN0YXRlKE9WRVJMQVlfTU9ERSk7XG4gICAgICAgIHRhZ2dlZEZlYXR1cmVzLnNob3dPdmVybGF5cygpO1xuICAgIH07XG5cbiAgICAvLyBUT0RPOiBtYWtlIHRoaXMgc21hcnQuICBpZiB0aGUgdGFyZ2V0IGRvZXNuJ3QgbWF0Y2ggb3VyIHNwZWNzIGZvciBhXG4gICAgLy8gVGFnIHRoZW4gY2xpbWIgdGhlIHRyZWUgdW50aWwgd2UgZmluZCBhbiBlbGVtZW50IHRoYXQgZG9lcy5cbiAgICBzZWxtby5maW5kVGFyZ2V0ID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICByZXR1cm4gZXZ0LnRhcmdldDtcbiAgICB9O1xuXG4gICAgc2VsbW8uaXNQcmV2aWV3aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gU2l6emxlKCcuX3BlbmRvLWd1aWRlXycpLmxlbmd0aCA+IDA7XG4gICAgfTtcblxuICAgIHNlbG1vLm92ZXJyaWRlT25DbGljayA9IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIGlmIChlbGVtLm9uY2xpY2spIHtcbiAgICAgICAgICAgIGVsZW0ub2xkT25jbGljayA9IGVsZW0ub25jbGljaztcbiAgICAgICAgICAgIGVsZW0ub25jbGljayA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgc2VsbW8uZml4T25DbGljayA9IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIGlmIChlbGVtICYmIGVsZW0ub2xkT25jbGljaykge1xuICAgICAgICAgICAgZWxlbS5vbmNsaWNrID0gZWxlbS5vbGRPbmNsaWNrO1xuICAgICAgICAgICAgZWxlbS5vbGRPbmNsaWNrID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBzZWxtby51bmhpZ2hsaWdodCA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgaWYgKCFzZWxtby5pc0luU3RhdGUoU0VMRUNUSU9OX01PREUpKSByZXR1cm47XG4gICAgICAgIGlmIChzZWxtby5oYXNMb2NrKCkpIHJldHVybjtcbiAgICAgICAgaWYgKHNlbG1vLmlzUHJldmlld2luZygpKSByZXR1cm47XG5cbiAgICAgICAgdmFyIHRhcmdldCA9IHNlbG1vLmZpbmRUYXJnZXQoZXZ0KTtcblxuICAgICAgICB2YXIgb2xkVGFyZ2V0ID0gU2l6emxlKCcuJyArIF9QRU5ET19TRUxFQ1RJT05fSElHSExJR0hUX0NMQVNTKVswXTtcbiAgICAgICAgZG9tLnJlbW92ZUNsYXNzKCcuJyArIF9QRU5ET19TRUxFQ1RJT05fSElHSExJR0hUX0NMQVNTLCBfUEVORE9fU0VMRUNUSU9OX0hJR0hMSUdIVF9DTEFTUyk7XG5cbiAgICAgICAgc2VsbW8uZml4T25DbGljayhvbGRUYXJnZXQpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBkZXRlY3RJZ25vcmVkRWxlbWVudChldnQpIHtcbiAgICAgICAgcmV0dXJuIGV2dC50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdwZW5kby1ub25zZWxlY3QtZWxlbWVudCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRldGVjdE1vZEtleXMoZXZ0KSB7XG4gICAgICAgIHJldHVybiAoZXZ0LnNoaWZ0S2V5IHx8IGV2dC5jdHJsS2V5IHx8IGV2dC5hbHRLZXkpIHx8IGRldGVjdElnbm9yZWRFbGVtZW50KGV2dCk7XG4gICAgfTtcblxuICAgIHNlbG1vLmhpZ2hsaWdodCA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgaWYgKCFzZWxtby5pc0luU3RhdGUoU0VMRUNUSU9OX01PREUpKSByZXR1cm47XG4gICAgICAgIGlmIChzZWxtby5oYXNMb2NrKCkpIHJldHVybjtcbiAgICAgICAgaWYgKHNlbG1vLmlzUHJldmlld2luZygpKSByZXR1cm47XG5cbiAgICAgICAgdmFyIHRhcmdldCA9IHNlbG1vLmZpbmRUYXJnZXQoZXZ0KTtcblxuICAgICAgICB2YXIgb2xkVGFyZ2V0ID0gU2l6emxlKCcuJyArIF9QRU5ET19TRUxFQ1RJT05fSElHSExJR0hUX0NMQVNTKVswXTtcbiAgICAgICAgZG9tLnJlbW92ZUNsYXNzKCcuJyArIF9QRU5ET19TRUxFQ1RJT05fSElHSExJR0hUX0NMQVNTLCBfUEVORE9fU0VMRUNUSU9OX0hJR0hMSUdIVF9DTEFTUyk7XG5cbiAgICAgICAgaWYgKGRldGVjdE1vZEtleXMoZXZ0KSkge1xuICAgICAgICAgICAgLy8gRG9uJ3QgaGlnaGxpZ2h0IGlmIG1vZGlmaWVyIGtleSBpcyBkb3duXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzZWxtby5maXhPbkNsaWNrKG9sZFRhcmdldCk7XG5cbiAgICAgICAgZG9tLmFkZENsYXNzKHRhcmdldCwgX1BFTkRPX1NFTEVDVElPTl9ISUdITElHSFRfQ0xBU1MpO1xuXG4gICAgICAgIHNlbG1vLm92ZXJyaWRlT25DbGljayh0YXJnZXQpO1xuXG4gICAgICAgIHJldHVybiBzZWxtby5zdG9wRXZlbnRCdWJibGluZyhldnQpO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKF8uaXNGdW5jdGlvbihkb20uZ2V0Q2xhc3MpKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9tLmdldENsYXNzKGVsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NOYW1lO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIEZJWE1FIC0gc2hvdWxkIG1lcmdlIHdpdGggZXh0cmFjdEVsZW1lbnRUcmVlQ29udGV4dFxuICAgIHNlbG1vLmdldFRhcmdldFBhdGggPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIHZhciBwYXRoRWxlbXNBcnIgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRhcmdldC5wYXJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgY2xhc3NlcyA9IHNlbG1vLl9nZXRWYWxpZENsYXNzTmFtZXModGFyZ2V0KTtcblxuICAgICAgICAgICAgdmFyIGVsZW0gPSB7XG4gICAgICAgICAgICAgICAgdGFnOiB0YXJnZXQubm9kZU5hbWUsXG4gICAgICAgICAgICAgICAgaWQ6IHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2lkJykgfHwgJycsXG4gICAgICAgICAgICAgICAgY2xhc3NlczogY2xhc3NlcyxcbiAgICAgICAgICAgICAgICBocmVmOiB0YXJnZXQuZ2V0QXR0cmlidXRlKCdocmVmJylcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwYXRoRWxlbXNBcnIudW5zaGlmdChlbGVtKTtcbiAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhdGhFbGVtc0FycjtcbiAgICB9O1xuXG4gICAgc2VsbW8uaXNCYWRDbGFzcyA9IGZ1bmN0aW9uIChjbHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBJR05PUkVfQ0xBU1NFUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKElHTk9SRV9DTEFTU0VTW2ldLnRvTG93ZXJDYXNlKCkgPT09IGNscy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFeGNsdWRlIGFsbCB0aGUgY2xhc3NlcyBnZW5lcmF0ZWQgYnkgVGV0aGVyXG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKCdeJyArIF9QRU5ET19URVRIRVJfQ0xBU1NfUFJFRklYICsgJy0nKS50ZXN0KGNscyk7XG4gICAgfTtcblxuICAgIHNlbG1vLl9nZXRWYWxpZENsYXNzTmFtZXMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgY2xhc3NlcyA9IFtdO1xuICAgICAgICBsZXQgY2xzU3RyID0gdHlwZW9mKGVsZW1lbnQuY2xhc3NOYW1lKSA9PSAnc3RyaW5nJyA/IGVsZW1lbnQuY2xhc3NOYW1lIDogZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgICAgIGlmIChjbHNTdHIgJiYgY2xzU3RyICE9PSAnJykge1xuICAgICAgICAgICAgdmFyIHJhd0NsYXNzZXMgPSBjbHNTdHIuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3Q2xhc3Nlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjbHMgPSByYXdDbGFzc2VzW2ldO1xuICAgICAgICAgICAgICAgIGNscy5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XG4gICAgICAgICAgICAgICAgaWYgKGNscyAhPT0gJycgJiYgc2VsbW8uaXNCYWRDbGFzcyhjbHMpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2goY2xzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsYXNzZXM7XG4gICAgfTtcblxuICAgIHNlbG1vLnRlc3RDc3NTZWxlY3RvciA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBlbGVtcyA9IG51bGw7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGVsZW1zID0gU2l6emxlKGRhdGEuY3NzU2VsZWN0b3IpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0ZWxsTWFzdGVyKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY3NzVGVzdFJlc3VsdCcsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ0ludmFsaWQgQ1NTIFNlbGVjdG9yJyxcbiAgICAgICAgICAgICAgICBpc0ludmFsaWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1zZyA9ICcnO1xuICAgICAgICB2YXIgc3VjY2VzcyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIENoZWNraW5nIGZvciB1bmFjY2VwdGVkIENTUyBzZWxlY3RvcnNcbiAgICAgICAgLy9ObyAqICsgfiB1bmxlc3MgZm9sbG93ZWQgYnkgPVxuICAgICAgICBpZihuZXcgUmVnRXhwKCcvW1xcK35cXCpdKD8hPSkvZycpLmV4ZWMoZGF0YS5jc3NTZWxlY3RvcikpIHtcbiAgICAgICAgICAgIHRlbGxNYXN0ZXIoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdjc3NUZXN0UmVzdWx0JyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnRGlzYWxsb3dlZCBDU1MgU2VsZWN0b3InLFxuICAgICAgICAgICAgICAgIGlzSW52YWxpZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBtc2cgPSAnTm8gZWxlbWVudHMgZm91bmQuJztcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtcy5sZW5ndGggPT09IDEgfHwgZGF0YS5hbGxvd011bHRpcGxlKSB7XG4gICAgICAgICAgICBzdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1zZyA9ICdNb3JlIHRoYW4gMSBlbGVtZW50IGZvdW5kLiAgUGxlYXNlIGNoYW5nZS4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdWNjZXNzKSB7IC8vIEhpZ2hsaWdodFxuICAgICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKCcuJyArIF9QRU5ET19TRUxFQ1RJT05fSElHSExJR0hUX0NMQVNTLCBfUEVORE9fU0VMRUNUSU9OX0hJR0hMSUdIVF9DTEFTUyk7XG4gICAgICAgICAgICBkb20uYWRkQ2xhc3MoZGF0YS5jc3NTZWxlY3RvciwgX1BFTkRPX1NFTEVDVElPTl9ISUdITElHSFRfQ0xBU1MpO1xuICAgICAgICB9XG4gICAgICAgIHRlbGxNYXN0ZXIoe1xuICAgICAgICAgICAgdHlwZTogJ2Nzc1Rlc3RSZXN1bHQnLFxuICAgICAgICAgICAgbWVzc2FnZTogbXNnLFxuICAgICAgICAgICAgc3VjY2Vzczogc3VjY2Vzc1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgc2VsbW8uSURfQkxBQ0tMSVNUID0gWyAvZXh0LWdlblxcZCsvLCAvZXh0LWNvbXAtXFxkKy8sIC94LWF1dG8tXFxkKy8sIC9nd3QtdWlkLVxcZCsvIF07XG4gICAgc2VsbW8uX2lzQmxhY2tMaXN0ZWRJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbG1vLklEX0JMQUNLTElTVC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG5ldyBSZWdFeHAoc2VsbW8uSURfQkxBQ0tMSVNUW2ldKS5leGVjKGlkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gQ3NzU2VsZWN0b3JCdWlsZGVyIChlbGVtZW50LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBwYXRoID0gW107XG4gICAgICAgIHZhciBjb25qdW5jdGlvbiA9ICcgPiAnO1xuICAgICAgICB2YXIgY3VycmVudENvbnRleHQgPSBjb250ZXh0O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZWxlY3Rvcjogc2VsZWN0b3IsXG4gICAgICAgICAgICB1cDogdXBcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiB1cCAoKSB7XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRDb250ZXh0LnBhcmVudEVsZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhdGgudW5zaGlmdChjcmVhdGVQYXRoTm9kZShlbGVtZW50LCBjdXJyZW50Q29udGV4dCkpO1xuICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0ID0gY3VycmVudENvbnRleHQucGFyZW50RWxlbTtcblxuICAgICAgICAgICAgcmV0dXJuIHBhdGhbMF0ubWF0Y2hDb3VudCAhPT0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNlbGVjdG9yIChvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIWNvbnRleHQucGFyZW50RWxlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnYm9keSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgcmV0dXJuIF8uY2hhaW4ocGF0aCkubWFwKGZ1bmN0aW9uIChwYXRoTm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXRoTm9kZS5jb250YWlucyAmJiBvcHRpb25zLmNvbnRhaW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXRoTm9kZS5iZXN0U2VsZWN0b3IgKyBwYXRoTm9kZS5jb250YWlucztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBlbmRvLmRvZXNFeGlzdChwYXRoTm9kZS5udGhDaGlsZCkgJiYgb3B0aW9ucy5udGhDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0aE5vZGUuYmVzdFNlbGVjdG9yICsgcGF0aE5vZGUubnRoQ2hpbGQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdGhOb2RlLmJlc3RTZWxlY3RvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KS52YWx1ZSgpLmpvaW4oY29uanVuY3Rpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlUGF0aE5vZGUgKGVsZW1lbnQsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0LmlkICYmICFzZWxtby5faXNCbGFja0xpc3RlZElkKGNvbnRleHQuaWQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkU2VsZWN0b3IgPSAnW2lkPVwiJyArIGNvbnRleHQuaWQgKyAnXCJdJztcbiAgICAgICAgICAgICAgICBpZiAoU2l6emxlKGlkU2VsZWN0b3IpLmxlbmd0aCA9PT0gMSkgeyAvLyBNYWtlIHN1cmUgaXQgcmVhbGx5IGlzIHVuaXF1ZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyAvLyBEb24ndCBib3RoZXIgZG9pbmcgYW55dGhpbmcgZWxzZSBpZiB3ZSBmb3VuZCBhIHVuaXF1ZSBpZFxuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdFNlbGVjdG9yOiAnIycgKyBlc2NhcGVDc3MoY29udGV4dC5pZCksXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaENvdW50OiAxXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IGVsZW1lbnQucGFyZW50Tm9kZTtcblxuICAgICAgICAgICAgdmFyIHNlbGVjdG9ycyA9IF8ubWFwKGdldFZhbGlkQXR0cmlidXRlcyhjb250ZXh0LmF0dHJzKSwgZnVuY3Rpb24gKGF0dHJOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdbJyArIGF0dHJOYW1lICsgJz1cIicgKyBjb250ZXh0LmF0dHJzW2F0dHJOYW1lXSArICdcIl0nO1xuICAgICAgICAgICAgfSkuY29uY2F0KF8ubWFwKHNlbG1vLl9nZXRWYWxpZENsYXNzTmFtZXMoZWxlbWVudCksIGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJy4nICsgZXNjYXBlQ3NzKGNsYXNzTmFtZSk7XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIGlmIChpZFNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3JzLnB1c2goaWRTZWxlY3Rvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGVjdG9ycy5wdXNoKGNvbnRleHQudGFnLnRvTG93ZXJDYXNlKCkpO1xuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgRmlsdGVyIGZvciBwb3RlbnRpYWwgc2VsZWN0b3JzIHRoYXQgcHJvdmlkZSBoaWdoIHNwZWNpZmljaXR5XG4gICAgICAgICAgICBhbW9uZyB0aGlzIGVsZW1lbnQncyBzaWJsaW5ncy5cbiAgICAgICAgICAgIFRoaXMgbWlnaHQgbWVhbiB0aGF0IHdlIGRyb3Agc29tZXRoaW5nIHRoYXQgcHJvdmlkZXMgaGlnaCBnbG9iYWxcbiAgICAgICAgICAgIHNwZWNpZmljaXR5LCBidXQsIGhleS4uLiB3ZSBnb3R0YSBsaW1pdCB0aGlzIHRoaW5nIHNvbWVob3cuXG4gICAgICAgICAgICBBbHNvLCB0cnlpbmcgdG8gYXZvaWQgcnVubmluZyBTaXp6bGUgYWdhaW5zdCB0aGUgZnVsbCBkb2N1bWVudFxuICAgICAgICAgICAgKHdpdGggbGlrZWx5IGluZWZmaWNpZW50IHNlbGVjdG9ycykgdG9vIG1hbnkgdGltZXMuXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgc2VsZWN0b3JzID0gXy5jaGFpbihzZWxlY3RvcnMpLm1hcChmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaENvdW50OiBTaXp6bGUoJz4nICsgc2VsZWN0b3IsIHBhcmVudE5vZGUpLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6IHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pLnNvcnRCeSgnbWF0Y2hDb3VudCcpLnBsdWNrKCdzZWxlY3RvcicpLmZpcnN0KDMpLnZhbHVlKCk7XG5cbiAgICAgICAgICAgIHZhciBwYXRoTm9kZSA9IHtcbiAgICAgICAgICAgICAgICBzZWxlY3RvcnM6IHNlbGVjdG9yc1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKHBlbmRvLmRvZXNFeGlzdChjb250ZXh0LmNoaWxkSW5kZXgpICYmIHBhcmVudE5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMSkgeyAvLyBlbGVtZW50IGhhcyBzaWJsaW5nc1xuICAgICAgICAgICAgICAgIHBhdGhOb2RlLm50aENoaWxkID0gJzpudGgtY2hpbGQoJyArIChjb250ZXh0LmNoaWxkSW5kZXggKyAxKSArICcpJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbnRleHQudHh0KSB7XG4gICAgICAgICAgICAgICAgcGF0aE5vZGUuY29udGFpbnMgPSBidWlsZENvbnRhaW5zUnVsZShjb250ZXh0LnR4dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBlbGVjdEJlc3RTZWxlY3RvcihwYXRoTm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBlbGVjdEJlc3RTZWxlY3RvciAocGF0aE5vZGUpIHtcbiAgICAgICAgICAgIHZhciBiZXN0U2VsZWN0b3JTb0ZhciA9IF8uY2hhaW4ocGF0aCkucGx1Y2soJ2Jlc3RTZWxlY3RvcicpLnZhbHVlKCk7XG5cbiAgICAgICAgICAgIHBhdGhOb2RlLm1hdGNoQ291bnQgPSBJbmZpbml0eTtcbiAgICAgICAgICAgIF8uZmluZChwYXRoTm9kZS5zZWxlY3RvcnMsIGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaENvdW50ID0gU2l6emxlKFtzZWxlY3Rvcl0uY29uY2F0KGJlc3RTZWxlY3RvclNvRmFyKS5qb2luKGNvbmp1bmN0aW9uKSkubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaENvdW50ID4gMCAmJiBtYXRjaENvdW50IDwgcGF0aE5vZGUubWF0Y2hDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBwYXRoTm9kZS5iZXN0U2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgcGF0aE5vZGUubWF0Y2hDb3VudCA9IG1hdGNoQ291bnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXRoTm9kZS5tYXRjaENvdW50ID09PSAxOyAvLyBTdG9wIGVhcmx5IGlmIHdlIGZpbmQgYSB1bmlxdWUgbWF0Y2hcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gcGF0aE5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRWYWxpZEF0dHJpYnV0ZXMgKGF0dHJzKSB7XG4gICAgICAgICAgICByZXR1cm4gXy5jaGFpbihhdHRycykua2V5cygpXG4gICAgICAgICAgICAgICAgLndpdGhvdXQoJ2lkJywgJ2NsYXNzJywgJ3RpdGxlJywgJ3RhYmluZGV4JylcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChhdHRyTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXR0cnNbYXR0ck5hbWVdO1xuICAgICAgICAgICAgICAgIH0pLnZhbHVlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBlc2NhcGVDc3MgKGNzcykge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2Nzcy1lc2NhcGVzI2Nzc1xuICAgICAgICAgICAgcmV0dXJuIGNzcy5yZXBsYWNlKC9bIVwiI1xcJCUmJ1xcKFxcKVxcKlxcKyxcXC5cXC86Ozw9PlxcP0BcXFtcXFxcXFxdXFxeYFxce1xcfFxcfX5dL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnXFxcXCcgKyBtYXRjaDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYnVpbGRDb250YWluc1J1bGUgKHRleHQpIHtcbiAgICAgICAgICAgIHZhciBzaW5nbGVRdW90ZUluZGV4LCBkb3VibGVRdW90ZUluZGV4LCBxdW90ZTtcbiAgICAgICAgICAgIGlmICgodGV4dCA9IHRleHQudHJpbSgpKSAmJlxuICAgICAgICAgICAgICAgIHRleHQubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgIHRleHQubGVuZ3RoIDwgMTI4ICYmXG4gICAgICAgICAgICAgICAgIS9cXHUwMGEwLy50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICAgICAgc2luZ2xlUXVvdGVJbmRleCA9IHRleHQuaW5kZXhPZignXFwnJyk7XG4gICAgICAgICAgICAgICAgZG91YmxlUXVvdGVJbmRleCA9IHRleHQuaW5kZXhPZignXCInKTtcbiAgICAgICAgICAgICAgICAvLyBDaG9vc2luZyB3aGV0aGVyIHRvIHVzZSBgJ2Agb3IgYFwiYCB3aGVuIHdyYXBwaW5nIDpjb250YWlucyBpbnB1dC5cbiAgICAgICAgICAgICAgICAvLyBgJ2AgaWYgaXQncyBub3QgZm91bmQgaW4gdGV4dC5cbiAgICAgICAgICAgICAgICAvLyBPUiBpZiBhIGBcImAgaXMgZm91bmQgYmVmb3JlIGFuIGluc3RhbmNlIG9mIGAnYFxuICAgICAgICAgICAgICAgIGlmIChzaW5nbGVRdW90ZUluZGV4ID09PSAtMSB8fFxuICAgICAgICAgICAgICAgICAgICAoZG91YmxlUXVvdGVJbmRleCAhPT0gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvdWJsZVF1b3RlSW5kZXggPCBzaW5nbGVRdW90ZUluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICBxdW90ZSA9ICdcXCcnO1xuICAgICAgICAgICAgICAgIC8vIFVzaW5nIGBcImAgaWYgYCdgIGlzIHVzZWQgaW4gaW5wdXQgYmVmb3JlIGBcImBcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBxdW90ZSA9ICdcIic7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gdGV4dCBzZXQgdG8gZmlyc3Qgc3Vic3RyaW5nIG9mIHRleHQgdGhhdCBkb2Vzbid0IGluY2x1ZGVcbiAgICAgICAgICAgICAgICAvLyBcXGYsIFxcbiwgXFxyLCBhbmQgdGhlIHR5cGUgb2YgcXVvdGF0aW9uIG1hcmsgdXNlZCB0byB3cmFwIDpjb250YWlucy5cbiAgICAgICAgICAgICAgICB0ZXh0ID0gbmV3IFJlZ0V4cCgnXlteXFxcXGZcXFxcblxcXFxyJyArIHF1b3RlICsgJ10rJykuZXhlYyh0ZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dCA/ICc6Y29udGFpbnMoJyArIHF1b3RlICsgdGV4dFswXSArIHF1b3RlICsgJyknIDogJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlQ3NzTWF0Y2ggKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBleHRyYWN0RWxlbWVudFRyZWVDb250ZXh0KGVsZW1lbnQpO1xuICAgICAgICB2YXIgc2VsZWN0b3JCdWlsZGVyID0gQ3NzU2VsZWN0b3JCdWlsZGVyKGVsZW1lbnQsIGNvbnRleHQpO1xuXG4gICAgICAgIHdoaWxlIChzZWxlY3RvckJ1aWxkZXIudXAoKSkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdG9yID0gXy5maW5kKFtcbiAgICAgICAgICAgICAgICBzZWxlY3RvckJ1aWxkZXIuc2VsZWN0b3IoKSxcbiAgICAgICAgICAgICAgICBzZWxlY3RvckJ1aWxkZXIuc2VsZWN0b3IoeyBjb250YWluczogdHJ1ZSB9KSxcbiAgICAgICAgICAgICAgICBzZWxlY3RvckJ1aWxkZXIuc2VsZWN0b3IoeyBjb250YWluczogdHJ1ZSwgbnRoQ2hpbGQ6IHRydWUgfSksXG4gICAgICAgICAgICAgICAgc2VsZWN0b3JCdWlsZGVyLnNlbGVjdG9yKHsgbnRoQ2hpbGQ6IHRydWUgfSlcbiAgICAgICAgICAgIF0sIGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IFNpenpsZShzZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoLmxlbmd0aCA9PT0gMSAmJiBtYXRjaFswXSA9PT0gZWxlbWVudDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZWN0b3JCdWlsZGVyLnNlbGVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gRWxlbWVudFRyZWVDb250ZXh0XG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IGlkXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IHRhZ1xuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBjbHNcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ3x1bmRlZmluZWR9IHR4dFxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjaGlsZEluZGV4XG4gICAgICogQHByb3BlcnR5IHtFbGVtZW50VHJlZUNvbnRleHR8dW5kZWZpbmVkfSBwYXJlbnRFbGVtXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGJ1aWxkIGFuIGFnZW50LXN0eWxlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwYXRoXG4gICAgICogdG8gdGhlIERPTSBlbGVtZW50LCBpZiB0aGUgYWdlbnQgZG9lcyBub3QgZXhwb3J0XG4gICAgICogcGVuZG8uZGVzaWduZXIuZXh0cmFjdEVsZW1lbnRUcmVlQ29udGV4dCAoPj0yLjMuMCkuXG4gICAgICogVGhpcyBpcyBhIHNpbXBsaWZpZWQgdmVyc2lvbiBvZiBleHRyYWN0RWxlbWVudFRyZWVDb250ZXh0XG4gICAgICogZnJvbSB0aGUgYWdlbnQsIHNpbmNlIHRoZSBkZXNpZ25lciByZXF1aXJlcyB0aGUgdXNlXG4gICAgICogb2YgbW9yZSBtb2Rlcm4gYnJvd3NlcnMuIEl0IGFsc28gZXhjbHVkZXMgYXR0cmlidXRlc1xuICAgICAqIGJlY2F1c2UgYXR0cmlidXRlcyB3ZXJlIG5vdCBwYXJ0IG9mIHN1Z2dlc3RlZCBtYXRjaGVzXG4gICAgICogdW50aWwgYWdlbnQgPj0yLjMuMFxuICAgICAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHJldHVybiB7RWxlbWVudFRyZWVDb250ZXh0fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV4dHJhY3RFbGVtZW50VHJlZUNvbnRleHRCYWNrRmlsbCAoZWxlbWVudCkge1xuICAgICAgICB2YXIgY29udGV4dCA9IHt9O1xuICAgICAgICB2YXIgY3VycmVudENvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB2YXIgY3VycmVudEVsZW1lbnQgPSBlbGVtZW50O1xuXG4gICAgICAgIHdoaWxlIChjdXJyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgY3VycmVudENvbnRleHQuaWQgPSBjdXJyZW50RWxlbWVudC5pZDtcbiAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0LnRhZyA9IGN1cnJlbnRFbGVtZW50Lm5vZGVOYW1lO1xuICAgICAgICAgICAgY3VycmVudENvbnRleHQuY2xzID0gY3VycmVudEVsZW1lbnQuY2xhc3NOYW1lO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudEVsZW1lbnQucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0LnBhcmVudEVsZW0gPSB7fTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udGV4dC5jaGlsZEluZGV4ID0gXy5pbmRleE9mKGN1cnJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQuY2hpbGRyZW4sIGN1cnJlbnRFbGVtZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3VycmVudENvbnRleHQgPSBjdXJyZW50Q29udGV4dC5wYXJlbnRFbGVtO1xuICAgICAgICAgICAgY3VycmVudEVsZW1lbnQgPSBjdXJyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwZW5kby5leGNsdWRlQWxsVGV4dCAmJiBfLmlzRnVuY3Rpb24ocGVuZG8uZ2V0VGV4dCkpIHtcbiAgICAgICAgICAgIGNvbnRleHQudHh0ID0gcGVuZG8uZ2V0VGV4dChlbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH1cblxuICAgIHNlbG1vLmNvbXB1dGVDc3NNYXRjaCA9IGNvbXB1dGVDc3NNYXRjaDtcblxuICAgIHNlbG1vLmdldFNlbGVjdGVkRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9yaWdDbGFzcyA9ICdvcmlnLScgKyBfUEVORE9fU0VMRUNUSU9OX0hJR0hMSUdIVF9DTEFTUztcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUob3JpZ0NsYXNzKVswXTtcbiAgICB9O1xuXG4gICAgc2VsbW8uY2xpY2sgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIGlmIChzZWxtby5pc0luU3RhdGUoTkFWSUdBVElPTl9NT0RFKSB8fFxuICAgICAgICAgICAgc2VsbW8uaXNJblN0YXRlKE9WRVJMQVlfTU9ERSkpIHtcbiAgICAgICAgICAgIHRlbGxNYXN0ZXIoe3R5cGU6ICduYXYtY2xpY2snfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAoc2VsbW8uaXNJblN0YXRlKFNFTEVDVElPTl9NT0RFKSAmJiAhc2VsbW8uaGFzTG9jaygpKSB7XG4gICAgICAgICAgICBpZiAoZGV0ZWN0TW9kS2V5cyhldnQpKSB7XG4gICAgICAgICAgICAgICAgLy8gVHJlYXQgbGlrZSBhIG5vcm1hbCBjbGljayBpZiBzaGlmdCBrZXkgaXMgZG93blxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxtby5hZGRMb2NrKCk7XG5cbiAgICAgICAgICAgIGRvbS5hZGRDbGFzcyhldnQudGFyZ2V0LCAnb3JpZy0nICsgX1BFTkRPX1NFTEVDVElPTl9ISUdITElHSFRfQ0xBU1MpO1xuICAgICAgICAgICAgc2VsbW8uZml4T25DbGljayhldnQudGFyZ2V0KTtcblxuICAgICAgICAgICAgdmFyIGNsaWVudF9jb29yZHMgPSB7eDogZXZ0LmNsaWVudFgsIHk6IGV2dC5jbGllbnRZfTtcbiAgICAgICAgICAgIHZhciBzY3JlZW5fY29vcmRzID0ge3g6IGV2dC5zY3JlZW5YLCB5OiBldnQuc2NyZWVuWX07XG5cbiAgICAgICAgICAgIC8vIE5PVEU6IGNhbid0IHN0cmluZ2lmeSBldnQgb3IgZXZ0LnRhcmdldDogY2lyY3VsYXIgcmVmZXJlbmNlXG4gICAgICAgICAgICB0ZWxsTWFzdGVyKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY2xpY2snLFxuICAgICAgICAgICAgICAgIHVybDogbG9jYXRpb24udG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdGFnTmFtZTogZXZ0LnRhcmdldC50YWdOYW1lLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBzZWxtby5nZXRUYXJnZXRQYXRoKGV2dC50YXJnZXQpLFxuICAgICAgICAgICAgICAgICAgICBjc3NNYXRjaDogc2VsbW8uY29tcHV0ZUNzc01hdGNoKGV2dC50YXJnZXQpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICBjbGllbnQ6IGNsaWVudF9jb29yZHMsXG4gICAgICAgICAgICAgICAgICAgIHNjcmVlbjogc2NyZWVuX2Nvb3Jkc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gc2VsbW8uc3RvcEV2ZW50QnViYmxpbmcoZXZ0KTtcbiAgICAgICAgfSBlbHNlIGlmIChzZWxtby5pc1ByZXZpZXdFbGVtZW50KGV2dC50YXJnZXQpID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyByZXR1cm4gc2VsbW8uc3RvcEV2ZW50QnViYmxpbmcoZXZ0KTtcbiAgICB9O1xuXG4gICAgc2VsbW8uZmluZE50aFBhcmVudCA9IGZ1bmN0aW9uIChlbGVtLCBudGgpIHtcbiAgICAgICAgdmFyIHAgPSBlbGVtLnBhcmVudE5vZGU7XG4gICAgICAgIHZhciBjb3VudCA9IDE7XG5cbiAgICAgICAgd2hpbGUgKGNvdW50IDwgbnRoKSB7XG4gICAgICAgICAgICBwID0gcC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwO1xuICAgIH07XG5cbiAgICBzZWxtby5oYW5kbGVNb3ZlU2VsZWN0aW9uVXAgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgbnRoID0gZGF0YS5kaXN0YW5jZTtcblxuICAgICAgICB2YXIgb3JpZ0NsYXNzID0gJ29yaWctJyArIF9QRU5ET19TRUxFQ1RJT05fSElHSExJR0hUX0NMQVNTO1xuXG4gICAgICAgIGRvbS5yZW1vdmVDbGFzcygnLicgKyBfUEVORE9fU0VMRUNUSU9OX0hJR0hMSUdIVF9DTEFTUywgX1BFTkRPX1NFTEVDVElPTl9ISUdITElHSFRfQ0xBU1MpO1xuXG4gICAgICAgIGlmIChudGggPT09IDApIHtcbiAgICAgICAgICAgIGRvbS5hZGRDbGFzcygnLicgKyBvcmlnQ2xhc3MsIF9QRU5ET19TRUxFQ1RJT05fSElHSExJR0hUX0NMQVNTKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShvcmlnQ2xhc3MpWzBdO1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHNlbG1vLmZpbmROdGhQYXJlbnQoZWxlbSwgbnRoKTtcblxuICAgICAgICAgICAgZG9tLmFkZENsYXNzKHRhcmdldCwgX1BFTkRPX1NFTEVDVElPTl9ISUdITElHSFRfQ0xBU1MpO1xuXG4gICAgICAgICAgICBpZiAoZGF0YS5yZXR1cm5Dc3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3NzTWF0Y2ggPSBzZWxtby5jb21wdXRlQ3NzTWF0Y2godGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB0ZWxsTWFzdGVyKHt0eXBlOiAnY3NzTWF0Y2gnLCBtYXRjaDogY3NzTWF0Y2ggfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgc2VsbW8uTU9ERVMgPSB7XG4gICAgICAgIHNlbGVjdGlvbjogc2VsbW8uc3RhcnRTZWxlY3Rpb25Nb2RlLFxuICAgICAgICBuYXZpZ2F0aW9uOiBzZWxtby5zdGFydE5hdmlnYXRpb25Nb2RlLFxuICAgICAgICBvdmVybGF5OiBzZWxtby5zdGFydE92ZXJsYXlNb2RlXG4gICAgfTtcblxuICAgIHNlbG1vLmVkaXRvckluc3RhbmNlID0gbnVsbDsgLy8gQ0tFRElUT1IgSU5TVEFOQ0VcbiAgICBzZWxtby5jdXJyZW50VXBsb2FkSW5mbyA9IG51bGw7XG5cbiAgICBzZWxtby5zaG93R3VpZGVQcmV2aWV3ID0gZnVuY3Rpb24gKGd1aWRlT3JTdGVwKSB7XG4gICAgICAgIGlmICghcGVuZG8uZGVzaWduZXIgfHwgIXBlbmRvLmRlc2lnbmVyLkd1aWRlRmFjdG9yeSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsbW8uY2xvc2VQcmV2aWV3KHRydWUpOy8vIGRvbid0IHRlbGwgbWFzdGVyIGFib3V0IHRoaXMgY2xvc2VQcmV2aWV3XG5cbiAgICAgICAgdmFyIGd1aWRlID0gZ3VpZGVPclN0ZXA7XG4gICAgICAgIGlmIChndWlkZU9yU3RlcC5ndWlkZUlkKSB7XG4gICAgICAgICAgICBndWlkZSA9IHtcbiAgICAgICAgICAgICAgICBpZDogZ3VpZGVPclN0ZXAuZ3VpZGVJZCxcbiAgICAgICAgICAgICAgICBzdGVwczogW2d1aWRlT3JTdGVwXSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChndWlkZU9yU3RlcC5iYWRnZUluZm8pIHtcbiAgICAgICAgICAgICAgICBndWlkZS5sYXVuY2hNZXRob2QgPSAnYmFkZ2UnO1xuICAgICAgICAgICAgICAgIGd1aWRlLmF0dHJpYnV0ZXMuYmFkZ2UgPSBndWlkZU9yU3RlcC5iYWRnZUluZm87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZ3VpZGUgPSBwZW5kby5kZXNpZ25lci5HdWlkZUZhY3RvcnkoZ3VpZGUpO1xuXG4gICAgICAgIGd1aWRlLnBsYWNlQmFkZ2UoKTtcbiAgICAgICAgZ3VpZGUuc2hvdygpO1xuXG4gICAgICAgIHNlbG1vLnByZXZpZXdlZEd1aWRlID0gZ3VpZGU7XG4gICAgICAgIHByZXZpZXdQb2xsKHNlbG1vLnBvbGxQcmV2aWV3TW9kZSk7XG4gICAgICAgIHJldHVybiBndWlkZS5pc1Nob3duKCk7XG4gICAgfTtcblxuICAgIHNlbG1vLnByZXZpZXdHdWlkZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBndWlkZSA9IGRhdGEuZ3VpZGU7XG5cbiAgICAgICAgZ3VpZGUuaGlkZUNyZWRpdHMgPSBkYXRhLmNvbmZpZy5oaWRlUG93ZXJlZEJ5O1xuXG4gICAgICAgIHZhciBzaG93biA9IHNlbG1vLnNob3dHdWlkZVByZXZpZXcoZ3VpZGUpO1xuXG4gICAgICAgIGlmIChndWlkZS5pc0VkaXRhYmxlICYmICFzaG93bikge1xuICAgICAgICAgICAgc2VsbW8ucHJldmlld0d1aWRlVGhyZWFkSGFuZGxlID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNlbG1vLnByZXZpZXdHdWlkZShkYXRhKTtcbiAgICAgICAgICAgIH0sIERFRkFVTFRfVElNRVJfTEVOR1RIKTtcbiAgICAgICAgfSBlbHNlIGlmIChzaG93bikge1xuICAgICAgICAgICAgdmFyIGVsbXMgPSBnZXRHdWlkZVByZXZpZXdET00oKTtcbiAgICAgICAgICAgIHZhciBndWlkZUNvbnRlbnRFbGVtZW50ID0gZWxtcztcbiAgICAgICAgICAgIGlmIChndWlkZS51cGxvYWQpIHtcbiAgICAgICAgICAgICAgICBzZWxtby5jdXJyZW50VXBsb2FkSW5mbyA9IGd1aWRlLnVwbG9hZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChndWlkZUNvbnRlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGd1aWRlLmlzRWRpdGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3VpZGVDb250ZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScsICd0cnVlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBlZGl0UHJldmlld0NsaWNrRm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRldGFjaEV2ZW50KGd1aWRlQ29udGVudEVsZW1lbnQucGFyZW50Tm9kZSwgJ2NsaWNrJywgZWRpdFByZXZpZXdDbGlja0ZuKTtcbiAgICAgICAgICAgICAgICAgICAgXy5kZWxheShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0RWRpdG9yKGd1aWRlKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMjAwKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGF0dGFjaEV2ZW50KGd1aWRlQ29udGVudEVsZW1lbnQucGFyZW50Tm9kZSwgJ2NsaWNrJywgZWRpdFByZXZpZXdDbGlja0ZuKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VuZEd1aWRlQ3NzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGdldEd1aWRlUHJldmlld0RPTSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGd1aWRlRWxlbSA9IFNpenpsZSgnLl9wZW5kby1ndWlkZV8nKVswXSxcbiAgICAgICAgICAgIGNvbnRlbnRFbGVtID0gU2l6emxlKCcuX3BlbmRvLWd1aWRlLWNvbnRlbnRfJywgZ3VpZGVFbGVtKVswXTtcblxuICAgICAgICBpZiAoIVNpenpsZSgnI3BlbmRvX2NrZV90b29sYmFyJykubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBhZGQgYSBzcG90IGZvciB0aGUgQ0tFRElUT1IgdG9vbGJhciB0byBsaXZlXG4gICAgICAgICAgICB2YXIgdG9vbGJhckVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHRvb2xiYXJFbGVtLmlkID0gJ3BlbmRvX2NrZV90b29sYmFyJztcbiAgICAgICAgICAgIGd1aWRlRWxlbS5hcHBlbmRDaGlsZCh0b29sYmFyRWxlbSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGVudEVsZW0pIHtcbiAgICAgICAgICAgIGNvbnRlbnRFbGVtLmlkID0gJ2VkaXRpbmdfZ3VpZGVfcHJldmlldyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRlbnRFbGVtO1xuICAgIH07XG5cbiAgICBzZWxtby51cGRhdGVVcGxvYWRJbmZvID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgc2VsbW8uY3VycmVudFVwbG9hZEluZm8gPSBkYXRhLnVwbG9hZDtcbiAgICB9O1xuXG4gICAgdmFyIGluaXRFZGl0b3IgPSBmdW5jdGlvbiAoZ3VpZGUpIHtcbiAgICAgICAgaWYgKGd1aWRlICYmIGd1aWRlLmlzRWRpdGFibGUpIHtcbiAgICAgICAgICAgIGxvZygnY2FsbGluZyBja2VkaXRvciBpbmxpbmUnKTtcblxuICAgICAgICAgICAgdmFyIGJhc2VQYXRoID0gd2luZG93LlBFTkRPX0NLRURJVE9SX0JBU0VQQVRIID0gUEVORE9fQ0tFRElUT1IuYmFzZVBhdGggPSBwZW5kby5IT1NUICsgJy9qcy9saWIvY2tlZGl0b3IvJztcblxuICAgICAgICAgICAgdmFyIHBsdWdpbnMgPSBQRU5ET19DS0VESVRPUi5wbHVnaW5zO1xuICAgICAgICAgICAgaWYgKCFwbHVnaW5zLmV4dGVybmFsc1sncGVuZG8tcG9sbCddKSB7XG4gICAgICAgICAgICAgICAgcGx1Z2lucy5hZGRFeHRlcm5hbCgncGVuZG8tcG9sbCcsIHBlbmRvLkhPU1QgKyAnL21vZHVsZXMvcGVuZG8uZGVzaWduZXIvcGx1Z2lucy9ja2VkaXRvci9wZW5kby1wb2xsLycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY2sgPSBQRU5ET19DS0VESVRPUi5pbmxpbmUoJ2VkaXRpbmdfZ3VpZGVfcHJldmlldycsIHtcbiAgICAgICAgICAgICAgICBjdXN0b21Db25maWc6ICcnLFxuICAgICAgICAgICAgICAgIHJlbW92ZVBsdWdpbnM6ICdlbGVtZW50c3BhdGgnLFxuICAgICAgICAgICAgICAgIHJlbW92ZUJ1dHRvbnM6ICdTdWJzY3JpcHQsU3VwZXJzY3JpcHQsU3RyaWtlVGhyb3VnaCcsXG4gICAgICAgICAgICAgICAgZXh0cmFQbHVnaW5zOiAnc2ltcGxldXBsb2FkcyxvZW1iZWQsanVzdGlmeSx3aWRnZXQsbGluZXV0aWxzLGZvbnQscmljaGNvbWJvLHBhbmVsYnV0dG9uLGZsb2F0cGFuZWwsY29sb3JidXR0b24saW1hZ2UyLHNoYXJlZHNwYWNlLHBlbmRvLXBvbGwnLFxuICAgICAgICAgICAgICAgIHNpbXBsZXVwbG9hZHNfYWNjZXB0ZWRFeHRlbnNpb25zOiAnanBnfGpwZWd8cG5nfGdpZicsXG4gICAgICAgICAgICAgICAgZmlsZWJyb3dzZXJJbWFnZVVwbG9hZFVybDogJy90ZXN0L3VwbG9hZCcsXG4gICAgICAgICAgICAgICAgcmVtb3ZlRGlhbG9nVGFiczogJ2ltYWdlOmFkdmFuY2VkO2xpbms6YWR2YW5jZWQnLFxuICAgICAgICAgICAgICAgIGJhc2VGbG9hdFpJbmRleDogOTk5OTk5OSxcbiAgICAgICAgICAgICAgICBhbGxvd2VkQ29udGVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBhZGQgYHByb3RlY3RlZFNvdXJjZWAgcmVnZXggZm9yIGA8JT0gJT5gIHRhZ3M/XG4gICAgICAgICAgICAgICAgc3RhcnR1cEZvY3VzOiB0cnVlLFxuICAgICAgICAgICAgICAgIHNoYXJlZFNwYWNlczoge1xuICAgICAgICAgICAgICAgICAgICB0b3A6ICdwZW5kb19ja2VfdG9vbGJhcidcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRvb2xiYXI6IFtcbiAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1NvdXJjZScsICctJywgJ0p1c3RpZnlMZWZ0JywgJ0p1c3RpZnlDZW50ZXInLCAnSnVzdGlmeVJpZ2h0JywgJ0p1c3RpZnlCbG9jaycsICctJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdCb2xkJywgJ0l0YWxpYycsICdVbmRlcmxpbmUnLCAnTGluaycsICdJbWFnZScsICdZb3V0dWJlJywgJ29lbWJlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRm9udCcsICdGb250U2l6ZScsICdUZXh0Q29sb3InXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgc2VsbW8uZWRpdG9ySW5zdGFuY2UgPSBjaztcblxuICAgICAgICAgICAgY2sub24oJ2luc3RhbmNlUmVhZHknLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWRpdG9yID0gZXYuZWRpdG9yO1xuICAgICAgICAgICAgICAgIGVkaXRvci5zZXRSZWFkT25seShmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBnZXRHdWlkZVByZXZpZXdET00oKTtcbiAgICAgICAgICAgICAgICB2YXIgZWRpdG9yX2lkID0gZWRpdG9yLnVpLnNwYWNlSWQoJ2NvbnRlbnRzJyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY2sub24oJ3NpbXBsZXVwbG9hZHMuc3RhcnRVcGxvYWQnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgICB2YXIgdXBsb2FkID0gc2VsbW8uY3VycmVudFVwbG9hZEluZm87XG4gICAgICAgICAgICAgICAgZXYuZGF0YS5leHRyYUZpZWxkcyA9IHVwbG9hZC5leHRyYUZpZWxkcyB8fCB1cGxvYWQuZXh0cmFEYXRhO1xuICAgICAgICAgICAgICAgIGV2LmRhdGEudXJsID0gdXBsb2FkLnVybCB8fCB1cGxvYWQudXBsb2FkVXJsO1xuICAgICAgICAgICAgICAgIGV2LmRhdGEuZG93bmxvYWRVcmwgPSB1cGxvYWQuZG93bmxvYWRVcmw7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gR2V0IG5ldyB1cGxvYWQgaW5mbyB3aGVuIGFuIHVwbG9hZCBmaW5pc2hlc1xuICAgICAgICAgICAgdmFyIHByZXBhcmVVcGxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGVsbE1hc3Rlcih7IHR5cGU6ICdwcmVwYXJlLXVwbG9hZCcgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2sub24oJ3NpbXBsZXVwbG9hZHMuZmluaXNoZWRVcGxvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcHJlcGFyZVVwbG9hZCgpO1xuICAgICAgICAgICAgICAgIHZhciBodG1sID0gc2VsbW8uZWRpdG9ySW5zdGFuY2UuZ2V0RGF0YSgpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUd1aWRlT2JqZWN0Q29udGVudChodG1sKTtcbiAgICAgICAgICAgICAgICB0ZWxsTWFzdGVyKHsgdHlwZTogJ2NvbnRlbnQtY2hhbmdlZCcsIGh0bWw6IGh0bWwgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNrLm9uKCdzaW1wbGV1cGxvYWRzLmVuZFVwbG9hZCcsIHByZXBhcmVVcGxvYWQpO1xuXG4gICAgICAgICAgICBjay5vbignY2hhbmdlJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgICAgIHZhciBodG1sID0gc2VsbW8uZWRpdG9ySW5zdGFuY2UuZ2V0RGF0YSgpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUd1aWRlT2JqZWN0Q29udGVudChodG1sKTtcbiAgICAgICAgICAgICAgICB0ZWxsTWFzdGVyKHsgdHlwZTogJ2NvbnRlbnQtY2hhbmdlZCcsIGh0bWw6IGh0bWwgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBzZWxtby5raWxsRWRpdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoc2VsbW8uZWRpdG9ySW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHNlbG1vLmVkaXRvckluc3RhbmNlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHNlbG1vLmVkaXRvckluc3RhbmNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBzZWxtby5jbG9zZVByZXZpZXcgPSBmdW5jdGlvbiAoc2lsZW50KSB7XG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoc2VsbW8ucHJldmlld0d1aWRlVGhyZWFkSGFuZGxlKTtcbiAgICAgICAgZGVsZXRlIHNlbG1vLnByZXZpZXdHdWlkZVRocmVhZEhhbmRsZTtcblxuICAgICAgICBpZiAoc2VsbW8uaXNQcmV2aWV3aW5nKCkpIHtcbiAgICAgICAgICAgIGlmIChzZWxtby5wcmV2aWV3ZWRHdWlkZSkge1xuICAgICAgICAgICAgICAgIHNlbG1vLnByZXZpZXdlZEd1aWRlLmhpZGUoKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgc2VsbW8ucHJldmlld2VkR3VpZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0b3BHdWlkZXMoKTtcbiAgICAgICAgICAgIHJlbW92ZUFsbEJhZGdlcygpO1xuXG4gICAgICAgICAgICBzZWxtby5raWxsRWRpdG9yKCk7XG5cbiAgICAgICAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgdGVsbE1hc3Rlcih7c3RhdHVzOiAnc3VjY2VzcycsIHR5cGU6ICdwcmV2aWV3LWRpc21pc3NlZCcsIG1zZzogJ3ByZXZpZXcgaXMgb3Zlcid9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgdXBkYXRlR3VpZGVPYmplY3RDb250ZW50ID0gZnVuY3Rpb24gKG5ld0NvbnRlbnQpIHtcbiAgICAgICAgdmFyIGd1aWRlID0gc2VsbW8ucHJldmlld2VkR3VpZGU7XG4gICAgICAgIGlmIChndWlkZSkge1xuICAgICAgICAgICAgXy5lYWNoKGd1aWRlLnN0ZXBzLCBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICAgICAgICAgIHN0ZXAuY29udGVudCA9IG5ld0NvbnRlbnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXNpemVHdWlkZVByZXZpZXcoKTtcbiAgICB9O1xuXG4gICAgdmFyIHJlc2l6ZUd1aWRlUHJldmlldyA9IGZ1bmN0aW9uIChuZXdDb250ZW50KSB7XG4gICAgICAgIHZhciBndWlkZSA9IHNlbG1vLnByZXZpZXdlZEd1aWRlO1xuICAgICAgICBpZiAoZ3VpZGUpIHtcbiAgICAgICAgICAgIF8uZWFjaChndWlkZS5zdGVwcywgZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgICAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKHN0ZXAucmVzaXplKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGVwLnJlc2l6ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHNlbG1vLnVwZGF0ZUNvbnRlbnQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB1cGRhdGVHdWlkZU9iamVjdENvbnRlbnQoZGF0YS5odG1sKTtcbiAgICAgICAgaWYgKHNlbG1vLmVkaXRvckluc3RhbmNlKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbiBlZGl0b3IsIGp1c3QgdXBkYXRlIHRoZSBjb250ZW50XG4gICAgICAgICAgICBzZWxtby5lZGl0b3JJbnN0YW5jZS5zZXREYXRhKGRhdGEuaHRtbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdlZGl0aW5nX2d1aWRlX3ByZXZpZXcnKTtcbiAgICAgICAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGd1aWRlID0gc2VsbW8ucHJldmlld2VkR3VpZGUsXG4gICAgICAgICAgICAgICAgICAgIHN0ZXAgPSBndWlkZSAmJiBfLmZpcnN0KGd1aWRlLnN0ZXBzKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RlcCAmJiBfLmlzRnVuY3Rpb24oc3RlcC5nZXRDb250ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc3RlcC50ZW1wbGF0ZTsvLyBmb3JjZSB0ZW1wbGF0ZSByZWNvbXBpbGF0aW9uXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQuaW5uZXJIVE1MID0gc3RlcC5nZXRDb250ZW50KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudC5pbm5lckhUTUwgPSBkYXRhLmh0bWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByZXZpZXdQb2xsKHNlbG1vLnBvbGxQcmV2aWV3TW9kZSk7XG4gICAgfTtcblxuICAgIHZhciB1cGRhdGVHdWlkZVdpZGdldCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBndWlkZVdpZGdldCA9IHBlbmRvLmd1aWRlV2lkZ2V0ID0gcGVuZG8uZ3VpZGVXaWRnZXQgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLmNvbmZpZykge1xuICAgICAgICAgICAgXy5leHRlbmQoZ3VpZGVXaWRnZXQuZGF0YSwgZGF0YS5jb25maWcpO1xuICAgICAgICAgICAgZ3VpZGVXaWRnZXQudGVtcGxhdGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHNlbG1vLnRvZ2dsZUxhdW5jaGVyID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdXBkYXRlR3VpZGVXaWRnZXQoZGF0YSk7XG4gICAgICAgIGlmIChkYXRhLmNvbmZpZy5lbmFibGVkKSB7XG4gICAgICAgICAgICByZW1vdmVMYXVuY2hlcigpO1xuICAgICAgICAgICAgY3JlYXRlTGF1bmNoZXIoZGF0YS5jb25maWcpO1xuICAgICAgICAgICAgc2VsbW8udXBkYXRlQWN0aXZlR3VpZGVzKCk7XG5cbiAgICAgICAgICAgIGRhdGEuY29uZmlnLmhpZGUgPyBoaWRlTGF1bmNoZXIoKSA6IHNob3dMYXVuY2hlcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gS2lsbCB0aGUgdGhpbmcuXG4gICAgICAgICAgICByZW1vdmVMYXVuY2hlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsbW8udXBkYXRlR3VpZGVDc3MoZGF0YSk7XG4gICAgfTtcblxuICAgIHNlbG1vLnVwZGF0ZUd1aWRlQ3NzID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gU2l6emxlKCcjX3BlbmRvLWNzc18nKVswXTtcbiAgICAgICAgaWYgKF8uaXNTdHJpbmcoZGF0YSkpIHtcbiAgICAgICAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gZGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzdHlsZSkge1xuICAgICAgICAgICAgICAgIHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlR3VpZGVXaWRnZXQoZGF0YSk7XG4gICAgICAgICAgICBsb2FkR3VpZGVDc3MoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyAhP1xuICAgIC8vIFdIWTogIHdoeSBpcyB0aGlzIGZ1bmN0aW9uIGlzUHJldmlld0VsZW1lbnQgbmVlZGVkP1xuXG4gICAgLy8gV2Ugc2hvdWxkIGRlZmluaXRlbHkgbm90IGxldCB0aGUgdXNlciBhdHRlbXB0IHRvIHNlbGVjdCBhbnlcbiAgICAvLyBQZW5kbyBnZW5lcmF0ZWQgY29udGVudCBpbnNpZGUgdGhlaXIgb3duIGFwcC5cblxuICAgIC8vIE9rLCB0aGlzIGFwcGVhcnMgdG8gYmVcblxuICAgIHNlbG1vLmlzUHJldmlld0VsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICB3aGlsZSAoZWxlbSkge1xuICAgICAgICAgICAgaWYgKGRvbS5oYXNDbGFzcyhlbGVtLCAnX3BlbmRvLWd1aWRlLWNvbnRlbnRfJykgfHwgZG9tLmhhc0NsYXNzKGVsZW0sICdja2VfJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmKGVsZW0uY2xhc3NOYW1lLmluZGV4T2YoXCJfcGVuZG8tZ3VpZGUtY29udGVudF9cIikgPj0gMCB8fCBlbGVtLmNsYXNzTmFtZS5pbmRleE9mKFwiY2tlX1wiKSA+PSAwKSB7XG4gICAgICAgICAgICAvLyAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICBlbGVtID0gZWxlbS5wYXJlbnRFbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgc2VsbW8uc2VsZWN0RWxlbWVudCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBlbGVtZW50O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBlbGVtZW50ID0gU2l6emxlKGRhdGEuY3NzTWF0Y2gpWzBdO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGFyZ2V0ID0ge307XG5cbiAgICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgICAgICB0YXJnZXQuYXZhaWxhYmxlID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb20uYWRkQ2xhc3MoZWxlbWVudCwgJ29yaWctJyArIF9QRU5ET19TRUxFQ1RJT05fSElHSExJR0hUX0NMQVNTKTtcblxuICAgICAgICAgICAgdGFyZ2V0ID0ge1xuICAgICAgICAgICAgICAgIHRhZ05hbWU6IGVsZW1lbnQudGFnTmFtZSxcbiAgICAgICAgICAgICAgICBwYXRoOiBzZWxtby5nZXRUYXJnZXRQYXRoKGVsZW1lbnQpLFxuICAgICAgICAgICAgICAgIGNzc01hdGNoOiBkYXRhLmNzc01hdGNoLFxuICAgICAgICAgICAgICAgIGF2YWlsYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRlbGxNYXN0ZXIoe1xuICAgICAgICAgICAgdHlwZTogJ2VsZW1lbnRJbmZvJyxcbiAgICAgICAgICAgIHByb21pc2VJZDogZGF0YS5wcm9taXNlSWQsXG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldFxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyogVGhpcyBpcyBhIFJQQyBjYWxsLiAgU2ltcGx5IGtub3cgdGhhdCBmb3Igbm93LiAqL1xuICAgIHNlbG1vLnRha2VTbmFwc2hvdCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgZ3VpZGUgPSBzZWxtby5wcmV2aWV3ZWRHdWlkZTtcbiAgICAgICAgICAgIGlmIChndWlkZSkge1xuICAgICAgICAgICAgICAgIHZhciBjb250ZW50RGl2ID0gU2l6emxlKCcuX3BlbmRvLWd1aWRlXyAuX3BlbmRvLWd1aWRlLWNvbnRlbnRfJyk7XG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRlbXBsYXRlcyBhcmUgZXZhbHVhdGVkIGJlZm9yZSBzY3JlZW5zaG90XG4gICAgICAgICAgICAgICAgZ3VpZGUuaGlkZSgpO1xuICAgICAgICAgICAgICAgIF8uZWFjaChndWlkZS5zdGVwcywgZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RlcC50ZW1wbGF0ZSA9IHBlbmRvLl8udGVtcGxhdGUoc3RlcC5jb250ZW50IHx8ICcnKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHN0ZXAuaXNFZGl0YWJsZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBndWlkZS5wbGFjZUJhZGdlKCk7XG4gICAgICAgICAgICAgICAgZ3VpZGUuc2hvdygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxtby5raWxsRWRpdG9yKCk7XG5cbiAgICAgICAgICAgIHZhciBndWlkZURpdiA9IGRvbSgnLl9wZW5kby1ndWlkZV8nKTtcbiAgICAgICAgICAgIGlmIChndWlkZURpdi5sZW5ndGggJiYgc2VsbW8uaXNFbGVtZW50VmlzaWJsZShndWlkZURpdlswXSkpIHtcbiAgICAgICAgICAgICAgICBodG1sMmNhbnZhcyhndWlkZURpdlswXSwge1xuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiAndHJhbnNwYXJlbnQnLFxuICAgICAgICAgICAgICAgICAgICBvbnJlbmRlcmVkOiBmdW5jdGlvbiAoY2FudmFzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNpemVkQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc2l6ZWRDb250ZXh0ID0gcmVzaXplZENhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3kgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBndWlkZVdpZHRoID0gZ3VpZGVEaXYud2lkdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ3VpZGVIZWlnaHQgPSBndWlkZURpdi5oZWlnaHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF4QmFubmVyV2lkdGggPSA2MDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXN0cmljdCB0aGUgd2lkdGggb2YgYmFubmVyIGd1aWRlIHNuYXBzaG90c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb20uaGFzQ2xhc3MoZ3VpZGVEaXZbMF0sICdfcGVuZG8tZ3VpZGUtYmFubmVyXycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN4ID0gTWF0aC5mbG9vcihNYXRoLm1heCgwLCBndWlkZVdpZHRoIC8gMiAtIG1heEJhbm5lcldpZHRoIC8gMikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBndWlkZVdpZHRoID0gTWF0aC5taW4oZ3VpZGVXaWR0aCwgbWF4QmFubmVyV2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBndWlkZVJhdGlvID0gZ3VpZGVIZWlnaHQgLyBndWlkZVdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkUmF0aW8gPSAzIC8gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHcgPSBndWlkZVdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaCA9IGd1aWRlSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR5ID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNjcmVlbnNob3QgdXNpbmcgMzo0IGFzcGVjdCByYXRpb1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChndWlkZVJhdGlvID4gZFJhdGlvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR3ID0gTWF0aC5mbG9vcihndWlkZUhlaWdodCAvIGRSYXRpbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR4ID0gTWF0aC5mbG9vcihNYXRoLmFicygoZHcgLSBndWlkZVdpZHRoKSAvIDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaCA9IE1hdGguZmxvb3IoZ3VpZGVXaWR0aCAqIGRSYXRpbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR5ID0gTWF0aC5mbG9vcihNYXRoLmFicygoZGggLSBndWlkZUhlaWdodCkgLyAyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzaXplZENhbnZhcy53aWR0aCA9IGR3O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc2l6ZWRDYW52YXMuaGVpZ2h0ID0gZGg7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNpemVkQ29udGV4dC5kcmF3SW1hZ2UoY2FudmFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeCwgc3ksIGR3LCBndWlkZUhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHgsIGR5LCBkdywgZ3VpZGVIZWlnaHQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGltYWdlID0gcmVzaXplZENhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3BuZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbGxNYXN0ZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc25hcHNob3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlSWQ6IGRhdGEucHJvbWlzZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZTogaW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZWxsTWFzdGVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3NuYXBzaG90JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZUlkOiBkYXRhLnByb21pc2VJZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB1c2VDT1JTOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRlbGxNYXN0ZXIoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc25hcHNob3QnLFxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlSWQ6IGRhdGEucHJvbWlzZUlkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRlbGxNYXN0ZXIoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzbmFwc2hvdCcsXG4gICAgICAgICAgICAgICAgcHJvbWlzZUlkOiBkYXRhLnByb21pc2VJZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgc2VsbW8uc3RvcElmU2VsZWN0aW5nID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAvLyBhZGQgc3VwcG9ydCBmb3Igc2hpZnRrZXkgaGVyZVxuICAgICAgICBpZiAoc2VsbW8uaXNJblN0YXRlKFNFTEVDVElPTl9NT0RFKSAmJlxuICAgICAgICAgICAgIXNlbG1vLmlzUHJldmlld0VsZW1lbnQoZXZ0LnRhcmdldCkgJiZcbiAgICAgICAgICAgICFkZXRlY3RNb2RLZXlzKGV2dClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsbW8uc3RvcEV2ZW50QnViYmxpbmcoZXZ0KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBzZWxtby5hdHRhY2hUbyA9IGZ1bmN0aW9uIChldmVudFR1cGxlKSB7XG4gICAgICAgIGF0dGFjaEV2ZW50KGRvY3VtZW50LCBldmVudFR1cGxlWzBdLCBldmVudFR1cGxlWzFdLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgc2VsbW8ubm9ybWFsaXplZFVybCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHBlbmRvLm5vcm1hbGl6ZWRVcmwgPSBkYXRhLnVybDtcbiAgICB9O1xuXG4gICAgLy8gVE9ETzogdXBkYXRlIHRoaXMgdG8gdXNlIHRoZSBvbmUgZXhwb3J0ZWQgZnJvbSBBZ2VudFxuICAgIHZhciBkZXRhY2hFdmVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBldnQsIGZuLCB1c2VDYXB0dXJlKSB7XG4gICAgICAgIGlmICghdXNlQ2FwdHVyZSkgdXNlQ2FwdHVyZSA9IGZhbHNlO1xuICAgICAgICBpZiAoZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0LCBmbiwgdXNlQ2FwdHVyZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50LmRldGFjaEV2ZW50KCdvbicgKyBldnQsIGZuKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgb25Mb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbG1vLnVwZGF0ZUd1aWRlQ3NzKCk7XG4gICAgICAgIGFkZE1lc3NhZ2VzKF8ucGFydGlhbChhZGRFdmVudHMsIGZpbmlzaEluaXQpKTtcbiAgICB9O1xuXG4gICAgdmFyIGFkZE1lc3NhZ2VzID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIHRlbGxNYXN0ZXIoe3N0YXR1czogJ3N1Y2Nlc3MnLCB0eXBlOiAnbW9kdWxlJywgbXNnOiAnc2VsZWN0aW9uIGlzIGxvYWRlZCcsIG1vZHVsZTogJ3NlbGVjdGlvbid9KTtcbiAgICAgICAgcmVnaXN0ZXJNZXNzYWdlSGFuZGxlcignc2VsZWN0aW9uLW1vZGUnLCBoYW5kbGVNb2RlQ2hhbmdlKTtcbiAgICAgICAgcmVnaXN0ZXJNZXNzYWdlSGFuZGxlcignbW92ZS1zZWxlY3Rpb24tdXAnLCBzZWxtby5oYW5kbGVNb3ZlU2VsZWN0aW9uVXApO1xuICAgICAgICByZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKCd0ZXN0LWNzcy1zZWxlY3RvcicsIHNlbG1vLnRlc3RDc3NTZWxlY3Rvcik7XG5cbiAgICAgICAgcmVnaXN0ZXJNZXNzYWdlSGFuZGxlcigncHJldmlldy1ndWlkZScsIHNlbG1vLnByZXZpZXdHdWlkZSk7XG4gICAgICAgIHJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoJ3N0b3AtcHJldmlldycsIHNlbG1vLmNsb3NlUHJldmlldyk7XG5cbiAgICAgICAgcmVnaXN0ZXJNZXNzYWdlSGFuZGxlcigndXBkYXRlLWNvbnRlbnQnLCBzZWxtby51cGRhdGVDb250ZW50KTtcbiAgICAgICAgcmVnaXN0ZXJNZXNzYWdlSGFuZGxlcigndGFrZS1zbmFwc2hvdCcsIHNlbG1vLnRha2VTbmFwc2hvdCk7XG4gICAgICAgIHJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoJ3NlbGVjdC1lbGVtZW50Jywgc2VsbW8uc2VsZWN0RWxlbWVudCk7XG4gICAgICAgIHJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoJ3RvZ2dsZS1sYXVuY2hlcicsIHNlbG1vLnRvZ2dsZUxhdW5jaGVyKTtcbiAgICAgICAgcmVnaXN0ZXJNZXNzYWdlSGFuZGxlcigndGFnZ2VkLWZlYXR1cmVzJywgc2VsbW8udXBkYXRlVGFnZ2VkRmVhdHVyZXMpO1xuICAgICAgICByZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKCdhY3RpdmUtZ3VpZGVzJywgc2VsbW8udXBkYXRlQWN0aXZlR3VpZGVzKTtcbiAgICAgICAgcmVnaXN0ZXJNZXNzYWdlSGFuZGxlcigndXBsb2FkLWluZm8nLCBzZWxtby51cGRhdGVVcGxvYWRJbmZvKTtcbiAgICAgICAgcmVnaXN0ZXJNZXNzYWdlSGFuZGxlcignbm9ybWFsaXplZC11cmwnLCBzZWxtby5ub3JtYWxpemVkVXJsKTtcblxuICAgICAgICByZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKCdwcmV2aWV3LWh0bWwnLCBfLnBhcnRpYWwoc2V0dXBScGMsIHByZXZpZXdIdG1sKSk7XG4gICAgICAgIHJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoJ3ByZXZpZXctY3NzJywgXy5wYXJ0aWFsKHNldHVwUnBjLCBwcmV2aWV3Q3NzKSk7XG4gICAgICAgIHJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoJ3ByZXZpZXctcG9sbCcsIF8ucGFydGlhbChzZXR1cFJwYywgcHJldmlld1BvbGwpKTtcbiAgICAgICAgcmVnaXN0ZXJNZXNzYWdlSGFuZGxlcignc3RvcC1wcmV2aWV3LWh0bWwtY3NzJywgXy5wYXJ0aWFsKHNldHVwUnBjLCBzdG9wUHJldmlld0h0bWxDc3MpKTtcbiAgICAgICAgcmVnaXN0ZXJNZXNzYWdlSGFuZGxlcignY2hlY2stZ3VpZGVzLWVuYWJsZWQnLCBfLnBhcnRpYWwoc2V0dXBScGMsIGNoZWNrR3VpZGVzRW5hYmxlZCkpO1xuICAgICAgICByZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKCdnZXQtc2l0ZS10aGVtZScsIF8ucGFydGlhbChzZXR1cFJwYywgc2VsbW8uZ2V0U2l0ZVRoZW1lKSk7XG5cbiAgICAgICAgLy8gTGF0ZXN0OiBhZGRlZCBmb3IgR3VpZGUtVGVtcGxhdGVzLiAgTmV4dCBzdGVwcyBhcmUgdG8gZWl0aGVyIG1ha2VzIHRoZXNlIHRoZVxuICAgICAgICAvLyBvbmx5IG9uZXMgb3IgZ2V0IHJpZCBvZiB0aGVtIGFuZCB1c2UgdGhlIG90aGVyc1xuICAgICAgICByZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKCdwcmV2aWV3R3VpZGUnLCBfLnBhcnRpYWwoc2V0dXBScGMsIHByZXZpZXdHdWlkZSkpO1xuICAgICAgICByZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKCdzdG9wUHJldmlld0d1aWRlJywgXy5wYXJ0aWFsKHNldHVwUnBjLCBzdG9wUHJldmlld0d1aWRlKSk7XG4gICAgICAgIHJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoJ3JlY29ubmVjdCcsIGZpbmlzaEluaXQpO1xuXG4gICAgICAgIGNiKCk7XG4gICAgfTtcblxuICAgIHZhciBsYXN0UHJldmlld2VkR3VpZGUgPSBudWxsO1xuICAgIHZhciBwcmV2aWV3R3VpZGUgPSBmdW5jdGlvbiAobXNnQ29udGVudCkge1xuICAgICAgICBzdG9wUHJldmlld0d1aWRlKCk7XG4gICAgICAgIF8uZWFjaChtc2dDb250ZW50Lmd1aWRlLnN0ZXBzLCBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICAgICAgc3RlcC5oaWRlQ3JlZGl0cyA9IG1zZ0NvbnRlbnQuY29uZmlnLmhpZGVQb3dlcmVkQnk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZ3VpZGUgPSBHdWlkZUZhY3RvcnkobXNnQ29udGVudC5ndWlkZSwgdHJ1ZSk7XG4gICAgICAgIGxhc3RQcmV2aWV3ZWRHdWlkZSA9IGd1aWRlO1xuICAgICAgICByZXR1cm4gZ3VpZGUuc2hvdygpO1xuICAgIH07XG5cbiAgICB2YXIgc3RvcFByZXZpZXdHdWlkZSA9IGZ1bmN0aW9uIChtc2dDb250ZW50KSB7XG4gICAgICAgIGlmIChsYXN0UHJldmlld2VkR3VpZGUpIGxhc3RQcmV2aWV3ZWRHdWlkZS5oaWRlKCk7XG4gICAgfTtcblxuICAgIHZhciBhZGRFdmVudHMgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgLy8gc2V0dXAgaGFuZGxlcnNcbiAgICAgICAgdmFyIGV2ZW50cyA9IFtcbiAgICAgICAgICAgIFsnbW91c2VvdXQnLCBzZWxtby51bmhpZ2hsaWdodF0sXG4gICAgICAgICAgICBbJ21vdXNlbW92ZScsIHNlbG1vLmhpZ2hsaWdodF0sXG4gICAgICAgICAgICBbJ2NsaWNrJywgc2VsbW8uY2xpY2tdLFxuICAgICAgICAgICAgWydtb3VzZWRvd24nLCBzZWxtby5zdG9wSWZTZWxlY3RpbmddLFxuICAgICAgICAgICAgWydtb3VzZXVwJywgc2VsbW8uc3RvcElmU2VsZWN0aW5nXSxcbiAgICAgICAgICAgIFsnZGJsY2xpY2snLCBzZWxtby5zdG9wSWZTZWxlY3RpbmddXG4gICAgICAgIF07XG4gICAgICAgIC8vIG5vdywgbWFwIHRoaXMgdG8uLi5cbiAgICAgICAgZXZlbnRzLm1hcChzZWxtby5hdHRhY2hUbyk7XG5cbiAgICAgICAgY2IoKTtcbiAgICB9O1xuXG4gICAgdmFyIHNldHVwUnBjID0gZnVuY3Rpb24gKGZuLCBkYXRhKSB7XG4gICAgICAgIHZhciBwSWQgPSBkYXRhLnByb21pc2VJZDtcbiAgICAgICAgdmFyIG9iaiA9IGZuKGRhdGEpO1xuICAgICAgICByZXR1cm4gbWFzdGVyQWNrKHBJZCwgb2JqKTtcbiAgICB9O1xuXG4gICAgdmFyIG1hc3RlckFjayA9IGZ1bmN0aW9uIChwSWQsIGRhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGRhdGEgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBkYXRhID0ge3ZhbHVlOiBkYXRhfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgICAgICBkYXRhLnByb21pc2VJZCA9IHBJZDtcblxuICAgICAgICB0ZWxsTWFzdGVyKGRhdGEpO1xuICAgIH07XG5cbiAgICB2YXIgYWRkRGVmYXVsdENzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNzc0xpbmsgPSBTaXp6bGUoJ2xpbmsjX3BlbmRvLWNzc18nKTtcbiAgICAgICAgaWYgKGNzc0xpbmsgPT0gMCkge1xuICAgICAgICAgICAgbG9hZEd1aWRlQ3NzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJlbW92ZURlZmF1bHRDc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjc3NMaW5rID0gU2l6emxlKCdsaW5rI19wZW5kby1jc3NfJyk7XG4gICAgICAgIGlmIChjc3NMaW5rLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIF8uZWFjaChjc3NMaW5rLCBmdW5jdGlvbiAobGluaykge1xuICAgICAgICAgICAgICAgIGxpbmsucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChsaW5rKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBwcmV2aWV3Q3NzID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkYXRhLnByZXZpZXcuaHRtbCxcbiAgICAgICAgICAgIGNzcyA9IGRhdGEucHJldmlldy5jc3MsXG4gICAgICAgICAgICB0eXBlID0gZGF0YS5wcmV2aWV3LnR5cGUgfHwgJ2xpZ2h0Ym94JyxcbiAgICAgICAgICAgIGNvbmZpZyA9IGRhdGEuY29uZmlnIHx8IHt9O1xuXG4gICAgICAgIGlmIChjc3MpIHtcbiAgICAgICAgICAgIHJlbW92ZURlZmF1bHRDc3MoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFkZERlZmF1bHRDc3MoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb250ZW50ID0gYWRkQ3NzVG9IdG1sKGNzcywgaHRtbCk7XG5cbiAgICAgICAgcHJldmlld0h0bWxDc3ModHlwZSwgY29udGVudCwgY29uZmlnKTtcbiAgICB9O1xuXG4gICAgdmFyIGFkZENzc1RvSHRtbCA9IGZ1bmN0aW9uIChjc3MsIGh0bWwpIHtcbiAgICAgICAgY3NzID0gXCI8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPlwiICsgY3NzICsgJzwvc3R5bGU+JztcbiAgICAgICAgcmV0dXJuIGNzcyArIGh0bWw7XG4gICAgfTtcblxuICAgIC8vIFRPRE86XG4gICAgLy8gLSBob3cgdG8gaGFuZGxlIHRvb2x0aXAgKHdoYXQgZWxlbWVudCB0byBhbmNob3IgdG8pP1xuICAgIC8vIC0gaG93IHRvIGhhbmRsZSBkaWZmZXJlbnQgdG9vbHRpcCBhcnJvdyBkaXJlY3Rpb25zP1xuICAgIC8vIC0gTGF1bmNoZXIgY3VzdG9taXphdGlvbnM/XG4gICAgdmFyIHByZXZpZXdIdG1sID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB2YXIgaHRtbCA9IG9iai5wcmV2aWV3Lmh0bWwsXG4gICAgICAgICAgICBjc3MgPSBvYmoucHJldmlldy5jc3MsXG4gICAgICAgICAgICB0eXBlID0gb2JqLnByZXZpZXcudHlwZSxcbiAgICAgICAgICAgIGNvbmZpZyA9IG9iai5jb25maWcgfHwge307XG5cbiAgICAgICAgdmFyIGNvbnRlbnQgPSBodG1sO1xuXG4gICAgICAgIGlmIChjc3MpIHsgY29udGVudCA9IGFkZENzc1RvSHRtbChjc3MsIGh0bWwpOyB9XG5cbiAgICAgICAgcHJldmlld0h0bWxDc3ModHlwZSwgY29udGVudCwgY29uZmlnKTtcbiAgICB9O1xuXG4gICAgdmFyIHByZXZpZXdQb2xsID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBpZiAoIW9iaikgcmV0dXJuO1xuICAgICAgICBzZWxtby5wb2xsUHJldmlld01vZGUgPSBvYmo7XG4gICAgICAgIHZhciBwb2xsID0gZG9tKCcuX3BlbmRvLXBvbGxfJyksXG4gICAgICAgICAgICBtZXNzYWdlID0gZG9tKCcuX3BlbmRvLXBvbGwtbWVzc2FnZV8nKSxcbiAgICAgICAgICAgIG5wc1JhdGluZyA9IGRvbSgnLl9wZW5kby1wb2xsLW5wc3JhdGluZ18nKSxcbiAgICAgICAgICAgIHN1Ym1pdCA9IGRvbSgnLl9wZW5kby1wb2xsLXN1Ym1pdF8nKTtcbiAgICAgICAgaWYgKHBvbGwubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgc3VibWl0dGVkID0gJ19wZW5kby1wb2xsLXN1Ym1pdHRlZF8nLFxuICAgICAgICAgICAgICAgIG5wc1JhdGluZ1NlbGVjdGVkID0gJ19wZW5kby1wb2xsLW5wc3JhdGluZy1zZWxlY3RlZF8nO1xuICAgICAgICAgICAgcG9sbC5yZW1vdmVDbGFzcyhzdWJtaXR0ZWQpO1xuICAgICAgICAgICAgcG9sbC5yZW1vdmVDbGFzcyhucHNSYXRpbmdTZWxlY3RlZCk7XG4gICAgICAgICAgICBpZiAobnBzUmF0aW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHN1Ym1pdC5jc3MoeyBkaXNwbGF5OiAnbm9uZScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqLnByZXZpZXcgPT0gJ21lc3NhZ2UnICYmIG1lc3NhZ2UubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcG9sbC5hZGRDbGFzcyhzdWJtaXR0ZWQpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuY3NzKCdtYXJnaW4tdG9wOi0nICsgKG1lc3NhZ2UuaGVpZ2h0KCkgLyAyKSArICdweCcpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvYmoucHJldmlldyA9PSAnbnBzcmVhc29uJykge1xuICAgICAgICAgICAgICAgIHBvbGwuYWRkQ2xhc3MobnBzUmF0aW5nU2VsZWN0ZWQpO1xuICAgICAgICAgICAgICAgIHN1Ym1pdC5jc3MoeyBkaXNwbGF5OiAnJyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc2l6ZUd1aWRlUHJldmlldygpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBwcmV2aWV3SHRtbENzcyA9IF8udGhyb3R0bGUoZnVuY3Rpb24gKHR5cGUsIGNvbnRlbnQsIGNvbmZpZykge1xuICAgICAgICByZW1vdmVQcmV2aWV3SHRtbENzcygpO1xuXG4gICAgICAgIHZhciBndWlkZSA9IEd1aWRlRmFjdG9yeSh7XG4gICAgICAgICAgICBpZDogJ3ByZXZpZXctZ3VpZGUnLFxuICAgICAgICAgICAgc3RlcHM6IFt7XG4gICAgICAgICAgICAgICAgaWQ6ICdwcmV2aWV3LXN0ZXAnLFxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgY29udGVudDogY29udGVudCxcbiAgICAgICAgICAgICAgICBoaWRlQ3JlZGl0czogY29uZmlnLmhpZGVQb3dlcmVkQnlcbiAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgYXR0cmlidXRlczoge31cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZ3VpZGUuc2hvdygpO1xuXG4gICAgICAgIGlmICh0eXBlID09ICd0b29sdGlwJykge1xuICAgICAgICAgICAgZG9tKCcjX3BlbmRvX2dfcHJldmlldy1zdGVwJykuY3NzKCd0b3A6IDBweDsnKTtcbiAgICAgICAgICAgIHZhciBwb3MgPSBnZXRPZmZzZXRQb3NpdGlvbihkb20oJyNfcGVuZG9fZ19wcmV2aWV3LXN0ZXAnKVswXSk7XG4gICAgICAgICAgICB2YXIgeFNjcm9sbEFtdCA9IChwb3MubGVmdCArIHBvcy53aWR0aCkgLSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgICAgIHZhciB5U2Nyb2xsYW10ID0gKHBvcy50b3AgKyBwb3MuaGVpZ2h0KSAtIHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbyh4U2Nyb2xsQW10LCAwKTtcbiAgICAgICAgfVxuICAgIH0sIDEwMCwge2xlYWRpbmc6IGZhbHNlfSk7XG5cbiAgICB2YXIgcmVtb3ZlUHJldmlld0h0bWxDc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvbSgnI19wZW5kb19nX3ByZXZpZXctc3RlcCcpLnJlbW92ZSgpO1xuICAgICAgICBzdG9wR3VpZGVzKCk7XG4gICAgfTtcblxuICAgIHZhciBzdG9wUHJldmlld0h0bWxDc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlbW92ZVByZXZpZXdIdG1sQ3NzKCk7XG4gICAgICAgIGFkZERlZmF1bHRDc3MoKTtcbiAgICB9O1xuXG4gICAgdmFyIGNoZWNrR3VpZGVzRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZUd1aWRlc0VuYWJsZWQ7XG4gICAgfTtcblxuICAgIC8vIENsb2JiZXIgZ3VpZGUgZXZlbnRzIHRvIHByZXZlbnQgZGlzbWlzcy9hZHZhbmNlIGJ1dHRvbnMgZnJvbSBkb2luZyBhbnl0aGluZ1xuICAgIHBlbmRvLm9uR3VpZGVBZHZhbmNlZCA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIHBlbmRvLm9uR3VpZGVEaXNtaXNzZWQgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICBwZW5kby5vbkd1aWRlUHJldmlvdXMgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIHZhciBmaW5pc2hJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0ZWxsTWFzdGVyKHtcbiAgICAgICAgICAgIHR5cGU6ICdyZWFkeScsXG4gICAgICAgICAgICB2ZXJzaW9uOiBwZW5kby5WRVJTSU9OLFxuICAgICAgICAgICAgdmlzaXRvcklkOiBnZXRWaXNpdG9ySWQoKVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIHNlbmRHdWlkZUNzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGN1ckd1aWRlQ29udGFpbmVyID0gZG9tKCcuX3BlbmRvLWd1aWRlXyAuX3BlbmRvLWd1aWRlLWNvbnRhaW5lcl8nKTtcblxuICAgICAgICBpZiAoY3VyR3VpZGVDb250YWluZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGJhY2tncm91bmRDb2xvciA9IGdldENvbXB1dGVkU3R5bGUoY3VyR3VpZGVDb250YWluZXJbMF0pWydiYWNrZ3JvdW5kLWNvbG9yJ107XG4gICAgICAgICAgICB0ZWxsTWFzdGVyKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZ3VpZGVQcmV2aWV3JyxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGJhY2tncm91bmRDb2xvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgd2hlbkxvYWRlZENhbGwob25Mb2FkZWQpO1xuXG4gICAgdmFyIGFsbG93Q29udGFpbnMgPSBmdW5jdGlvbiAoc2VsZWN0b3JzKSB7XG4gICAgICAgIHJldHVybiAhLzpjb250YWluc1xcKC8udGVzdChzZWxlY3RvcnMuam9pbignICcpKTtcbiAgICB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGx1Z2lucy9zZWxlY3Rpb24uanMiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJib2R5LnBlbmRvLXNlbGVjdGlvbiAucGVuZG8tc2VsZWN0aW9uLUhMIHtcXG4gICAgb3V0bGluZTogMnB4IHNvbGlkIHJlZCAhaW1wb3J0YW50O1xcbn1cXG5cXG5ib2R5LnBlbmRvLXNlbGVjdGlvbiAucGVuZG8tdGFnZ2VkLUhMIHtcXG4gICAgb3V0bGluZTogMnB4IHNvbGlkICM5OTk7XFxufVxcblxcbi5wZW5kby1vdmVybGF5IHtcXG4gICAgei1pbmRleDogMTAwMDA7XFxuICAgIG9wYWNpdHk6IDAuNztcXG59XFxuXFxuLnBlbmRvLXRvb2x0aXAge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcXG4gICAgei1pbmRleDogMTAwMDA7XFxuICAgIHBhZGRpbmc6IDRweDtcXG59XFxuXFxuLnBlbmRvLXRvb2x0aXAucGVuZG8tdGV0aGVyLWVuYWJsZWQge1xcbiAgICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xcbn1cXG5cXG4ucGVuZG8tdG9vbHRpcD4ucGVuZG8tdG9vbHRpcC1jb250ZW50IHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICB6LWluZGV4OiAyO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRUVFO1xcbiAgICBwYWRkaW5nOiA1cHg7XFxuICAgIGJveC1zaGFkb3c6IDFweCAxcHggMnB4IDBweCAjQ0NDO1xcbiAgICBmb250LXNpemU6IDEwcHg7XFxuICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XFxuICAgIGNvbG9yOiAjMzMzO1xcbn1cXG5cXG4ucGVuZG8tdG9vbHRpcDpiZWZvcmUsXFxuLnBlbmRvLXRvb2x0aXA6YWZ0ZXIge1xcbiAgICBjb250ZW50OiAnJztcXG4gICAgd2lkdGg6IDEwcHg7XFxuICAgIGhlaWdodDogMTBweDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0VFRTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7XFxuICAgIC1tb3otdHJhbnNmb3JtOiByb3RhdGUoNDVkZWcpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiByb3RhdGUoNDVkZWcpO1xcbiAgICAtby10cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB0b3A6IGF1dG87XFxuICAgIGJvdHRvbTogYXV0bztcXG4gICAgbGVmdDogYXV0bztcXG4gICAgcmlnaHQ6IGF1dG87XFxuICAgIG1hcmdpbjogMDtcXG59XFxuXFxuLnBlbmRvLXRvb2x0aXA6YmVmb3JlIHtcXG4gICAgei1pbmRleDogMztcXG59XFxuXFxuLnBlbmRvLXRvb2x0aXA6YWZ0ZXIge1xcbiAgICB6LWluZGV4OiAxO1xcbiAgICBib3gtc2hhZG93OiAxcHggMXB4IDJweCAwcHggI0NDQztcXG59XFxuXFxuLnBlbmRvLXRvb2x0aXAucGVuZG8tdGV0aGVyLXRhcmdldC1hdHRhY2hlZC1jZW50ZXI6YmVmb3JlLFxcbi5wZW5kby10b29sdGlwLnBlbmRvLXRldGhlci10YXJnZXQtYXR0YWNoZWQtY2VudGVyOmFmdGVyIHtcXG4gICAgbGVmdDogNTAlO1xcbiAgICBtYXJnaW4tbGVmdDogLTVweDtcXG59XFxuXFxuLnBlbmRvLXRvb2x0aXAucGVuZG8tdGV0aGVyLXRhcmdldC1hdHRhY2hlZC1ib3R0b206YmVmb3JlLFxcbi5wZW5kby10b29sdGlwLnBlbmRvLXRldGhlci10YXJnZXQtYXR0YWNoZWQtYm90dG9tOmFmdGVyIHtcXG4gICAgdG9wOiAtMXB4O1xcbn1cXG5cXG4ucGVuZG8tdG9vbHRpcC5wZW5kby10ZXRoZXItdGFyZ2V0LWF0dGFjaGVkLXRvcDpiZWZvcmUsXFxuLnBlbmRvLXRvb2x0aXAucGVuZG8tdGV0aGVyLXRhcmdldC1hdHRhY2hlZC10b3A6YWZ0ZXIge1xcbiAgICBib3R0b206IC0xcHg7XFxufVxcblxcbi5wZW5kby10b29sdGlwLnBlbmRvLXRldGhlci10YXJnZXQtYXR0YWNoZWQtbWlkZGxlOmJlZm9yZSxcXG4ucGVuZG8tdG9vbHRpcC5wZW5kby10ZXRoZXItdGFyZ2V0LWF0dGFjaGVkLW1pZGRsZTphZnRlciB7XFxuICAgIHRvcDogNTAlO1xcbiAgICBtYXJnaW4tdG9wOiAtNXB4O1xcbn1cXG5cXG4ucGVuZG8tdG9vbHRpcC5wZW5kby10ZXRoZXItdGFyZ2V0LWF0dGFjaGVkLXJpZ2h0OmJlZm9yZSxcXG4ucGVuZG8tdG9vbHRpcC5wZW5kby10ZXRoZXItdGFyZ2V0LWF0dGFjaGVkLXJpZ2h0OmFmdGVyIHtcXG4gICAgbGVmdDogLTFweDtcXG59XFxuXFxuLnBlbmRvLXRvb2x0aXAucGVuZG8tdGV0aGVyLXRhcmdldC1hdHRhY2hlZC1sZWZ0OmJlZm9yZSxcXG4ucGVuZG8tdG9vbHRpcC5wZW5kby10ZXRoZXItdGFyZ2V0LWF0dGFjaGVkLWxlZnQ6YWZ0ZXIge1xcbiAgICByaWdodDogLTFweDtcXG59XFxuXFxuLnBlbmRvLXRvb2x0aXAgc3Ryb25nIHtcXG4gICAgZm9udC1zaXplOiAxMXB4O1xcbn1cXG5cXG4ucGVuZG8tdG9vbHRpcCB0YWJsZSB0ciB0ZCB7XFxuICAgIHBhZGRpbmctbGVmdDogNXB4O1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogYm90dG9tO1xcbiAgICB0ZXh0LWFsaWduOiByaWdodDtcXG59XFxuXFxuLnBlbmRvLXRvb2x0aXAgdGFibGUgdHIgdGQ6Zmlyc3QtY2hpbGQge1xcbiAgICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgICBwYWRkaW5nLWxlZnQ6IDA7XFxufVxcblxcbi5wZW5kby10b29sdGlwIHRhYmxlIHRyIHRkOmxhc3QtY2hpbGQge1xcbiAgICB0ZXh0LWFsaWduOiBsZWZ0O1xcbn1cXG5cXG4ucGVuZG8tdG9vbHRpcCB0YWJsZSB0ciB0ZFtjb2xzcGFuXSB7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG59XFxuXFxuLnBlbmRvLXRvb2x0aXAgdGFibGUgdHIgdGQucGVuZG8tcHJvY2Vzc2luZy1mZWF0dXJlIHtcXG4gICAgZm9udC1zdHlsZTogaXRhbGljO1xcbiAgICB0ZXh0LXRyYW5zZm9ybTogbm9uZTtcXG59XFxuXFxuLnBlbmRvLXRvb2x0aXAgLnBlbmRvLXByb2dyZXNzYmFyIHtcXG4gICAgaGVpZ2h0OiA2cHg7XFxuICAgIHdpZHRoOiA0MHB4O1xcbiAgICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgICBwYWRkaW5nOiAwO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjQ0NDO1xcbn1cXG5cXG4ucGVuZG8tdG9vbHRpcCAucGVuZG8tcHJvZ3Jlc3NiYXIgPiBkaXYge1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMzMzM7XFxufVxcblxcbi5wZW5kby10b29sdGlwIC5wZW5kby1lZGl0LWZlYXR1cmUge1xcbiAgICBwYWRkaW5nLXRvcDogNXB4O1xcbiAgICB0ZXh0LWFsaWduOiByaWdodDtcXG59XFxuXFxuLnBlbmRvLXRvb2x0aXAgLnBlbmRvLWVkaXQtZmVhdHVyZSA+IGEge1xcbiAgICBjb2xvcjogZGFya2JsdWU7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG59XFxuXFxuLnBlbmRvLXRvb2x0aXAgLnBlbmRvLWVkaXQtZmVhdHVyZSA+IGE6aG92ZXIge1xcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXG59XFxuXFxuLl9wZW5kby1ndWlkZV8gPiAuX3BlbmRvLWd1aWRlLWNvbnRhaW5lcl8gPiAuX3BlbmRvLWd1aWRlLWNvbnRlbnRfW2NvbnRlbnRlZGl0YWJsZV0ge1xcbiAgICBvdXRsaW5lLXN0eWxlOiBub25lO1xcbn1cXG5cXG4uX3BlbmRvLWxhdW5jaGVyLWl0ZW1fLFxcbi5fcGVuZG8tbGF1bmNoZXItaXRlbV8gPiBhIHtcXG4gICAgY3Vyc29yOiBtb3ZlO1xcbn1cXG5cXG4jcGVuZG9fY2tlX3Rvb2xiYXIge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogLTI5cHg7XFxuICAgIGxlZnQ6IDE1cHg7XFxuICAgIG1pbi13aWR0aDogNTIwcHg7XFxuICAgIHotaW5kZXg6IDEwMDA7XFxuICAgIC8qIG1ha2Ugc3VyZSB0aGUgdG9vbGJhciBpcyB2aXNpYmxlICovXFxuICAgIGRpc3BsYXk6IGJsb2NrICFpbXBvcnRhbnQ7XFxuICAgIHZpc2liaWxpdHk6IHZpc2libGUgIWltcG9ydGFudDtcXG4gICAgb3BhY2l0eTogMSAhaW1wb3J0YW50O1xcbn1cXG5cXG5AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiAzMjBweCkge1xcbiAgICAuX3BlbmRvLWxhdW5jaGVyLWFjdGl2ZV8ge1xcbiAgICAgICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xcbiAgICB9XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyP3tcIm1vZHVsZXNcIjpmYWxzZX0hLi9wbHVnaW5zL3NlbGVjdGlvbi5jc3Ncbi8vIG1vZHVsZSBpZCA9IDc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcblx0dmFyIGxpc3QgPSBbXTtcblxuXHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gdGhpc1tpXTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmVzdWx0LnB1c2goXCJAbWVkaWEgXCIgKyBpdGVtWzJdICsgXCJ7XCIgKyBpdGVtWzFdICsgXCJ9XCIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVzdWx0LnB1c2goaXRlbVsxXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1xuLy8gbW9kdWxlIGlkID0gNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcm9jZXNzL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi9TdWJzY3JpYmVyJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIElubmVyU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKElubmVyU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbm5lclN1YnNjcmliZXIocGFyZW50LCBvdXRlclZhbHVlLCBvdXRlckluZGV4KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5vdXRlclZhbHVlID0gb3V0ZXJWYWx1ZTtcbiAgICAgICAgdGhpcy5vdXRlckluZGV4ID0gb3V0ZXJJbmRleDtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgfVxuICAgIElubmVyU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQubm90aWZ5TmV4dCh0aGlzLm91dGVyVmFsdWUsIHZhbHVlLCB0aGlzLm91dGVySW5kZXgsIHRoaXMuaW5kZXgrKywgdGhpcyk7XG4gICAgfTtcbiAgICBJbm5lclN1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICB0aGlzLnBhcmVudC5ub3RpZnlFcnJvcihlcnJvciwgdGhpcyk7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICAgIElubmVyU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnBhcmVudC5ub3RpZnlDb21wbGV0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIElubmVyU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbmV4cG9ydHMuSW5uZXJTdWJzY3JpYmVyID0gSW5uZXJTdWJzY3JpYmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW5uZXJTdWJzY3JpYmVyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL0lubmVyU3Vic2NyaWJlci5qc1xuLy8gbW9kdWxlIGlkID0gNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiB0c2xpbnQ6ZGlzYWJsZTpuby11bnVzZWQtdmFyaWFibGUgKi9cbi8vIFN1YmplY3QgaW1wb3J0ZWQgYmVmb3JlIE9ic2VydmFibGUgdG8gYnlwYXNzIGNpcmN1bGFyIGRlcGVuZGVuY3kgaXNzdWUgc2luY2Vcbi8vIFN1YmplY3QgZXh0ZW5kcyBPYnNlcnZhYmxlIGFuZCBPYnNlcnZhYmxlIHJlZmVyZW5jZXMgU3ViamVjdCBpbiBpdCdzXG4vLyBkZWZpbml0aW9uXG52YXIgU3ViamVjdF8xID0gcmVxdWlyZSgnLi9TdWJqZWN0Jyk7XG5leHBvcnRzLlN1YmplY3QgPSBTdWJqZWN0XzEuU3ViamVjdDtcbmV4cG9ydHMuQW5vbnltb3VzU3ViamVjdCA9IFN1YmplY3RfMS5Bbm9ueW1vdXNTdWJqZWN0O1xuLyogdHNsaW50OmVuYWJsZTpuby11bnVzZWQtdmFyaWFibGUgKi9cbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL09ic2VydmFibGUnKTtcbmV4cG9ydHMuT2JzZXJ2YWJsZSA9IE9ic2VydmFibGVfMS5PYnNlcnZhYmxlO1xuLy8gc3RhdGljc1xuLyogdHNsaW50OmRpc2FibGU6bm8tdXNlLWJlZm9yZS1kZWNsYXJlICovXG5yZXF1aXJlKCcuL2FkZC9vYnNlcnZhYmxlL2JpbmRDYWxsYmFjaycpO1xucmVxdWlyZSgnLi9hZGQvb2JzZXJ2YWJsZS9iaW5kTm9kZUNhbGxiYWNrJyk7XG5yZXF1aXJlKCcuL2FkZC9vYnNlcnZhYmxlL2NvbWJpbmVMYXRlc3QnKTtcbnJlcXVpcmUoJy4vYWRkL29ic2VydmFibGUvY29uY2F0Jyk7XG5yZXF1aXJlKCcuL2FkZC9vYnNlcnZhYmxlL2RlZmVyJyk7XG5yZXF1aXJlKCcuL2FkZC9vYnNlcnZhYmxlL2VtcHR5Jyk7XG5yZXF1aXJlKCcuL2FkZC9vYnNlcnZhYmxlL2ZvcmtKb2luJyk7XG5yZXF1aXJlKCcuL2FkZC9vYnNlcnZhYmxlL2Zyb20nKTtcbnJlcXVpcmUoJy4vYWRkL29ic2VydmFibGUvZnJvbUV2ZW50Jyk7XG5yZXF1aXJlKCcuL2FkZC9vYnNlcnZhYmxlL2Zyb21FdmVudFBhdHRlcm4nKTtcbnJlcXVpcmUoJy4vYWRkL29ic2VydmFibGUvZnJvbVByb21pc2UnKTtcbnJlcXVpcmUoJy4vYWRkL29ic2VydmFibGUvZ2VuZXJhdGUnKTtcbnJlcXVpcmUoJy4vYWRkL29ic2VydmFibGUvaWYnKTtcbnJlcXVpcmUoJy4vYWRkL29ic2VydmFibGUvaW50ZXJ2YWwnKTtcbnJlcXVpcmUoJy4vYWRkL29ic2VydmFibGUvbWVyZ2UnKTtcbnJlcXVpcmUoJy4vYWRkL29ic2VydmFibGUvcmFjZScpO1xucmVxdWlyZSgnLi9hZGQvb2JzZXJ2YWJsZS9uZXZlcicpO1xucmVxdWlyZSgnLi9hZGQvb2JzZXJ2YWJsZS9vZicpO1xucmVxdWlyZSgnLi9hZGQvb2JzZXJ2YWJsZS9vbkVycm9yUmVzdW1lTmV4dCcpO1xucmVxdWlyZSgnLi9hZGQvb2JzZXJ2YWJsZS9wYWlycycpO1xucmVxdWlyZSgnLi9hZGQvb2JzZXJ2YWJsZS9yYW5nZScpO1xucmVxdWlyZSgnLi9hZGQvb2JzZXJ2YWJsZS91c2luZycpO1xucmVxdWlyZSgnLi9hZGQvb2JzZXJ2YWJsZS90aHJvdycpO1xucmVxdWlyZSgnLi9hZGQvb2JzZXJ2YWJsZS90aW1lcicpO1xucmVxdWlyZSgnLi9hZGQvb2JzZXJ2YWJsZS96aXAnKTtcbi8vZG9tXG5yZXF1aXJlKCcuL2FkZC9vYnNlcnZhYmxlL2RvbS9hamF4Jyk7XG5yZXF1aXJlKCcuL2FkZC9vYnNlcnZhYmxlL2RvbS93ZWJTb2NrZXQnKTtcbi8vb3BlcmF0b3JzXG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9idWZmZXInKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL2J1ZmZlckNvdW50Jyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9idWZmZXJUaW1lJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9idWZmZXJUb2dnbGUnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL2J1ZmZlcldoZW4nKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL2NhdGNoJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9jb21iaW5lQWxsJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9jb21iaW5lTGF0ZXN0Jyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9jb25jYXQnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL2NvbmNhdEFsbCcpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvY29uY2F0TWFwJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9jb25jYXRNYXBUbycpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvY291bnQnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL2RlbWF0ZXJpYWxpemUnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL2RlYm91bmNlJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9kZWJvdW5jZVRpbWUnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL2RlZmF1bHRJZkVtcHR5Jyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9kZWxheScpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvZGVsYXlXaGVuJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9kaXN0aW5jdCcpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvZGlzdGluY3RVbnRpbENoYW5nZWQnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL2Rpc3RpbmN0VW50aWxLZXlDaGFuZ2VkJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9kbycpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvZXhoYXVzdCcpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvZXhoYXVzdE1hcCcpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvZXhwYW5kJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9lbGVtZW50QXQnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL2ZpbHRlcicpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvZmluYWxseScpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvZmluZCcpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvZmluZEluZGV4Jyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9maXJzdCcpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvZ3JvdXBCeScpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvaWdub3JlRWxlbWVudHMnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL2lzRW1wdHknKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL2F1ZGl0Jyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9hdWRpdFRpbWUnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL2xhc3QnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL2xldCcpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvZXZlcnknKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL21hcCcpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvbWFwVG8nKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL21hdGVyaWFsaXplJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9tYXgnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL21lcmdlJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9tZXJnZUFsbCcpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvbWVyZ2VNYXAnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL21lcmdlTWFwVG8nKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL21lcmdlU2NhbicpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvbWluJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9tdWx0aWNhc3QnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL29ic2VydmVPbicpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3Ivb25FcnJvclJlc3VtZU5leHQnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL3BhaXJ3aXNlJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9wYXJ0aXRpb24nKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL3BsdWNrJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9wdWJsaXNoJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9wdWJsaXNoQmVoYXZpb3InKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL3B1Ymxpc2hSZXBsYXknKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL3B1Ymxpc2hMYXN0Jyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9yYWNlJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9yZWR1Y2UnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL3JlcGVhdCcpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvcmVwZWF0V2hlbicpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvcmV0cnknKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL3JldHJ5V2hlbicpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3Ivc2FtcGxlJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9zYW1wbGVUaW1lJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9zY2FuJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9zZXF1ZW5jZUVxdWFsJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9zaGFyZScpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3Ivc2luZ2xlJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9za2lwJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9za2lwVW50aWwnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL3NraXBXaGlsZScpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3Ivc3RhcnRXaXRoJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9zdWJzY3JpYmVPbicpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3Ivc3dpdGNoJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9zd2l0Y2hNYXAnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL3N3aXRjaE1hcFRvJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci90YWtlJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci90YWtlTGFzdCcpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvdGFrZVVudGlsJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci90YWtlV2hpbGUnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL3Rocm90dGxlJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci90aHJvdHRsZVRpbWUnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL3RpbWVJbnRlcnZhbCcpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvdGltZW91dCcpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvdGltZW91dFdpdGgnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL3RpbWVzdGFtcCcpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvdG9BcnJheScpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvdG9Qcm9taXNlJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci93aW5kb3cnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL3dpbmRvd0NvdW50Jyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci93aW5kb3dUaW1lJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci93aW5kb3dUb2dnbGUnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL3dpbmRvd1doZW4nKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL3dpdGhMYXRlc3RGcm9tJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci96aXAnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL3ppcEFsbCcpO1xuLyogdHNsaW50OmRpc2FibGU6bm8tdW51c2VkLXZhcmlhYmxlICovXG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuL1N1YnNjcmlwdGlvbicpO1xuZXhwb3J0cy5TdWJzY3JpcHRpb24gPSBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb247XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi9TdWJzY3JpYmVyJyk7XG5leHBvcnRzLlN1YnNjcmliZXIgPSBTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcjtcbnZhciBBc3luY1N1YmplY3RfMSA9IHJlcXVpcmUoJy4vQXN5bmNTdWJqZWN0Jyk7XG5leHBvcnRzLkFzeW5jU3ViamVjdCA9IEFzeW5jU3ViamVjdF8xLkFzeW5jU3ViamVjdDtcbnZhciBSZXBsYXlTdWJqZWN0XzEgPSByZXF1aXJlKCcuL1JlcGxheVN1YmplY3QnKTtcbmV4cG9ydHMuUmVwbGF5U3ViamVjdCA9IFJlcGxheVN1YmplY3RfMS5SZXBsYXlTdWJqZWN0O1xudmFyIEJlaGF2aW9yU3ViamVjdF8xID0gcmVxdWlyZSgnLi9CZWhhdmlvclN1YmplY3QnKTtcbmV4cG9ydHMuQmVoYXZpb3JTdWJqZWN0ID0gQmVoYXZpb3JTdWJqZWN0XzEuQmVoYXZpb3JTdWJqZWN0O1xudmFyIENvbm5lY3RhYmxlT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9vYnNlcnZhYmxlL0Nvbm5lY3RhYmxlT2JzZXJ2YWJsZScpO1xuZXhwb3J0cy5Db25uZWN0YWJsZU9ic2VydmFibGUgPSBDb25uZWN0YWJsZU9ic2VydmFibGVfMS5Db25uZWN0YWJsZU9ic2VydmFibGU7XG52YXIgTm90aWZpY2F0aW9uXzEgPSByZXF1aXJlKCcuL05vdGlmaWNhdGlvbicpO1xuZXhwb3J0cy5Ob3RpZmljYXRpb24gPSBOb3RpZmljYXRpb25fMS5Ob3RpZmljYXRpb247XG52YXIgRW1wdHlFcnJvcl8xID0gcmVxdWlyZSgnLi91dGlsL0VtcHR5RXJyb3InKTtcbmV4cG9ydHMuRW1wdHlFcnJvciA9IEVtcHR5RXJyb3JfMS5FbXB0eUVycm9yO1xudmFyIEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yXzEgPSByZXF1aXJlKCcuL3V0aWwvQXJndW1lbnRPdXRPZlJhbmdlRXJyb3InKTtcbmV4cG9ydHMuQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IgPSBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcl8xLkFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yO1xudmFyIE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXzEgPSByZXF1aXJlKCcuL3V0aWwvT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3InKTtcbmV4cG9ydHMuT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IgPSBPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xLk9iamVjdFVuc3Vic2NyaWJlZEVycm9yO1xudmFyIFRpbWVvdXRFcnJvcl8xID0gcmVxdWlyZSgnLi91dGlsL1RpbWVvdXRFcnJvcicpO1xuZXhwb3J0cy5UaW1lb3V0RXJyb3IgPSBUaW1lb3V0RXJyb3JfMS5UaW1lb3V0RXJyb3I7XG52YXIgVW5zdWJzY3JpcHRpb25FcnJvcl8xID0gcmVxdWlyZSgnLi91dGlsL1Vuc3Vic2NyaXB0aW9uRXJyb3InKTtcbmV4cG9ydHMuVW5zdWJzY3JpcHRpb25FcnJvciA9IFVuc3Vic2NyaXB0aW9uRXJyb3JfMS5VbnN1YnNjcmlwdGlvbkVycm9yO1xudmFyIHRpbWVJbnRlcnZhbF8xID0gcmVxdWlyZSgnLi9vcGVyYXRvci90aW1lSW50ZXJ2YWwnKTtcbmV4cG9ydHMuVGltZUludGVydmFsID0gdGltZUludGVydmFsXzEuVGltZUludGVydmFsO1xudmFyIHRpbWVzdGFtcF8xID0gcmVxdWlyZSgnLi9vcGVyYXRvci90aW1lc3RhbXAnKTtcbmV4cG9ydHMuVGltZXN0YW1wID0gdGltZXN0YW1wXzEuVGltZXN0YW1wO1xudmFyIFRlc3RTY2hlZHVsZXJfMSA9IHJlcXVpcmUoJy4vdGVzdGluZy9UZXN0U2NoZWR1bGVyJyk7XG5leHBvcnRzLlRlc3RTY2hlZHVsZXIgPSBUZXN0U2NoZWR1bGVyXzEuVGVzdFNjaGVkdWxlcjtcbnZhciBWaXJ0dWFsVGltZVNjaGVkdWxlcl8xID0gcmVxdWlyZSgnLi9zY2hlZHVsZXIvVmlydHVhbFRpbWVTY2hlZHVsZXInKTtcbmV4cG9ydHMuVmlydHVhbFRpbWVTY2hlZHVsZXIgPSBWaXJ0dWFsVGltZVNjaGVkdWxlcl8xLlZpcnR1YWxUaW1lU2NoZWR1bGVyO1xudmFyIEFqYXhPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL29ic2VydmFibGUvZG9tL0FqYXhPYnNlcnZhYmxlJyk7XG5leHBvcnRzLkFqYXhSZXNwb25zZSA9IEFqYXhPYnNlcnZhYmxlXzEuQWpheFJlc3BvbnNlO1xuZXhwb3J0cy5BamF4RXJyb3IgPSBBamF4T2JzZXJ2YWJsZV8xLkFqYXhFcnJvcjtcbmV4cG9ydHMuQWpheFRpbWVvdXRFcnJvciA9IEFqYXhPYnNlcnZhYmxlXzEuQWpheFRpbWVvdXRFcnJvcjtcbnZhciBhc2FwXzEgPSByZXF1aXJlKCcuL3NjaGVkdWxlci9hc2FwJyk7XG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJy4vc2NoZWR1bGVyL2FzeW5jJyk7XG52YXIgcXVldWVfMSA9IHJlcXVpcmUoJy4vc2NoZWR1bGVyL3F1ZXVlJyk7XG52YXIgYW5pbWF0aW9uRnJhbWVfMSA9IHJlcXVpcmUoJy4vc2NoZWR1bGVyL2FuaW1hdGlvbkZyYW1lJyk7XG52YXIgcnhTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuL3N5bWJvbC9yeFN1YnNjcmliZXInKTtcbnZhciBpdGVyYXRvcl8xID0gcmVxdWlyZSgnLi9zeW1ib2wvaXRlcmF0b3InKTtcbnZhciBvYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL3N5bWJvbC9vYnNlcnZhYmxlJyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm5vLXVudXNlZC12YXJpYWJsZSAqL1xuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBSeC5TY2hlZHVsZXJcbiAqIEBwcm9wZXJ0eSB7U2NoZWR1bGVyfSBxdWV1ZSBTY2hlZHVsZXMgb24gYSBxdWV1ZSBpbiB0aGUgY3VycmVudCBldmVudCBmcmFtZVxuICogKHRyYW1wb2xpbmUgc2NoZWR1bGVyKS4gVXNlIHRoaXMgZm9yIGl0ZXJhdGlvbiBvcGVyYXRpb25zLlxuICogQHByb3BlcnR5IHtTY2hlZHVsZXJ9IGFzYXAgU2NoZWR1bGVzIG9uIHRoZSBtaWNybyB0YXNrIHF1ZXVlLCB3aGljaCB1c2VzIHRoZVxuICogZmFzdGVzdCB0cmFuc3BvcnQgbWVjaGFuaXNtIGF2YWlsYWJsZSwgZWl0aGVyIE5vZGUuanMnIGBwcm9jZXNzLm5leHRUaWNrKClgXG4gKiBvciBXZWIgV29ya2VyIE1lc3NhZ2VDaGFubmVsIG9yIHNldFRpbWVvdXQgb3Igb3RoZXJzLiBVc2UgdGhpcyBmb3JcbiAqIGFzeW5jaHJvbm91cyBjb252ZXJzaW9ucy5cbiAqIEBwcm9wZXJ0eSB7U2NoZWR1bGVyfSBhc3luYyBTY2hlZHVsZXMgd29yayB3aXRoIGBzZXRJbnRlcnZhbGAuIFVzZSB0aGlzIGZvclxuICogdGltZS1iYXNlZCBvcGVyYXRpb25zLlxuICogQHByb3BlcnR5IHtTY2hlZHVsZXJ9IGFuaW1hdGlvbkZyYW1lIFNjaGVkdWxlcyB3b3JrIHdpdGggYHJlcXVlc3RBbmltYXRpb25GcmFtZWAuXG4gKiBVc2UgdGhpcyBmb3Igc3luY2hyb25pemluZyB3aXRoIHRoZSBwbGF0Zm9ybSdzIHBhaW50aW5nXG4gKi9cbnZhciBTY2hlZHVsZXIgPSB7XG4gICAgYXNhcDogYXNhcF8xLmFzYXAsXG4gICAgcXVldWU6IHF1ZXVlXzEucXVldWUsXG4gICAgYW5pbWF0aW9uRnJhbWU6IGFuaW1hdGlvbkZyYW1lXzEuYW5pbWF0aW9uRnJhbWUsXG4gICAgYXN5bmM6IGFzeW5jXzEuYXN5bmNcbn07XG5leHBvcnRzLlNjaGVkdWxlciA9IFNjaGVkdWxlcjtcbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUnguU3ltYm9sXG4gKiBAcHJvcGVydHkge1N5bWJvbHxzdHJpbmd9IHJ4U3Vic2NyaWJlciBBIHN5bWJvbCB0byB1c2UgYXMgYSBwcm9wZXJ0eSBuYW1lIHRvXG4gKiByZXRyaWV2ZSBhbiBcIlJ4IHNhZmVcIiBPYnNlcnZlciBmcm9tIGFuIG9iamVjdC4gXCJSeCBzYWZldHlcIiBjYW4gYmUgZGVmaW5lZCBhc1xuICogYW4gb2JqZWN0IHRoYXQgaGFzIGFsbCBvZiB0aGUgdHJhaXRzIG9mIGFuIFJ4IFN1YnNjcmliZXIsIGluY2x1ZGluZyB0aGVcbiAqIGFiaWxpdHkgdG8gYWRkIGFuZCByZW1vdmUgc3Vic2NyaXB0aW9ucyB0byB0aGUgc3Vic2NyaXB0aW9uIGNoYWluIGFuZFxuICogZ3VhcmFudGVlcyBpbnZvbHZpbmcgZXZlbnQgdHJpZ2dlcmluZyAoY2FuJ3QgXCJuZXh0XCIgYWZ0ZXIgdW5zdWJzY3JpcHRpb24sXG4gKiBldGMpLlxuICogQHByb3BlcnR5IHtTeW1ib2x8c3RyaW5nfSBvYnNlcnZhYmxlIEEgc3ltYm9sIHRvIHVzZSBhcyBhIHByb3BlcnR5IG5hbWUgdG9cbiAqIHJldHJpZXZlIGFuIE9ic2VydmFibGUgYXMgZGVmaW5lZCBieSB0aGUgW0VDTUFTY3JpcHQgXCJPYnNlcnZhYmxlXCIgc3BlY10oaHR0cHM6Ly9naXRodWIuY29tL3plbnBhcnNpbmcvZXMtb2JzZXJ2YWJsZSkuXG4gKiBAcHJvcGVydHkge1N5bWJvbHxzdHJpbmd9IGl0ZXJhdG9yIFRoZSBFUzYgc3ltYm9sIHRvIHVzZSBhcyBhIHByb3BlcnR5IG5hbWVcbiAqIHRvIHJldHJpZXZlIGFuIGl0ZXJhdG9yIGZyb20gYW4gb2JqZWN0LlxuICovXG52YXIgU3ltYm9sID0ge1xuICAgIHJ4U3Vic2NyaWJlcjogcnhTdWJzY3JpYmVyXzEuJCRyeFN1YnNjcmliZXIsXG4gICAgb2JzZXJ2YWJsZTogb2JzZXJ2YWJsZV8xLiQkb2JzZXJ2YWJsZSxcbiAgICBpdGVyYXRvcjogaXRlcmF0b3JfMS4kJGl0ZXJhdG9yXG59O1xuZXhwb3J0cy5TeW1ib2wgPSBTeW1ib2w7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SeC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9SeC5qc1xuLy8gbW9kdWxlIGlkID0gNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEFuIGV4ZWN1dGlvbiBjb250ZXh0IGFuZCBhIGRhdGEgc3RydWN0dXJlIHRvIG9yZGVyIHRhc2tzIGFuZCBzY2hlZHVsZSB0aGVpclxuICogZXhlY3V0aW9uLiBQcm92aWRlcyBhIG5vdGlvbiBvZiAocG90ZW50aWFsbHkgdmlydHVhbCkgdGltZSwgdGhyb3VnaCB0aGVcbiAqIGBub3coKWAgZ2V0dGVyIG1ldGhvZC5cbiAqXG4gKiBFYWNoIHVuaXQgb2Ygd29yayBpbiBhIFNjaGVkdWxlciBpcyBjYWxsZWQgYW4ge0BsaW5rIEFjdGlvbn0uXG4gKlxuICogYGBgdHNcbiAqIGNsYXNzIFNjaGVkdWxlciB7XG4gKiAgIG5vdygpOiBudW1iZXI7XG4gKiAgIHNjaGVkdWxlKHdvcmssIGRlbGF5Pywgc3RhdGU/KTogU3Vic2NyaXB0aW9uO1xuICogfVxuICogYGBgXG4gKlxuICogQGNsYXNzIFNjaGVkdWxlclxuICovXG52YXIgU2NoZWR1bGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTY2hlZHVsZXIoU2NoZWR1bGVyQWN0aW9uLCBub3cpIHtcbiAgICAgICAgaWYgKG5vdyA9PT0gdm9pZCAwKSB7IG5vdyA9IFNjaGVkdWxlci5ub3c7IH1cbiAgICAgICAgdGhpcy5TY2hlZHVsZXJBY3Rpb24gPSBTY2hlZHVsZXJBY3Rpb247XG4gICAgICAgIHRoaXMubm93ID0gbm93O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZXMgYSBmdW5jdGlvbiwgYHdvcmtgLCBmb3IgZXhlY3V0aW9uLiBNYXkgaGFwcGVuIGF0IHNvbWUgcG9pbnQgaW5cbiAgICAgKiB0aGUgZnV0dXJlLCBhY2NvcmRpbmcgdG8gdGhlIGBkZWxheWAgcGFyYW1ldGVyLCBpZiBzcGVjaWZpZWQuIE1heSBiZSBwYXNzZWRcbiAgICAgKiBzb21lIGNvbnRleHQgb2JqZWN0LCBgc3RhdGVgLCB3aGljaCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgYHdvcmtgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogVGhlIGdpdmVuIGFyZ3VtZW50cyB3aWxsIGJlIHByb2Nlc3NlZCBhbiBzdG9yZWQgYXMgYW4gQWN0aW9uIG9iamVjdCBpbiBhXG4gICAgICogcXVldWUgb2YgYWN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oc3RhdGU6ID9UKTogP1N1YnNjcmlwdGlvbn0gd29yayBBIGZ1bmN0aW9uIHJlcHJlc2VudGluZyBhXG4gICAgICogdGFzaywgb3Igc29tZSB1bml0IG9mIHdvcmsgdG8gYmUgZXhlY3V0ZWQgYnkgdGhlIFNjaGVkdWxlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlbGF5XSBUaW1lIHRvIHdhaXQgYmVmb3JlIGV4ZWN1dGluZyB0aGUgd29yaywgd2hlcmUgdGhlXG4gICAgICogdGltZSB1bml0IGlzIGltcGxpY2l0IGFuZCBkZWZpbmVkIGJ5IHRoZSBTY2hlZHVsZXIgaXRzZWxmLlxuICAgICAqIEBwYXJhbSB7VH0gW3N0YXRlXSBTb21lIGNvbnRleHR1YWwgZGF0YSB0aGF0IHRoZSBgd29ya2AgZnVuY3Rpb24gdXNlcyB3aGVuXG4gICAgICogY2FsbGVkIGJ5IHRoZSBTY2hlZHVsZXIuXG4gICAgICogQHJldHVybiB7U3Vic2NyaXB0aW9ufSBBIHN1YnNjcmlwdGlvbiBpbiBvcmRlciB0byBiZSBhYmxlIHRvIHVuc3Vic2NyaWJlXG4gICAgICogdGhlIHNjaGVkdWxlZCB3b3JrLlxuICAgICAqL1xuICAgIFNjaGVkdWxlci5wcm90b3R5cGUuc2NoZWR1bGUgPSBmdW5jdGlvbiAod29yaywgZGVsYXksIHN0YXRlKSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuU2NoZWR1bGVyQWN0aW9uKHRoaXMsIHdvcmspLnNjaGVkdWxlKHN0YXRlLCBkZWxheSk7XG4gICAgfTtcbiAgICBTY2hlZHVsZXIubm93ID0gRGF0ZS5ub3cgPyBEYXRlLm5vdyA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICtuZXcgRGF0ZSgpOyB9O1xuICAgIHJldHVybiBTY2hlZHVsZXI7XG59KCkpO1xuZXhwb3J0cy5TY2hlZHVsZXIgPSBTY2hlZHVsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TY2hlZHVsZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvU2NoZWR1bGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgYmluZENhbGxiYWNrXzEgPSByZXF1aXJlKCcuLi8uLi9vYnNlcnZhYmxlL2JpbmRDYWxsYmFjaycpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUuYmluZENhbGxiYWNrID0gYmluZENhbGxiYWNrXzEuYmluZENhbGxiYWNrO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmluZENhbGxiYWNrLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vYnNlcnZhYmxlL2JpbmRDYWxsYmFjay5qc1xuLy8gbW9kdWxlIGlkID0gODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGJpbmROb2RlQ2FsbGJhY2tfMSA9IHJlcXVpcmUoJy4uLy4uL29ic2VydmFibGUvYmluZE5vZGVDYWxsYmFjaycpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUuYmluZE5vZGVDYWxsYmFjayA9IGJpbmROb2RlQ2FsbGJhY2tfMS5iaW5kTm9kZUNhbGxiYWNrO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmluZE5vZGVDYWxsYmFjay5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb2JzZXJ2YWJsZS9iaW5kTm9kZUNhbGxiYWNrLmpzXG4vLyBtb2R1bGUgaWQgPSA4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgY29tYmluZUxhdGVzdF8xID0gcmVxdWlyZSgnLi4vLi4vb2JzZXJ2YWJsZS9jb21iaW5lTGF0ZXN0Jyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5jb21iaW5lTGF0ZXN0ID0gY29tYmluZUxhdGVzdF8xLmNvbWJpbmVMYXRlc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21iaW5lTGF0ZXN0LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vYnNlcnZhYmxlL2NvbWJpbmVMYXRlc3QuanNcbi8vIG1vZHVsZSBpZCA9IDgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBjb25jYXRfMSA9IHJlcXVpcmUoJy4uLy4uL29ic2VydmFibGUvY29uY2F0Jyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5jb25jYXQgPSBjb25jYXRfMS5jb25jYXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25jYXQuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvYWRkL29ic2VydmFibGUvY29uY2F0LmpzXG4vLyBtb2R1bGUgaWQgPSA4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZGVmZXJfMSA9IHJlcXVpcmUoJy4uLy4uL29ic2VydmFibGUvZGVmZXInKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLmRlZmVyID0gZGVmZXJfMS5kZWZlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmVyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vYnNlcnZhYmxlL2RlZmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgYWpheF8xID0gcmVxdWlyZSgnLi4vLi4vLi4vb2JzZXJ2YWJsZS9kb20vYWpheCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUuYWpheCA9IGFqYXhfMS5hamF4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWpheC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb2JzZXJ2YWJsZS9kb20vYWpheC5qc1xuLy8gbW9kdWxlIGlkID0gODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHdlYlNvY2tldF8xID0gcmVxdWlyZSgnLi4vLi4vLi4vb2JzZXJ2YWJsZS9kb20vd2ViU29ja2V0Jyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS53ZWJTb2NrZXQgPSB3ZWJTb2NrZXRfMS53ZWJTb2NrZXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWJTb2NrZXQuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvYWRkL29ic2VydmFibGUvZG9tL3dlYlNvY2tldC5qc1xuLy8gbW9kdWxlIGlkID0gODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGVtcHR5XzEgPSByZXF1aXJlKCcuLi8uLi9vYnNlcnZhYmxlL2VtcHR5Jyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5lbXB0eSA9IGVtcHR5XzEuZW1wdHk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbXB0eS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb2JzZXJ2YWJsZS9lbXB0eS5qc1xuLy8gbW9kdWxlIGlkID0gODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGZvcmtKb2luXzEgPSByZXF1aXJlKCcuLi8uLi9vYnNlcnZhYmxlL2ZvcmtKb2luJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5mb3JrSm9pbiA9IGZvcmtKb2luXzEuZm9ya0pvaW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JrSm9pbi5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb2JzZXJ2YWJsZS9mb3JrSm9pbi5qc1xuLy8gbW9kdWxlIGlkID0gODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGZyb21fMSA9IHJlcXVpcmUoJy4uLy4uL29ic2VydmFibGUvZnJvbScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUuZnJvbSA9IGZyb21fMS5mcm9tO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnJvbS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb2JzZXJ2YWJsZS9mcm9tLmpzXG4vLyBtb2R1bGUgaWQgPSA5MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZnJvbUV2ZW50XzEgPSByZXF1aXJlKCcuLi8uLi9vYnNlcnZhYmxlL2Zyb21FdmVudCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUuZnJvbUV2ZW50ID0gZnJvbUV2ZW50XzEuZnJvbUV2ZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnJvbUV2ZW50LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vYnNlcnZhYmxlL2Zyb21FdmVudC5qc1xuLy8gbW9kdWxlIGlkID0gOTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGZyb21FdmVudFBhdHRlcm5fMSA9IHJlcXVpcmUoJy4uLy4uL29ic2VydmFibGUvZnJvbUV2ZW50UGF0dGVybicpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUuZnJvbUV2ZW50UGF0dGVybiA9IGZyb21FdmVudFBhdHRlcm5fMS5mcm9tRXZlbnRQYXR0ZXJuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnJvbUV2ZW50UGF0dGVybi5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb2JzZXJ2YWJsZS9mcm9tRXZlbnRQYXR0ZXJuLmpzXG4vLyBtb2R1bGUgaWQgPSA5MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZnJvbVByb21pc2VfMSA9IHJlcXVpcmUoJy4uLy4uL29ic2VydmFibGUvZnJvbVByb21pc2UnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLmZyb21Qcm9taXNlID0gZnJvbVByb21pc2VfMS5mcm9tUHJvbWlzZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZyb21Qcm9taXNlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vYnNlcnZhYmxlL2Zyb21Qcm9taXNlLmpzXG4vLyBtb2R1bGUgaWQgPSA5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgR2VuZXJhdGVPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9vYnNlcnZhYmxlL0dlbmVyYXRlT2JzZXJ2YWJsZScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUuZ2VuZXJhdGUgPSBHZW5lcmF0ZU9ic2VydmFibGVfMS5HZW5lcmF0ZU9ic2VydmFibGUuY3JlYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2VuZXJhdGUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvYWRkL29ic2VydmFibGUvZ2VuZXJhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBpZl8xID0gcmVxdWlyZSgnLi4vLi4vb2JzZXJ2YWJsZS9pZicpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUuaWYgPSBpZl8xLl9pZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlmLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vYnNlcnZhYmxlL2lmLmpzXG4vLyBtb2R1bGUgaWQgPSA5NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgaW50ZXJ2YWxfMSA9IHJlcXVpcmUoJy4uLy4uL29ic2VydmFibGUvaW50ZXJ2YWwnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLmludGVydmFsID0gaW50ZXJ2YWxfMS5pbnRlcnZhbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVydmFsLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vYnNlcnZhYmxlL2ludGVydmFsLmpzXG4vLyBtb2R1bGUgaWQgPSA5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgbWVyZ2VfMSA9IHJlcXVpcmUoJy4uLy4uL29ic2VydmFibGUvbWVyZ2UnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLm1lcmdlID0gbWVyZ2VfMS5tZXJnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmdlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vYnNlcnZhYmxlL21lcmdlLmpzXG4vLyBtb2R1bGUgaWQgPSA5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgbmV2ZXJfMSA9IHJlcXVpcmUoJy4uLy4uL29ic2VydmFibGUvbmV2ZXInKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLm5ldmVyID0gbmV2ZXJfMS5uZXZlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5ldmVyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vYnNlcnZhYmxlL25ldmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA5OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgb2ZfMSA9IHJlcXVpcmUoJy4uLy4uL29ic2VydmFibGUvb2YnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLm9mID0gb2ZfMS5vZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9mLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vYnNlcnZhYmxlL29mLmpzXG4vLyBtb2R1bGUgaWQgPSA5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgb25FcnJvclJlc3VtZU5leHRfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL29uRXJyb3JSZXN1bWVOZXh0Jyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5vbkVycm9yUmVzdW1lTmV4dCA9IG9uRXJyb3JSZXN1bWVOZXh0XzEub25FcnJvclJlc3VtZU5leHRTdGF0aWM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vbkVycm9yUmVzdW1lTmV4dC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb2JzZXJ2YWJsZS9vbkVycm9yUmVzdW1lTmV4dC5qc1xuLy8gbW9kdWxlIGlkID0gMTAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBwYWlyc18xID0gcmVxdWlyZSgnLi4vLi4vb2JzZXJ2YWJsZS9wYWlycycpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucGFpcnMgPSBwYWlyc18xLnBhaXJzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFpcnMuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvYWRkL29ic2VydmFibGUvcGFpcnMuanNcbi8vIG1vZHVsZSBpZCA9IDEwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgcmFjZV8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvcmFjZScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucmFjZSA9IHJhY2VfMS5yYWNlU3RhdGljO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFjZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb2JzZXJ2YWJsZS9yYWNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHJhbmdlXzEgPSByZXF1aXJlKCcuLi8uLi9vYnNlcnZhYmxlL3JhbmdlJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5yYW5nZSA9IHJhbmdlXzEucmFuZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYW5nZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb2JzZXJ2YWJsZS9yYW5nZS5qc1xuLy8gbW9kdWxlIGlkID0gMTAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciB0aHJvd18xID0gcmVxdWlyZSgnLi4vLi4vb2JzZXJ2YWJsZS90aHJvdycpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUudGhyb3cgPSB0aHJvd18xLl90aHJvdztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRocm93LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vYnNlcnZhYmxlL3Rocm93LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHRpbWVyXzEgPSByZXF1aXJlKCcuLi8uLi9vYnNlcnZhYmxlL3RpbWVyJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS50aW1lciA9IHRpbWVyXzEudGltZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb2JzZXJ2YWJsZS90aW1lci5qc1xuLy8gbW9kdWxlIGlkID0gMTA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciB1c2luZ18xID0gcmVxdWlyZSgnLi4vLi4vb2JzZXJ2YWJsZS91c2luZycpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUudXNpbmcgPSB1c2luZ18xLnVzaW5nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNpbmcuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvYWRkL29ic2VydmFibGUvdXNpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDEwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgemlwXzEgPSByZXF1aXJlKCcuLi8uLi9vYnNlcnZhYmxlL3ppcCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUuemlwID0gemlwXzEuemlwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9emlwLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vYnNlcnZhYmxlL3ppcC5qc1xuLy8gbW9kdWxlIGlkID0gMTA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBhdWRpdF8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvYXVkaXQnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5hdWRpdCA9IGF1ZGl0XzEuYXVkaXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdWRpdC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb3BlcmF0b3IvYXVkaXQuanNcbi8vIG1vZHVsZSBpZCA9IDEwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgYXVkaXRUaW1lXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9hdWRpdFRpbWUnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5hdWRpdFRpbWUgPSBhdWRpdFRpbWVfMS5hdWRpdFRpbWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdWRpdFRpbWUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvYWRkL29wZXJhdG9yL2F1ZGl0VGltZS5qc1xuLy8gbW9kdWxlIGlkID0gMTA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBidWZmZXJfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2J1ZmZlcicpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmJ1ZmZlciA9IGJ1ZmZlcl8xLmJ1ZmZlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1ZmZlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb3BlcmF0b3IvYnVmZmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGJ1ZmZlckNvdW50XzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9idWZmZXJDb3VudCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmJ1ZmZlckNvdW50ID0gYnVmZmVyQ291bnRfMS5idWZmZXJDb3VudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1ZmZlckNvdW50LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9idWZmZXJDb3VudC5qc1xuLy8gbW9kdWxlIGlkID0gMTExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBidWZmZXJUaW1lXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9idWZmZXJUaW1lJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuYnVmZmVyVGltZSA9IGJ1ZmZlclRpbWVfMS5idWZmZXJUaW1lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVmZmVyVGltZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb3BlcmF0b3IvYnVmZmVyVGltZS5qc1xuLy8gbW9kdWxlIGlkID0gMTEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBidWZmZXJUb2dnbGVfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2J1ZmZlclRvZ2dsZScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmJ1ZmZlclRvZ2dsZSA9IGJ1ZmZlclRvZ2dsZV8xLmJ1ZmZlclRvZ2dsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1ZmZlclRvZ2dsZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb3BlcmF0b3IvYnVmZmVyVG9nZ2xlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGJ1ZmZlcldoZW5fMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2J1ZmZlcldoZW4nKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5idWZmZXJXaGVuID0gYnVmZmVyV2hlbl8xLmJ1ZmZlcldoZW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWZmZXJXaGVuLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9idWZmZXJXaGVuLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGNhdGNoXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9jYXRjaCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmNhdGNoID0gY2F0Y2hfMS5fY2F0Y2g7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuX2NhdGNoID0gY2F0Y2hfMS5fY2F0Y2g7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYXRjaC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb3BlcmF0b3IvY2F0Y2guanNcbi8vIG1vZHVsZSBpZCA9IDExNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgY29tYmluZUFsbF8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvY29tYmluZUFsbCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmNvbWJpbmVBbGwgPSBjb21iaW5lQWxsXzEuY29tYmluZUFsbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbWJpbmVBbGwuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvYWRkL29wZXJhdG9yL2NvbWJpbmVBbGwuanNcbi8vIG1vZHVsZSBpZCA9IDExNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgY29tYmluZUxhdGVzdF8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvY29tYmluZUxhdGVzdCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmNvbWJpbmVMYXRlc3QgPSBjb21iaW5lTGF0ZXN0XzEuY29tYmluZUxhdGVzdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbWJpbmVMYXRlc3QuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvYWRkL29wZXJhdG9yL2NvbWJpbmVMYXRlc3QuanNcbi8vIG1vZHVsZSBpZCA9IDExN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgY29uY2F0XzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9jb25jYXQnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5jb25jYXQgPSBjb25jYXRfMS5jb25jYXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25jYXQuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvYWRkL29wZXJhdG9yL2NvbmNhdC5qc1xuLy8gbW9kdWxlIGlkID0gMTE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBjb25jYXRBbGxfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2NvbmNhdEFsbCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmNvbmNhdEFsbCA9IGNvbmNhdEFsbF8xLmNvbmNhdEFsbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmNhdEFsbC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb3BlcmF0b3IvY29uY2F0QWxsLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGNvbmNhdE1hcF8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvY29uY2F0TWFwJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuY29uY2F0TWFwID0gY29uY2F0TWFwXzEuY29uY2F0TWFwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uY2F0TWFwLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9jb25jYXRNYXAuanNcbi8vIG1vZHVsZSBpZCA9IDEyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgY29uY2F0TWFwVG9fMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2NvbmNhdE1hcFRvJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuY29uY2F0TWFwVG8gPSBjb25jYXRNYXBUb18xLmNvbmNhdE1hcFRvO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uY2F0TWFwVG8uanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvYWRkL29wZXJhdG9yL2NvbmNhdE1hcFRvLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGNvdW50XzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9jb3VudCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmNvdW50ID0gY291bnRfMS5jb3VudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvdW50LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9jb3VudC5qc1xuLy8gbW9kdWxlIGlkID0gMTIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBkZWJvdW5jZV8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvZGVib3VuY2UnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5kZWJvdW5jZSA9IGRlYm91bmNlXzEuZGVib3VuY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWJvdW5jZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb3BlcmF0b3IvZGVib3VuY2UuanNcbi8vIG1vZHVsZSBpZCA9IDEyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZGVib3VuY2VUaW1lXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9kZWJvdW5jZVRpbWUnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5kZWJvdW5jZVRpbWUgPSBkZWJvdW5jZVRpbWVfMS5kZWJvdW5jZVRpbWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWJvdW5jZVRpbWUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvYWRkL29wZXJhdG9yL2RlYm91bmNlVGltZS5qc1xuLy8gbW9kdWxlIGlkID0gMTI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBkZWZhdWx0SWZFbXB0eV8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvZGVmYXVsdElmRW1wdHknKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5kZWZhdWx0SWZFbXB0eSA9IGRlZmF1bHRJZkVtcHR5XzEuZGVmYXVsdElmRW1wdHk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0SWZFbXB0eS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb3BlcmF0b3IvZGVmYXVsdElmRW1wdHkuanNcbi8vIG1vZHVsZSBpZCA9IDEyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZGVsYXlfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2RlbGF5Jyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZGVsYXkgPSBkZWxheV8xLmRlbGF5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVsYXkuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvYWRkL29wZXJhdG9yL2RlbGF5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGRlbGF5V2hlbl8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvZGVsYXlXaGVuJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZGVsYXlXaGVuID0gZGVsYXlXaGVuXzEuZGVsYXlXaGVuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVsYXlXaGVuLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9kZWxheVdoZW4uanNcbi8vIG1vZHVsZSBpZCA9IDEyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZGVtYXRlcmlhbGl6ZV8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvZGVtYXRlcmlhbGl6ZScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmRlbWF0ZXJpYWxpemUgPSBkZW1hdGVyaWFsaXplXzEuZGVtYXRlcmlhbGl6ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlbWF0ZXJpYWxpemUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvYWRkL29wZXJhdG9yL2RlbWF0ZXJpYWxpemUuanNcbi8vIG1vZHVsZSBpZCA9IDEyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZGlzdGluY3RfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2Rpc3RpbmN0Jyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZGlzdGluY3QgPSBkaXN0aW5jdF8xLmRpc3RpbmN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlzdGluY3QuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvYWRkL29wZXJhdG9yL2Rpc3RpbmN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGRpc3RpbmN0VW50aWxDaGFuZ2VkXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9kaXN0aW5jdFVudGlsQ2hhbmdlZCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmRpc3RpbmN0VW50aWxDaGFuZ2VkID0gZGlzdGluY3RVbnRpbENoYW5nZWRfMS5kaXN0aW5jdFVudGlsQ2hhbmdlZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpc3RpbmN0VW50aWxDaGFuZ2VkLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9kaXN0aW5jdFVudGlsQ2hhbmdlZC5qc1xuLy8gbW9kdWxlIGlkID0gMTMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBkaXN0aW5jdFVudGlsS2V5Q2hhbmdlZF8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvZGlzdGluY3RVbnRpbEtleUNoYW5nZWQnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5kaXN0aW5jdFVudGlsS2V5Q2hhbmdlZCA9IGRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkXzEuZGlzdGluY3RVbnRpbEtleUNoYW5nZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXN0aW5jdFVudGlsS2V5Q2hhbmdlZC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb3BlcmF0b3IvZGlzdGluY3RVbnRpbEtleUNoYW5nZWQuanNcbi8vIG1vZHVsZSBpZCA9IDEzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZG9fMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2RvJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZG8gPSBkb18xLl9kbztcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5fZG8gPSBkb18xLl9kbztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRvLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9kby5qc1xuLy8gbW9kdWxlIGlkID0gMTMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBlbGVtZW50QXRfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2VsZW1lbnRBdCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmVsZW1lbnRBdCA9IGVsZW1lbnRBdF8xLmVsZW1lbnRBdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVsZW1lbnRBdC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb3BlcmF0b3IvZWxlbWVudEF0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGV2ZXJ5XzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9ldmVyeScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmV2ZXJ5ID0gZXZlcnlfMS5ldmVyeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZXJ5LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9ldmVyeS5qc1xuLy8gbW9kdWxlIGlkID0gMTM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBleGhhdXN0XzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9leGhhdXN0Jyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZXhoYXVzdCA9IGV4aGF1c3RfMS5leGhhdXN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhoYXVzdC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb3BlcmF0b3IvZXhoYXVzdC5qc1xuLy8gbW9kdWxlIGlkID0gMTM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBleGhhdXN0TWFwXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9leGhhdXN0TWFwJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZXhoYXVzdE1hcCA9IGV4aGF1c3RNYXBfMS5leGhhdXN0TWFwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhoYXVzdE1hcC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb3BlcmF0b3IvZXhoYXVzdE1hcC5qc1xuLy8gbW9kdWxlIGlkID0gMTM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBleHBhbmRfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2V4cGFuZCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmV4cGFuZCA9IGV4cGFuZF8xLmV4cGFuZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4cGFuZC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb3BlcmF0b3IvZXhwYW5kLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGZpbHRlcl8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvZmlsdGVyJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZmlsdGVyID0gZmlsdGVyXzEuZmlsdGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsdGVyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9maWx0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZmluYWxseV8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvZmluYWxseScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmZpbmFsbHkgPSBmaW5hbGx5XzEuX2ZpbmFsbHk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuX2ZpbmFsbHkgPSBmaW5hbGx5XzEuX2ZpbmFsbHk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maW5hbGx5LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9maW5hbGx5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGZpbmRfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2ZpbmQnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5maW5kID0gZmluZF8xLmZpbmQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maW5kLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9maW5kLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGZpbmRJbmRleF8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvZmluZEluZGV4Jyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZmluZEluZGV4ID0gZmluZEluZGV4XzEuZmluZEluZGV4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmluZEluZGV4LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9maW5kSW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZmlyc3RfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2ZpcnN0Jyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZmlyc3QgPSBmaXJzdF8xLmZpcnN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zmlyc3QuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvYWRkL29wZXJhdG9yL2ZpcnN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGdyb3VwQnlfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2dyb3VwQnknKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5ncm91cEJ5ID0gZ3JvdXBCeV8xLmdyb3VwQnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncm91cEJ5LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9ncm91cEJ5LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGlnbm9yZUVsZW1lbnRzXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9pZ25vcmVFbGVtZW50cycpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmlnbm9yZUVsZW1lbnRzID0gaWdub3JlRWxlbWVudHNfMS5pZ25vcmVFbGVtZW50cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlnbm9yZUVsZW1lbnRzLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9pZ25vcmVFbGVtZW50cy5qc1xuLy8gbW9kdWxlIGlkID0gMTQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBpc0VtcHR5XzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9pc0VtcHR5Jyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuaXNFbXB0eSA9IGlzRW1wdHlfMS5pc0VtcHR5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNFbXB0eS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb3BlcmF0b3IvaXNFbXB0eS5qc1xuLy8gbW9kdWxlIGlkID0gMTQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBsYXN0XzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9sYXN0Jyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUubGFzdCA9IGxhc3RfMS5sYXN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGFzdC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb3BlcmF0b3IvbGFzdC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBsZXRfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2xldCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmxldCA9IGxldF8xLmxldFByb3RvO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmxldEJpbmQgPSBsZXRfMS5sZXRQcm90bztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxldC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb3BlcmF0b3IvbGV0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIG1hcF8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvbWFwJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUubWFwID0gbWFwXzEubWFwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFwLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9tYXAuanNcbi8vIG1vZHVsZSBpZCA9IDE0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgbWFwVG9fMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL21hcFRvJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUubWFwVG8gPSBtYXBUb18xLm1hcFRvO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFwVG8uanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvYWRkL29wZXJhdG9yL21hcFRvLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIG1hdGVyaWFsaXplXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9tYXRlcmlhbGl6ZScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLm1hdGVyaWFsaXplID0gbWF0ZXJpYWxpemVfMS5tYXRlcmlhbGl6ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGVyaWFsaXplLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9tYXRlcmlhbGl6ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBtYXhfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL21heCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLm1heCA9IG1heF8xLm1heDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1heC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb3BlcmF0b3IvbWF4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIG1lcmdlXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9tZXJnZScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLm1lcmdlID0gbWVyZ2VfMS5tZXJnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmdlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9tZXJnZS5qc1xuLy8gbW9kdWxlIGlkID0gMTUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBtZXJnZUFsbF8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvbWVyZ2VBbGwnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5tZXJnZUFsbCA9IG1lcmdlQWxsXzEubWVyZ2VBbGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXJnZUFsbC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb3BlcmF0b3IvbWVyZ2VBbGwuanNcbi8vIG1vZHVsZSBpZCA9IDE1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgbWVyZ2VNYXBfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL21lcmdlTWFwJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUubWVyZ2VNYXAgPSBtZXJnZU1hcF8xLm1lcmdlTWFwO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmZsYXRNYXAgPSBtZXJnZU1hcF8xLm1lcmdlTWFwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVyZ2VNYXAuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvYWRkL29wZXJhdG9yL21lcmdlTWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIG1lcmdlTWFwVG9fMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL21lcmdlTWFwVG8nKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5mbGF0TWFwVG8gPSBtZXJnZU1hcFRvXzEubWVyZ2VNYXBUbztcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5tZXJnZU1hcFRvID0gbWVyZ2VNYXBUb18xLm1lcmdlTWFwVG87XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXJnZU1hcFRvLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9tZXJnZU1hcFRvLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIG1lcmdlU2Nhbl8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvbWVyZ2VTY2FuJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUubWVyZ2VTY2FuID0gbWVyZ2VTY2FuXzEubWVyZ2VTY2FuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVyZ2VTY2FuLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9tZXJnZVNjYW4uanNcbi8vIG1vZHVsZSBpZCA9IDE1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgbWluXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9taW4nKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5taW4gPSBtaW5fMS5taW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1taW4uanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvYWRkL29wZXJhdG9yL21pbi5qc1xuLy8gbW9kdWxlIGlkID0gMTU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBtdWx0aWNhc3RfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL211bHRpY2FzdCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLm11bHRpY2FzdCA9IG11bHRpY2FzdF8xLm11bHRpY2FzdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW11bHRpY2FzdC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb3BlcmF0b3IvbXVsdGljYXN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIG9ic2VydmVPbl8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3Ivb2JzZXJ2ZU9uJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUub2JzZXJ2ZU9uID0gb2JzZXJ2ZU9uXzEub2JzZXJ2ZU9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JzZXJ2ZU9uLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9vYnNlcnZlT24uanNcbi8vIG1vZHVsZSBpZCA9IDE1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgb25FcnJvclJlc3VtZU5leHRfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL29uRXJyb3JSZXN1bWVOZXh0Jyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUub25FcnJvclJlc3VtZU5leHQgPSBvbkVycm9yUmVzdW1lTmV4dF8xLm9uRXJyb3JSZXN1bWVOZXh0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b25FcnJvclJlc3VtZU5leHQuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvYWRkL29wZXJhdG9yL29uRXJyb3JSZXN1bWVOZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHBhaXJ3aXNlXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9wYWlyd2lzZScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnBhaXJ3aXNlID0gcGFpcndpc2VfMS5wYWlyd2lzZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhaXJ3aXNlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9wYWlyd2lzZS5qc1xuLy8gbW9kdWxlIGlkID0gMTYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBwYXJ0aXRpb25fMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3BhcnRpdGlvbicpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnBhcnRpdGlvbiA9IHBhcnRpdGlvbl8xLnBhcnRpdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnRpdGlvbi5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb3BlcmF0b3IvcGFydGl0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHBsdWNrXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9wbHVjaycpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnBsdWNrID0gcGx1Y2tfMS5wbHVjaztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBsdWNrLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9wbHVjay5qc1xuLy8gbW9kdWxlIGlkID0gMTYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBwdWJsaXNoXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9wdWJsaXNoJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUucHVibGlzaCA9IHB1Ymxpc2hfMS5wdWJsaXNoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHVibGlzaC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb3BlcmF0b3IvcHVibGlzaC5qc1xuLy8gbW9kdWxlIGlkID0gMTY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBwdWJsaXNoQmVoYXZpb3JfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3B1Ymxpc2hCZWhhdmlvcicpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnB1Ymxpc2hCZWhhdmlvciA9IHB1Ymxpc2hCZWhhdmlvcl8xLnB1Ymxpc2hCZWhhdmlvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXB1Ymxpc2hCZWhhdmlvci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb3BlcmF0b3IvcHVibGlzaEJlaGF2aW9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHB1Ymxpc2hMYXN0XzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9wdWJsaXNoTGFzdCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnB1Ymxpc2hMYXN0ID0gcHVibGlzaExhc3RfMS5wdWJsaXNoTGFzdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXB1Ymxpc2hMYXN0LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9wdWJsaXNoTGFzdC5qc1xuLy8gbW9kdWxlIGlkID0gMTY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBwdWJsaXNoUmVwbGF5XzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9wdWJsaXNoUmVwbGF5Jyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUucHVibGlzaFJlcGxheSA9IHB1Ymxpc2hSZXBsYXlfMS5wdWJsaXNoUmVwbGF5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHVibGlzaFJlcGxheS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb3BlcmF0b3IvcHVibGlzaFJlcGxheS5qc1xuLy8gbW9kdWxlIGlkID0gMTY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciByYWNlXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9yYWNlJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUucmFjZSA9IHJhY2VfMS5yYWNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFjZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb3BlcmF0b3IvcmFjZS5qc1xuLy8gbW9kdWxlIGlkID0gMTY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciByZWR1Y2VfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3JlZHVjZScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnJlZHVjZSA9IHJlZHVjZV8xLnJlZHVjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZHVjZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb3BlcmF0b3IvcmVkdWNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHJlcGVhdF8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvcmVwZWF0Jyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUucmVwZWF0ID0gcmVwZWF0XzEucmVwZWF0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVwZWF0LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9yZXBlYXQuanNcbi8vIG1vZHVsZSBpZCA9IDE3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgcmVwZWF0V2hlbl8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvcmVwZWF0V2hlbicpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnJlcGVhdFdoZW4gPSByZXBlYXRXaGVuXzEucmVwZWF0V2hlbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlcGVhdFdoZW4uanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvYWRkL29wZXJhdG9yL3JlcGVhdFdoZW4uanNcbi8vIG1vZHVsZSBpZCA9IDE3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgcmV0cnlfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3JldHJ5Jyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUucmV0cnkgPSByZXRyeV8xLnJldHJ5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmV0cnkuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvYWRkL29wZXJhdG9yL3JldHJ5LmpzXG4vLyBtb2R1bGUgaWQgPSAxNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHJldHJ5V2hlbl8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvcmV0cnlXaGVuJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUucmV0cnlXaGVuID0gcmV0cnlXaGVuXzEucmV0cnlXaGVuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmV0cnlXaGVuLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9yZXRyeVdoZW4uanNcbi8vIG1vZHVsZSBpZCA9IDE3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgc2FtcGxlXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9zYW1wbGUnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5zYW1wbGUgPSBzYW1wbGVfMS5zYW1wbGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zYW1wbGUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvYWRkL29wZXJhdG9yL3NhbXBsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBzYW1wbGVUaW1lXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9zYW1wbGVUaW1lJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuc2FtcGxlVGltZSA9IHNhbXBsZVRpbWVfMS5zYW1wbGVUaW1lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2FtcGxlVGltZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb3BlcmF0b3Ivc2FtcGxlVGltZS5qc1xuLy8gbW9kdWxlIGlkID0gMTc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBzY2FuXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9zY2FuJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuc2NhbiA9IHNjYW5fMS5zY2FuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2Nhbi5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb3BlcmF0b3Ivc2Nhbi5qc1xuLy8gbW9kdWxlIGlkID0gMTc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBzZXF1ZW5jZUVxdWFsXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9zZXF1ZW5jZUVxdWFsJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuc2VxdWVuY2VFcXVhbCA9IHNlcXVlbmNlRXF1YWxfMS5zZXF1ZW5jZUVxdWFsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VxdWVuY2VFcXVhbC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb3BlcmF0b3Ivc2VxdWVuY2VFcXVhbC5qc1xuLy8gbW9kdWxlIGlkID0gMTc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBzaGFyZV8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3Ivc2hhcmUnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5zaGFyZSA9IHNoYXJlXzEuc2hhcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGFyZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb3BlcmF0b3Ivc2hhcmUuanNcbi8vIG1vZHVsZSBpZCA9IDE3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgc2luZ2xlXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9zaW5nbGUnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5zaW5nbGUgPSBzaW5nbGVfMS5zaW5nbGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaW5nbGUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvYWRkL29wZXJhdG9yL3NpbmdsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBza2lwXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9za2lwJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuc2tpcCA9IHNraXBfMS5za2lwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2tpcC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb3BlcmF0b3Ivc2tpcC5qc1xuLy8gbW9kdWxlIGlkID0gMTgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBza2lwVW50aWxfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3NraXBVbnRpbCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnNraXBVbnRpbCA9IHNraXBVbnRpbF8xLnNraXBVbnRpbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNraXBVbnRpbC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb3BlcmF0b3Ivc2tpcFVudGlsLmpzXG4vLyBtb2R1bGUgaWQgPSAxODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHNraXBXaGlsZV8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3Ivc2tpcFdoaWxlJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuc2tpcFdoaWxlID0gc2tpcFdoaWxlXzEuc2tpcFdoaWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2tpcFdoaWxlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9za2lwV2hpbGUuanNcbi8vIG1vZHVsZSBpZCA9IDE4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgc3RhcnRXaXRoXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9zdGFydFdpdGgnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5zdGFydFdpdGggPSBzdGFydFdpdGhfMS5zdGFydFdpdGg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGFydFdpdGguanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvYWRkL29wZXJhdG9yL3N0YXJ0V2l0aC5qc1xuLy8gbW9kdWxlIGlkID0gMTgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBzdWJzY3JpYmVPbl8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3Ivc3Vic2NyaWJlT24nKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVPbiA9IHN1YnNjcmliZU9uXzEuc3Vic2NyaWJlT247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJzY3JpYmVPbi5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb3BlcmF0b3Ivc3Vic2NyaWJlT24uanNcbi8vIG1vZHVsZSBpZCA9IDE4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgc3dpdGNoXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9zd2l0Y2gnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5zd2l0Y2ggPSBzd2l0Y2hfMS5fc3dpdGNoO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLl9zd2l0Y2ggPSBzd2l0Y2hfMS5fc3dpdGNoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3dpdGNoLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9zd2l0Y2guanNcbi8vIG1vZHVsZSBpZCA9IDE4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgc3dpdGNoTWFwXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9zd2l0Y2hNYXAnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5zd2l0Y2hNYXAgPSBzd2l0Y2hNYXBfMS5zd2l0Y2hNYXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zd2l0Y2hNYXAuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvYWRkL29wZXJhdG9yL3N3aXRjaE1hcC5qc1xuLy8gbW9kdWxlIGlkID0gMTg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBzd2l0Y2hNYXBUb18xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3Ivc3dpdGNoTWFwVG8nKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5zd2l0Y2hNYXBUbyA9IHN3aXRjaE1hcFRvXzEuc3dpdGNoTWFwVG87XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zd2l0Y2hNYXBUby5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb3BlcmF0b3Ivc3dpdGNoTWFwVG8uanNcbi8vIG1vZHVsZSBpZCA9IDE4N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgdGFrZV8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvdGFrZScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnRha2UgPSB0YWtlXzEudGFrZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRha2UuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvYWRkL29wZXJhdG9yL3Rha2UuanNcbi8vIG1vZHVsZSBpZCA9IDE4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgdGFrZUxhc3RfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3Rha2VMYXN0Jyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUudGFrZUxhc3QgPSB0YWtlTGFzdF8xLnRha2VMYXN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFrZUxhc3QuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvYWRkL29wZXJhdG9yL3Rha2VMYXN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHRha2VVbnRpbF8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvdGFrZVVudGlsJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUudGFrZVVudGlsID0gdGFrZVVudGlsXzEudGFrZVVudGlsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFrZVVudGlsLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vcGVyYXRvci90YWtlVW50aWwuanNcbi8vIG1vZHVsZSBpZCA9IDE5MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgdGFrZVdoaWxlXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci90YWtlV2hpbGUnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS50YWtlV2hpbGUgPSB0YWtlV2hpbGVfMS50YWtlV2hpbGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWtlV2hpbGUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvYWRkL29wZXJhdG9yL3Rha2VXaGlsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciB0aHJvdHRsZV8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvdGhyb3R0bGUnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS50aHJvdHRsZSA9IHRocm90dGxlXzEudGhyb3R0bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aHJvdHRsZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb3BlcmF0b3IvdGhyb3R0bGUuanNcbi8vIG1vZHVsZSBpZCA9IDE5MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgdGhyb3R0bGVUaW1lXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci90aHJvdHRsZVRpbWUnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS50aHJvdHRsZVRpbWUgPSB0aHJvdHRsZVRpbWVfMS50aHJvdHRsZVRpbWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aHJvdHRsZVRpbWUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvYWRkL29wZXJhdG9yL3Rocm90dGxlVGltZS5qc1xuLy8gbW9kdWxlIGlkID0gMTkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciB0aW1lSW50ZXJ2YWxfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3RpbWVJbnRlcnZhbCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnRpbWVJbnRlcnZhbCA9IHRpbWVJbnRlcnZhbF8xLnRpbWVJbnRlcnZhbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbWVJbnRlcnZhbC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb3BlcmF0b3IvdGltZUludGVydmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHRpbWVvdXRfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3RpbWVvdXQnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS50aW1lb3V0ID0gdGltZW91dF8xLnRpbWVvdXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lb3V0LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vcGVyYXRvci90aW1lb3V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHRpbWVvdXRXaXRoXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci90aW1lb3V0V2l0aCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnRpbWVvdXRXaXRoID0gdGltZW91dFdpdGhfMS50aW1lb3V0V2l0aDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbWVvdXRXaXRoLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vcGVyYXRvci90aW1lb3V0V2l0aC5qc1xuLy8gbW9kdWxlIGlkID0gMTk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciB0aW1lc3RhbXBfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3RpbWVzdGFtcCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnRpbWVzdGFtcCA9IHRpbWVzdGFtcF8xLnRpbWVzdGFtcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbWVzdGFtcC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb3BlcmF0b3IvdGltZXN0YW1wLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHRvQXJyYXlfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3RvQXJyYXknKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS50b0FycmF5ID0gdG9BcnJheV8xLnRvQXJyYXk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b0FycmF5LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vcGVyYXRvci90b0FycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAxOThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHRvUHJvbWlzZV8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvdG9Qcm9taXNlJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUudG9Qcm9taXNlID0gdG9Qcm9taXNlXzEudG9Qcm9taXNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9Qcm9taXNlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vcGVyYXRvci90b1Byb21pc2UuanNcbi8vIG1vZHVsZSBpZCA9IDE5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgd2luZG93XzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci93aW5kb3cnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS53aW5kb3cgPSB3aW5kb3dfMS53aW5kb3c7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13aW5kb3cuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvYWRkL29wZXJhdG9yL3dpbmRvdy5qc1xuLy8gbW9kdWxlIGlkID0gMjAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciB3aW5kb3dDb3VudF8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3Ivd2luZG93Q291bnQnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS53aW5kb3dDb3VudCA9IHdpbmRvd0NvdW50XzEud2luZG93Q291bnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13aW5kb3dDb3VudC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb3BlcmF0b3Ivd2luZG93Q291bnQuanNcbi8vIG1vZHVsZSBpZCA9IDIwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgd2luZG93VGltZV8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3Ivd2luZG93VGltZScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLndpbmRvd1RpbWUgPSB3aW5kb3dUaW1lXzEud2luZG93VGltZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdpbmRvd1RpbWUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvYWRkL29wZXJhdG9yL3dpbmRvd1RpbWUuanNcbi8vIG1vZHVsZSBpZCA9IDIwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgd2luZG93VG9nZ2xlXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci93aW5kb3dUb2dnbGUnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS53aW5kb3dUb2dnbGUgPSB3aW5kb3dUb2dnbGVfMS53aW5kb3dUb2dnbGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13aW5kb3dUb2dnbGUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvYWRkL29wZXJhdG9yL3dpbmRvd1RvZ2dsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciB3aW5kb3dXaGVuXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci93aW5kb3dXaGVuJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUud2luZG93V2hlbiA9IHdpbmRvd1doZW5fMS53aW5kb3dXaGVuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2luZG93V2hlbi5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb3BlcmF0b3Ivd2luZG93V2hlbi5qc1xuLy8gbW9kdWxlIGlkID0gMjA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciB3aXRoTGF0ZXN0RnJvbV8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3Ivd2l0aExhdGVzdEZyb20nKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS53aXRoTGF0ZXN0RnJvbSA9IHdpdGhMYXRlc3RGcm9tXzEud2l0aExhdGVzdEZyb207XG4vLyMgc291cmNlTWFwcGluZ1VSTD13aXRoTGF0ZXN0RnJvbS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb3BlcmF0b3Ivd2l0aExhdGVzdEZyb20uanNcbi8vIG1vZHVsZSBpZCA9IDIwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgemlwXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci96aXAnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS56aXAgPSB6aXBfMS56aXBQcm90bztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXppcC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb3BlcmF0b3IvemlwLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHppcEFsbF8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvemlwQWxsJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuemlwQWxsID0gemlwQWxsXzEuemlwQWxsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9emlwQWxsLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vcGVyYXRvci96aXBBbGwuanNcbi8vIG1vZHVsZSBpZCA9IDIwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciBTY2FsYXJPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL1NjYWxhck9ic2VydmFibGUnKTtcbnZhciBFbXB0eU9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vRW1wdHlPYnNlcnZhYmxlJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIEFycmF5TGlrZU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBcnJheUxpa2VPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFycmF5TGlrZU9ic2VydmFibGUoYXJyYXlMaWtlLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuYXJyYXlMaWtlID0gYXJyYXlMaWtlO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgaWYgKCFzY2hlZHVsZXIgJiYgYXJyYXlMaWtlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5faXNTY2FsYXIgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IGFycmF5TGlrZVswXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBBcnJheUxpa2VPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChhcnJheUxpa2UsIHNjaGVkdWxlcikge1xuICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXlMaWtlLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbXB0eU9ic2VydmFibGVfMS5FbXB0eU9ic2VydmFibGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2NhbGFyT2JzZXJ2YWJsZV8xLlNjYWxhck9ic2VydmFibGUoYXJyYXlMaWtlWzBdLCBzY2hlZHVsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheUxpa2VPYnNlcnZhYmxlKGFycmF5TGlrZSwgc2NoZWR1bGVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXJyYXlMaWtlT2JzZXJ2YWJsZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgYXJyYXlMaWtlID0gc3RhdGUuYXJyYXlMaWtlLCBpbmRleCA9IHN0YXRlLmluZGV4LCBsZW5ndGggPSBzdGF0ZS5sZW5ndGgsIHN1YnNjcmliZXIgPSBzdGF0ZS5zdWJzY3JpYmVyO1xuICAgICAgICBpZiAoc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXggPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3Vic2NyaWJlci5uZXh0KGFycmF5TGlrZVtpbmRleF0pO1xuICAgICAgICBzdGF0ZS5pbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZShzdGF0ZSk7XG4gICAgfTtcbiAgICBBcnJheUxpa2VPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgYXJyYXlMaWtlID0gX2EuYXJyYXlMaWtlLCBzY2hlZHVsZXIgPSBfYS5zY2hlZHVsZXI7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcnJheUxpa2UubGVuZ3RoO1xuICAgICAgICBpZiAoc2NoZWR1bGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlKEFycmF5TGlrZU9ic2VydmFibGUuZGlzcGF0Y2gsIDAsIHtcbiAgICAgICAgICAgICAgICBhcnJheUxpa2U6IGFycmF5TGlrZSwgaW5kZXg6IGluZGV4LCBsZW5ndGg6IGxlbmd0aCwgc3Vic2NyaWJlcjogc3Vic2NyaWJlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aCAmJiAhc3Vic2NyaWJlci5jbG9zZWQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChhcnJheUxpa2VbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQXJyYXlMaWtlT2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuQXJyYXlMaWtlT2JzZXJ2YWJsZSA9IEFycmF5TGlrZU9ic2VydmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BcnJheUxpa2VPYnNlcnZhYmxlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29ic2VydmFibGUvQXJyYXlMaWtlT2JzZXJ2YWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIHRyeUNhdGNoXzEgPSByZXF1aXJlKCcuLi91dGlsL3RyeUNhdGNoJyk7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvZXJyb3JPYmplY3QnKTtcbnZhciBBc3luY1N1YmplY3RfMSA9IHJlcXVpcmUoJy4uL0FzeW5jU3ViamVjdCcpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBCb3VuZENhbGxiYWNrT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJvdW5kQ2FsbGJhY2tPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJvdW5kQ2FsbGJhY2tPYnNlcnZhYmxlKGNhbGxiYWNrRnVuYywgc2VsZWN0b3IsIGFyZ3MsIGNvbnRleHQsIHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5jYWxsYmFja0Z1bmMgPSBjYWxsYmFja0Z1bmM7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgfVxuICAgIC8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBjYWxsYmFjayBBUEkgdG8gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gT2JzZXJ2YWJsZS5cbiAgICAgKlxuICAgICAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5HaXZlIGl0IGEgZnVuY3Rpb24gYGZgIG9mIHR5cGUgYGYoeCwgY2FsbGJhY2spYCBhbmRcbiAgICAgKiBpdCB3aWxsIHJldHVybiBhIGZ1bmN0aW9uIGBnYCB0aGF0IHdoZW4gY2FsbGVkIGFzIGBnKHgpYCB3aWxsIG91dHB1dCBhblxuICAgICAqIE9ic2VydmFibGUuPC9zcGFuPlxuICAgICAqXG4gICAgICogYGJpbmRDYWxsYmFja2AgaXMgbm90IGFuIG9wZXJhdG9yIGJlY2F1c2UgaXRzIGlucHV0IGFuZCBvdXRwdXQgYXJlIG5vdFxuICAgICAqIE9ic2VydmFibGVzLiBUaGUgaW5wdXQgaXMgYSBmdW5jdGlvbiBgZnVuY2Agd2l0aCBzb21lIHBhcmFtZXRlcnMsIGJ1dCB0aGVcbiAgICAgKiBsYXN0IHBhcmFtZXRlciBtdXN0IGJlIGEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBgZnVuY2AgY2FsbHMgd2hlbiBpdCBpc1xuICAgICAqIGRvbmUuXG4gICAgICpcbiAgICAgKiBUaGUgb3V0cHV0IG9mIGBiaW5kQ2FsbGJhY2tgIGlzIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyB0aGUgc2FtZSBwYXJhbWV0ZXJzXG4gICAgICogYXMgYGZ1bmNgLCBleGNlcHQgdGhlIGxhc3Qgb25lICh0aGUgY2FsbGJhY2spLiBXaGVuIHRoZSBvdXRwdXQgZnVuY3Rpb25cbiAgICAgKiBpcyBjYWxsZWQgd2l0aCBhcmd1bWVudHMsIGl0IHdpbGwgcmV0dXJuIGFuIE9ic2VydmFibGUuIElmIGBmdW5jYCBmdW5jdGlvblxuICAgICAqIGNhbGxzIGl0cyBjYWxsYmFjayB3aXRoIG9uZSBhcmd1bWVudCwgdGhlIE9ic2VydmFibGUgd2lsbCBlbWl0IHRoYXQgdmFsdWUuXG4gICAgICogSWYgb24gdGhlIG90aGVyIGhhbmQgY2FsbGJhY2sgaXMgY2FsbGVkIHdpdGggbXVsdGlwbGUgdmFsdWVzLCByZXN1bHRpbmdcbiAgICAgKiBPYnNlcnZhYmxlIHdpbGwgZW1pdCBhbiBhcnJheSB3aXRoIHRoZXNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEl0IGlzIHZlcnkgaW1wb3J0YW50IHRvIHJlbWVtYmVyLCB0aGF0IGlucHV0IGZ1bmN0aW9uIGBmdW5jYCBpcyBub3QgY2FsbGVkXG4gICAgICogd2hlbiBvdXRwdXQgZnVuY3Rpb24gaXMsIGJ1dCByYXRoZXIgd2hlbiBPYnNlcnZhYmxlIHJldHVybmVkIGJ5IG91dHB1dFxuICAgICAqIGZ1bmN0aW9uIGlzIHN1YnNjcmliZWQuIFRoaXMgbWVhbnMgaWYgYGZ1bmNgIG1ha2VzIEFKQVggcmVxdWVzdCwgdGhhdCByZXF1ZXN0XG4gICAgICogd2lsbCBiZSBtYWRlIGV2ZXJ5IHRpbWUgc29tZW9uZSBzdWJzY3JpYmVzIHRvIHJlc3VsdGluZyBPYnNlcnZhYmxlLCBidXQgbm90IGJlZm9yZS5cbiAgICAgKlxuICAgICAqIE9wdGlvbmFsbHksIHNlbGVjdG9yIGZ1bmN0aW9uIGNhbiBiZSBwYXNzZWQgdG8gYGJpbmRPYnNlcnZhYmxlYC4gVGhhdCBmdW5jdGlvblxuICAgICAqIHRha2VzIHRoZSBzYW1lIGFyZ3VtZW50cyBhcyBjYWxsYmFjaywgYW5kIHJldHVybnMgdmFsdWVcbiAgICAgKiB0aGF0IHdpbGwgYmUgZW1pdHRlZCBieSBPYnNlcnZhYmxlIGluc3RlYWQgb2YgY2FsbGJhY2sgcGFyYW1ldGVycyB0aGVtc2VsdmVzLlxuICAgICAqIEV2ZW4gdGhvdWdoIGJ5IGRlZmF1bHQgbXVsdGlwbGUgYXJndW1lbnRzIHBhc3NlZCB0byBjYWxsYmFjayBhcHBlYXIgaW4gdGhlIHN0cmVhbSBhcyBhcnJheSxcbiAgICAgKiBzZWxlY3RvciBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aXRoIGFyZ3VtZW50cyBkaXJlY3RseSwganVzdCBhcyBjYWxsYmFjayB3b3VsZC5cbiAgICAgKiBUaGlzIG1lYW5zIHlvdSBjYW4gaW1hZ2luZSBkZWZhdWx0IHNlbGVjdG9yICh3aGVuIG9uZSBpcyBub3QgcHJvdmlkZWQgZXhwbGljaXRseSlcbiAgICAgKiBhcyBmdW5jdGlvbiB0aGF0IGFnZ3JlZ2F0ZXMgYWxsIGl0cyBhcmd1bWVudHMgaW50byBhcnJheSwgb3Igc2ltcGx5IHJldHVybnMgZmlyc3QgYXJndW1lbnQsXG4gICAgICogaWYgdGhlcmUgaXMgb25seSBvbmUuXG4gICAgICpcbiAgICAgKiBMYXN0IG9wdGlvbmFsIHBhcmFtZXRlciAtIHtAbGluayBTY2hlZHVsZXJ9IC0gY2FuIGJlIHVzZWQgdG8gY29udHJvbCB3aGVuIGNhbGxcbiAgICAgKiB0byBgZnVuY2AgaGFwcGVucyBhZnRlciBzb21lb25lIHN1YnNjcmliZXMgdG8gT2JzZXJ2YWJsZSwgYXMgd2VsbCBhcyB3aGVuIHJlc3VsdHNcbiAgICAgKiBwYXNzZWQgdG8gY2FsbGJhY2sgd2lsbCBiZSBlbWl0dGVkLiBCeSBkZWZhdWx0IHN1YnNjcmlwdGlvbiB0byBPYnNlcnZhYmxlIGNhbGxzIGBmdW5jYFxuICAgICAqIHN5bmNocm9ub3VzbHksIGJ1dCB1c2luZyBgU2NoZWR1bGVyLmFzeW5jYCBhcyBsYXN0IHBhcmFtZXRlciB3aWxsIGRlZmVyIGNhbGwgdG8gaW5wdXQgZnVuY3Rpb24sXG4gICAgICoganVzdCBsaWtlIHdyYXBwaW5nIHRoYXQgY2FsbCBpbiBgc2V0VGltZW91dGAgd2l0aCB0aW1lIGAwYCB3b3VsZC4gU28gaWYgeW91IHVzZSBhc3luYyBTY2hlZHVsZXJcbiAgICAgKiBhbmQgY2FsbCBgc3Vic2NyaWJlYCBvbiBvdXRwdXQgT2JzZXJ2YWJsZSwgYWxsIGZ1bmN0aW9uIGNhbGxzIHRoYXQgYXJlIGN1cnJlbnRseSBleGVjdXRpbmcsXG4gICAgICogd2lsbCBlbmQgYmVmb3JlIGBmdW5jYCBpcyBpbnZva2VkLlxuICAgICAqXG4gICAgICogV2hlbiBpdCBjb21lcyB0byBlbWl0dGluZyByZXN1bHRzIHBhc3NlZCB0byBjYWxsYmFjaywgYnkgZGVmYXVsdCB0aGV5IGFyZSBlbWl0dGVkXG4gICAgICogaW1tZWRpYXRlbHkgYWZ0ZXIgYGZ1bmNgIGludm9rZXMgY2FsbGJhY2suIEluIHBhcnRpY3VsYXIsIGlmIGNhbGxiYWNrIGlzIGNhbGxlZCBzeW5jaHJvbm91c2x5LFxuICAgICAqIHRoZW4gc3Vic2NyaXB0aW9uIHRvIHJlc3VsdGluZyBPYnNlcnZhYmxlIHdpbGwgY2FsbCBgbmV4dGAgZnVuY3Rpb24gc3luY2hyb25vdXNseSBhcyB3ZWxsLlxuICAgICAqIElmIHlvdSB3YW50IHRvIGRlZmVyIHRoYXQgY2FsbCwgdXNpbmcgYFNjaGVkdWxlci5hc3luY2Agd2lsbCwgYWdhaW4sIGRvIHRoZSBqb2IuXG4gICAgICogVGhpcyBtZWFucyB0aGF0IGJ5IHVzaW5nIGBTY2hlZHVsZXIuYXN5bmNgIHlvdSBjYW4sIGluIGEgc2Vuc2UsIGVuc3VyZSB0aGF0IGBmdW5jYFxuICAgICAqIGFsd2F5cyBjYWxscyBpdHMgY2FsbGJhY2sgYXN5bmNocm9ub3VzbHksIHRodXMgYXZvaWRpbmcgdGVycmlmeWluZyBaYWxnby5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCBPYnNlcnZhYmxlIGNyZWF0ZWQgYnkgb3V0cHV0IGZ1bmN0aW9uIHdpbGwgYWx3YXlzIGVtaXQgb25seSBvbmUgdmFsdWVcbiAgICAgKiBhbmQgdGhlbiBjb21wbGV0ZSByaWdodCBhZnRlci4gRXZlbiBpZiBgZnVuY2AgY2FsbHMgY2FsbGJhY2sgbXVsdGlwbGUgdGltZXMsIHZhbHVlcyBmcm9tXG4gICAgICogc2Vjb25kIGFuZCBmb2xsb3dpbmcgY2FsbHMgd2lsbCBuZXZlciBhcHBlYXIgaW4gdGhlIHN0cmVhbS4gSWYgeW91IG5lZWQgdG9cbiAgICAgKiBsaXN0ZW4gZm9yIG11bHRpcGxlIGNhbGxzLCB5b3UgcHJvYmFibHkgd2FudCB0byB1c2Uge0BsaW5rIGZyb21FdmVudH0gb3JcbiAgICAgKiB7QGxpbmsgZnJvbUV2ZW50UGF0dGVybn0gaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIElmIGBmdW5jYCBkZXBlbmRzIG9uIHNvbWUgY29udGV4dCAoYHRoaXNgIHByb3BlcnR5KSwgdGhhdCBjb250ZXh0IHdpbGwgYmUgc2V0XG4gICAgICogdG8gdGhlIHNhbWUgY29udGV4dCB0aGF0IG91dHB1dCBmdW5jdGlvbiBoYXMgYXQgY2FsbCB0aW1lLiBJbiBwYXJ0aWN1bGFyLCBpZiBgZnVuY2BcbiAgICAgKiBpcyBjYWxsZWQgYXMgbWV0aG9kIG9mIHNvbWUgb2JqZWN0LCBpbiBvcmRlciB0byBwcmVzZXJ2ZSBwcm9wZXIgYmVoYXZpb3VyLFxuICAgICAqIGl0IGlzIHJlY29tbWVuZGVkIHRvIHNldCBjb250ZXh0IG9mIG91dHB1dCBmdW5jdGlvbiB0byB0aGF0IG9iamVjdCBhcyB3ZWxsLFxuICAgICAqIHByb3ZpZGVkIGBmdW5jYCBpcyBub3QgYWxyZWFkeSBib3VuZC5cbiAgICAgKlxuICAgICAqIElmIGlucHV0IGZ1bmN0aW9uIGNhbGxzIGl0cyBjYWxsYmFjayBpbiBcIm5vZGUgc3R5bGVcIiAoaS5lLiBmaXJzdCBhcmd1bWVudCB0byBjYWxsYmFjayBpc1xuICAgICAqIG9wdGlvbmFsIGVycm9yIHBhcmFtZXRlciBzaWduYWxpbmcgd2hldGhlciBjYWxsIGZhaWxlZCBvciBub3QpLCB7QGxpbmsgYmluZE5vZGVDYWxsYmFja31cbiAgICAgKiBwcm92aWRlcyBjb252ZW5pZW50IGVycm9yIGhhbmRsaW5nIGFuZCBwcm9iYWJseSBpcyBhIGJldHRlciBjaG9pY2UuXG4gICAgICogYGJpbmRDYWxsYmFja2Agd2lsbCB0cmVhdCBzdWNoIGZ1bmN0aW9ucyB3aXRob3V0IGFueSBkaWZmZXJlbmNlIGFuZCBlcnJvciBwYXJhbWV0ZXJcbiAgICAgKiAod2hldGhlciBwYXNzZWQgb3Igbm90KSB3aWxsIGFsd2F5cyBiZSBpbnRlcnByZXRlZCBhcyByZWd1bGFyIGNhbGxiYWNrIGFyZ3VtZW50LlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db252ZXJ0IGpRdWVyeSdzIGdldEpTT04gdG8gYW4gT2JzZXJ2YWJsZSBBUEk8L2NhcHRpb24+XG4gICAgICogLy8gU3VwcG9zZSB3ZSBoYXZlIGpRdWVyeS5nZXRKU09OKCcvbXkvdXJsJywgY2FsbGJhY2spXG4gICAgICogdmFyIGdldEpTT05Bc09ic2VydmFibGUgPSBSeC5PYnNlcnZhYmxlLmJpbmRDYWxsYmFjayhqUXVlcnkuZ2V0SlNPTik7XG4gICAgICogdmFyIHJlc3VsdCA9IGdldEpTT05Bc09ic2VydmFibGUoJy9teS91cmwnKTtcbiAgICAgKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCksIGUgPT4gY29uc29sZS5lcnJvcihlKSk7XG4gICAgICpcbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlJlY2VpdmUgYXJyYXkgb2YgYXJndW1lbnRzIHBhc3NlZCB0byBjYWxsYmFjazwvY2FwdGlvbj5cbiAgICAgKiBzb21lRnVuY3Rpb24oKGEsIGIsIGMpID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGEpOyAvLyA1XG4gICAgICogICBjb25zb2xlLmxvZyhiKTsgLy8gJ3NvbWUgc3RyaW5nJ1xuICAgICAqICAgY29uc29sZS5sb2coYyk7IC8vIHtzb21lUHJvcGVydHk6ICdzb21lVmFsdWUnfVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogY29uc3QgYm91bmRTb21lRnVuY3Rpb24gPSBSeC5PYnNlcnZhYmxlLmJpbmRDYWxsYmFjayhzb21lRnVuY3Rpb24pO1xuICAgICAqIGJvdW5kU29tZUZ1bmN0aW9uLnN1YnNjcmliZSh2YWx1ZXMgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2codmFsdWVzKSAvLyBbNSwgJ3NvbWUgc3RyaW5nJywge3NvbWVQcm9wZXJ0eTogJ3NvbWVWYWx1ZSd9XVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Vc2UgYmluZENhbGxiYWNrIHdpdGggc2VsZWN0b3IgZnVuY3Rpb248L2NhcHRpb24+XG4gICAgICogc29tZUZ1bmN0aW9uKChhLCBiLCBjKSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZyhhKTsgLy8gJ2EnXG4gICAgICogICBjb25zb2xlLmxvZyhiKTsgLy8gJ2InXG4gICAgICogICBjb25zb2xlLmxvZyhjKTsgLy8gJ2MnXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjb25zdCBib3VuZFNvbWVGdW5jdGlvbiA9IFJ4Lk9ic2VydmFibGUuYmluZENhbGxiYWNrKHNvbWVGdW5jdGlvbiwgKGEsIGIsIGMpID0+IGEgKyBiICsgYyk7XG4gICAgICogYm91bmRTb21lRnVuY3Rpb24uc3Vic2NyaWJlKHZhbHVlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHZhbHVlKSAvLyAnYWJjJ1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db21wYXJlIGJlaGF2aW91ciB3aXRoIGFuZCB3aXRob3V0IGFzeW5jIFNjaGVkdWxlcjwvY2FwdGlvbj5cbiAgICAgKiBmdW5jdGlvbiBpQ2FsbE15Q2FsbGJhY2tTeW5jaHJvbm91c2x5KGNiKSB7XG4gICAgICogICBjYigpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGNvbnN0IGJvdW5kU3luY0ZuID0gUnguT2JzZXJ2YWJsZS5iaW5kQ2FsbGJhY2soaUNhbGxNeUNhbGxiYWNrU3luY2hyb25vdXNseSk7XG4gICAgICogY29uc3QgYm91bmRBc3luY0ZuID0gUnguT2JzZXJ2YWJsZS5iaW5kQ2FsbGJhY2soaUNhbGxNeUNhbGxiYWNrU3luY2hyb25vdXNseSwgbnVsbCwgUnguU2NoZWR1bGVyLmFzeW5jKTtcbiAgICAgKlxuICAgICAqIGJvdW5kU3luY0ZuKCkuc3Vic2NyaWJlKCgpID0+IGNvbnNvbGUubG9nKCdJIHdhcyBzeW5jIScpKTtcbiAgICAgKiBib3VuZEFzeW5jRm4oKS5zdWJzY3JpYmUoKCkgPT4gY29uc29sZS5sb2coJ0kgd2FzIGFzeW5jIScpKTtcbiAgICAgKiBjb25zb2xlLmxvZygnVGhpcyBoYXBwZW5lZC4uLicpO1xuICAgICAqXG4gICAgICogLy8gTG9nczpcbiAgICAgKiAvLyBJIHdhcyBzeW5jIVxuICAgICAqIC8vIFRoaXMgaGFwcGVuZWQuLi5cbiAgICAgKiAvLyBJIHdhcyBhc3luYyFcbiAgICAgKlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+VXNlIGJpbmRDYWxsYmFjayBvbiBvYmplY3QgbWV0aG9kPC9jYXB0aW9uPlxuICAgICAqIGNvbnN0IGJvdW5kTWV0aG9kID0gUnguT2JzZXJ2YWJsZS5iaW5kQ2FsbGJhY2soc29tZU9iamVjdC5tZXRob2RXaXRoQ2FsbGJhY2spO1xuICAgICAqIGJvdW5kTWV0aG9kLmNhbGwoc29tZU9iamVjdCkgLy8gbWFrZSBzdXJlIG1ldGhvZFdpdGhDYWxsYmFjayBoYXMgYWNjZXNzIHRvIHNvbWVPYmplY3RcbiAgICAgKiAuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAqXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBiaW5kTm9kZUNhbGxiYWNrfVxuICAgICAqIEBzZWUge0BsaW5rIGZyb219XG4gICAgICogQHNlZSB7QGxpbmsgZnJvbVByb21pc2V9XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jIEZ1bmN0aW9uIHdpdGggYSBjYWxsYmFjayBhcyB0aGUgbGFzdCBwYXJhbWV0ZXIuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW3NlbGVjdG9yXSBBIGZ1bmN0aW9uIHdoaWNoIHRha2VzIHRoZSBhcmd1bWVudHMgZnJvbSB0aGVcbiAgICAgKiBjYWxsYmFjayBhbmQgbWFwcyB0aG9zZSB0byBhIHZhbHVlIHRvIGVtaXQgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICAgICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSBUaGUgc2NoZWR1bGVyIG9uIHdoaWNoIHRvIHNjaGVkdWxlIHRoZVxuICAgICAqIGNhbGxiYWNrcy5cbiAgICAgKiBAcmV0dXJuIHtmdW5jdGlvbiguLi5wYXJhbXM6ICopOiBPYnNlcnZhYmxlfSBBIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgdGhlXG4gICAgICogT2JzZXJ2YWJsZSB0aGF0IGRlbGl2ZXJzIHRoZSBzYW1lIHZhbHVlcyB0aGUgY2FsbGJhY2sgd291bGQgZGVsaXZlci5cbiAgICAgKiBAc3RhdGljIHRydWVcbiAgICAgKiBAbmFtZSBiaW5kQ2FsbGJhY2tcbiAgICAgKiBAb3duZXIgT2JzZXJ2YWJsZVxuICAgICAqL1xuICAgIEJvdW5kQ2FsbGJhY2tPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChmdW5jLCBzZWxlY3Rvciwgc2NoZWR1bGVyKSB7XG4gICAgICAgIGlmIChzZWxlY3RvciA9PT0gdm9pZCAwKSB7IHNlbGVjdG9yID0gdW5kZWZpbmVkOyB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb3VuZENhbGxiYWNrT2JzZXJ2YWJsZShmdW5jLCBzZWxlY3RvciwgYXJncywgdGhpcywgc2NoZWR1bGVyKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEJvdW5kQ2FsbGJhY2tPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrRnVuYyA9IHRoaXMuY2FsbGJhY2tGdW5jO1xuICAgICAgICB2YXIgYXJncyA9IHRoaXMuYXJncztcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICB2YXIgc3ViamVjdCA9IHRoaXMuc3ViamVjdDtcbiAgICAgICAgaWYgKCFzY2hlZHVsZXIpIHtcbiAgICAgICAgICAgIGlmICghc3ViamVjdCkge1xuICAgICAgICAgICAgICAgIHN1YmplY3QgPSB0aGlzLnN1YmplY3QgPSBuZXcgQXN5bmNTdWJqZWN0XzEuQXN5bmNTdWJqZWN0KCk7XG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiBoYW5kbGVyRm4oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbm5lckFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyQXJnc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gaGFuZGxlckZuLnNvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdG9yID0gc291cmNlLnNlbGVjdG9yLCBzdWJqZWN0ID0gc291cmNlLnN1YmplY3Q7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdF8xID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaChzZWxlY3RvcikuYXBwbHkodGhpcywgaW5uZXJBcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRfMSA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YmplY3QuZXJyb3IoZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YmplY3QubmV4dChyZXN1bHRfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViamVjdC5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ViamVjdC5uZXh0KGlubmVyQXJncy5sZW5ndGggPD0gMSA/IGlubmVyQXJnc1swXSA6IGlubmVyQXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJqZWN0LmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIHVzZSBuYW1lZCBmdW5jdGlvbiBpbnN0YW5jZSB0byBhdm9pZCBjbG9zdXJlLlxuICAgICAgICAgICAgICAgIGhhbmRsZXIuc291cmNlID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaChjYWxsYmFja0Z1bmMpLmFwcGx5KHRoaXMuY29udGV4dCwgYXJncy5jb25jYXQoaGFuZGxlcikpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViamVjdC5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdWJqZWN0LnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGUoQm91bmRDYWxsYmFja09ic2VydmFibGUuZGlzcGF0Y2gsIDAsIHsgc291cmNlOiB0aGlzLCBzdWJzY3JpYmVyOiBzdWJzY3JpYmVyLCBjb250ZXh0OiB0aGlzLmNvbnRleHQgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJvdW5kQ2FsbGJhY2tPYnNlcnZhYmxlLmRpc3BhdGNoID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHNvdXJjZSA9IHN0YXRlLnNvdXJjZSwgc3Vic2NyaWJlciA9IHN0YXRlLnN1YnNjcmliZXIsIGNvbnRleHQgPSBzdGF0ZS5jb250ZXh0O1xuICAgICAgICB2YXIgY2FsbGJhY2tGdW5jID0gc291cmNlLmNhbGxiYWNrRnVuYywgYXJncyA9IHNvdXJjZS5hcmdzLCBzY2hlZHVsZXIgPSBzb3VyY2Uuc2NoZWR1bGVyO1xuICAgICAgICB2YXIgc3ViamVjdCA9IHNvdXJjZS5zdWJqZWN0O1xuICAgICAgICBpZiAoIXN1YmplY3QpIHtcbiAgICAgICAgICAgIHN1YmplY3QgPSBzb3VyY2Uuc3ViamVjdCA9IG5ldyBBc3luY1N1YmplY3RfMS5Bc3luY1N1YmplY3QoKTtcbiAgICAgICAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlckZuKCkge1xuICAgICAgICAgICAgICAgIHZhciBpbm5lckFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICBpbm5lckFyZ3NbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSBoYW5kbGVyRm4uc291cmNlO1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RvciA9IHNvdXJjZS5zZWxlY3Rvciwgc3ViamVjdCA9IHNvdXJjZS5zdWJqZWN0O1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0XzIgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKHNlbGVjdG9yKS5hcHBseSh0aGlzLCBpbm5lckFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0XzIgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYWRkKHNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaEVycm9yLCAwLCB7IGVycjogZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lLCBzdWJqZWN0OiBzdWJqZWN0IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYWRkKHNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaE5leHQsIDAsIHsgdmFsdWU6IHJlc3VsdF8yLCBzdWJqZWN0OiBzdWJqZWN0IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gaW5uZXJBcmdzLmxlbmd0aCA8PSAxID8gaW5uZXJBcmdzWzBdIDogaW5uZXJBcmdzO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmFkZChzY2hlZHVsZXIuc2NoZWR1bGUoZGlzcGF0Y2hOZXh0LCAwLCB7IHZhbHVlOiB2YWx1ZSwgc3ViamVjdDogc3ViamVjdCB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIHVzZSBuYW1lZCBmdW5jdGlvbiB0byBwYXNzIHZhbHVlcyBpbiB3aXRob3V0IGNsb3N1cmVcbiAgICAgICAgICAgIGhhbmRsZXIuc291cmNlID0gc291cmNlO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoXzEudHJ5Q2F0Y2goY2FsbGJhY2tGdW5jKS5hcHBseShjb250ZXh0LCBhcmdzLmNvbmNhdChoYW5kbGVyKSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgc3ViamVjdC5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNlbGYuYWRkKHN1YmplY3Quc3Vic2NyaWJlKHN1YnNjcmliZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBCb3VuZENhbGxiYWNrT2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuQm91bmRDYWxsYmFja09ic2VydmFibGUgPSBCb3VuZENhbGxiYWNrT2JzZXJ2YWJsZTtcbmZ1bmN0aW9uIGRpc3BhdGNoTmV4dChhcmcpIHtcbiAgICB2YXIgdmFsdWUgPSBhcmcudmFsdWUsIHN1YmplY3QgPSBhcmcuc3ViamVjdDtcbiAgICBzdWJqZWN0Lm5leHQodmFsdWUpO1xuICAgIHN1YmplY3QuY29tcGxldGUoKTtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoRXJyb3IoYXJnKSB7XG4gICAgdmFyIGVyciA9IGFyZy5lcnIsIHN1YmplY3QgPSBhcmcuc3ViamVjdDtcbiAgICBzdWJqZWN0LmVycm9yKGVycik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Cb3VuZENhbGxiYWNrT2JzZXJ2YWJsZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vYnNlcnZhYmxlL0JvdW5kQ2FsbGJhY2tPYnNlcnZhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG52YXIgdHJ5Q2F0Y2hfMSA9IHJlcXVpcmUoJy4uL3V0aWwvdHJ5Q2F0Y2gnKTtcbnZhciBlcnJvck9iamVjdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9lcnJvck9iamVjdCcpO1xudmFyIEFzeW5jU3ViamVjdF8xID0gcmVxdWlyZSgnLi4vQXN5bmNTdWJqZWN0Jyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIEJvdW5kTm9kZUNhbGxiYWNrT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJvdW5kTm9kZUNhbGxiYWNrT2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCb3VuZE5vZGVDYWxsYmFja09ic2VydmFibGUoY2FsbGJhY2tGdW5jLCBzZWxlY3RvciwgYXJncywgY29udGV4dCwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmNhbGxiYWNrRnVuYyA9IGNhbGxiYWNrRnVuYztcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIE5vZGUuanMtc3R5bGUgY2FsbGJhY2sgQVBJIHRvIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuXG4gICAgICogT2JzZXJ2YWJsZS5cbiAgICAgKlxuICAgICAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5JdCdzIGp1c3QgbGlrZSB7QGxpbmsgYmluZENhbGxiYWNrfSwgYnV0IHRoZVxuICAgICAqIGNhbGxiYWNrIGlzIGV4cGVjdGVkIHRvIGJlIG9mIHR5cGUgYGNhbGxiYWNrKGVycm9yLCByZXN1bHQpYC48L3NwYW4+XG4gICAgICpcbiAgICAgKiBgYmluZE5vZGVDYWxsYmFja2AgaXMgbm90IGFuIG9wZXJhdG9yIGJlY2F1c2UgaXRzIGlucHV0IGFuZCBvdXRwdXQgYXJlIG5vdFxuICAgICAqIE9ic2VydmFibGVzLiBUaGUgaW5wdXQgaXMgYSBmdW5jdGlvbiBgZnVuY2Agd2l0aCBzb21lIHBhcmFtZXRlcnMsIGJ1dCB0aGVcbiAgICAgKiBsYXN0IHBhcmFtZXRlciBtdXN0IGJlIGEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBgZnVuY2AgY2FsbHMgd2hlbiBpdCBpc1xuICAgICAqIGRvbmUuIFRoZSBjYWxsYmFjayBmdW5jdGlvbiBpcyBleHBlY3RlZCB0byBmb2xsb3cgTm9kZS5qcyBjb252ZW50aW9ucyxcbiAgICAgKiB3aGVyZSB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIGNhbGxiYWNrIGlzIGFuIGVycm9yIG9iamVjdCwgc2lnbmFsaW5nXG4gICAgICogd2hldGhlciBjYWxsIHdhcyBzdWNjZXNzZnVsLiBJZiB0aGF0IG9iamVjdCBpcyBwYXNzZWQgdG8gY2FsbGJhY2ssIGl0IG1lYW5zXG4gICAgICogc29tZXRoaW5nIHdlbnQgd3JvbmcuXG4gICAgICpcbiAgICAgKiBUaGUgb3V0cHV0IG9mIGBiaW5kTm9kZUNhbGxiYWNrYCBpcyBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgdGhlIHNhbWVcbiAgICAgKiBwYXJhbWV0ZXJzIGFzIGBmdW5jYCwgZXhjZXB0IHRoZSBsYXN0IG9uZSAodGhlIGNhbGxiYWNrKS4gV2hlbiB0aGUgb3V0cHV0XG4gICAgICogZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggYXJndW1lbnRzLCBpdCB3aWxsIHJldHVybiBhbiBPYnNlcnZhYmxlLlxuICAgICAqIElmIGBmdW5jYCBjYWxscyBpdHMgY2FsbGJhY2sgd2l0aCBlcnJvciBwYXJhbWV0ZXIgcHJlc2VudCwgT2JzZXJ2YWJsZSB3aWxsXG4gICAgICogZXJyb3Igd2l0aCB0aGF0IHZhbHVlIGFzIHdlbGwuIElmIGVycm9yIHBhcmFtZXRlciBpcyBub3QgcGFzc2VkLCBPYnNlcnZhYmxlIHdpbGwgZW1pdFxuICAgICAqIHNlY29uZCBwYXJhbWV0ZXIuIElmIHRoZXJlIGFyZSBtb3JlIHBhcmFtZXRlcnMgKHRoaXJkIGFuZCBzbyBvbiksXG4gICAgICogT2JzZXJ2YWJsZSB3aWxsIGVtaXQgYW4gYXJyYXkgd2l0aCBhbGwgYXJndW1lbnRzLCBleGNlcHQgZmlyc3QgZXJyb3IgYXJndW1lbnQuXG4gICAgICpcbiAgICAgKiBPcHRpb25hbGx5IGBiaW5kTm9kZUNhbGxiYWNrYCBhY2NlcHRzIHNlbGVjdG9yIGZ1bmN0aW9uLCB3aGljaCBhbGxvd3MgeW91IHRvXG4gICAgICogbWFrZSByZXN1bHRpbmcgT2JzZXJ2YWJsZSBlbWl0IHZhbHVlIGNvbXB1dGVkIGJ5IHNlbGVjdG9yLCBpbnN0ZWFkIG9mIHJlZ3VsYXJcbiAgICAgKiBjYWxsYmFjayBhcmd1bWVudHMuIEl0IHdvcmtzIHNpbWlsYXJseSB0byB7QGxpbmsgYmluZENhbGxiYWNrfSBzZWxlY3RvciwgYnV0XG4gICAgICogTm9kZS5qcy1zdHlsZSBlcnJvciBhcmd1bWVudCB3aWxsIG5ldmVyIGJlIHBhc3NlZCB0byB0aGF0IGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IGBmdW5jYCB3aWxsIG5vdCBiZSBjYWxsZWQgYXQgdGhlIHNhbWUgdGltZSBvdXRwdXQgZnVuY3Rpb24gaXMsXG4gICAgICogYnV0IHJhdGhlciB3aGVuZXZlciByZXN1bHRpbmcgT2JzZXJ2YWJsZSBpcyBzdWJzY3JpYmVkLiBCeSBkZWZhdWx0IGNhbGwgdG9cbiAgICAgKiBgZnVuY2Agd2lsbCBoYXBwZW4gc3luY2hyb25vdXNseSBhZnRlciBzdWJzY3JpcHRpb24sIGJ1dCB0aGF0IGNhbiBiZSBjaGFuZ2VkXG4gICAgICogd2l0aCBwcm9wZXIge0BsaW5rIFNjaGVkdWxlcn0gcHJvdmlkZWQgYXMgb3B0aW9uYWwgdGhpcmQgcGFyYW1ldGVyLiBTY2hlZHVsZXJcbiAgICAgKiBjYW4gYWxzbyBjb250cm9sIHdoZW4gdmFsdWVzIGZyb20gY2FsbGJhY2sgd2lsbCBiZSBlbWl0dGVkIGJ5IE9ic2VydmFibGUuXG4gICAgICogVG8gZmluZCBvdXQgbW9yZSwgY2hlY2sgb3V0IGRvY3VtZW50YXRpb24gZm9yIHtAbGluayBiaW5kQ2FsbGJhY2t9LCB3aGVyZVxuICAgICAqIFNjaGVkdWxlciB3b3JrcyBleGFjdGx5IHRoZSBzYW1lLlxuICAgICAqXG4gICAgICogQXMgaW4ge0BsaW5rIGJpbmRDYWxsYmFja30sIGNvbnRleHQgKGB0aGlzYCBwcm9wZXJ0eSkgb2YgaW5wdXQgZnVuY3Rpb24gd2lsbCBiZSBzZXQgdG8gY29udGV4dFxuICAgICAqIG9mIHJldHVybmVkIGZ1bmN0aW9uLCB3aGVuIGl0IGlzIGNhbGxlZC5cbiAgICAgKlxuICAgICAqIEFmdGVyIE9ic2VydmFibGUgZW1pdHMgdmFsdWUsIGl0IHdpbGwgY29tcGxldGUgaW1tZWRpYXRlbHkuIFRoaXMgbWVhbnNcbiAgICAgKiBldmVuIGlmIGBmdW5jYCBjYWxscyBjYWxsYmFjayBhZ2FpbiwgdmFsdWVzIGZyb20gc2Vjb25kIGFuZCBjb25zZWN1dGl2ZVxuICAgICAqIGNhbGxzIHdpbGwgbmV2ZXIgYXBwZWFyIG9uIHRoZSBzdHJlYW0uIElmIHlvdSBuZWVkIHRvIGhhbmRsZSBmdW5jdGlvbnNcbiAgICAgKiB0aGF0IGNhbGwgY2FsbGJhY2tzIG11bHRpcGxlIHRpbWVzLCBjaGVjayBvdXQge0BsaW5rIGZyb21FdmVudH0gb3JcbiAgICAgKiB7QGxpbmsgZnJvbUV2ZW50UGF0dGVybn0gaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCBgYmluZE5vZGVDYWxsYmFja2AgY2FuIGJlIHVzZWQgaW4gbm9uLU5vZGUuanMgZW52aXJvbm1lbnRzIGFzIHdlbGwuXG4gICAgICogXCJOb2RlLmpzLXN0eWxlXCIgY2FsbGJhY2tzIGFyZSBqdXN0IGEgY29udmVudGlvbiwgc28gaWYgeW91IHdyaXRlIGZvclxuICAgICAqIGJyb3dzZXJzIG9yIGFueSBvdGhlciBlbnZpcm9ubWVudCBhbmQgQVBJIHlvdSB1c2UgaW1wbGVtZW50cyB0aGF0IGNhbGxiYWNrIHN0eWxlLFxuICAgICAqIGBiaW5kTm9kZUNhbGxiYWNrYCBjYW4gYmUgc2FmZWx5IHVzZWQgb24gdGhhdCBBUEkgZnVuY3Rpb25zIGFzIHdlbGwuXG4gICAgICpcbiAgICAgKiBSZW1lbWJlciB0aGF0IEVycm9yIG9iamVjdCBwYXNzZWQgdG8gY2FsbGJhY2sgZG9lcyBub3QgaGF2ZSB0byBiZSBhbiBpbnN0YW5jZVxuICAgICAqIG9mIEphdmFTY3JpcHQgYnVpbHQtaW4gYEVycm9yYCBvYmplY3QuIEluIGZhY3QsIGl0IGRvZXMgbm90IGV2ZW4gaGF2ZSB0byBhbiBvYmplY3QuXG4gICAgICogRXJyb3IgcGFyYW1ldGVyIG9mIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGludGVycHJldGVkIGFzIFwicHJlc2VudFwiLCB3aGVuIHZhbHVlXG4gICAgICogb2YgdGhhdCBwYXJhbWV0ZXIgaXMgdHJ1dGh5LiBJdCBjb3VsZCBiZSwgZm9yIGV4YW1wbGUsIG5vbi16ZXJvIG51bWJlciwgbm9uLWVtcHR5XG4gICAgICogc3RyaW5nIG9yIGJvb2xlYW4gYHRydWVgLiBJbiBhbGwgb2YgdGhlc2UgY2FzZXMgcmVzdWx0aW5nIE9ic2VydmFibGUgd291bGQgZXJyb3JcbiAgICAgKiB3aXRoIHRoYXQgdmFsdWUuIFRoaXMgbWVhbnMgdXN1YWxseSByZWd1bGFyIHN0eWxlIGNhbGxiYWNrcyB3aWxsIGZhaWwgdmVyeSBvZnRlbiB3aGVuXG4gICAgICogYGJpbmROb2RlQ2FsbGJhY2tgIGlzIHVzZWQuIElmIHlvdXIgT2JzZXJ2YWJsZSBlcnJvcnMgbXVjaCBtb3JlIG9mdGVuIHRoZW4geW91XG4gICAgICogd291bGQgZXhwZWN0LCBjaGVjayBpZiBjYWxsYmFjayByZWFsbHkgaXMgY2FsbGVkIGluIE5vZGUuanMtc3R5bGUgYW5kLCBpZiBub3QsXG4gICAgICogc3dpdGNoIHRvIHtAbGluayBiaW5kQ2FsbGJhY2t9IGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgZXZlbiBpZiBlcnJvciBwYXJhbWV0ZXIgaXMgdGVjaG5pY2FsbHkgcHJlc2VudCBpbiBjYWxsYmFjaywgYnV0IGl0cyB2YWx1ZVxuICAgICAqIGlzIGZhbHN5LCBpdCBzdGlsbCB3b24ndCBhcHBlYXIgaW4gYXJyYXkgZW1pdHRlZCBieSBPYnNlcnZhYmxlIG9yIGluIHNlbGVjdG9yIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5SZWFkIGEgZmlsZSBmcm9tIHRoZSBmaWxlc3lzdGVtIGFuZCBnZXQgdGhlIGRhdGEgYXMgYW4gT2JzZXJ2YWJsZTwvY2FwdGlvbj5cbiAgICAgKiBpbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG4gICAgICogdmFyIHJlYWRGaWxlQXNPYnNlcnZhYmxlID0gUnguT2JzZXJ2YWJsZS5iaW5kTm9kZUNhbGxiYWNrKGZzLnJlYWRGaWxlKTtcbiAgICAgKiB2YXIgcmVzdWx0ID0gcmVhZEZpbGVBc09ic2VydmFibGUoJy4vcm9hZE5hbWVzLnR4dCcsICd1dGY4Jyk7XG4gICAgICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpLCBlID0+IGNvbnNvbGUuZXJyb3IoZSkpO1xuICAgICAqXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Vc2Ugb24gZnVuY3Rpb24gY2FsbGluZyBjYWxsYmFjayB3aXRoIG11bHRpcGxlIGFyZ3VtZW50czwvY2FwdGlvbj5cbiAgICAgKiBzb21lRnVuY3Rpb24oKGVyciwgYSwgYikgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coZXJyKTsgLy8gbnVsbFxuICAgICAqICAgY29uc29sZS5sb2coYSk7IC8vIDVcbiAgICAgKiAgIGNvbnNvbGUubG9nKGIpOyAvLyBcInNvbWUgc3RyaW5nXCJcbiAgICAgKiB9KTtcbiAgICAgKiB2YXIgYm91bmRTb21lRnVuY3Rpb24gPSBSeC5PYnNlcnZhYmxlLmJpbmROb2RlQ2FsbGJhY2soc29tZUZ1bmN0aW9uKTtcbiAgICAgKiBib3VuZFNvbWVGdW5jdGlvbigpXG4gICAgICogLnN1YnNjcmliZSh2YWx1ZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZyh2YWx1ZSk7IC8vIFs1LCBcInNvbWUgc3RyaW5nXCJdXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlVzZSB3aXRoIHNlbGVjdG9yIGZ1bmN0aW9uPC9jYXB0aW9uPlxuICAgICAqIHNvbWVGdW5jdGlvbigoZXJyLCBhLCBiKSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZyhlcnIpOyAvLyB1bmRlZmluZWRcbiAgICAgKiAgIGNvbnNvbGUubG9nKGEpOyAvLyBcImFiY1wiXG4gICAgICogICBjb25zb2xlLmxvZyhiKTsgLy8gXCJERUZcIlxuICAgICAqIH0pO1xuICAgICAqIHZhciBib3VuZFNvbWVGdW5jdGlvbiA9IFJ4Lk9ic2VydmFibGUuYmluZE5vZGVDYWxsYmFjayhzb21lRnVuY3Rpb24sIChhLCBiKSA9PiBhICsgYik7XG4gICAgICogYm91bmRTb21lRnVuY3Rpb24oKVxuICAgICAqIC5zdWJzY3JpYmUodmFsdWUgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2codmFsdWUpOyAvLyBcImFiY0RFRlwiXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlVzZSBvbiBmdW5jdGlvbiBjYWxsaW5nIGNhbGxiYWNrIGluIHJlZ3VsYXIgc3R5bGU8L2NhcHRpb24+XG4gICAgICogc29tZUZ1bmN0aW9uKGEgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coYSk7IC8vIDVcbiAgICAgKiB9KTtcbiAgICAgKiB2YXIgYm91bmRTb21lRnVuY3Rpb24gPSBSeC5PYnNlcnZhYmxlLmJpbmROb2RlQ2FsbGJhY2soc29tZUZ1bmN0aW9uKTtcbiAgICAgKiBib3VuZFNvbWVGdW5jdGlvbigpXG4gICAgICogLnN1YnNjcmliZShcbiAgICAgKiAgIHZhbHVlID0+IHt9ICAgICAgICAgICAgIC8vIG5ldmVyIGdldHMgY2FsbGVkXG4gICAgICogICBlcnIgPT4gY29uc29sZS5sb2coZXJyKSAvLyA1XG4gICAgICopO1xuICAgICAqXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBiaW5kQ2FsbGJhY2t9XG4gICAgICogQHNlZSB7QGxpbmsgZnJvbX1cbiAgICAgKiBAc2VlIHtAbGluayBmcm9tUHJvbWlzZX1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmMgRnVuY3Rpb24gd2l0aCBhIE5vZGUuanMtc3R5bGUgY2FsbGJhY2sgYXMgdGhlIGxhc3QgcGFyYW1ldGVyLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtzZWxlY3Rvcl0gQSBmdW5jdGlvbiB3aGljaCB0YWtlcyB0aGUgYXJndW1lbnRzIGZyb20gdGhlXG4gICAgICogY2FsbGJhY2sgYW5kIG1hcHMgdGhvc2UgdG8gYSB2YWx1ZSB0byBlbWl0IG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAgICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gVGhlIHNjaGVkdWxlciBvbiB3aGljaCB0byBzY2hlZHVsZSB0aGVcbiAgICAgKiBjYWxsYmFja3MuXG4gICAgICogQHJldHVybiB7ZnVuY3Rpb24oLi4ucGFyYW1zOiAqKTogT2JzZXJ2YWJsZX0gQSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIHRoZVxuICAgICAqIE9ic2VydmFibGUgdGhhdCBkZWxpdmVycyB0aGUgc2FtZSB2YWx1ZXMgdGhlIE5vZGUuanMgY2FsbGJhY2sgd291bGRcbiAgICAgKiBkZWxpdmVyLlxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBuYW1lIGJpbmROb2RlQ2FsbGJhY2tcbiAgICAgKiBAb3duZXIgT2JzZXJ2YWJsZVxuICAgICAqL1xuICAgIEJvdW5kTm9kZUNhbGxiYWNrT2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAoZnVuYywgc2VsZWN0b3IsIHNjaGVkdWxlcikge1xuICAgICAgICBpZiAoc2VsZWN0b3IgPT09IHZvaWQgMCkgeyBzZWxlY3RvciA9IHVuZGVmaW5lZDsgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgQm91bmROb2RlQ2FsbGJhY2tPYnNlcnZhYmxlKGZ1bmMsIHNlbGVjdG9yLCBhcmdzLCB0aGlzLCBzY2hlZHVsZXIpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgQm91bmROb2RlQ2FsbGJhY2tPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrRnVuYyA9IHRoaXMuY2FsbGJhY2tGdW5jO1xuICAgICAgICB2YXIgYXJncyA9IHRoaXMuYXJncztcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICB2YXIgc3ViamVjdCA9IHRoaXMuc3ViamVjdDtcbiAgICAgICAgaWYgKCFzY2hlZHVsZXIpIHtcbiAgICAgICAgICAgIGlmICghc3ViamVjdCkge1xuICAgICAgICAgICAgICAgIHN1YmplY3QgPSB0aGlzLnN1YmplY3QgPSBuZXcgQXN5bmNTdWJqZWN0XzEuQXN5bmNTdWJqZWN0KCk7XG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiBoYW5kbGVyRm4oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbm5lckFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyQXJnc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gaGFuZGxlckZuLnNvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdG9yID0gc291cmNlLnNlbGVjdG9yLCBzdWJqZWN0ID0gc291cmNlLnN1YmplY3Q7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSBpbm5lckFyZ3Muc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ViamVjdC5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0XzEgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKHNlbGVjdG9yKS5hcHBseSh0aGlzLCBpbm5lckFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdF8xID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViamVjdC5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViamVjdC5uZXh0KHJlc3VsdF8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJqZWN0LmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJqZWN0Lm5leHQoaW5uZXJBcmdzLmxlbmd0aCA8PSAxID8gaW5uZXJBcmdzWzBdIDogaW5uZXJBcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YmplY3QuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gdXNlIG5hbWVkIGZ1bmN0aW9uIGluc3RhbmNlIHRvIGF2b2lkIGNsb3N1cmUuXG4gICAgICAgICAgICAgICAgaGFuZGxlci5zb3VyY2UgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKGNhbGxiYWNrRnVuYykuYXBwbHkodGhpcy5jb250ZXh0LCBhcmdzLmNvbmNhdChoYW5kbGVyKSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBzdWJqZWN0LmVycm9yKGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1YmplY3Quc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaCwgMCwgeyBzb3VyY2U6IHRoaXMsIHN1YnNjcmliZXI6IHN1YnNjcmliZXIsIGNvbnRleHQ6IHRoaXMuY29udGV4dCB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEJvdW5kTm9kZUNhbGxiYWNrT2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuQm91bmROb2RlQ2FsbGJhY2tPYnNlcnZhYmxlID0gQm91bmROb2RlQ2FsbGJhY2tPYnNlcnZhYmxlO1xuZnVuY3Rpb24gZGlzcGF0Y2goc3RhdGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHNvdXJjZSA9IHN0YXRlLnNvdXJjZSwgc3Vic2NyaWJlciA9IHN0YXRlLnN1YnNjcmliZXIsIGNvbnRleHQgPSBzdGF0ZS5jb250ZXh0O1xuICAgIC8vIFhYWDogY2FzdCB0byBgYW55YCB0byBhY2Nlc3MgdG8gdGhlIHByaXZhdGUgZmllbGQgaW4gYHNvdXJjZWAuXG4gICAgdmFyIF9hID0gc291cmNlLCBjYWxsYmFja0Z1bmMgPSBfYS5jYWxsYmFja0Z1bmMsIGFyZ3MgPSBfYS5hcmdzLCBzY2hlZHVsZXIgPSBfYS5zY2hlZHVsZXI7XG4gICAgdmFyIHN1YmplY3QgPSBzb3VyY2Uuc3ViamVjdDtcbiAgICBpZiAoIXN1YmplY3QpIHtcbiAgICAgICAgc3ViamVjdCA9IHNvdXJjZS5zdWJqZWN0ID0gbmV3IEFzeW5jU3ViamVjdF8xLkFzeW5jU3ViamVjdCgpO1xuICAgICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXJGbigpIHtcbiAgICAgICAgICAgIHZhciBpbm5lckFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgaW5uZXJBcmdzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGhhbmRsZXJGbi5zb3VyY2U7XG4gICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBzb3VyY2Uuc2VsZWN0b3IsIHN1YmplY3QgPSBzb3VyY2Uuc3ViamVjdDtcbiAgICAgICAgICAgIHZhciBlcnIgPSBpbm5lckFyZ3Muc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmFkZChzY2hlZHVsZXIuc2NoZWR1bGUoZGlzcGF0Y2hFcnJvciwgMCwgeyBlcnI6IGVyciwgc3ViamVjdDogc3ViamVjdCB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHRfMiA9IHRyeUNhdGNoXzEudHJ5Q2F0Y2goc2VsZWN0b3IpLmFwcGx5KHRoaXMsIGlubmVyQXJncyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdF8yID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYWRkKHNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaEVycm9yLCAwLCB7IGVycjogZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lLCBzdWJqZWN0OiBzdWJqZWN0IH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYWRkKHNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaE5leHQsIDAsIHsgdmFsdWU6IHJlc3VsdF8yLCBzdWJqZWN0OiBzdWJqZWN0IH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBpbm5lckFyZ3MubGVuZ3RoIDw9IDEgPyBpbm5lckFyZ3NbMF0gOiBpbm5lckFyZ3M7XG4gICAgICAgICAgICAgICAgc2VsZi5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoTmV4dCwgMCwgeyB2YWx1ZTogdmFsdWUsIHN1YmplY3Q6IHN1YmplY3QgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyB1c2UgbmFtZWQgZnVuY3Rpb24gdG8gcGFzcyB2YWx1ZXMgaW4gd2l0aG91dCBjbG9zdXJlXG4gICAgICAgIGhhbmRsZXIuc291cmNlID0gc291cmNlO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaChjYWxsYmFja0Z1bmMpLmFwcGx5KGNvbnRleHQsIGFyZ3MuY29uY2F0KGhhbmRsZXIpKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgc2VsZi5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoRXJyb3IsIDAsIHsgZXJyOiBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUsIHN1YmplY3Q6IHN1YmplY3QgfSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbGYuYWRkKHN1YmplY3Quc3Vic2NyaWJlKHN1YnNjcmliZXIpKTtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoTmV4dChhcmcpIHtcbiAgICB2YXIgdmFsdWUgPSBhcmcudmFsdWUsIHN1YmplY3QgPSBhcmcuc3ViamVjdDtcbiAgICBzdWJqZWN0Lm5leHQodmFsdWUpO1xuICAgIHN1YmplY3QuY29tcGxldGUoKTtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoRXJyb3IoYXJnKSB7XG4gICAgdmFyIGVyciA9IGFyZy5lcnIsIHN1YmplY3QgPSBhcmcuc3ViamVjdDtcbiAgICBzdWJqZWN0LmVycm9yKGVycik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Cb3VuZE5vZGVDYWxsYmFja09ic2VydmFibGUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb2JzZXJ2YWJsZS9Cb3VuZE5vZGVDYWxsYmFja09ic2VydmFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDIxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIERlZmVyT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERlZmVyT2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEZWZlck9ic2VydmFibGUob2JzZXJ2YWJsZUZhY3RvcnkpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZUZhY3RvcnkgPSBvYnNlcnZhYmxlRmFjdG9yeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIHRoYXQsIG9uIHN1YnNjcmliZSwgY2FsbHMgYW4gT2JzZXJ2YWJsZSBmYWN0b3J5IHRvXG4gICAgICogbWFrZSBhbiBPYnNlcnZhYmxlIGZvciBlYWNoIG5ldyBPYnNlcnZlci5cbiAgICAgKlxuICAgICAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5DcmVhdGVzIHRoZSBPYnNlcnZhYmxlIGxhemlseSwgdGhhdCBpcywgb25seSB3aGVuIGl0XG4gICAgICogaXMgc3Vic2NyaWJlZC5cbiAgICAgKiA8L3NwYW4+XG4gICAgICpcbiAgICAgKiA8aW1nIHNyYz1cIi4vaW1nL2RlZmVyLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICAgICAqXG4gICAgICogYGRlZmVyYCBhbGxvd3MgeW91IHRvIGNyZWF0ZSB0aGUgT2JzZXJ2YWJsZSBvbmx5IHdoZW4gdGhlIE9ic2VydmVyXG4gICAgICogc3Vic2NyaWJlcywgYW5kIGNyZWF0ZSBhIGZyZXNoIE9ic2VydmFibGUgZm9yIGVhY2ggT2JzZXJ2ZXIuIEl0IHdhaXRzIHVudGlsXG4gICAgICogYW4gT2JzZXJ2ZXIgc3Vic2NyaWJlcyB0byBpdCwgYW5kIHRoZW4gaXQgZ2VuZXJhdGVzIGFuIE9ic2VydmFibGUsXG4gICAgICogdHlwaWNhbGx5IHdpdGggYW4gT2JzZXJ2YWJsZSBmYWN0b3J5IGZ1bmN0aW9uLiBJdCBkb2VzIHRoaXMgYWZyZXNoIGZvciBlYWNoXG4gICAgICogc3Vic2NyaWJlciwgc28gYWx0aG91Z2ggZWFjaCBzdWJzY3JpYmVyIG1heSB0aGluayBpdCBpcyBzdWJzY3JpYmluZyB0byB0aGVcbiAgICAgKiBzYW1lIE9ic2VydmFibGUsIGluIGZhY3QgZWFjaCBzdWJzY3JpYmVyIGdldHMgaXRzIG93biBpbmRpdmlkdWFsXG4gICAgICogT2JzZXJ2YWJsZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlN1YnNjcmliZSB0byBlaXRoZXIgYW4gT2JzZXJ2YWJsZSBvZiBjbGlja3Mgb3IgYW4gT2JzZXJ2YWJsZSBvZiBpbnRlcnZhbCwgYXQgcmFuZG9tPC9jYXB0aW9uPlxuICAgICAqIHZhciBjbGlja3NPckludGVydmFsID0gUnguT2JzZXJ2YWJsZS5kZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICogICBpZiAoTWF0aC5yYW5kb20oKSA+IDAuNSkge1xuICAgICAqICAgICByZXR1cm4gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICAgICAqICAgfSBlbHNlIHtcbiAgICAgKiAgICAgcmV0dXJuIFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICogY2xpY2tzT3JJbnRlcnZhbC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gICAgICpcbiAgICAgKiAvLyBSZXN1bHRzIGluIHRoZSBmb2xsb3dpbmcgYmVoYXZpb3I6XG4gICAgICogLy8gSWYgdGhlIHJlc3VsdCBvZiBNYXRoLnJhbmRvbSgpIGlzIGdyZWF0ZXIgdGhhbiAwLjUgaXQgd2lsbCBsaXN0ZW5cbiAgICAgKiAvLyBmb3IgY2xpY2tzIGFueXdoZXJlIG9uIHRoZSBcImRvY3VtZW50XCI7IHdoZW4gZG9jdW1lbnQgaXMgY2xpY2tlZCBpdFxuICAgICAqIC8vIHdpbGwgbG9nIGEgTW91c2VFdmVudCBvYmplY3QgdG8gdGhlIGNvbnNvbGUuIElmIHRoZSByZXN1bHQgaXMgbGVzc1xuICAgICAqIC8vIHRoYW4gMC41IGl0IHdpbGwgZW1pdCBhc2NlbmRpbmcgbnVtYmVycywgb25lIGV2ZXJ5IHNlY29uZCgxMDAwbXMpLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgY3JlYXRlfVxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpOiBTdWJzY3JpYmFibGVPclByb21pc2V9IG9ic2VydmFibGVGYWN0b3J5IFRoZSBPYnNlcnZhYmxlXG4gICAgICogZmFjdG9yeSBmdW5jdGlvbiB0byBpbnZva2UgZm9yIGVhY2ggT2JzZXJ2ZXIgdGhhdCBzdWJzY3JpYmVzIHRvIHRoZSBvdXRwdXRcbiAgICAgKiBPYnNlcnZhYmxlLiBNYXkgYWxzbyByZXR1cm4gYSBQcm9taXNlLCB3aGljaCB3aWxsIGJlIGNvbnZlcnRlZCBvbiB0aGUgZmx5XG4gICAgICogdG8gYW4gT2JzZXJ2YWJsZS5cbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHdob3NlIE9ic2VydmVycycgc3Vic2NyaXB0aW9ucyB0cmlnZ2VyXG4gICAgICogYW4gaW52b2NhdGlvbiBvZiB0aGUgZ2l2ZW4gT2JzZXJ2YWJsZSBmYWN0b3J5IGZ1bmN0aW9uLlxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBuYW1lIGRlZmVyXG4gICAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICAgKi9cbiAgICBEZWZlck9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKG9ic2VydmFibGVGYWN0b3J5KSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVmZXJPYnNlcnZhYmxlKG9ic2VydmFibGVGYWN0b3J5KTtcbiAgICB9O1xuICAgIERlZmVyT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVmZXJTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMub2JzZXJ2YWJsZUZhY3RvcnkpO1xuICAgIH07XG4gICAgcmV0dXJuIERlZmVyT2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuRGVmZXJPYnNlcnZhYmxlID0gRGVmZXJPYnNlcnZhYmxlO1xudmFyIERlZmVyU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERlZmVyU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEZWZlclN1YnNjcmliZXIoZGVzdGluYXRpb24sIGZhY3RvcnkpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmZhY3RvcnkgPSBmYWN0b3J5O1xuICAgICAgICB0aGlzLnRyeURlZmVyKCk7XG4gICAgfVxuICAgIERlZmVyU3Vic2NyaWJlci5wcm90b3R5cGUudHJ5RGVmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxsRmFjdG9yeSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlZmVyU3Vic2NyaWJlci5wcm90b3R5cGUuX2NhbGxGYWN0b3J5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5mYWN0b3J5KCk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgcmVzdWx0KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBEZWZlclN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGVmZXJPYnNlcnZhYmxlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29ic2VydmFibGUvRGVmZXJPYnNlcnZhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIEVycm9yT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEVycm9yT2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFcnJvck9ic2VydmFibGUoZXJyb3IsIHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgbm8gaXRlbXMgdG8gdGhlIE9ic2VydmVyIGFuZCBpbW1lZGlhdGVseVxuICAgICAqIGVtaXRzIGFuIGVycm9yIG5vdGlmaWNhdGlvbi5cbiAgICAgKlxuICAgICAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5KdXN0IGVtaXRzICdlcnJvcicsIGFuZCBub3RoaW5nIGVsc2UuXG4gICAgICogPC9zcGFuPlxuICAgICAqXG4gICAgICogPGltZyBzcmM9XCIuL2ltZy90aHJvdy5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAgICAgKlxuICAgICAqIFRoaXMgc3RhdGljIG9wZXJhdG9yIGlzIHVzZWZ1bCBmb3IgY3JlYXRpbmcgYSBzaW1wbGUgT2JzZXJ2YWJsZSB0aGF0IG9ubHlcbiAgICAgKiBlbWl0cyB0aGUgZXJyb3Igbm90aWZpY2F0aW9uLiBJdCBjYW4gYmUgdXNlZCBmb3IgY29tcG9zaW5nIHdpdGggb3RoZXJcbiAgICAgKiBPYnNlcnZhYmxlcywgc3VjaCBhcyBpbiBhIHtAbGluayBtZXJnZU1hcH0uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0IHRoZSBudW1iZXIgNywgdGhlbiBlbWl0IGFuIGVycm9yLjwvY2FwdGlvbj5cbiAgICAgKiB2YXIgcmVzdWx0ID0gUnguT2JzZXJ2YWJsZS50aHJvdyhuZXcgRXJyb3IoJ29vcHMhJykpLnN0YXJ0V2l0aCg3KTtcbiAgICAgKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCksIGUgPT4gY29uc29sZS5lcnJvcihlKSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5NYXAgYW5kIGZsYXR0ZW4gbnVtYmVycyB0byB0aGUgc2VxdWVuY2UgJ2EnLCAnYicsICdjJywgYnV0IHRocm93IGFuIGVycm9yIGZvciAxMzwvY2FwdGlvbj5cbiAgICAgKiB2YXIgaW50ZXJ2YWwgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApO1xuICAgICAqIHZhciByZXN1bHQgPSBpbnRlcnZhbC5tZXJnZU1hcCh4ID0+XG4gICAgICogICB4ID09PSAxMyA/XG4gICAgICogICAgIFJ4Lk9ic2VydmFibGUudGhyb3coJ1RoaXJ0ZWVucyBhcmUgYmFkJykgOlxuICAgICAqICAgICBSeC5PYnNlcnZhYmxlLm9mKCdhJywgJ2InLCAnYycpXG4gICAgICogKTtcbiAgICAgKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCksIGUgPT4gY29uc29sZS5lcnJvcihlKSk7XG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBjcmVhdGV9XG4gICAgICogQHNlZSB7QGxpbmsgZW1wdHl9XG4gICAgICogQHNlZSB7QGxpbmsgbmV2ZXJ9XG4gICAgICogQHNlZSB7QGxpbmsgb2Z9XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2FueX0gZXJyb3IgVGhlIHBhcnRpY3VsYXIgRXJyb3IgdG8gcGFzcyB0byB0aGUgZXJyb3Igbm90aWZpY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSBBIHtAbGluayBJU2NoZWR1bGVyfSB0byB1c2UgZm9yIHNjaGVkdWxpbmdcbiAgICAgKiB0aGUgZW1pc3Npb24gb2YgdGhlIGVycm9yIG5vdGlmaWNhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBlcnJvciBPYnNlcnZhYmxlOiBlbWl0cyBvbmx5IHRoZSBlcnJvciBub3RpZmljYXRpb25cbiAgICAgKiB1c2luZyB0aGUgZ2l2ZW4gZXJyb3IgYXJndW1lbnQuXG4gICAgICogQHN0YXRpYyB0cnVlXG4gICAgICogQG5hbWUgdGhyb3dcbiAgICAgKiBAb3duZXIgT2JzZXJ2YWJsZVxuICAgICAqL1xuICAgIEVycm9yT2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAoZXJyb3IsIHNjaGVkdWxlcikge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yT2JzZXJ2YWJsZShlcnJvciwgc2NoZWR1bGVyKTtcbiAgICB9O1xuICAgIEVycm9yT2JzZXJ2YWJsZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgdmFyIGVycm9yID0gYXJnLmVycm9yLCBzdWJzY3JpYmVyID0gYXJnLnN1YnNjcmliZXI7XG4gICAgICAgIHN1YnNjcmliZXIuZXJyb3IoZXJyb3IpO1xuICAgIH07XG4gICAgRXJyb3JPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIGVycm9yID0gdGhpcy5lcnJvcjtcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICBpZiAoc2NoZWR1bGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlKEVycm9yT2JzZXJ2YWJsZS5kaXNwYXRjaCwgMCwge1xuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvciwgc3Vic2NyaWJlcjogc3Vic2NyaWJlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEVycm9yT2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuRXJyb3JPYnNlcnZhYmxlID0gRXJyb3JPYnNlcnZhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXJyb3JPYnNlcnZhYmxlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29ic2VydmFibGUvRXJyb3JPYnNlcnZhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG52YXIgRW1wdHlPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL0VtcHR5T2JzZXJ2YWJsZScpO1xudmFyIGlzQXJyYXlfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNBcnJheScpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG52YXIgRm9ya0pvaW5PYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRm9ya0pvaW5PYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZvcmtKb2luT2JzZXJ2YWJsZShzb3VyY2VzLCByZXN1bHRTZWxlY3Rvcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5zb3VyY2VzID0gc291cmNlcztcbiAgICAgICAgdGhpcy5yZXN1bHRTZWxlY3RvciA9IHJlc3VsdFNlbGVjdG9yO1xuICAgIH1cbiAgICAvKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBzb3VyY2VzXG4gICAgICogQHJldHVybiB7YW55fVxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBuYW1lIGZvcmtKb2luXG4gICAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICAgKi9cbiAgICBGb3JrSm9pbk9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgc291cmNlc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc291cmNlcyA9PT0gbnVsbCB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVtcHR5T2JzZXJ2YWJsZV8xLkVtcHR5T2JzZXJ2YWJsZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHRTZWxlY3RvciA9IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2Ygc291cmNlc1tzb3VyY2VzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXN1bHRTZWxlY3RvciA9IHNvdXJjZXMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIGZpcnN0IGFuZCBvbmx5IG90aGVyIGFyZ3VtZW50IGJlc2lkZXMgdGhlIHJlc3VsdFNlbGVjdG9yIGlzIGFuIGFycmF5XG4gICAgICAgIC8vIGFzc3VtZSBpdCdzIGJlZW4gY2FsbGVkIHdpdGggYGZvcmtKb2luKFtvYnMxLCBvYnMyLCBvYnMzXSwgcmVzdWx0U2VsZWN0b3IpYFxuICAgICAgICBpZiAoc291cmNlcy5sZW5ndGggPT09IDEgJiYgaXNBcnJheV8xLmlzQXJyYXkoc291cmNlc1swXSkpIHtcbiAgICAgICAgICAgIHNvdXJjZXMgPSBzb3VyY2VzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbXB0eU9ic2VydmFibGVfMS5FbXB0eU9ic2VydmFibGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEZvcmtKb2luT2JzZXJ2YWJsZShzb3VyY2VzLCByZXN1bHRTZWxlY3Rvcik7XG4gICAgfTtcbiAgICBGb3JrSm9pbk9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICByZXR1cm4gbmV3IEZvcmtKb2luU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnNvdXJjZXMsIHRoaXMucmVzdWx0U2VsZWN0b3IpO1xuICAgIH07XG4gICAgcmV0dXJuIEZvcmtKb2luT2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuRm9ya0pvaW5PYnNlcnZhYmxlID0gRm9ya0pvaW5PYnNlcnZhYmxlO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBGb3JrSm9pblN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGb3JrSm9pblN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRm9ya0pvaW5TdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBzb3VyY2VzLCByZXN1bHRTZWxlY3Rvcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuc291cmNlcyA9IHNvdXJjZXM7XG4gICAgICAgIHRoaXMucmVzdWx0U2VsZWN0b3IgPSByZXN1bHRTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5jb21wbGV0ZWQgPSAwO1xuICAgICAgICB0aGlzLmhhdmVWYWx1ZXMgPSAwO1xuICAgICAgICB2YXIgbGVuID0gc291cmNlcy5sZW5ndGg7XG4gICAgICAgIHRoaXMudG90YWwgPSBsZW47XG4gICAgICAgIHRoaXMudmFsdWVzID0gbmV3IEFycmF5KGxlbik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2ldO1xuICAgICAgICAgICAgdmFyIGlubmVyU3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBzb3VyY2UsIG51bGwsIGkpO1xuICAgICAgICAgICAgaWYgKGlubmVyU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgaW5uZXJTdWJzY3JpcHRpb24ub3V0ZXJJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoaW5uZXJTdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIEZvcmtKb2luU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLnZhbHVlc1tvdXRlckluZGV4XSA9IGlubmVyVmFsdWU7XG4gICAgICAgIGlmICghaW5uZXJTdWIuX2hhc1ZhbHVlKSB7XG4gICAgICAgICAgICBpbm5lclN1Yi5faGFzVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5oYXZlVmFsdWVzKys7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEZvcmtKb2luU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoaW5uZXJTdWIpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgaGF2ZVZhbHVlcyA9IF9hLmhhdmVWYWx1ZXMsIHJlc3VsdFNlbGVjdG9yID0gX2EucmVzdWx0U2VsZWN0b3IsIHZhbHVlcyA9IF9hLnZhbHVlcztcbiAgICAgICAgdmFyIGxlbiA9IHZhbHVlcy5sZW5ndGg7XG4gICAgICAgIGlmICghaW5uZXJTdWIuX2hhc1ZhbHVlKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tcGxldGVkKys7XG4gICAgICAgIGlmICh0aGlzLmNvbXBsZXRlZCAhPT0gbGVuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhdmVWYWx1ZXMgPT09IGxlbikge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0U2VsZWN0b3IgPyByZXN1bHRTZWxlY3Rvci5hcHBseSh0aGlzLCB2YWx1ZXMpIDogdmFsdWVzO1xuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9O1xuICAgIHJldHVybiBGb3JrSm9pblN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Rm9ya0pvaW5PYnNlcnZhYmxlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29ic2VydmFibGUvRm9ya0pvaW5PYnNlcnZhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG52YXIgdHJ5Q2F0Y2hfMSA9IHJlcXVpcmUoJy4uL3V0aWwvdHJ5Q2F0Y2gnKTtcbnZhciBpc0Z1bmN0aW9uXzEgPSByZXF1aXJlKCcuLi91dGlsL2lzRnVuY3Rpb24nKTtcbnZhciBlcnJvck9iamVjdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9lcnJvck9iamVjdCcpO1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaXB0aW9uJyk7XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuZnVuY3Rpb24gaXNOb2RlU3R5bGVFdmVudEVtaXR0ZXIoc291cmNlT2JqKSB7XG4gICAgcmV0dXJuICEhc291cmNlT2JqICYmIHR5cGVvZiBzb3VyY2VPYmouYWRkTGlzdGVuZXIgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHNvdXJjZU9iai5yZW1vdmVMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIGlzSlF1ZXJ5U3R5bGVFdmVudEVtaXR0ZXIoc291cmNlT2JqKSB7XG4gICAgcmV0dXJuICEhc291cmNlT2JqICYmIHR5cGVvZiBzb3VyY2VPYmoub24gPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHNvdXJjZU9iai5vZmYgPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBpc05vZGVMaXN0KHNvdXJjZU9iaikge1xuICAgIHJldHVybiAhIXNvdXJjZU9iaiAmJiB0b1N0cmluZy5jYWxsKHNvdXJjZU9iaikgPT09ICdbb2JqZWN0IE5vZGVMaXN0XSc7XG59XG5mdW5jdGlvbiBpc0hUTUxDb2xsZWN0aW9uKHNvdXJjZU9iaikge1xuICAgIHJldHVybiAhIXNvdXJjZU9iaiAmJiB0b1N0cmluZy5jYWxsKHNvdXJjZU9iaikgPT09ICdbb2JqZWN0IEhUTUxDb2xsZWN0aW9uXSc7XG59XG5mdW5jdGlvbiBpc0V2ZW50VGFyZ2V0KHNvdXJjZU9iaikge1xuICAgIHJldHVybiAhIXNvdXJjZU9iaiAmJiB0eXBlb2Ygc291cmNlT2JqLmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHNvdXJjZU9iai5yZW1vdmVFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nO1xufVxuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBGcm9tRXZlbnRPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRnJvbUV2ZW50T2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGcm9tRXZlbnRPYnNlcnZhYmxlKHNvdXJjZU9iaiwgZXZlbnROYW1lLCBzZWxlY3Rvciwgb3B0aW9ucykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5zb3VyY2VPYmogPSBzb3VyY2VPYmo7XG4gICAgICAgIHRoaXMuZXZlbnROYW1lID0gZXZlbnROYW1lO1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIC8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgZXZlbnRzIG9mIGEgc3BlY2lmaWMgdHlwZSBjb21pbmcgZnJvbSB0aGVcbiAgICAgKiBnaXZlbiBldmVudCB0YXJnZXQuXG4gICAgICpcbiAgICAgKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+Q3JlYXRlcyBhbiBPYnNlcnZhYmxlIGZyb20gRE9NIGV2ZW50cywgb3IgTm9kZVxuICAgICAqIEV2ZW50RW1pdHRlciBldmVudHMgb3Igb3RoZXJzLjwvc3Bhbj5cbiAgICAgKlxuICAgICAqIDxpbWcgc3JjPVwiLi9pbWcvZnJvbUV2ZW50LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICAgICAqXG4gICAgICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIGJ5IGF0dGFjaGluZyBhbiBldmVudCBsaXN0ZW5lciB0byBhbiBcImV2ZW50IHRhcmdldFwiLFxuICAgICAqIHdoaWNoIG1heSBiZSBhbiBvYmplY3Qgd2l0aCBgYWRkRXZlbnRMaXN0ZW5lcmAgYW5kIGByZW1vdmVFdmVudExpc3RlbmVyYCxcbiAgICAgKiBhIE5vZGUuanMgRXZlbnRFbWl0dGVyLCBhIGpRdWVyeSBzdHlsZSBFdmVudEVtaXR0ZXIsIGEgTm9kZUxpc3QgZnJvbSB0aGVcbiAgICAgKiBET00sIG9yIGFuIEhUTUxDb2xsZWN0aW9uIGZyb20gdGhlIERPTS4gVGhlIGV2ZW50IGhhbmRsZXIgaXMgYXR0YWNoZWQgd2hlblxuICAgICAqIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBpcyBzdWJzY3JpYmVkLCBhbmQgcmVtb3ZlZCB3aGVuIHRoZSBTdWJzY3JpcHRpb24gaXNcbiAgICAgKiB1bnN1YnNjcmliZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0cyBjbGlja3MgaGFwcGVuaW5nIG9uIHRoZSBET00gZG9jdW1lbnQ8L2NhcHRpb24+XG4gICAgICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAgICAgKiBjbGlja3Muc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICAgICAqXG4gICAgICogLy8gUmVzdWx0cyBpbjpcbiAgICAgKiAvLyBNb3VzZUV2ZW50IG9iamVjdCBsb2dnZWQgdG8gY29uc29sZSBldmVyeXRpbWUgYSBjbGlja1xuICAgICAqIC8vIG9jY3VycyBvbiB0aGUgZG9jdW1lbnQuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBmcm9tfVxuICAgICAqIEBzZWUge0BsaW5rIGZyb21FdmVudFBhdHRlcm59XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0TGlrZX0gdGFyZ2V0IFRoZSBET01FbGVtZW50LCBldmVudCB0YXJnZXQsIE5vZGUuanNcbiAgICAgKiBFdmVudEVtaXR0ZXIsIE5vZGVMaXN0IG9yIEhUTUxDb2xsZWN0aW9uIHRvIGF0dGFjaCB0aGUgZXZlbnQgaGFuZGxlciB0by5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBldmVudCBuYW1lIG9mIGludGVyZXN0LCBiZWluZyBlbWl0dGVkIGJ5IHRoZVxuICAgICAqIGB0YXJnZXRgLlxuICAgICAqIEBwYXJhbSB7RXZlbnRMaXN0ZW5lck9wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zIHRvIHBhc3MgdGhyb3VnaCB0byBhZGRFdmVudExpc3RlbmVyXG4gICAgICogQHBhcmFtIHtTZWxlY3Rvck1ldGhvZFNpZ25hdHVyZTxUPn0gW3NlbGVjdG9yXSBBbiBvcHRpb25hbCBmdW5jdGlvbiB0b1xuICAgICAqIHBvc3QtcHJvY2VzcyByZXN1bHRzLiBJdCB0YWtlcyB0aGUgYXJndW1lbnRzIGZyb20gdGhlIGV2ZW50IGhhbmRsZXIgYW5kXG4gICAgICogc2hvdWxkIHJldHVybiBhIHNpbmdsZSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fVxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBuYW1lIGZyb21FdmVudFxuICAgICAqIEBvd25lciBPYnNlcnZhYmxlXG4gICAgICovXG4gICAgRnJvbUV2ZW50T2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAodGFyZ2V0LCBldmVudE5hbWUsIG9wdGlvbnMsIHNlbGVjdG9yKSB7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uXzEuaXNGdW5jdGlvbihvcHRpb25zKSkge1xuICAgICAgICAgICAgc2VsZWN0b3IgPSBvcHRpb25zO1xuICAgICAgICAgICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEZyb21FdmVudE9ic2VydmFibGUodGFyZ2V0LCBldmVudE5hbWUsIHNlbGVjdG9yLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIEZyb21FdmVudE9ic2VydmFibGUuc2V0dXBTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAoc291cmNlT2JqLCBldmVudE5hbWUsIGhhbmRsZXIsIHN1YnNjcmliZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHVuc3Vic2NyaWJlO1xuICAgICAgICBpZiAoaXNOb2RlTGlzdChzb3VyY2VPYmopIHx8IGlzSFRNTENvbGxlY3Rpb24oc291cmNlT2JqKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNvdXJjZU9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIEZyb21FdmVudE9ic2VydmFibGUuc2V0dXBTdWJzY3JpcHRpb24oc291cmNlT2JqW2ldLCBldmVudE5hbWUsIGhhbmRsZXIsIHN1YnNjcmliZXIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRXZlbnRUYXJnZXQoc291cmNlT2JqKSkge1xuICAgICAgICAgICAgdmFyIHNvdXJjZV8xID0gc291cmNlT2JqO1xuICAgICAgICAgICAgc291cmNlT2JqLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gc291cmNlXzEucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpOyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzSlF1ZXJ5U3R5bGVFdmVudEVtaXR0ZXIoc291cmNlT2JqKSkge1xuICAgICAgICAgICAgdmFyIHNvdXJjZV8yID0gc291cmNlT2JqO1xuICAgICAgICAgICAgc291cmNlT2JqLm9uKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNvdXJjZV8yLm9mZihldmVudE5hbWUsIGhhbmRsZXIpOyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzTm9kZVN0eWxlRXZlbnRFbWl0dGVyKHNvdXJjZU9iaikpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2VfMyA9IHNvdXJjZU9iajtcbiAgICAgICAgICAgIHNvdXJjZU9iai5hZGRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBzb3VyY2VfMy5yZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpOyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBldmVudCB0YXJnZXQnKTtcbiAgICAgICAgfVxuICAgICAgICBzdWJzY3JpYmVyLmFkZChuZXcgU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKHVuc3Vic2NyaWJlKSk7XG4gICAgfTtcbiAgICBGcm9tRXZlbnRPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIHNvdXJjZU9iaiA9IHRoaXMuc291cmNlT2JqO1xuICAgICAgICB2YXIgZXZlbnROYW1lID0gdGhpcy5ldmVudE5hbWU7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yO1xuICAgICAgICB2YXIgaGFuZGxlciA9IHNlbGVjdG9yID8gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKHNlbGVjdG9yKS5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IoZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IDogZnVuY3Rpb24gKGUpIHsgcmV0dXJuIHN1YnNjcmliZXIubmV4dChlKTsgfTtcbiAgICAgICAgRnJvbUV2ZW50T2JzZXJ2YWJsZS5zZXR1cFN1YnNjcmlwdGlvbihzb3VyY2VPYmosIGV2ZW50TmFtZSwgaGFuZGxlciwgc3Vic2NyaWJlciwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICByZXR1cm4gRnJvbUV2ZW50T2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuRnJvbUV2ZW50T2JzZXJ2YWJsZSA9IEZyb21FdmVudE9ic2VydmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Gcm9tRXZlbnRPYnNlcnZhYmxlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29ic2VydmFibGUvRnJvbUV2ZW50T2JzZXJ2YWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgaXNGdW5jdGlvbl8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc0Z1bmN0aW9uJyk7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaXB0aW9uJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIEZyb21FdmVudFBhdHRlcm5PYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRnJvbUV2ZW50UGF0dGVybk9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRnJvbUV2ZW50UGF0dGVybk9ic2VydmFibGUoYWRkSGFuZGxlciwgcmVtb3ZlSGFuZGxlciwgc2VsZWN0b3IpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuYWRkSGFuZGxlciA9IGFkZEhhbmRsZXI7XG4gICAgICAgIHRoaXMucmVtb3ZlSGFuZGxlciA9IHJlbW92ZUhhbmRsZXI7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIGZyb20gYW4gQVBJIGJhc2VkIG9uIGFkZEhhbmRsZXIvcmVtb3ZlSGFuZGxlclxuICAgICAqIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5Db252ZXJ0cyBhbnkgYWRkSGFuZGxlci9yZW1vdmVIYW5kbGVyIEFQSSB0byBhblxuICAgICAqIE9ic2VydmFibGUuPC9zcGFuPlxuICAgICAqXG4gICAgICogPGltZyBzcmM9XCIuL2ltZy9mcm9tRXZlbnRQYXR0ZXJuLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICAgICAqXG4gICAgICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIGJ5IHVzaW5nIHRoZSBgYWRkSGFuZGxlcmAgYW5kIGByZW1vdmVIYW5kbGVyYFxuICAgICAqIGZ1bmN0aW9ucyB0byBhZGQgYW5kIHJlbW92ZSB0aGUgaGFuZGxlcnMsIHdpdGggYW4gb3B0aW9uYWwgc2VsZWN0b3JcbiAgICAgKiBmdW5jdGlvbiB0byBwcm9qZWN0IHRoZSBldmVudCBhcmd1bWVudHMgdG8gYSByZXN1bHQuIFRoZSBgYWRkSGFuZGxlcmAgaXNcbiAgICAgKiBjYWxsZWQgd2hlbiB0aGUgb3V0cHV0IE9ic2VydmFibGUgaXMgc3Vic2NyaWJlZCwgYW5kIGByZW1vdmVIYW5kbGVyYCBpc1xuICAgICAqIGNhbGxlZCB3aGVuIHRoZSBTdWJzY3JpcHRpb24gaXMgdW5zdWJzY3JpYmVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdHMgY2xpY2tzIGhhcHBlbmluZyBvbiB0aGUgRE9NIGRvY3VtZW50PC9jYXB0aW9uPlxuICAgICAqIGZ1bmN0aW9uIGFkZENsaWNrSGFuZGxlcihoYW5kbGVyKSB7XG4gICAgICogICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZXIpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHJlbW92ZUNsaWNrSGFuZGxlcihoYW5kbGVyKSB7XG4gICAgICogICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZXIpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudFBhdHRlcm4oXG4gICAgICogICBhZGRDbGlja0hhbmRsZXIsXG4gICAgICogICByZW1vdmVDbGlja0hhbmRsZXJcbiAgICAgKiApO1xuICAgICAqIGNsaWNrcy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBmcm9tfVxuICAgICAqIEBzZWUge0BsaW5rIGZyb21FdmVudH1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oaGFuZGxlcjogRnVuY3Rpb24pOiBhbnl9IGFkZEhhbmRsZXIgQSBmdW5jdGlvbiB0aGF0IHRha2VzXG4gICAgICogYSBgaGFuZGxlcmAgZnVuY3Rpb24gYXMgYXJndW1lbnQgYW5kIGF0dGFjaGVzIGl0IHNvbWVob3cgdG8gdGhlIGFjdHVhbFxuICAgICAqIHNvdXJjZSBvZiBldmVudHMuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihoYW5kbGVyOiBGdW5jdGlvbiwgc2lnbmFsPzogYW55KTogdm9pZH0gW3JlbW92ZUhhbmRsZXJdIEFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRoYXRcbiAgICAgKiB0YWtlcyBhIGBoYW5kbGVyYCBmdW5jdGlvbiBhcyBhcmd1bWVudCBhbmQgcmVtb3ZlcyBpdCBpbiBjYXNlIGl0IHdhc1xuICAgICAqIHByZXZpb3VzbHkgYXR0YWNoZWQgdXNpbmcgYGFkZEhhbmRsZXJgLiBpZiBhZGRIYW5kbGVyIHJldHVybnMgc2lnbmFsIHRvIHRlYXJkb3duIHdoZW4gcmVtb3ZlLFxuICAgICAqIHJlbW92ZUhhbmRsZXIgZnVuY3Rpb24gd2lsbCBmb3J3YXJkIGl0LlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oLi4uYXJnczogYW55KTogVH0gW3NlbGVjdG9yXSBBbiBvcHRpb25hbCBmdW5jdGlvbiB0b1xuICAgICAqIHBvc3QtcHJvY2VzcyByZXN1bHRzLiBJdCB0YWtlcyB0aGUgYXJndW1lbnRzIGZyb20gdGhlIGV2ZW50IGhhbmRsZXIgYW5kXG4gICAgICogc2hvdWxkIHJldHVybiBhIHNpbmdsZSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fVxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBuYW1lIGZyb21FdmVudFBhdHRlcm5cbiAgICAgKiBAb3duZXIgT2JzZXJ2YWJsZVxuICAgICAqL1xuICAgIEZyb21FdmVudFBhdHRlcm5PYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChhZGRIYW5kbGVyLCByZW1vdmVIYW5kbGVyLCBzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gbmV3IEZyb21FdmVudFBhdHRlcm5PYnNlcnZhYmxlKGFkZEhhbmRsZXIsIHJlbW92ZUhhbmRsZXIsIHNlbGVjdG9yKTtcbiAgICB9O1xuICAgIEZyb21FdmVudFBhdHRlcm5PYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHJlbW92ZUhhbmRsZXIgPSB0aGlzLnJlbW92ZUhhbmRsZXI7XG4gICAgICAgIHZhciBoYW5kbGVyID0gISF0aGlzLnNlbGVjdG9yID8gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLl9jYWxsU2VsZWN0b3Ioc3Vic2NyaWJlciwgYXJncyk7XG4gICAgICAgIH0gOiBmdW5jdGlvbiAoZSkgeyBzdWJzY3JpYmVyLm5leHQoZSk7IH07XG4gICAgICAgIHZhciByZXRWYWx1ZSA9IHRoaXMuX2NhbGxBZGRIYW5kbGVyKGhhbmRsZXIsIHN1YnNjcmliZXIpO1xuICAgICAgICBpZiAoIWlzRnVuY3Rpb25fMS5pc0Z1bmN0aW9uKHJlbW92ZUhhbmRsZXIpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3Vic2NyaWJlci5hZGQobmV3IFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvL1RPRE86IGRldGVybWluZSB3aGV0aGVyIG9yIG5vdCB0byBmb3J3YXJkIHRvIGVycm9yIGhhbmRsZXJcbiAgICAgICAgICAgIHJlbW92ZUhhbmRsZXIoaGFuZGxlciwgcmV0VmFsdWUpO1xuICAgICAgICB9KSk7XG4gICAgfTtcbiAgICBGcm9tRXZlbnRQYXR0ZXJuT2JzZXJ2YWJsZS5wcm90b3R5cGUuX2NhbGxTZWxlY3RvciA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBhcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5zZWxlY3Rvci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBGcm9tRXZlbnRQYXR0ZXJuT2JzZXJ2YWJsZS5wcm90b3R5cGUuX2NhbGxBZGRIYW5kbGVyID0gZnVuY3Rpb24gKGhhbmRsZXIsIGVycm9yU3Vic2NyaWJlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkSGFuZGxlcihoYW5kbGVyKSB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBlcnJvclN1YnNjcmliZXIuZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBGcm9tRXZlbnRQYXR0ZXJuT2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuRnJvbUV2ZW50UGF0dGVybk9ic2VydmFibGUgPSBGcm9tRXZlbnRQYXR0ZXJuT2JzZXJ2YWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZyb21FdmVudFBhdHRlcm5PYnNlcnZhYmxlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29ic2VydmFibGUvRnJvbUV2ZW50UGF0dGVybk9ic2VydmFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDIxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciBpc1NjaGVkdWxlcl8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc1NjaGVkdWxlcicpO1xudmFyIHNlbGZTZWxlY3RvciA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIEdlbmVyYXRlT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdlbmVyYXRlT2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBHZW5lcmF0ZU9ic2VydmFibGUoaW5pdGlhbFN0YXRlLCBjb25kaXRpb24sIGl0ZXJhdGUsIHJlc3VsdFNlbGVjdG9yLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuaW5pdGlhbFN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcbiAgICAgICAgdGhpcy5pdGVyYXRlID0gaXRlcmF0ZTtcbiAgICAgICAgdGhpcy5yZXN1bHRTZWxlY3RvciA9IHJlc3VsdFNlbGVjdG9yO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgR2VuZXJhdGVPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChpbml0aWFsU3RhdGVPck9wdGlvbnMsIGNvbmRpdGlvbiwgaXRlcmF0ZSwgcmVzdWx0U2VsZWN0b3JPck9ic2VydmFibGUsIHNjaGVkdWxlcikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEdlbmVyYXRlT2JzZXJ2YWJsZShpbml0aWFsU3RhdGVPck9wdGlvbnMuaW5pdGlhbFN0YXRlLCBpbml0aWFsU3RhdGVPck9wdGlvbnMuY29uZGl0aW9uLCBpbml0aWFsU3RhdGVPck9wdGlvbnMuaXRlcmF0ZSwgaW5pdGlhbFN0YXRlT3JPcHRpb25zLnJlc3VsdFNlbGVjdG9yIHx8IHNlbGZTZWxlY3RvciwgaW5pdGlhbFN0YXRlT3JPcHRpb25zLnNjaGVkdWxlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdFNlbGVjdG9yT3JPYnNlcnZhYmxlID09PSB1bmRlZmluZWQgfHwgaXNTY2hlZHVsZXJfMS5pc1NjaGVkdWxlcihyZXN1bHRTZWxlY3Rvck9yT2JzZXJ2YWJsZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgR2VuZXJhdGVPYnNlcnZhYmxlKGluaXRpYWxTdGF0ZU9yT3B0aW9ucywgY29uZGl0aW9uLCBpdGVyYXRlLCBzZWxmU2VsZWN0b3IsIHJlc3VsdFNlbGVjdG9yT3JPYnNlcnZhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEdlbmVyYXRlT2JzZXJ2YWJsZShpbml0aWFsU3RhdGVPck9wdGlvbnMsIGNvbmRpdGlvbiwgaXRlcmF0ZSwgcmVzdWx0U2VsZWN0b3JPck9ic2VydmFibGUsIHNjaGVkdWxlcik7XG4gICAgfTtcbiAgICBHZW5lcmF0ZU9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmluaXRpYWxTdGF0ZTtcbiAgICAgICAgaWYgKHRoaXMuc2NoZWR1bGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY2hlZHVsZXIuc2NoZWR1bGUoR2VuZXJhdGVPYnNlcnZhYmxlLmRpc3BhdGNoLCAwLCB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlcjogc3Vic2NyaWJlcixcbiAgICAgICAgICAgICAgICBpdGVyYXRlOiB0aGlzLml0ZXJhdGUsXG4gICAgICAgICAgICAgICAgY29uZGl0aW9uOiB0aGlzLmNvbmRpdGlvbixcbiAgICAgICAgICAgICAgICByZXN1bHRTZWxlY3RvcjogdGhpcy5yZXN1bHRTZWxlY3RvcixcbiAgICAgICAgICAgICAgICBzdGF0ZTogc3RhdGUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hID0gdGhpcywgY29uZGl0aW9uID0gX2EuY29uZGl0aW9uLCByZXN1bHRTZWxlY3RvciA9IF9hLnJlc3VsdFNlbGVjdG9yLCBpdGVyYXRlID0gX2EuaXRlcmF0ZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBjb25kaXRpb25SZXN1bHQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uUmVzdWx0ID0gY29uZGl0aW9uKHN0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFjb25kaXRpb25SZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB2b2lkIDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0U2VsZWN0b3Ioc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQodmFsdWUpO1xuICAgICAgICAgICAgaWYgKHN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHN0YXRlID0gaXRlcmF0ZShzdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XG4gICAgfTtcbiAgICBHZW5lcmF0ZU9ic2VydmFibGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIHN1YnNjcmliZXIgPSBzdGF0ZS5zdWJzY3JpYmVyLCBjb25kaXRpb24gPSBzdGF0ZS5jb25kaXRpb247XG4gICAgICAgIGlmIChzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5uZWVkSXRlcmF0ZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5zdGF0ZSA9IHN0YXRlLml0ZXJhdGUoc3RhdGUuc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5uZWVkSXRlcmF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgICAgICAgdmFyIGNvbmRpdGlvblJlc3VsdCA9IHZvaWQgMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uZGl0aW9uUmVzdWx0ID0gY29uZGl0aW9uKHN0YXRlLnN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjb25kaXRpb25SZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbHVlID0gc3RhdGUucmVzdWx0U2VsZWN0b3Ioc3RhdGUuc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdWJzY3JpYmVyLm5leHQodmFsdWUpO1xuICAgICAgICBpZiAoc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zY2hlZHVsZShzdGF0ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gR2VuZXJhdGVPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5HZW5lcmF0ZU9ic2VydmFibGUgPSBHZW5lcmF0ZU9ic2VydmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HZW5lcmF0ZU9ic2VydmFibGUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb2JzZXJ2YWJsZS9HZW5lcmF0ZU9ic2VydmFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDIxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIElmT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKElmT2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJZk9ic2VydmFibGUoY29uZGl0aW9uLCB0aGVuU291cmNlLCBlbHNlU291cmNlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcbiAgICAgICAgdGhpcy50aGVuU291cmNlID0gdGhlblNvdXJjZTtcbiAgICAgICAgdGhpcy5lbHNlU291cmNlID0gZWxzZVNvdXJjZTtcbiAgICB9XG4gICAgSWZPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChjb25kaXRpb24sIHRoZW5Tb3VyY2UsIGVsc2VTb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJZk9ic2VydmFibGUoY29uZGl0aW9uLCB0aGVuU291cmNlLCBlbHNlU291cmNlKTtcbiAgICB9O1xuICAgIElmT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGNvbmRpdGlvbiA9IF9hLmNvbmRpdGlvbiwgdGhlblNvdXJjZSA9IF9hLnRoZW5Tb3VyY2UsIGVsc2VTb3VyY2UgPSBfYS5lbHNlU291cmNlO1xuICAgICAgICByZXR1cm4gbmV3IElmU3Vic2NyaWJlcihzdWJzY3JpYmVyLCBjb25kaXRpb24sIHRoZW5Tb3VyY2UsIGVsc2VTb3VyY2UpO1xuICAgIH07XG4gICAgcmV0dXJuIElmT2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuSWZPYnNlcnZhYmxlID0gSWZPYnNlcnZhYmxlO1xudmFyIElmU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKElmU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJZlN1YnNjcmliZXIoZGVzdGluYXRpb24sIGNvbmRpdGlvbiwgdGhlblNvdXJjZSwgZWxzZVNvdXJjZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgICAgICB0aGlzLnRoZW5Tb3VyY2UgPSB0aGVuU291cmNlO1xuICAgICAgICB0aGlzLmVsc2VTb3VyY2UgPSBlbHNlU291cmNlO1xuICAgICAgICB0aGlzLnRyeUlmKCk7XG4gICAgfVxuICAgIElmU3Vic2NyaWJlci5wcm90b3R5cGUudHJ5SWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGNvbmRpdGlvbiA9IF9hLmNvbmRpdGlvbiwgdGhlblNvdXJjZSA9IF9hLnRoZW5Tb3VyY2UsIGVsc2VTb3VyY2UgPSBfYS5lbHNlU291cmNlO1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gY29uZGl0aW9uKCk7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gcmVzdWx0ID8gdGhlblNvdXJjZSA6IGVsc2VTb3VyY2U7XG4gICAgICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBzb3VyY2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbXBsZXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5fZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIElmU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JZk9ic2VydmFibGUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb2JzZXJ2YWJsZS9JZk9ic2VydmFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDIxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGlzTnVtZXJpY18xID0gcmVxdWlyZSgnLi4vdXRpbC9pc051bWVyaWMnKTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJy4uL3NjaGVkdWxlci9hc3luYycpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBJbnRlcnZhbE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbnRlcnZhbE9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW50ZXJ2YWxPYnNlcnZhYmxlKHBlcmlvZCwgc2NoZWR1bGVyKSB7XG4gICAgICAgIGlmIChwZXJpb2QgPT09IHZvaWQgMCkgeyBwZXJpb2QgPSAwOyB9XG4gICAgICAgIGlmIChzY2hlZHVsZXIgPT09IHZvaWQgMCkgeyBzY2hlZHVsZXIgPSBhc3luY18xLmFzeW5jOyB9XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnBlcmlvZCA9IHBlcmlvZDtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIGlmICghaXNOdW1lcmljXzEuaXNOdW1lcmljKHBlcmlvZCkgfHwgcGVyaW9kIDwgMCkge1xuICAgICAgICAgICAgdGhpcy5wZXJpb2QgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2NoZWR1bGVyIHx8IHR5cGVvZiBzY2hlZHVsZXIuc2NoZWR1bGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVyID0gYXN5bmNfMS5hc3luYztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBzZXF1ZW50aWFsIG51bWJlcnMgZXZlcnkgc3BlY2lmaWVkXG4gICAgICogaW50ZXJ2YWwgb2YgdGltZSwgb24gYSBzcGVjaWZpZWQgSVNjaGVkdWxlci5cbiAgICAgKlxuICAgICAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5FbWl0cyBpbmNyZW1lbnRhbCBudW1iZXJzIHBlcmlvZGljYWxseSBpbiB0aW1lLlxuICAgICAqIDwvc3Bhbj5cbiAgICAgKlxuICAgICAqIDxpbWcgc3JjPVwiLi9pbWcvaW50ZXJ2YWwucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gICAgICpcbiAgICAgKiBgaW50ZXJ2YWxgIHJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGFuIGluZmluaXRlIHNlcXVlbmNlIG9mXG4gICAgICogYXNjZW5kaW5nIGludGVnZXJzLCB3aXRoIGEgY29uc3RhbnQgaW50ZXJ2YWwgb2YgdGltZSBvZiB5b3VyIGNob29zaW5nXG4gICAgICogYmV0d2VlbiB0aG9zZSBlbWlzc2lvbnMuIFRoZSBmaXJzdCBlbWlzc2lvbiBpcyBub3Qgc2VudCBpbW1lZGlhdGVseSwgYnV0XG4gICAgICogb25seSBhZnRlciB0aGUgZmlyc3QgcGVyaW9kIGhhcyBwYXNzZWQuIEJ5IGRlZmF1bHQsIHRoaXMgb3BlcmF0b3IgdXNlcyB0aGVcbiAgICAgKiBgYXN5bmNgIElTY2hlZHVsZXIgdG8gcHJvdmlkZSBhIG5vdGlvbiBvZiB0aW1lLCBidXQgeW91IG1heSBwYXNzIGFueVxuICAgICAqIElTY2hlZHVsZXIgdG8gaXQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0cyBhc2NlbmRpbmcgbnVtYmVycywgb25lIGV2ZXJ5IHNlY29uZCAoMTAwMG1zKTwvY2FwdGlvbj5cbiAgICAgKiB2YXIgbnVtYmVycyA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gICAgICogbnVtYmVycy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayB0aW1lcn1cbiAgICAgKiBAc2VlIHtAbGluayBkZWxheX1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGVyaW9kPTBdIFRoZSBpbnRlcnZhbCBzaXplIGluIG1pbGxpc2Vjb25kcyAoYnkgZGVmYXVsdClcbiAgICAgKiBvciB0aGUgdGltZSB1bml0IGRldGVybWluZWQgYnkgdGhlIHNjaGVkdWxlcidzIGNsb2NrLlxuICAgICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyPWFzeW5jXSBUaGUgSVNjaGVkdWxlciB0byB1c2UgZm9yIHNjaGVkdWxpbmdcbiAgICAgKiB0aGUgZW1pc3Npb24gb2YgdmFsdWVzLCBhbmQgcHJvdmlkaW5nIGEgbm90aW9uIG9mIFwidGltZVwiLlxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBhIHNlcXVlbnRpYWwgbnVtYmVyIGVhY2ggdGltZVxuICAgICAqIGludGVydmFsLlxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBuYW1lIGludGVydmFsXG4gICAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICAgKi9cbiAgICBJbnRlcnZhbE9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKHBlcmlvZCwgc2NoZWR1bGVyKSB7XG4gICAgICAgIGlmIChwZXJpb2QgPT09IHZvaWQgMCkgeyBwZXJpb2QgPSAwOyB9XG4gICAgICAgIGlmIChzY2hlZHVsZXIgPT09IHZvaWQgMCkgeyBzY2hlZHVsZXIgPSBhc3luY18xLmFzeW5jOyB9XG4gICAgICAgIHJldHVybiBuZXcgSW50ZXJ2YWxPYnNlcnZhYmxlKHBlcmlvZCwgc2NoZWR1bGVyKTtcbiAgICB9O1xuICAgIEludGVydmFsT2JzZXJ2YWJsZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgaW5kZXggPSBzdGF0ZS5pbmRleCwgc3Vic2NyaWJlciA9IHN0YXRlLnN1YnNjcmliZXIsIHBlcmlvZCA9IHN0YXRlLnBlcmlvZDtcbiAgICAgICAgc3Vic2NyaWJlci5uZXh0KGluZGV4KTtcbiAgICAgICAgaWYgKHN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuaW5kZXggKz0gMTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZShzdGF0ZSwgcGVyaW9kKTtcbiAgICB9O1xuICAgIEludGVydmFsT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHZhciBwZXJpb2QgPSB0aGlzLnBlcmlvZDtcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICBzdWJzY3JpYmVyLmFkZChzY2hlZHVsZXIuc2NoZWR1bGUoSW50ZXJ2YWxPYnNlcnZhYmxlLmRpc3BhdGNoLCBwZXJpb2QsIHtcbiAgICAgICAgICAgIGluZGV4OiBpbmRleCwgc3Vic2NyaWJlcjogc3Vic2NyaWJlciwgcGVyaW9kOiBwZXJpb2RcbiAgICAgICAgfSkpO1xuICAgIH07XG4gICAgcmV0dXJuIEludGVydmFsT2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuSW50ZXJ2YWxPYnNlcnZhYmxlID0gSW50ZXJ2YWxPYnNlcnZhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW50ZXJ2YWxPYnNlcnZhYmxlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29ic2VydmFibGUvSW50ZXJ2YWxPYnNlcnZhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciByb290XzEgPSByZXF1aXJlKCcuLi91dGlsL3Jvb3QnKTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG52YXIgaXRlcmF0b3JfMSA9IHJlcXVpcmUoJy4uL3N5bWJvbC9pdGVyYXRvcicpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBJdGVyYXRvck9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJdGVyYXRvck9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSXRlcmF0b3JPYnNlcnZhYmxlKGl0ZXJhdG9yLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICBpZiAoaXRlcmF0b3IgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpdGVyYXRvciBjYW5ub3QgYmUgbnVsbC4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLml0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoaXRlcmF0b3IpO1xuICAgIH1cbiAgICBJdGVyYXRvck9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvck9ic2VydmFibGUoaXRlcmF0b3IsIHNjaGVkdWxlcik7XG4gICAgfTtcbiAgICBJdGVyYXRvck9ic2VydmFibGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXgsIGhhc0Vycm9yID0gc3RhdGUuaGFzRXJyb3IsIGl0ZXJhdG9yID0gc3RhdGUuaXRlcmF0b3IsIHN1YnNjcmliZXIgPSBzdGF0ZS5zdWJzY3JpYmVyO1xuICAgICAgICBpZiAoaGFzRXJyb3IpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3Ioc3RhdGUuZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN1YnNjcmliZXIubmV4dChyZXN1bHQudmFsdWUpO1xuICAgICAgICBzdGF0ZS5pbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgaWYgKHN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yLnJldHVybiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2NoZWR1bGUoc3RhdGUpO1xuICAgIH07XG4gICAgSXRlcmF0b3JPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgaXRlcmF0b3IgPSBfYS5pdGVyYXRvciwgc2NoZWR1bGVyID0gX2Euc2NoZWR1bGVyO1xuICAgICAgICBpZiAoc2NoZWR1bGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlKEl0ZXJhdG9yT2JzZXJ2YWJsZS5kaXNwYXRjaCwgMCwge1xuICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCwgaXRlcmF0b3I6IGl0ZXJhdG9yLCBzdWJzY3JpYmVyOiBzdWJzY3JpYmVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yLnJldHVybiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBJdGVyYXRvck9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLkl0ZXJhdG9yT2JzZXJ2YWJsZSA9IEl0ZXJhdG9yT2JzZXJ2YWJsZTtcbnZhciBTdHJpbmdJdGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RyaW5nSXRlcmF0b3Ioc3RyLCBpZHgsIGxlbikge1xuICAgICAgICBpZiAoaWR4ID09PSB2b2lkIDApIHsgaWR4ID0gMDsgfVxuICAgICAgICBpZiAobGVuID09PSB2b2lkIDApIHsgbGVuID0gc3RyLmxlbmd0aDsgfVxuICAgICAgICB0aGlzLnN0ciA9IHN0cjtcbiAgICAgICAgdGhpcy5pZHggPSBpZHg7XG4gICAgICAgIHRoaXMubGVuID0gbGVuO1xuICAgIH1cbiAgICBTdHJpbmdJdGVyYXRvci5wcm90b3R5cGVbaXRlcmF0b3JfMS4kJGl0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzKTsgfTtcbiAgICBTdHJpbmdJdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWR4IDwgdGhpcy5sZW4gPyB7XG4gICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnN0ci5jaGFyQXQodGhpcy5pZHgrKylcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gU3RyaW5nSXRlcmF0b3I7XG59KCkpO1xudmFyIEFycmF5SXRlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFycmF5SXRlcmF0b3IoYXJyLCBpZHgsIGxlbikge1xuICAgICAgICBpZiAoaWR4ID09PSB2b2lkIDApIHsgaWR4ID0gMDsgfVxuICAgICAgICBpZiAobGVuID09PSB2b2lkIDApIHsgbGVuID0gdG9MZW5ndGgoYXJyKTsgfVxuICAgICAgICB0aGlzLmFyciA9IGFycjtcbiAgICAgICAgdGhpcy5pZHggPSBpZHg7XG4gICAgICAgIHRoaXMubGVuID0gbGVuO1xuICAgIH1cbiAgICBBcnJheUl0ZXJhdG9yLnByb3RvdHlwZVtpdGVyYXRvcl8xLiQkaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcbiAgICBBcnJheUl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZHggPCB0aGlzLmxlbiA/IHtcbiAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMuYXJyW3RoaXMuaWR4KytdXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIEFycmF5SXRlcmF0b3I7XG59KCkpO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3Iob2JqKSB7XG4gICAgdmFyIGkgPSBvYmpbaXRlcmF0b3JfMS4kJGl0ZXJhdG9yXTtcbiAgICBpZiAoIWkgJiYgdHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmdJdGVyYXRvcihvYmopO1xuICAgIH1cbiAgICBpZiAoIWkgJiYgb2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXJyYXlJdGVyYXRvcihvYmopO1xuICAgIH1cbiAgICBpZiAoIWkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb2JqZWN0IGlzIG5vdCBpdGVyYWJsZScpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqW2l0ZXJhdG9yXzEuJCRpdGVyYXRvcl0oKTtcbn1cbnZhciBtYXhTYWZlSW50ZWdlciA9IE1hdGgucG93KDIsIDUzKSAtIDE7XG5mdW5jdGlvbiB0b0xlbmd0aChvKSB7XG4gICAgdmFyIGxlbiA9ICtvLmxlbmd0aDtcbiAgICBpZiAoaXNOYU4obGVuKSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYgKGxlbiA9PT0gMCB8fCAhbnVtYmVySXNGaW5pdGUobGVuKSkge1xuICAgICAgICByZXR1cm4gbGVuO1xuICAgIH1cbiAgICBsZW4gPSBzaWduKGxlbikgKiBNYXRoLmZsb29yKE1hdGguYWJzKGxlbikpO1xuICAgIGlmIChsZW4gPD0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYgKGxlbiA+IG1heFNhZmVJbnRlZ2VyKSB7XG4gICAgICAgIHJldHVybiBtYXhTYWZlSW50ZWdlcjtcbiAgICB9XG4gICAgcmV0dXJuIGxlbjtcbn1cbmZ1bmN0aW9uIG51bWJlcklzRmluaXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgcm9vdF8xLnJvb3QuaXNGaW5pdGUodmFsdWUpO1xufVxuZnVuY3Rpb24gc2lnbih2YWx1ZSkge1xuICAgIHZhciB2YWx1ZUFzTnVtYmVyID0gK3ZhbHVlO1xuICAgIGlmICh2YWx1ZUFzTnVtYmVyID09PSAwKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZUFzTnVtYmVyO1xuICAgIH1cbiAgICBpZiAoaXNOYU4odmFsdWVBc051bWJlcikpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlQXNOdW1iZXI7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZUFzTnVtYmVyIDwgMCA/IC0xIDogMTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUl0ZXJhdG9yT2JzZXJ2YWJsZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vYnNlcnZhYmxlL0l0ZXJhdG9yT2JzZXJ2YWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIG5vb3BfMSA9IHJlcXVpcmUoJy4uL3V0aWwvbm9vcCcpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBOZXZlck9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOZXZlck9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTmV2ZXJPYnNlcnZhYmxlKCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgbm8gaXRlbXMgdG8gdGhlIE9ic2VydmVyLlxuICAgICAqXG4gICAgICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkFuIE9ic2VydmFibGUgdGhhdCBuZXZlciBlbWl0cyBhbnl0aGluZy48L3NwYW4+XG4gICAgICpcbiAgICAgKiA8aW1nIHNyYz1cIi4vaW1nL25ldmVyLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICAgICAqXG4gICAgICogVGhpcyBzdGF0aWMgb3BlcmF0b3IgaXMgdXNlZnVsIGZvciBjcmVhdGluZyBhIHNpbXBsZSBPYnNlcnZhYmxlIHRoYXQgZW1pdHNcbiAgICAgKiBuZWl0aGVyIHZhbHVlcyBub3IgZXJyb3JzIG5vciB0aGUgY29tcGxldGlvbiBub3RpZmljYXRpb24uIEl0IGNhbiBiZSB1c2VkXG4gICAgICogZm9yIHRlc3RpbmcgcHVycG9zZXMgb3IgZm9yIGNvbXBvc2luZyB3aXRoIG90aGVyIE9ic2VydmFibGVzLiBQbGVhc2Ugbm90XG4gICAgICogdGhhdCBieSBuZXZlciBlbWl0dGluZyBhIGNvbXBsZXRlIG5vdGlmaWNhdGlvbiwgdGhpcyBPYnNlcnZhYmxlIGtlZXBzIHRoZVxuICAgICAqIHN1YnNjcmlwdGlvbiBmcm9tIGJlaW5nIGRpc3Bvc2VkIGF1dG9tYXRpY2FsbHkuIFN1YnNjcmlwdGlvbnMgbmVlZCB0byBiZVxuICAgICAqIG1hbnVhbGx5IGRpc3Bvc2VkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdCB0aGUgbnVtYmVyIDcsIHRoZW4gbmV2ZXIgZW1pdCBhbnl0aGluZyBlbHNlIChub3QgZXZlbiBjb21wbGV0ZSkuPC9jYXB0aW9uPlxuICAgICAqIGZ1bmN0aW9uIGluZm8oKSB7XG4gICAgICogICBjb25zb2xlLmxvZygnV2lsbCBub3QgYmUgY2FsbGVkJyk7XG4gICAgICogfVxuICAgICAqIHZhciByZXN1bHQgPSBSeC5PYnNlcnZhYmxlLm5ldmVyKCkuc3RhcnRXaXRoKDcpO1xuICAgICAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSwgaW5mbywgaW5mbyk7XG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBjcmVhdGV9XG4gICAgICogQHNlZSB7QGxpbmsgZW1wdHl9XG4gICAgICogQHNlZSB7QGxpbmsgb2Z9XG4gICAgICogQHNlZSB7QGxpbmsgdGhyb3d9XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBIFwibmV2ZXJcIiBPYnNlcnZhYmxlOiBuZXZlciBlbWl0cyBhbnl0aGluZy5cbiAgICAgKiBAc3RhdGljIHRydWVcbiAgICAgKiBAbmFtZSBuZXZlclxuICAgICAqIEBvd25lciBPYnNlcnZhYmxlXG4gICAgICovXG4gICAgTmV2ZXJPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOZXZlck9ic2VydmFibGUoKTtcbiAgICB9O1xuICAgIE5ldmVyT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIG5vb3BfMS5ub29wKCk7XG4gICAgfTtcbiAgICByZXR1cm4gTmV2ZXJPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5OZXZlck9ic2VydmFibGUgPSBOZXZlck9ic2VydmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1OZXZlck9ic2VydmFibGUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb2JzZXJ2YWJsZS9OZXZlck9ic2VydmFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDIyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbmZ1bmN0aW9uIGRpc3BhdGNoKHN0YXRlKSB7XG4gICAgdmFyIG9iaiA9IHN0YXRlLm9iaiwga2V5cyA9IHN0YXRlLmtleXMsIGxlbmd0aCA9IHN0YXRlLmxlbmd0aCwgaW5kZXggPSBzdGF0ZS5pbmRleCwgc3Vic2NyaWJlciA9IHN0YXRlLnN1YnNjcmliZXI7XG4gICAgaWYgKGluZGV4ID09PSBsZW5ndGgpIHtcbiAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBrZXkgPSBrZXlzW2luZGV4XTtcbiAgICBzdWJzY3JpYmVyLm5leHQoW2tleSwgb2JqW2tleV1dKTtcbiAgICBzdGF0ZS5pbmRleCA9IGluZGV4ICsgMTtcbiAgICB0aGlzLnNjaGVkdWxlKHN0YXRlKTtcbn1cbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG52YXIgUGFpcnNPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGFpcnNPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBhaXJzT2JzZXJ2YWJsZShvYmosIHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5vYmogPSBvYmo7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLmtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGFuIG9iamVjdCBpbnRvIGFuIG9ic2VydmFibGUgc2VxdWVuY2Ugb2YgW2tleSwgdmFsdWVdIHBhaXJzXG4gICAgICogdXNpbmcgYW4gb3B0aW9uYWwgSVNjaGVkdWxlciB0byBlbnVtZXJhdGUgdGhlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkNvbnZlcnRzIGEgamF2YXNjcmlwdCBvYmplY3QgdG8gYW4gT2JzZXJ2YWJsZTwvY2FwdGlvbj5cbiAgICAgKiB2YXIgb2JqID0ge1xuICAgICAqICAgZm9vOiA0MixcbiAgICAgKiAgIGJhcjogNTYsXG4gICAgICogICBiYXo6IDc4XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBzb3VyY2UgPSBSeC5PYnNlcnZhYmxlLnBhaXJzKG9iaik7XG4gICAgICpcbiAgICAgKiB2YXIgc3Vic2NyaXB0aW9uID0gc291cmNlLnN1YnNjcmliZShcbiAgICAgKiAgIGZ1bmN0aW9uICh4KSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKCdOZXh0OiAlcycsIHgpO1xuICAgICAqICAgfSxcbiAgICAgKiAgIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coJ0Vycm9yOiAlcycsIGVycik7XG4gICAgICogICB9LFxuICAgICAqICAgZnVuY3Rpb24gKCkge1xuICAgICAqICAgICBjb25zb2xlLmxvZygnQ29tcGxldGVkJyk7XG4gICAgICogICB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBpbnNwZWN0IGFuZCB0dXJuIGludG8gYW5cbiAgICAgKiBPYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSBBbiBvcHRpb25hbCBJU2NoZWR1bGVyIHRvIHJ1biB0aGVcbiAgICAgKiBlbnVtZXJhdGlvbiBvZiB0aGUgaW5wdXQgc2VxdWVuY2Ugb24uXG4gICAgICogQHJldHVybnMgeyhPYnNlcnZhYmxlPEFycmF5PHN0cmluZyB8IFQ+Pil9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugb2ZcbiAgICAgKiBba2V5LCB2YWx1ZV0gcGFpcnMgZnJvbSB0aGUgb2JqZWN0LlxuICAgICAqL1xuICAgIFBhaXJzT2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAob2JqLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYWlyc09ic2VydmFibGUob2JqLCBzY2hlZHVsZXIpO1xuICAgIH07XG4gICAgUGFpcnNPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywga2V5cyA9IF9hLmtleXMsIHNjaGVkdWxlciA9IF9hLnNjaGVkdWxlcjtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgICAgICBpZiAoc2NoZWR1bGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoLCAwLCB7XG4gICAgICAgICAgICAgICAgb2JqOiB0aGlzLm9iaiwga2V5czoga2V5cywgbGVuZ3RoOiBsZW5ndGgsIGluZGV4OiAwLCBzdWJzY3JpYmVyOiBzdWJzY3JpYmVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpZHhdO1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChba2V5LCB0aGlzLm9ialtrZXldXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBQYWlyc09ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLlBhaXJzT2JzZXJ2YWJsZSA9IFBhaXJzT2JzZXJ2YWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBhaXJzT2JzZXJ2YWJsZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vYnNlcnZhYmxlL1BhaXJzT2JzZXJ2YWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBSYW5nZU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSYW5nZU9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmFuZ2VPYnNlcnZhYmxlKHN0YXJ0LCBjb3VudCwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuX2NvdW50ID0gY291bnQ7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBhIHNlcXVlbmNlIG9mIG51bWJlcnMgd2l0aGluIGEgc3BlY2lmaWVkXG4gICAgICogcmFuZ2UuXG4gICAgICpcbiAgICAgKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+RW1pdHMgYSBzZXF1ZW5jZSBvZiBudW1iZXJzIGluIGEgcmFuZ2UuPC9zcGFuPlxuICAgICAqXG4gICAgICogPGltZyBzcmM9XCIuL2ltZy9yYW5nZS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAgICAgKlxuICAgICAqIGByYW5nZWAgb3BlcmF0b3IgZW1pdHMgYSByYW5nZSBvZiBzZXF1ZW50aWFsIGludGVnZXJzLCBpbiBvcmRlciwgd2hlcmUgeW91XG4gICAgICogc2VsZWN0IHRoZSBgc3RhcnRgIG9mIHRoZSByYW5nZSBhbmQgaXRzIGBsZW5ndGhgLiBCeSBkZWZhdWx0LCB1c2VzIG5vXG4gICAgICogSVNjaGVkdWxlciBhbmQganVzdCBkZWxpdmVycyB0aGUgbm90aWZpY2F0aW9ucyBzeW5jaHJvbm91c2x5LCBidXQgbWF5IHVzZVxuICAgICAqIGFuIG9wdGlvbmFsIElTY2hlZHVsZXIgdG8gcmVndWxhdGUgdGhvc2UgZGVsaXZlcmllcy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXRzIHRoZSBudW1iZXJzIDEgdG8gMTA8L2NhcHRpb24+XG4gICAgICogdmFyIG51bWJlcnMgPSBSeC5PYnNlcnZhYmxlLnJhbmdlKDEsIDEwKTtcbiAgICAgKiBudW1iZXJzLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIHRpbWVyfVxuICAgICAqIEBzZWUge0BsaW5rIGludGVydmFsfVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgdmFsdWUgb2YgdGhlIGZpcnN0IGludGVnZXIgaW4gdGhlIHNlcXVlbmNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY291bnQ9MF0gVGhlIG51bWJlciBvZiBzZXF1ZW50aWFsIGludGVnZXJzIHRvIGdlbmVyYXRlLlxuICAgICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSBBIHtAbGluayBJU2NoZWR1bGVyfSB0byB1c2UgZm9yIHNjaGVkdWxpbmdcbiAgICAgKiB0aGUgZW1pc3Npb25zIG9mIHRoZSBub3RpZmljYXRpb25zLlxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgb2YgbnVtYmVycyB0aGF0IGVtaXRzIGEgZmluaXRlIHJhbmdlIG9mXG4gICAgICogc2VxdWVudGlhbCBpbnRlZ2Vycy5cbiAgICAgKiBAc3RhdGljIHRydWVcbiAgICAgKiBAbmFtZSByYW5nZVxuICAgICAqIEBvd25lciBPYnNlcnZhYmxlXG4gICAgICovXG4gICAgUmFuZ2VPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChzdGFydCwgY291bnQsIHNjaGVkdWxlcikge1xuICAgICAgICBpZiAoc3RhcnQgPT09IHZvaWQgMCkgeyBzdGFydCA9IDA7IH1cbiAgICAgICAgaWYgKGNvdW50ID09PSB2b2lkIDApIHsgY291bnQgPSAwOyB9XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2VPYnNlcnZhYmxlKHN0YXJ0LCBjb3VudCwgc2NoZWR1bGVyKTtcbiAgICB9O1xuICAgIFJhbmdlT2JzZXJ2YWJsZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgc3RhcnQgPSBzdGF0ZS5zdGFydCwgaW5kZXggPSBzdGF0ZS5pbmRleCwgY291bnQgPSBzdGF0ZS5jb3VudCwgc3Vic2NyaWJlciA9IHN0YXRlLnN1YnNjcmliZXI7XG4gICAgICAgIGlmIChpbmRleCA+PSBjb3VudCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN1YnNjcmliZXIubmV4dChzdGFydCk7XG4gICAgICAgIGlmIChzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmluZGV4ID0gaW5kZXggKyAxO1xuICAgICAgICBzdGF0ZS5zdGFydCA9IHN0YXJ0ICsgMTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZShzdGF0ZSk7XG4gICAgfTtcbiAgICBSYW5nZU9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgICAgICB2YXIgY291bnQgPSB0aGlzLl9jb3VudDtcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICBpZiAoc2NoZWR1bGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlKFJhbmdlT2JzZXJ2YWJsZS5kaXNwYXRjaCwgMCwge1xuICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCwgY291bnQ6IGNvdW50LCBzdGFydDogc3RhcnQsIHN1YnNjcmliZXI6IHN1YnNjcmliZXJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCsrID49IGNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChzdGFydCsrKTtcbiAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBSYW5nZU9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLlJhbmdlT2JzZXJ2YWJsZSA9IFJhbmdlT2JzZXJ2YWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJhbmdlT2JzZXJ2YWJsZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vYnNlcnZhYmxlL1JhbmdlT2JzZXJ2YWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIGFzYXBfMSA9IHJlcXVpcmUoJy4uL3NjaGVkdWxlci9hc2FwJyk7XG52YXIgaXNOdW1lcmljXzEgPSByZXF1aXJlKCcuLi91dGlsL2lzTnVtZXJpYycpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBTdWJzY3JpYmVPbk9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdWJzY3JpYmVPbk9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3Vic2NyaWJlT25PYnNlcnZhYmxlKHNvdXJjZSwgZGVsYXlUaW1lLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgaWYgKGRlbGF5VGltZSA9PT0gdm9pZCAwKSB7IGRlbGF5VGltZSA9IDA7IH1cbiAgICAgICAgaWYgKHNjaGVkdWxlciA9PT0gdm9pZCAwKSB7IHNjaGVkdWxlciA9IGFzYXBfMS5hc2FwOyB9XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5kZWxheVRpbWUgPSBkZWxheVRpbWU7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICBpZiAoIWlzTnVtZXJpY18xLmlzTnVtZXJpYyhkZWxheVRpbWUpIHx8IGRlbGF5VGltZSA8IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVsYXlUaW1lID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNjaGVkdWxlciB8fCB0eXBlb2Ygc2NoZWR1bGVyLnNjaGVkdWxlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlciA9IGFzYXBfMS5hc2FwO1xuICAgICAgICB9XG4gICAgfVxuICAgIFN1YnNjcmliZU9uT2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAoc291cmNlLCBkZWxheSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxuICAgICAgICBpZiAoc2NoZWR1bGVyID09PSB2b2lkIDApIHsgc2NoZWR1bGVyID0gYXNhcF8xLmFzYXA7IH1cbiAgICAgICAgcmV0dXJuIG5ldyBTdWJzY3JpYmVPbk9ic2VydmFibGUoc291cmNlLCBkZWxheSwgc2NoZWR1bGVyKTtcbiAgICB9O1xuICAgIFN1YnNjcmliZU9uT2JzZXJ2YWJsZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZy5zb3VyY2UsIHN1YnNjcmliZXIgPSBhcmcuc3Vic2NyaWJlcjtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKHNvdXJjZS5zdWJzY3JpYmUoc3Vic2NyaWJlcikpO1xuICAgIH07XG4gICAgU3Vic2NyaWJlT25PYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIGRlbGF5ID0gdGhpcy5kZWxheVRpbWU7XG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlKFN1YnNjcmliZU9uT2JzZXJ2YWJsZS5kaXNwYXRjaCwgZGVsYXksIHtcbiAgICAgICAgICAgIHNvdXJjZTogc291cmNlLCBzdWJzY3JpYmVyOiBzdWJzY3JpYmVyXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFN1YnNjcmliZU9uT2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuU3Vic2NyaWJlT25PYnNlcnZhYmxlID0gU3Vic2NyaWJlT25PYnNlcnZhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3Vic2NyaWJlT25PYnNlcnZhYmxlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29ic2VydmFibGUvU3Vic2NyaWJlT25PYnNlcnZhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBpc051bWVyaWNfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNOdW1lcmljJyk7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIGFzeW5jXzEgPSByZXF1aXJlKCcuLi9zY2hlZHVsZXIvYXN5bmMnKTtcbnZhciBpc1NjaGVkdWxlcl8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc1NjaGVkdWxlcicpO1xudmFyIGlzRGF0ZV8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc0RhdGUnKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG52YXIgVGltZXJPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGltZXJPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRpbWVyT2JzZXJ2YWJsZShkdWVUaW1lLCBwZXJpb2QsIHNjaGVkdWxlcikge1xuICAgICAgICBpZiAoZHVlVGltZSA9PT0gdm9pZCAwKSB7IGR1ZVRpbWUgPSAwOyB9XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnBlcmlvZCA9IC0xO1xuICAgICAgICB0aGlzLmR1ZVRpbWUgPSAwO1xuICAgICAgICBpZiAoaXNOdW1lcmljXzEuaXNOdW1lcmljKHBlcmlvZCkpIHtcbiAgICAgICAgICAgIHRoaXMucGVyaW9kID0gTnVtYmVyKHBlcmlvZCkgPCAxICYmIDEgfHwgTnVtYmVyKHBlcmlvZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNTY2hlZHVsZXJfMS5pc1NjaGVkdWxlcihwZXJpb2QpKSB7XG4gICAgICAgICAgICBzY2hlZHVsZXIgPSBwZXJpb2Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1NjaGVkdWxlcl8xLmlzU2NoZWR1bGVyKHNjaGVkdWxlcikpIHtcbiAgICAgICAgICAgIHNjaGVkdWxlciA9IGFzeW5jXzEuYXN5bmM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIHRoaXMuZHVlVGltZSA9IGlzRGF0ZV8xLmlzRGF0ZShkdWVUaW1lKSA/XG4gICAgICAgICAgICAoK2R1ZVRpbWUgLSB0aGlzLnNjaGVkdWxlci5ub3coKSkgOlxuICAgICAgICAgICAgZHVlVGltZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIHRoYXQgc3RhcnRzIGVtaXR0aW5nIGFmdGVyIGFuIGBpbml0aWFsRGVsYXlgIGFuZFxuICAgICAqIGVtaXRzIGV2ZXIgaW5jcmVhc2luZyBudW1iZXJzIGFmdGVyIGVhY2ggYHBlcmlvZGAgb2YgdGltZSB0aGVyZWFmdGVyLlxuICAgICAqXG4gICAgICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0cyBsaWtlIHtAbGluayBpbnRlcnZhbH0sIGJ1dCB5b3UgY2FuIHNwZWNpZnkgd2hlblxuICAgICAqIHNob3VsZCB0aGUgZW1pc3Npb25zIHN0YXJ0Ljwvc3Bhbj5cbiAgICAgKlxuICAgICAqIDxpbWcgc3JjPVwiLi9pbWcvdGltZXIucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gICAgICpcbiAgICAgKiBgdGltZXJgIHJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGFuIGluZmluaXRlIHNlcXVlbmNlIG9mIGFzY2VuZGluZ1xuICAgICAqIGludGVnZXJzLCB3aXRoIGEgY29uc3RhbnQgaW50ZXJ2YWwgb2YgdGltZSwgYHBlcmlvZGAgb2YgeW91ciBjaG9vc2luZ1xuICAgICAqIGJldHdlZW4gdGhvc2UgZW1pc3Npb25zLiBUaGUgZmlyc3QgZW1pc3Npb24gaGFwcGVucyBhZnRlciB0aGUgc3BlY2lmaWVkXG4gICAgICogYGluaXRpYWxEZWxheWAuIFRoZSBpbml0aWFsIGRlbGF5IG1heSBiZSBhIHtAbGluayBEYXRlfS4gQnkgZGVmYXVsdCwgdGhpc1xuICAgICAqIG9wZXJhdG9yIHVzZXMgdGhlIGBhc3luY2AgSVNjaGVkdWxlciB0byBwcm92aWRlIGEgbm90aW9uIG9mIHRpbWUsIGJ1dCB5b3VcbiAgICAgKiBtYXkgcGFzcyBhbnkgSVNjaGVkdWxlciB0byBpdC4gSWYgYHBlcmlvZGAgaXMgbm90IHNwZWNpZmllZCwgdGhlIG91dHB1dFxuICAgICAqIE9ic2VydmFibGUgZW1pdHMgb25seSBvbmUgdmFsdWUsIGAwYC4gT3RoZXJ3aXNlLCBpdCBlbWl0cyBhbiBpbmZpbml0ZVxuICAgICAqIHNlcXVlbmNlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdHMgYXNjZW5kaW5nIG51bWJlcnMsIG9uZSBldmVyeSBzZWNvbmQgKDEwMDBtcyksIHN0YXJ0aW5nIGFmdGVyIDMgc2Vjb25kczwvY2FwdGlvbj5cbiAgICAgKiB2YXIgbnVtYmVycyA9IFJ4Lk9ic2VydmFibGUudGltZXIoMzAwMCwgMTAwMCk7XG4gICAgICogbnVtYmVycy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0cyBvbmUgbnVtYmVyIGFmdGVyIGZpdmUgc2Vjb25kczwvY2FwdGlvbj5cbiAgICAgKiB2YXIgbnVtYmVycyA9IFJ4Lk9ic2VydmFibGUudGltZXIoNTAwMCk7XG4gICAgICogbnVtYmVycy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBpbnRlcnZhbH1cbiAgICAgKiBAc2VlIHtAbGluayBkZWxheX1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfERhdGV9IGluaXRpYWxEZWxheSBUaGUgaW5pdGlhbCBkZWxheSB0aW1lIHRvIHdhaXQgYmVmb3JlXG4gICAgICogZW1pdHRpbmcgdGhlIGZpcnN0IHZhbHVlIG9mIGAwYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BlcmlvZF0gVGhlIHBlcmlvZCBvZiB0aW1lIGJldHdlZW4gZW1pc3Npb25zIG9mIHRoZVxuICAgICAqIHN1YnNlcXVlbnQgbnVtYmVycy5cbiAgICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcj1hc3luY10gVGhlIElTY2hlZHVsZXIgdG8gdXNlIGZvciBzY2hlZHVsaW5nXG4gICAgICogdGhlIGVtaXNzaW9uIG9mIHZhbHVlcywgYW5kIHByb3ZpZGluZyBhIG5vdGlvbiBvZiBcInRpbWVcIi5cbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgYSBgMGAgYWZ0ZXIgdGhlXG4gICAgICogYGluaXRpYWxEZWxheWAgYW5kIGV2ZXIgaW5jcmVhc2luZyBudW1iZXJzIGFmdGVyIGVhY2ggYHBlcmlvZGAgb2YgdGltZVxuICAgICAqIHRoZXJlYWZ0ZXIuXG4gICAgICogQHN0YXRpYyB0cnVlXG4gICAgICogQG5hbWUgdGltZXJcbiAgICAgKiBAb3duZXIgT2JzZXJ2YWJsZVxuICAgICAqL1xuICAgIFRpbWVyT2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAoaW5pdGlhbERlbGF5LCBwZXJpb2QsIHNjaGVkdWxlcikge1xuICAgICAgICBpZiAoaW5pdGlhbERlbGF5ID09PSB2b2lkIDApIHsgaW5pdGlhbERlbGF5ID0gMDsgfVxuICAgICAgICByZXR1cm4gbmV3IFRpbWVyT2JzZXJ2YWJsZShpbml0aWFsRGVsYXksIHBlcmlvZCwgc2NoZWR1bGVyKTtcbiAgICB9O1xuICAgIFRpbWVyT2JzZXJ2YWJsZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgaW5kZXggPSBzdGF0ZS5pbmRleCwgcGVyaW9kID0gc3RhdGUucGVyaW9kLCBzdWJzY3JpYmVyID0gc3RhdGUuc3Vic2NyaWJlcjtcbiAgICAgICAgdmFyIGFjdGlvbiA9IHRoaXM7XG4gICAgICAgIHN1YnNjcmliZXIubmV4dChpbmRleCk7XG4gICAgICAgIGlmIChzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBlcmlvZCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuaW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgIGFjdGlvbi5zY2hlZHVsZShzdGF0ZSwgcGVyaW9kKTtcbiAgICB9O1xuICAgIFRpbWVyT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHBlcmlvZCA9IF9hLnBlcmlvZCwgZHVlVGltZSA9IF9hLmR1ZVRpbWUsIHNjaGVkdWxlciA9IF9hLnNjaGVkdWxlcjtcbiAgICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShUaW1lck9ic2VydmFibGUuZGlzcGF0Y2gsIGR1ZVRpbWUsIHtcbiAgICAgICAgICAgIGluZGV4OiBpbmRleCwgcGVyaW9kOiBwZXJpb2QsIHN1YnNjcmliZXI6IHN1YnNjcmliZXJcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGltZXJPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5UaW1lck9ic2VydmFibGUgPSBUaW1lck9ic2VydmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaW1lck9ic2VydmFibGUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb2JzZXJ2YWJsZS9UaW1lck9ic2VydmFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDIyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIFVzaW5nT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFVzaW5nT2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBVc2luZ09ic2VydmFibGUocmVzb3VyY2VGYWN0b3J5LCBvYnNlcnZhYmxlRmFjdG9yeSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZXNvdXJjZUZhY3RvcnkgPSByZXNvdXJjZUZhY3Rvcnk7XG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZUZhY3RvcnkgPSBvYnNlcnZhYmxlRmFjdG9yeTtcbiAgICB9XG4gICAgVXNpbmdPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChyZXNvdXJjZUZhY3RvcnksIG9ic2VydmFibGVGYWN0b3J5KSB7XG4gICAgICAgIHJldHVybiBuZXcgVXNpbmdPYnNlcnZhYmxlKHJlc291cmNlRmFjdG9yeSwgb2JzZXJ2YWJsZUZhY3RvcnkpO1xuICAgIH07XG4gICAgVXNpbmdPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcmVzb3VyY2VGYWN0b3J5ID0gX2EucmVzb3VyY2VGYWN0b3J5LCBvYnNlcnZhYmxlRmFjdG9yeSA9IF9hLm9ic2VydmFibGVGYWN0b3J5O1xuICAgICAgICB2YXIgcmVzb3VyY2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXNvdXJjZSA9IHJlc291cmNlRmFjdG9yeSgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVc2luZ1N1YnNjcmliZXIoc3Vic2NyaWJlciwgcmVzb3VyY2UsIG9ic2VydmFibGVGYWN0b3J5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBVc2luZ09ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLlVzaW5nT2JzZXJ2YWJsZSA9IFVzaW5nT2JzZXJ2YWJsZTtcbnZhciBVc2luZ1N1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhVc2luZ1N1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVXNpbmdTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCByZXNvdXJjZSwgb2JzZXJ2YWJsZUZhY3RvcnkpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnJlc291cmNlID0gcmVzb3VyY2U7XG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZUZhY3RvcnkgPSBvYnNlcnZhYmxlRmFjdG9yeTtcbiAgICAgICAgZGVzdGluYXRpb24uYWRkKHJlc291cmNlKTtcbiAgICAgICAgdGhpcy50cnlVc2UoKTtcbiAgICB9XG4gICAgVXNpbmdTdWJzY3JpYmVyLnByb3RvdHlwZS50cnlVc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gdGhpcy5vYnNlcnZhYmxlRmFjdG9yeS5jYWxsKHRoaXMsIHRoaXMucmVzb3VyY2UpO1xuICAgICAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgc291cmNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5fZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFVzaW5nU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Vc2luZ09ic2VydmFibGUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb2JzZXJ2YWJsZS9Vc2luZ09ic2VydmFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDIyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBCb3VuZENhbGxiYWNrT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9Cb3VuZENhbGxiYWNrT2JzZXJ2YWJsZScpO1xuZXhwb3J0cy5iaW5kQ2FsbGJhY2sgPSBCb3VuZENhbGxiYWNrT2JzZXJ2YWJsZV8xLkJvdW5kQ2FsbGJhY2tPYnNlcnZhYmxlLmNyZWF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpbmRDYWxsYmFjay5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vYnNlcnZhYmxlL2JpbmRDYWxsYmFjay5qc1xuLy8gbW9kdWxlIGlkID0gMjI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIEJvdW5kTm9kZUNhbGxiYWNrT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9Cb3VuZE5vZGVDYWxsYmFja09ic2VydmFibGUnKTtcbmV4cG9ydHMuYmluZE5vZGVDYWxsYmFjayA9IEJvdW5kTm9kZUNhbGxiYWNrT2JzZXJ2YWJsZV8xLkJvdW5kTm9kZUNhbGxiYWNrT2JzZXJ2YWJsZS5jcmVhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iaW5kTm9kZUNhbGxiYWNrLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29ic2VydmFibGUvYmluZE5vZGVDYWxsYmFjay5qc1xuLy8gbW9kdWxlIGlkID0gMjI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGlzU2NoZWR1bGVyXzEgPSByZXF1aXJlKCcuLi91dGlsL2lzU2NoZWR1bGVyJyk7XG52YXIgaXNBcnJheV8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc0FycmF5Jyk7XG52YXIgQXJyYXlPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL0FycmF5T2JzZXJ2YWJsZScpO1xudmFyIGNvbWJpbmVMYXRlc3RfMSA9IHJlcXVpcmUoJy4uL29wZXJhdG9yL2NvbWJpbmVMYXRlc3QnKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIENvbWJpbmVzIG11bHRpcGxlIE9ic2VydmFibGVzIHRvIGNyZWF0ZSBhbiBPYnNlcnZhYmxlIHdob3NlIHZhbHVlcyBhcmVcbiAqIGNhbGN1bGF0ZWQgZnJvbSB0aGUgbGF0ZXN0IHZhbHVlcyBvZiBlYWNoIG9mIGl0cyBpbnB1dCBPYnNlcnZhYmxlcy5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+V2hlbmV2ZXIgYW55IGlucHV0IE9ic2VydmFibGUgZW1pdHMgYSB2YWx1ZSwgaXRcbiAqIGNvbXB1dGVzIGEgZm9ybXVsYSB1c2luZyB0aGUgbGF0ZXN0IHZhbHVlcyBmcm9tIGFsbCB0aGUgaW5wdXRzLCB0aGVuIGVtaXRzXG4gKiB0aGUgb3V0cHV0IG9mIHRoYXQgZm9ybXVsYS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9jb21iaW5lTGF0ZXN0LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBjb21iaW5lTGF0ZXN0YCBjb21iaW5lcyB0aGUgdmFsdWVzIGZyb20gYWxsIHRoZSBPYnNlcnZhYmxlcyBwYXNzZWQgYXNcbiAqIGFyZ3VtZW50cy4gVGhpcyBpcyBkb25lIGJ5IHN1YnNjcmliaW5nIHRvIGVhY2ggT2JzZXJ2YWJsZSBpbiBvcmRlciBhbmQsXG4gKiB3aGVuZXZlciBhbnkgT2JzZXJ2YWJsZSBlbWl0cywgY29sbGVjdGluZyBhbiBhcnJheSBvZiB0aGUgbW9zdCByZWNlbnRcbiAqIHZhbHVlcyBmcm9tIGVhY2ggT2JzZXJ2YWJsZS4gU28gaWYgeW91IHBhc3MgYG5gIE9ic2VydmFibGVzIHRvIG9wZXJhdG9yLFxuICogcmV0dXJuZWQgT2JzZXJ2YWJsZSB3aWxsIGFsd2F5cyBlbWl0IGFuIGFycmF5IG9mIGBuYCB2YWx1ZXMsIGluIG9yZGVyXG4gKiBjb3JyZXNwb25kaW5nIHRvIG9yZGVyIG9mIHBhc3NlZCBPYnNlcnZhYmxlcyAodmFsdWUgZnJvbSB0aGUgZmlyc3QgT2JzZXJ2YWJsZVxuICogb24gdGhlIGZpcnN0IHBsYWNlIGFuZCBzbyBvbikuXG4gKlxuICogU3RhdGljIHZlcnNpb24gb2YgYGNvbWJpbmVMYXRlc3RgIGFjY2VwdHMgZWl0aGVyIGFuIGFycmF5IG9mIE9ic2VydmFibGVzXG4gKiBvciBlYWNoIE9ic2VydmFibGUgY2FuIGJlIHB1dCBkaXJlY3RseSBhcyBhbiBhcmd1bWVudC4gTm90ZSB0aGF0IGFycmF5IG9mXG4gKiBPYnNlcnZhYmxlcyBpcyBnb29kIGNob2ljZSwgaWYgeW91IGRvbid0IGtub3cgYmVmb3JlaGFuZCBob3cgbWFueSBPYnNlcnZhYmxlc1xuICogeW91IHdpbGwgY29tYmluZS4gUGFzc2luZyBlbXB0eSBhcnJheSB3aWxsIHJlc3VsdCBpbiBPYnNlcnZhYmxlIHRoYXRcbiAqIGNvbXBsZXRlcyBpbW1lZGlhdGVseS5cbiAqXG4gKiBUbyBlbnN1cmUgb3V0cHV0IGFycmF5IGhhcyBhbHdheXMgdGhlIHNhbWUgbGVuZ3RoLCBgY29tYmluZUxhdGVzdGAgd2lsbFxuICogYWN0dWFsbHkgd2FpdCBmb3IgYWxsIGlucHV0IE9ic2VydmFibGVzIHRvIGVtaXQgYXQgbGVhc3Qgb25jZSxcbiAqIGJlZm9yZSBpdCBzdGFydHMgZW1pdHRpbmcgcmVzdWx0cy4gVGhpcyBtZWFucyBpZiBzb21lIE9ic2VydmFibGUgZW1pdHNcbiAqIHZhbHVlcyBiZWZvcmUgb3RoZXIgT2JzZXJ2YWJsZXMgc3RhcnRlZCBlbWl0dGluZywgYWxsIHRoYXQgdmFsdWVzIGJ1dCBsYXN0XG4gKiB3aWxsIGJlIGxvc3QuIE9uIHRoZSBvdGhlciBoYW5kLCBpcyBzb21lIE9ic2VydmFibGUgZG9lcyBub3QgZW1pdCB2YWx1ZSBidXRcbiAqIGNvbXBsZXRlcywgcmVzdWx0aW5nIE9ic2VydmFibGUgd2lsbCBjb21wbGV0ZSBhdCB0aGUgc2FtZSBtb21lbnQgd2l0aG91dFxuICogZW1pdHRpbmcgYW55dGhpbmcsIHNpbmNlIGl0IHdpbGwgYmUgbm93IGltcG9zc2libGUgdG8gaW5jbHVkZSB2YWx1ZSBmcm9tXG4gKiBjb21wbGV0ZWQgT2JzZXJ2YWJsZSBpbiByZXN1bHRpbmcgYXJyYXkuIEFsc28sIGlmIHNvbWUgaW5wdXQgT2JzZXJ2YWJsZSBkb2VzXG4gKiBub3QgZW1pdCBhbnkgdmFsdWUgYW5kIG5ldmVyIGNvbXBsZXRlcywgYGNvbWJpbmVMYXRlc3RgIHdpbGwgYWxzbyBuZXZlciBlbWl0XG4gKiBhbmQgbmV2ZXIgY29tcGxldGUsIHNpbmNlLCBhZ2FpbiwgaXQgd2lsbCB3YWl0IGZvciBhbGwgc3RyZWFtcyB0byBlbWl0IHNvbWVcbiAqIHZhbHVlLlxuICpcbiAqIElmIGF0IGxlYXN0IG9uZSBPYnNlcnZhYmxlIHdhcyBwYXNzZWQgdG8gYGNvbWJpbmVMYXRlc3RgIGFuZCBhbGwgcGFzc2VkIE9ic2VydmFibGVzXG4gKiBlbWl0dGVkIHNvbWV0aGluZywgcmVzdWx0aW5nIE9ic2VydmFibGUgd2lsbCBjb21wbGV0ZSB3aGVuIGFsbCBjb21iaW5lZFxuICogc3RyZWFtcyBjb21wbGV0ZS4gU28gZXZlbiBpZiBzb21lIE9ic2VydmFibGUgY29tcGxldGVzLCByZXN1bHQgb2ZcbiAqIGBjb21iaW5lTGF0ZXN0YCB3aWxsIHN0aWxsIGVtaXQgdmFsdWVzIHdoZW4gb3RoZXIgT2JzZXJ2YWJsZXMgZG8uIEluIGNhc2VcbiAqIG9mIGNvbXBsZXRlZCBPYnNlcnZhYmxlLCBpdHMgdmFsdWUgZnJvbSBub3cgb24gd2lsbCBhbHdheXMgYmUgdGhlIGxhc3RcbiAqIGVtaXR0ZWQgdmFsdWUuIE9uIHRoZSBvdGhlciBoYW5kLCBpZiBhbnkgT2JzZXJ2YWJsZSBlcnJvcnMsIGBjb21iaW5lTGF0ZXN0YFxuICogd2lsbCBlcnJvciBpbW1lZGlhdGVseSBhcyB3ZWxsLCBhbmQgYWxsIG90aGVyIE9ic2VydmFibGVzIHdpbGwgYmUgdW5zdWJzY3JpYmVkLlxuICpcbiAqIGBjb21iaW5lTGF0ZXN0YCBhY2NlcHRzIGFzIG9wdGlvbmFsIHBhcmFtZXRlciBgcHJvamVjdGAgZnVuY3Rpb24sIHdoaWNoIHRha2VzXG4gKiBhcyBhcmd1bWVudHMgYWxsIHZhbHVlcyB0aGF0IHdvdWxkIG5vcm1hbGx5IGJlIGVtaXR0ZWQgYnkgcmVzdWx0aW5nIE9ic2VydmFibGUuXG4gKiBgcHJvamVjdGAgY2FuIHJldHVybiBhbnkga2luZCBvZiB2YWx1ZSwgd2hpY2ggd2lsbCBiZSB0aGVuIGVtaXR0ZWQgYnkgT2JzZXJ2YWJsZVxuICogaW5zdGVhZCBvZiBkZWZhdWx0IGFycmF5LiBOb3RlIHRoYXQgYHByb2plY3RgIGRvZXMgbm90IHRha2UgYXMgYXJndW1lbnQgdGhhdCBhcnJheVxuICogb2YgdmFsdWVzLCBidXQgdmFsdWVzIHRoZW1zZWx2ZXMuIFRoYXQgbWVhbnMgZGVmYXVsdCBgcHJvamVjdGAgY2FuIGJlIGltYWdpbmVkXG4gKiBhcyBmdW5jdGlvbiB0aGF0IHRha2VzIGFsbCBpdHMgYXJndW1lbnRzIGFuZCBwdXRzIHRoZW0gaW50byBhbiBhcnJheS5cbiAqXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q29tYmluZSB0d28gdGltZXIgT2JzZXJ2YWJsZXM8L2NhcHRpb24+XG4gKiBjb25zdCBmaXJzdFRpbWVyID0gUnguT2JzZXJ2YWJsZS50aW1lcigwLCAxMDAwKTsgLy8gZW1pdCAwLCAxLCAyLi4uIGFmdGVyIGV2ZXJ5IHNlY29uZCwgc3RhcnRpbmcgZnJvbSBub3dcbiAqIGNvbnN0IHNlY29uZFRpbWVyID0gUnguT2JzZXJ2YWJsZS50aW1lcig1MDAsIDEwMDApOyAvLyBlbWl0IDAsIDEsIDIuLi4gYWZ0ZXIgZXZlcnkgc2Vjb25kLCBzdGFydGluZyAwLDVzIGZyb20gbm93XG4gKiBjb25zdCBjb21iaW5lZFRpbWVycyA9IFJ4Lk9ic2VydmFibGUuY29tYmluZUxhdGVzdChmaXJzdFRpbWVyLCBzZWNvbmRUaW1lcik7XG4gKiBjb21iaW5lZFRpbWVycy5zdWJzY3JpYmUodmFsdWUgPT4gY29uc29sZS5sb2codmFsdWUpKTtcbiAqIC8vIExvZ3NcbiAqIC8vIFswLCAwXSBhZnRlciAwLjVzXG4gKiAvLyBbMSwgMF0gYWZ0ZXIgMXNcbiAqIC8vIFsxLCAxXSBhZnRlciAxLjVzXG4gKiAvLyBbMiwgMV0gYWZ0ZXIgMnNcbiAqXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q29tYmluZSBhbiBhcnJheSBvZiBPYnNlcnZhYmxlczwvY2FwdGlvbj5cbiAqIGNvbnN0IG9ic2VydmFibGVzID0gWzEsIDUsIDEwXS5tYXAoXG4gKiAgIG4gPT4gUnguT2JzZXJ2YWJsZS5vZihuKS5kZWxheShuICogMTAwMCkuc3RhcnRXaXRoKDApIC8vIGVtaXQgMCBhbmQgdGhlbiBlbWl0IG4gYWZ0ZXIgbiBzZWNvbmRzXG4gKiApO1xuICogY29uc3QgY29tYmluZWQgPSBSeC5PYnNlcnZhYmxlLmNvbWJpbmVMYXRlc3Qob2JzZXJ2YWJsZXMpO1xuICogY29tYmluZWQuc3Vic2NyaWJlKHZhbHVlID0+IGNvbnNvbGUubG9nKHZhbHVlKSk7XG4gKiAvLyBMb2dzXG4gKiAvLyBbMCwgMCwgMF0gaW1tZWRpYXRlbHlcbiAqIC8vIFsxLCAwLCAwXSBhZnRlciAxc1xuICogLy8gWzEsIDUsIDBdIGFmdGVyIDVzXG4gKiAvLyBbMSwgNSwgMTBdIGFmdGVyIDEwc1xuICpcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Vc2UgcHJvamVjdCBmdW5jdGlvbiB0byBkeW5hbWljYWxseSBjYWxjdWxhdGUgdGhlIEJvZHktTWFzcyBJbmRleDwvY2FwdGlvbj5cbiAqIHZhciB3ZWlnaHQgPSBSeC5PYnNlcnZhYmxlLm9mKDcwLCA3MiwgNzYsIDc5LCA3NSk7XG4gKiB2YXIgaGVpZ2h0ID0gUnguT2JzZXJ2YWJsZS5vZigxLjc2LCAxLjc3LCAxLjc4KTtcbiAqIHZhciBibWkgPSBSeC5PYnNlcnZhYmxlLmNvbWJpbmVMYXRlc3Qod2VpZ2h0LCBoZWlnaHQsICh3LCBoKSA9PiB3IC8gKGggKiBoKSk7XG4gKiBibWkuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coJ0JNSSBpcyAnICsgeCkpO1xuICpcbiAqIC8vIFdpdGggb3V0cHV0IHRvIGNvbnNvbGU6XG4gKiAvLyBCTUkgaXMgMjQuMjEyMjkzMzg4NDI5NzUzXG4gKiAvLyBCTUkgaXMgMjMuOTM5NDgwOTkyMDUyMDlcbiAqIC8vIEJNSSBpcyAyMy42NzEyNTM2Mjk1OTIyMjJcbiAqXG4gKlxuICogQHNlZSB7QGxpbmsgY29tYmluZUFsbH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlfVxuICogQHNlZSB7QGxpbmsgd2l0aExhdGVzdEZyb219XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlSW5wdXR9IG9ic2VydmFibGUxIEFuIGlucHV0IE9ic2VydmFibGUgdG8gY29tYmluZSB3aXRoIG90aGVyIE9ic2VydmFibGVzLlxuICogQHBhcmFtIHtPYnNlcnZhYmxlSW5wdXR9IG9ic2VydmFibGUyIEFuIGlucHV0IE9ic2VydmFibGUgdG8gY29tYmluZSB3aXRoIG90aGVyIE9ic2VydmFibGVzLlxuICogTW9yZSB0aGFuIG9uZSBpbnB1dCBPYnNlcnZhYmxlcyBtYXkgYmUgZ2l2ZW4gYXMgYXJndW1lbnRzXG4gKiBvciBhbiBhcnJheSBvZiBPYnNlcnZhYmxlcyBtYXkgYmUgZ2l2ZW4gYXMgdGhlIGZpcnN0IGFyZ3VtZW50LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW3Byb2plY3RdIEFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIHByb2plY3QgdGhlIHZhbHVlcyBmcm9tXG4gKiB0aGUgY29tYmluZWQgbGF0ZXN0IHZhbHVlcyBpbnRvIGEgbmV3IHZhbHVlIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyPW51bGxdIFRoZSBJU2NoZWR1bGVyIHRvIHVzZSBmb3Igc3Vic2NyaWJpbmcgdG9cbiAqIGVhY2ggaW5wdXQgT2JzZXJ2YWJsZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgb2YgcHJvamVjdGVkIHZhbHVlcyBmcm9tIHRoZSBtb3N0IHJlY2VudFxuICogdmFsdWVzIGZyb20gZWFjaCBpbnB1dCBPYnNlcnZhYmxlLCBvciBhbiBhcnJheSBvZiB0aGUgbW9zdCByZWNlbnQgdmFsdWVzIGZyb21cbiAqIGVhY2ggaW5wdXQgT2JzZXJ2YWJsZS5cbiAqIEBzdGF0aWMgdHJ1ZVxuICogQG5hbWUgY29tYmluZUxhdGVzdFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gY29tYmluZUxhdGVzdCgpIHtcbiAgICB2YXIgb2JzZXJ2YWJsZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBvYnNlcnZhYmxlc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIHByb2plY3QgPSBudWxsO1xuICAgIHZhciBzY2hlZHVsZXIgPSBudWxsO1xuICAgIGlmIChpc1NjaGVkdWxlcl8xLmlzU2NoZWR1bGVyKG9ic2VydmFibGVzW29ic2VydmFibGVzLmxlbmd0aCAtIDFdKSkge1xuICAgICAgICBzY2hlZHVsZXIgPSBvYnNlcnZhYmxlcy5wb3AoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvYnNlcnZhYmxlc1tvYnNlcnZhYmxlcy5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcm9qZWN0ID0gb2JzZXJ2YWJsZXMucG9wKCk7XG4gICAgfVxuICAgIC8vIGlmIHRoZSBmaXJzdCBhbmQgb25seSBvdGhlciBhcmd1bWVudCBiZXNpZGVzIHRoZSByZXN1bHRTZWxlY3RvciBpcyBhbiBhcnJheVxuICAgIC8vIGFzc3VtZSBpdCdzIGJlZW4gY2FsbGVkIHdpdGggYGNvbWJpbmVMYXRlc3QoW29iczEsIG9iczIsIG9iczNdLCBwcm9qZWN0KWBcbiAgICBpZiAob2JzZXJ2YWJsZXMubGVuZ3RoID09PSAxICYmIGlzQXJyYXlfMS5pc0FycmF5KG9ic2VydmFibGVzWzBdKSkge1xuICAgICAgICBvYnNlcnZhYmxlcyA9IG9ic2VydmFibGVzWzBdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEFycmF5T2JzZXJ2YWJsZV8xLkFycmF5T2JzZXJ2YWJsZShvYnNlcnZhYmxlcywgc2NoZWR1bGVyKS5saWZ0KG5ldyBjb21iaW5lTGF0ZXN0XzEuQ29tYmluZUxhdGVzdE9wZXJhdG9yKHByb2plY3QpKTtcbn1cbmV4cG9ydHMuY29tYmluZUxhdGVzdCA9IGNvbWJpbmVMYXRlc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21iaW5lTGF0ZXN0LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29ic2VydmFibGUvY29tYmluZUxhdGVzdC5qc1xuLy8gbW9kdWxlIGlkID0gMjI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvbmNhdF8xID0gcmVxdWlyZSgnLi4vb3BlcmF0b3IvY29uY2F0Jyk7XG5leHBvcnRzLmNvbmNhdCA9IGNvbmNhdF8xLmNvbmNhdFN0YXRpYztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmNhdC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vYnNlcnZhYmxlL2NvbmNhdC5qc1xuLy8gbW9kdWxlIGlkID0gMjI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIERlZmVyT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9EZWZlck9ic2VydmFibGUnKTtcbmV4cG9ydHMuZGVmZXIgPSBEZWZlck9ic2VydmFibGVfMS5EZWZlck9ic2VydmFibGUuY3JlYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb2JzZXJ2YWJsZS9kZWZlci5qc1xuLy8gbW9kdWxlIGlkID0gMjMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3ViamVjdF8xID0gcmVxdWlyZSgnLi4vLi4vU3ViamVjdCcpO1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uLy4uL1N1YnNjcmliZXInKTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuLi8uLi9TdWJzY3JpcHRpb24nKTtcbnZhciByb290XzEgPSByZXF1aXJlKCcuLi8uLi91dGlsL3Jvb3QnKTtcbnZhciBSZXBsYXlTdWJqZWN0XzEgPSByZXF1aXJlKCcuLi8uLi9SZXBsYXlTdWJqZWN0Jyk7XG52YXIgdHJ5Q2F0Y2hfMSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdHJ5Q2F0Y2gnKTtcbnZhciBlcnJvck9iamVjdF8xID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9lcnJvck9iamVjdCcpO1xudmFyIGFzc2lnbl8xID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9hc3NpZ24nKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG52YXIgV2ViU29ja2V0U3ViamVjdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFdlYlNvY2tldFN1YmplY3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gV2ViU29ja2V0U3ViamVjdCh1cmxDb25maWdPclNvdXJjZSwgZGVzdGluYXRpb24pIHtcbiAgICAgICAgaWYgKHVybENvbmZpZ09yU291cmNlIGluc3RhbmNlb2YgT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uLCB1cmxDb25maWdPclNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuV2ViU29ja2V0Q3RvciA9IHJvb3RfMS5yb290LldlYlNvY2tldDtcbiAgICAgICAgICAgIHRoaXMuX291dHB1dCA9IG5ldyBTdWJqZWN0XzEuU3ViamVjdCgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB1cmxDb25maWdPclNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVybCA9IHVybENvbmZpZ09yU291cmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gV0FSTklORzogY29uZmlnIG9iamVjdCBjb3VsZCBvdmVycmlkZSBpbXBvcnRhbnQgbWVtYmVycyBoZXJlLlxuICAgICAgICAgICAgICAgIGFzc2lnbl8xLmFzc2lnbih0aGlzLCB1cmxDb25maWdPclNvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuV2ViU29ja2V0Q3Rvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm8gV2ViU29ja2V0IGNvbnN0cnVjdG9yIGNhbiBiZSBmb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBSZXBsYXlTdWJqZWN0XzEuUmVwbGF5U3ViamVjdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFdlYlNvY2tldFN1YmplY3QucHJvdG90eXBlLnJlc3VsdFNlbGVjdG9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZS5kYXRhKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdyYXBwZXIgYXJvdW5kIHRoZSB3M2MtY29tcGF0aWJsZSBXZWJTb2NrZXQgb2JqZWN0IHByb3ZpZGVkIGJ5IHRoZSBicm93c2VyLlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+V3JhcHMgYnJvd3NlciBXZWJTb2NrZXQ8L2NhcHRpb24+XG4gICAgICpcbiAgICAgKiBsZXQgc3ViamVjdCA9IE9ic2VydmFibGUud2ViU29ja2V0KCd3czovL2xvY2FsaG9zdDo4MDgxJyk7XG4gICAgICogc3ViamVjdC5zdWJzY3JpYmUoXG4gICAgICogICAgKG1zZykgPT4gY29uc29sZS5sb2coJ21lc3NhZ2UgcmVjZWl2ZWQ6ICcgKyBtc2cpLFxuICAgICAqICAgIChlcnIpID0+IGNvbnNvbGUubG9nKGVyciksXG4gICAgICogICAgKCkgPT4gY29uc29sZS5sb2coJ2NvbXBsZXRlJylcbiAgICAgKiAgKTtcbiAgICAgKiBzdWJqZWN0Lm5leHQoSlNPTi5zdHJpbmdpZnkoeyBvcDogJ2hlbGxvJyB9KSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5XcmFwcyBXZWJTb2NrZXQgZnJvbSBub2RlanMtd2Vic29ja2V0ICh1c2luZyBub2RlLmpzKTwvY2FwdGlvbj5cbiAgICAgKlxuICAgICAqIGltcG9ydCB7IHczY3dlYnNvY2tldCB9IGZyb20gJ3dlYnNvY2tldCc7XG4gICAgICpcbiAgICAgKiBsZXQgc29ja2V0ID0gbmV3IFdlYlNvY2tldFN1YmplY3Qoe1xuICAgICAqICAgdXJsOiAnd3M6Ly9sb2NhbGhvc3Q6ODA4MScsXG4gICAgICogICBXZWJTb2NrZXRDdG9yOiB3M2N3ZWJzb2NrZXRcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGxldCBzdWJqZWN0ID0gT2JzZXJ2YWJsZS53ZWJTb2NrZXQoJ3dzOi8vbG9jYWxob3N0OjgwODEnKTtcbiAgICAgKiBzdWJqZWN0LnN1YnNjcmliZShcbiAgICAgKiAgICAobXNnKSA9PiBjb25zb2xlLmxvZygnbWVzc2FnZSByZWNlaXZlZDogJyArIG1zZyksXG4gICAgICogICAgKGVycikgPT4gY29uc29sZS5sb2coZXJyKSxcbiAgICAgKiAgICAoKSA9PiBjb25zb2xlLmxvZygnY29tcGxldGUnKVxuICAgICAqICApO1xuICAgICAqIHN1YmplY3QubmV4dChKU09OLnN0cmluZ2lmeSh7IG9wOiAnaGVsbG8nIH0pKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgV2ViU29ja2V0U3ViamVjdENvbmZpZ30gdXJsQ29uZmlnT3JTb3VyY2UgdGhlIHNvdXJjZSBvZiB0aGUgd2Vic29ja2V0IGFzIGFuIHVybCBvciBhIHN0cnVjdHVyZSBkZWZpbmluZyB0aGUgd2Vic29ja2V0IG9iamVjdFxuICAgICAqIEByZXR1cm4ge1dlYlNvY2tldFN1YmplY3R9XG4gICAgICogQHN0YXRpYyB0cnVlXG4gICAgICogQG5hbWUgd2ViU29ja2V0XG4gICAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICAgKi9cbiAgICBXZWJTb2NrZXRTdWJqZWN0LmNyZWF0ZSA9IGZ1bmN0aW9uICh1cmxDb25maWdPclNvdXJjZSkge1xuICAgICAgICByZXR1cm4gbmV3IFdlYlNvY2tldFN1YmplY3QodXJsQ29uZmlnT3JTb3VyY2UpO1xuICAgIH07XG4gICAgV2ViU29ja2V0U3ViamVjdC5wcm90b3R5cGUubGlmdCA9IGZ1bmN0aW9uIChvcGVyYXRvcikge1xuICAgICAgICB2YXIgc29jayA9IG5ldyBXZWJTb2NrZXRTdWJqZWN0KHRoaXMsIHRoaXMuZGVzdGluYXRpb24pO1xuICAgICAgICBzb2NrLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgIHJldHVybiBzb2NrO1xuICAgIH07XG4gICAgV2ViU29ja2V0U3ViamVjdC5wcm90b3R5cGUuX3Jlc2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc29ja2V0ID0gbnVsbDtcbiAgICAgICAgaWYgKCF0aGlzLnNvdXJjZSkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBSZXBsYXlTdWJqZWN0XzEuUmVwbGF5U3ViamVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX291dHB1dCA9IG5ldyBTdWJqZWN0XzEuU3ViamVjdCgpO1xuICAgIH07XG4gICAgLy8gVE9ETzogZmFjdG9yIHRoaXMgb3V0IHRvIGJlIGEgcHJvcGVyIE9wZXJhdG9yL1N1YnNjcmliZXIgaW1wbGVtZW50YXRpb24gYW5kIGVsaW1pbmF0ZSBjbG9zdXJlc1xuICAgIFdlYlNvY2tldFN1YmplY3QucHJvdG90eXBlLm11bHRpcGxleCA9IGZ1bmN0aW9uIChzdWJNc2csIHVuc3ViTXNnLCBtZXNzYWdlRmlsdGVyKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKHN1Yk1zZykoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5uZXh0KHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gc2VsZi5zdWJzY3JpYmUoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaChtZXNzYWdlRmlsdGVyKSh4KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIG9ic2VydmVyLmVycm9yKGVycik7IH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9ic2VydmVyLmNvbXBsZXRlKCk7IH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaCh1bnN1Yk1zZykoKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm5leHQocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFdlYlNvY2tldFN1YmplY3QucHJvdG90eXBlLl9jb25uZWN0U29ja2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgV2ViU29ja2V0Q3RvciA9IHRoaXMuV2ViU29ja2V0Q3RvcjtcbiAgICAgICAgdmFyIG9ic2VydmVyID0gdGhpcy5fb3V0cHV0O1xuICAgICAgICB2YXIgc29ja2V0ID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNvY2tldCA9IHRoaXMucHJvdG9jb2wgP1xuICAgICAgICAgICAgICAgIG5ldyBXZWJTb2NrZXRDdG9yKHRoaXMudXJsLCB0aGlzLnByb3RvY29sKSA6XG4gICAgICAgICAgICAgICAgbmV3IFdlYlNvY2tldEN0b3IodGhpcy51cmwpO1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQgPSBzb2NrZXQ7XG4gICAgICAgICAgICBpZiAodGhpcy5iaW5hcnlUeXBlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSA9IHRoaXMuYmluYXJ5VHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuc29ja2V0ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChzb2NrZXQgJiYgc29ja2V0LnJlYWR5U3RhdGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBzb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHNvY2tldC5vbm9wZW4gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIG9wZW5PYnNlcnZlciA9IF90aGlzLm9wZW5PYnNlcnZlcjtcbiAgICAgICAgICAgIGlmIChvcGVuT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICBvcGVuT2JzZXJ2ZXIubmV4dChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBxdWV1ZSA9IF90aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICAgICAgX3RoaXMuZGVzdGluYXRpb24gPSBTdWJzY3JpYmVyXzEuU3Vic2NyaWJlci5jcmVhdGUoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHNvY2tldC5yZWFkeVN0YXRlID09PSAxICYmIHNvY2tldC5zZW5kKHgpOyB9LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHZhciBjbG9zaW5nT2JzZXJ2ZXIgPSBfdGhpcy5jbG9zaW5nT2JzZXJ2ZXI7XG4gICAgICAgICAgICAgICAgaWYgKGNsb3NpbmdPYnNlcnZlcikge1xuICAgICAgICAgICAgICAgICAgICBjbG9zaW5nT2JzZXJ2ZXIubmV4dCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZSAmJiBlLmNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LmNsb3NlKGUuY29kZSwgZS5yZWFzb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IobmV3IFR5cGVFcnJvcignV2ViU29ja2V0U3ViamVjdC5lcnJvciBtdXN0IGJlIGNhbGxlZCB3aXRoIGFuIG9iamVjdCB3aXRoIGFuIGVycm9yIGNvZGUsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2FuZCBhbiBvcHRpb25hbCByZWFzb246IHsgY29kZTogbnVtYmVyLCByZWFzb246IHN0cmluZyB9JykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5fcmVzZXRTdGF0ZSgpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBjbG9zaW5nT2JzZXJ2ZXIgPSBfdGhpcy5jbG9zaW5nT2JzZXJ2ZXI7XG4gICAgICAgICAgICAgICAgaWYgKGNsb3NpbmdPYnNlcnZlcikge1xuICAgICAgICAgICAgICAgICAgICBjbG9zaW5nT2JzZXJ2ZXIubmV4dCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcmVzZXRTdGF0ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocXVldWUgJiYgcXVldWUgaW5zdGFuY2VvZiBSZXBsYXlTdWJqZWN0XzEuUmVwbGF5U3ViamVjdCkge1xuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5hZGQocXVldWUuc3Vic2NyaWJlKF90aGlzLmRlc3RpbmF0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHNvY2tldC5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIF90aGlzLl9yZXNldFN0YXRlKCk7XG4gICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlKTtcbiAgICAgICAgfTtcbiAgICAgICAgc29ja2V0Lm9uY2xvc2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgX3RoaXMuX3Jlc2V0U3RhdGUoKTtcbiAgICAgICAgICAgIHZhciBjbG9zZU9ic2VydmVyID0gX3RoaXMuY2xvc2VPYnNlcnZlcjtcbiAgICAgICAgICAgIGlmIChjbG9zZU9ic2VydmVyKSB7XG4gICAgICAgICAgICAgICAgY2xvc2VPYnNlcnZlci5uZXh0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUud2FzQ2xlYW4pIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHNvY2tldC5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoXzEudHJ5Q2F0Y2goX3RoaXMucmVzdWx0U2VsZWN0b3IpKGUpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBXZWJTb2NrZXRTdWJqZWN0LnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuc29ja2V0KSB7XG4gICAgICAgICAgICB0aGlzLl9jb25uZWN0U29ja2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24oKTtcbiAgICAgICAgc3Vic2NyaXB0aW9uLmFkZCh0aGlzLl9vdXRwdXQuc3Vic2NyaWJlKHN1YnNjcmliZXIpKTtcbiAgICAgICAgc3Vic2NyaXB0aW9uLmFkZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc29ja2V0ID0gX3RoaXMuc29ja2V0O1xuICAgICAgICAgICAgaWYgKF90aGlzLl9vdXRwdXQub2JzZXJ2ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChzb2NrZXQgJiYgc29ja2V0LnJlYWR5U3RhdGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLl9yZXNldFN0YXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgIH07XG4gICAgV2ViU29ja2V0U3ViamVjdC5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHNvdXJjZSA9IF9hLnNvdXJjZSwgc29ja2V0ID0gX2Euc29ja2V0O1xuICAgICAgICBpZiAoc29ja2V0ICYmIHNvY2tldC5yZWFkeVN0YXRlID09PSAxKSB7XG4gICAgICAgICAgICBzb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0U3RhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlLmNhbGwodGhpcyk7XG4gICAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gbmV3IFJlcGxheVN1YmplY3RfMS5SZXBsYXlTdWJqZWN0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBXZWJTb2NrZXRTdWJqZWN0O1xufShTdWJqZWN0XzEuQW5vbnltb3VzU3ViamVjdCkpO1xuZXhwb3J0cy5XZWJTb2NrZXRTdWJqZWN0ID0gV2ViU29ja2V0U3ViamVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdlYlNvY2tldFN1YmplY3QuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb2JzZXJ2YWJsZS9kb20vV2ViU29ja2V0U3ViamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMjMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIEFqYXhPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL0FqYXhPYnNlcnZhYmxlJyk7XG5leHBvcnRzLmFqYXggPSBBamF4T2JzZXJ2YWJsZV8xLkFqYXhPYnNlcnZhYmxlLmNyZWF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFqYXguanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb2JzZXJ2YWJsZS9kb20vYWpheC5qc1xuLy8gbW9kdWxlIGlkID0gMjMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIFdlYlNvY2tldFN1YmplY3RfMSA9IHJlcXVpcmUoJy4vV2ViU29ja2V0U3ViamVjdCcpO1xuZXhwb3J0cy53ZWJTb2NrZXQgPSBXZWJTb2NrZXRTdWJqZWN0XzEuV2ViU29ja2V0U3ViamVjdC5jcmVhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWJTb2NrZXQuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb2JzZXJ2YWJsZS9kb20vd2ViU29ja2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAyMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgRW1wdHlPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL0VtcHR5T2JzZXJ2YWJsZScpO1xuZXhwb3J0cy5lbXB0eSA9IEVtcHR5T2JzZXJ2YWJsZV8xLkVtcHR5T2JzZXJ2YWJsZS5jcmVhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbXB0eS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vYnNlcnZhYmxlL2VtcHR5LmpzXG4vLyBtb2R1bGUgaWQgPSAyMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgRm9ya0pvaW5PYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL0ZvcmtKb2luT2JzZXJ2YWJsZScpO1xuZXhwb3J0cy5mb3JrSm9pbiA9IEZvcmtKb2luT2JzZXJ2YWJsZV8xLkZvcmtKb2luT2JzZXJ2YWJsZS5jcmVhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JrSm9pbi5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vYnNlcnZhYmxlL2ZvcmtKb2luLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgRnJvbU9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vRnJvbU9ic2VydmFibGUnKTtcbmV4cG9ydHMuZnJvbSA9IEZyb21PYnNlcnZhYmxlXzEuRnJvbU9ic2VydmFibGUuY3JlYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnJvbS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vYnNlcnZhYmxlL2Zyb20uanNcbi8vIG1vZHVsZSBpZCA9IDIzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBGcm9tRXZlbnRPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL0Zyb21FdmVudE9ic2VydmFibGUnKTtcbmV4cG9ydHMuZnJvbUV2ZW50ID0gRnJvbUV2ZW50T2JzZXJ2YWJsZV8xLkZyb21FdmVudE9ic2VydmFibGUuY3JlYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnJvbUV2ZW50LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29ic2VydmFibGUvZnJvbUV2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAyMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgRnJvbUV2ZW50UGF0dGVybk9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vRnJvbUV2ZW50UGF0dGVybk9ic2VydmFibGUnKTtcbmV4cG9ydHMuZnJvbUV2ZW50UGF0dGVybiA9IEZyb21FdmVudFBhdHRlcm5PYnNlcnZhYmxlXzEuRnJvbUV2ZW50UGF0dGVybk9ic2VydmFibGUuY3JlYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnJvbUV2ZW50UGF0dGVybi5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vYnNlcnZhYmxlL2Zyb21FdmVudFBhdHRlcm4uanNcbi8vIG1vZHVsZSBpZCA9IDIzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBQcm9taXNlT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9Qcm9taXNlT2JzZXJ2YWJsZScpO1xuZXhwb3J0cy5mcm9tUHJvbWlzZSA9IFByb21pc2VPYnNlcnZhYmxlXzEuUHJvbWlzZU9ic2VydmFibGUuY3JlYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnJvbVByb21pc2UuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb2JzZXJ2YWJsZS9mcm9tUHJvbWlzZS5qc1xuLy8gbW9kdWxlIGlkID0gMjM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIElmT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9JZk9ic2VydmFibGUnKTtcbmV4cG9ydHMuX2lmID0gSWZPYnNlcnZhYmxlXzEuSWZPYnNlcnZhYmxlLmNyZWF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlmLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29ic2VydmFibGUvaWYuanNcbi8vIG1vZHVsZSBpZCA9IDI0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBJbnRlcnZhbE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vSW50ZXJ2YWxPYnNlcnZhYmxlJyk7XG5leHBvcnRzLmludGVydmFsID0gSW50ZXJ2YWxPYnNlcnZhYmxlXzEuSW50ZXJ2YWxPYnNlcnZhYmxlLmNyZWF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVydmFsLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29ic2VydmFibGUvaW50ZXJ2YWwuanNcbi8vIG1vZHVsZSBpZCA9IDI0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBtZXJnZV8xID0gcmVxdWlyZSgnLi4vb3BlcmF0b3IvbWVyZ2UnKTtcbmV4cG9ydHMubWVyZ2UgPSBtZXJnZV8xLm1lcmdlU3RhdGljO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVyZ2UuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb2JzZXJ2YWJsZS9tZXJnZS5qc1xuLy8gbW9kdWxlIGlkID0gMjQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE5ldmVyT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9OZXZlck9ic2VydmFibGUnKTtcbmV4cG9ydHMubmV2ZXIgPSBOZXZlck9ic2VydmFibGVfMS5OZXZlck9ic2VydmFibGUuY3JlYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmV2ZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb2JzZXJ2YWJsZS9uZXZlci5qc1xuLy8gbW9kdWxlIGlkID0gMjQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIEFycmF5T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9BcnJheU9ic2VydmFibGUnKTtcbmV4cG9ydHMub2YgPSBBcnJheU9ic2VydmFibGVfMS5BcnJheU9ic2VydmFibGUub2Y7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vZi5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vYnNlcnZhYmxlL29mLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgUGFpcnNPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL1BhaXJzT2JzZXJ2YWJsZScpO1xuZXhwb3J0cy5wYWlycyA9IFBhaXJzT2JzZXJ2YWJsZV8xLlBhaXJzT2JzZXJ2YWJsZS5jcmVhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWlycy5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vYnNlcnZhYmxlL3BhaXJzLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgUmFuZ2VPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL1JhbmdlT2JzZXJ2YWJsZScpO1xuZXhwb3J0cy5yYW5nZSA9IFJhbmdlT2JzZXJ2YWJsZV8xLlJhbmdlT2JzZXJ2YWJsZS5jcmVhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYW5nZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vYnNlcnZhYmxlL3JhbmdlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgRXJyb3JPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL0Vycm9yT2JzZXJ2YWJsZScpO1xuZXhwb3J0cy5fdGhyb3cgPSBFcnJvck9ic2VydmFibGVfMS5FcnJvck9ic2VydmFibGUuY3JlYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGhyb3cuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb2JzZXJ2YWJsZS90aHJvdy5qc1xuLy8gbW9kdWxlIGlkID0gMjQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIFRpbWVyT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9UaW1lck9ic2VydmFibGUnKTtcbmV4cG9ydHMudGltZXIgPSBUaW1lck9ic2VydmFibGVfMS5UaW1lck9ic2VydmFibGUuY3JlYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGltZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb2JzZXJ2YWJsZS90aW1lci5qc1xuLy8gbW9kdWxlIGlkID0gMjQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIFVzaW5nT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9Vc2luZ09ic2VydmFibGUnKTtcbmV4cG9ydHMudXNpbmcgPSBVc2luZ09ic2VydmFibGVfMS5Vc2luZ09ic2VydmFibGUuY3JlYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNpbmcuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb2JzZXJ2YWJsZS91c2luZy5qc1xuLy8gbW9kdWxlIGlkID0gMjQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHppcF8xID0gcmVxdWlyZSgnLi4vb3BlcmF0b3IvemlwJyk7XG5leHBvcnRzLnppcCA9IHppcF8xLnppcFN0YXRpYztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXppcC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vYnNlcnZhYmxlL3ppcC5qc1xuLy8gbW9kdWxlIGlkID0gMjUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgdHJ5Q2F0Y2hfMSA9IHJlcXVpcmUoJy4uL3V0aWwvdHJ5Q2F0Y2gnKTtcbnZhciBlcnJvck9iamVjdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9lcnJvck9iamVjdCcpO1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qKlxuICogSWdub3JlcyBzb3VyY2UgdmFsdWVzIGZvciBhIGR1cmF0aW9uIGRldGVybWluZWQgYnkgYW5vdGhlciBPYnNlcnZhYmxlLCB0aGVuXG4gKiBlbWl0cyB0aGUgbW9zdCByZWNlbnQgdmFsdWUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUsIHRoZW4gcmVwZWF0cyB0aGlzXG4gKiBwcm9jZXNzLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5JdCdzIGxpa2Uge0BsaW5rIGF1ZGl0VGltZX0sIGJ1dCB0aGUgc2lsZW5jaW5nXG4gKiBkdXJhdGlvbiBpcyBkZXRlcm1pbmVkIGJ5IGEgc2Vjb25kIE9ic2VydmFibGUuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvYXVkaXQucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYGF1ZGl0YCBpcyBzaW1pbGFyIHRvIGB0aHJvdHRsZWAsIGJ1dCBlbWl0cyB0aGUgbGFzdCB2YWx1ZSBmcm9tIHRoZSBzaWxlbmNlZFxuICogdGltZSB3aW5kb3csIGluc3RlYWQgb2YgdGhlIGZpcnN0IHZhbHVlLiBgYXVkaXRgIGVtaXRzIHRoZSBtb3N0IHJlY2VudCB2YWx1ZVxuICogZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlIGFzIHNvb24gYXMgaXRzIGludGVybmFsXG4gKiB0aW1lciBiZWNvbWVzIGRpc2FibGVkLCBhbmQgaWdub3JlcyBzb3VyY2UgdmFsdWVzIHdoaWxlIHRoZSB0aW1lciBpcyBlbmFibGVkLlxuICogSW5pdGlhbGx5LCB0aGUgdGltZXIgaXMgZGlzYWJsZWQuIEFzIHNvb24gYXMgdGhlIGZpcnN0IHNvdXJjZSB2YWx1ZSBhcnJpdmVzLFxuICogdGhlIHRpbWVyIGlzIGVuYWJsZWQgYnkgY2FsbGluZyB0aGUgYGR1cmF0aW9uU2VsZWN0b3JgIGZ1bmN0aW9uIHdpdGggdGhlXG4gKiBzb3VyY2UgdmFsdWUsIHdoaWNoIHJldHVybnMgdGhlIFwiZHVyYXRpb25cIiBPYnNlcnZhYmxlLiBXaGVuIHRoZSBkdXJhdGlvblxuICogT2JzZXJ2YWJsZSBlbWl0cyBhIHZhbHVlIG9yIGNvbXBsZXRlcywgdGhlIHRpbWVyIGlzIGRpc2FibGVkLCB0aGVuIHRoZSBtb3N0XG4gKiByZWNlbnQgc291cmNlIHZhbHVlIGlzIGVtaXR0ZWQgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLCBhbmQgdGhpcyBwcm9jZXNzXG4gKiByZXBlYXRzIGZvciB0aGUgbmV4dCBzb3VyY2UgdmFsdWUuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdCBjbGlja3MgYXQgYSByYXRlIG9mIGF0IG1vc3Qgb25lIGNsaWNrIHBlciBzZWNvbmQ8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy5hdWRpdChldiA9PiBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgYXVkaXRUaW1lfVxuICogQHNlZSB7QGxpbmsgZGVib3VuY2V9XG4gKiBAc2VlIHtAbGluayBkZWxheVdoZW59XG4gKiBAc2VlIHtAbGluayBzYW1wbGV9XG4gKiBAc2VlIHtAbGluayB0aHJvdHRsZX1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBUKTogU3Vic2NyaWJhYmxlT3JQcm9taXNlfSBkdXJhdGlvblNlbGVjdG9yIEEgZnVuY3Rpb25cbiAqIHRoYXQgcmVjZWl2ZXMgYSB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgZm9yIGNvbXB1dGluZyB0aGUgc2lsZW5jaW5nXG4gKiBkdXJhdGlvbiwgcmV0dXJuZWQgYXMgYW4gT2JzZXJ2YWJsZSBvciBhIFByb21pc2UuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBBbiBPYnNlcnZhYmxlIHRoYXQgcGVyZm9ybXMgcmF0ZS1saW1pdGluZyBvZlxuICogZW1pc3Npb25zIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCBhdWRpdFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gYXVkaXQoZHVyYXRpb25TZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IEF1ZGl0T3BlcmF0b3IoZHVyYXRpb25TZWxlY3RvcikpO1xufVxuZXhwb3J0cy5hdWRpdCA9IGF1ZGl0O1xudmFyIEF1ZGl0T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEF1ZGl0T3BlcmF0b3IoZHVyYXRpb25TZWxlY3Rvcikge1xuICAgICAgICB0aGlzLmR1cmF0aW9uU2VsZWN0b3IgPSBkdXJhdGlvblNlbGVjdG9yO1xuICAgIH1cbiAgICBBdWRpdE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgQXVkaXRTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuZHVyYXRpb25TZWxlY3RvcikpO1xuICAgIH07XG4gICAgcmV0dXJuIEF1ZGl0T3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBBdWRpdFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBdWRpdFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXVkaXRTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBkdXJhdGlvblNlbGVjdG9yKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5kdXJhdGlvblNlbGVjdG9yID0gZHVyYXRpb25TZWxlY3RvcjtcbiAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBBdWRpdFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IHRydWU7XG4gICAgICAgIGlmICghdGhpcy50aHJvdHRsZWQpIHtcbiAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9IHRyeUNhdGNoXzEudHJ5Q2F0Y2godGhpcy5kdXJhdGlvblNlbGVjdG9yKSh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoZHVyYXRpb24gPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZCh0aGlzLnRocm90dGxlZCA9IHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgZHVyYXRpb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQXVkaXRTdWJzY3JpYmVyLnByb3RvdHlwZS5jbGVhclRocm90dGxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCB2YWx1ZSA9IF9hLnZhbHVlLCBoYXNWYWx1ZSA9IF9hLmhhc1ZhbHVlLCB0aHJvdHRsZWQgPSBfYS50aHJvdHRsZWQ7XG4gICAgICAgIGlmICh0aHJvdHRsZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKHRocm90dGxlZCk7XG4gICAgICAgICAgICB0aGlzLnRocm90dGxlZCA9IG51bGw7XG4gICAgICAgICAgICB0aHJvdHRsZWQudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXVkaXRTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpIHtcbiAgICAgICAgdGhpcy5jbGVhclRocm90dGxlKCk7XG4gICAgfTtcbiAgICBBdWRpdFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNsZWFyVGhyb3R0bGUoKTtcbiAgICB9O1xuICAgIHJldHVybiBBdWRpdFN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXVkaXQuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3IvYXVkaXQuanNcbi8vIG1vZHVsZSBpZCA9IDI1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGFzeW5jXzEgPSByZXF1aXJlKCcuLi9zY2hlZHVsZXIvYXN5bmMnKTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG4vKipcbiAqIElnbm9yZXMgc291cmNlIHZhbHVlcyBmb3IgYGR1cmF0aW9uYCBtaWxsaXNlY29uZHMsIHRoZW4gZW1pdHMgdGhlIG1vc3QgcmVjZW50XG4gKiB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgdGhlbiByZXBlYXRzIHRoaXMgcHJvY2Vzcy5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+V2hlbiBpdCBzZWVzIGEgc291cmNlIHZhbHVlcywgaXQgaWdub3JlcyB0aGF0IHBsdXNcbiAqIHRoZSBuZXh0IG9uZXMgZm9yIGBkdXJhdGlvbmAgbWlsbGlzZWNvbmRzLCBhbmQgdGhlbiBpdCBlbWl0cyB0aGUgbW9zdCByZWNlbnRcbiAqIHZhbHVlIGZyb20gdGhlIHNvdXJjZS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9hdWRpdFRpbWUucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYGF1ZGl0VGltZWAgaXMgc2ltaWxhciB0byBgdGhyb3R0bGVUaW1lYCwgYnV0IGVtaXRzIHRoZSBsYXN0IHZhbHVlIGZyb20gdGhlXG4gKiBzaWxlbmNlZCB0aW1lIHdpbmRvdywgaW5zdGVhZCBvZiB0aGUgZmlyc3QgdmFsdWUuIGBhdWRpdFRpbWVgIGVtaXRzIHRoZSBtb3N0XG4gKiByZWNlbnQgdmFsdWUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlIGFzIHNvb24gYXNcbiAqIGl0cyBpbnRlcm5hbCB0aW1lciBiZWNvbWVzIGRpc2FibGVkLCBhbmQgaWdub3JlcyBzb3VyY2UgdmFsdWVzIHdoaWxlIHRoZVxuICogdGltZXIgaXMgZW5hYmxlZC4gSW5pdGlhbGx5LCB0aGUgdGltZXIgaXMgZGlzYWJsZWQuIEFzIHNvb24gYXMgdGhlIGZpcnN0XG4gKiBzb3VyY2UgdmFsdWUgYXJyaXZlcywgdGhlIHRpbWVyIGlzIGVuYWJsZWQuIEFmdGVyIGBkdXJhdGlvbmAgbWlsbGlzZWNvbmRzIChvclxuICogdGhlIHRpbWUgdW5pdCBkZXRlcm1pbmVkIGludGVybmFsbHkgYnkgdGhlIG9wdGlvbmFsIGBzY2hlZHVsZXJgKSBoYXMgcGFzc2VkLFxuICogdGhlIHRpbWVyIGlzIGRpc2FibGVkLCB0aGVuIHRoZSBtb3N0IHJlY2VudCBzb3VyY2UgdmFsdWUgaXMgZW1pdHRlZCBvbiB0aGVcbiAqIG91dHB1dCBPYnNlcnZhYmxlLCBhbmQgdGhpcyBwcm9jZXNzIHJlcGVhdHMgZm9yIHRoZSBuZXh0IHNvdXJjZSB2YWx1ZS5cbiAqIE9wdGlvbmFsbHkgdGFrZXMgYSB7QGxpbmsgSVNjaGVkdWxlcn0gZm9yIG1hbmFnaW5nIHRpbWVycy5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0IGNsaWNrcyBhdCBhIHJhdGUgb2YgYXQgbW9zdCBvbmUgY2xpY2sgcGVyIHNlY29uZDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLmF1ZGl0VGltZSgxMDAwKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgYXVkaXR9XG4gKiBAc2VlIHtAbGluayBkZWJvdW5jZVRpbWV9XG4gKiBAc2VlIHtAbGluayBkZWxheX1cbiAqIEBzZWUge0BsaW5rIHNhbXBsZVRpbWV9XG4gKiBAc2VlIHtAbGluayB0aHJvdHRsZVRpbWV9XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uIFRpbWUgdG8gd2FpdCBiZWZvcmUgZW1pdHRpbmcgdGhlIG1vc3QgcmVjZW50IHNvdXJjZVxuICogdmFsdWUsIG1lYXN1cmVkIGluIG1pbGxpc2Vjb25kcyBvciB0aGUgdGltZSB1bml0IGRldGVybWluZWQgaW50ZXJuYWxseVxuICogYnkgdGhlIG9wdGlvbmFsIGBzY2hlZHVsZXJgLlxuICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9YXN5bmNdIFRoZSB7QGxpbmsgSVNjaGVkdWxlcn0gdG8gdXNlIGZvclxuICogbWFuYWdpbmcgdGhlIHRpbWVycyB0aGF0IGhhbmRsZSB0aGUgcmF0ZS1saW1pdGluZyBiZWhhdmlvci5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IEFuIE9ic2VydmFibGUgdGhhdCBwZXJmb3JtcyByYXRlLWxpbWl0aW5nIG9mXG4gKiBlbWlzc2lvbnMgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIGF1ZGl0VGltZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gYXVkaXRUaW1lKGR1cmF0aW9uLCBzY2hlZHVsZXIpIHtcbiAgICBpZiAoc2NoZWR1bGVyID09PSB2b2lkIDApIHsgc2NoZWR1bGVyID0gYXN5bmNfMS5hc3luYzsgfVxuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IEF1ZGl0VGltZU9wZXJhdG9yKGR1cmF0aW9uLCBzY2hlZHVsZXIpKTtcbn1cbmV4cG9ydHMuYXVkaXRUaW1lID0gYXVkaXRUaW1lO1xudmFyIEF1ZGl0VGltZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBdWRpdFRpbWVPcGVyYXRvcihkdXJhdGlvbiwgc2NoZWR1bGVyKSB7XG4gICAgICAgIHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgfVxuICAgIEF1ZGl0VGltZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgQXVkaXRUaW1lU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmR1cmF0aW9uLCB0aGlzLnNjaGVkdWxlcikpO1xuICAgIH07XG4gICAgcmV0dXJuIEF1ZGl0VGltZU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgQXVkaXRUaW1lU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEF1ZGl0VGltZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXVkaXRUaW1lU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgZHVyYXRpb24sIHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIHRoaXMuaGFzVmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gICAgQXVkaXRUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLnRocm90dGxlZCkge1xuICAgICAgICAgICAgdGhpcy5hZGQodGhpcy50aHJvdHRsZWQgPSB0aGlzLnNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaE5leHQsIHRoaXMuZHVyYXRpb24sIHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXVkaXRUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUuY2xlYXJUaHJvdHRsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgdmFsdWUgPSBfYS52YWx1ZSwgaGFzVmFsdWUgPSBfYS5oYXNWYWx1ZSwgdGhyb3R0bGVkID0gX2EudGhyb3R0bGVkO1xuICAgICAgICBpZiAodGhyb3R0bGVkKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZSh0aHJvdHRsZWQpO1xuICAgICAgICAgICAgdGhpcy50aHJvdHRsZWQgPSBudWxsO1xuICAgICAgICAgICAgdGhyb3R0bGVkLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc1ZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuaGFzVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBBdWRpdFRpbWVTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuZnVuY3Rpb24gZGlzcGF0Y2hOZXh0KHN1YnNjcmliZXIpIHtcbiAgICBzdWJzY3JpYmVyLmNsZWFyVGhyb3R0bGUoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1ZGl0VGltZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvci9hdWRpdFRpbWUuanNcbi8vIG1vZHVsZSBpZCA9IDI1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qKlxuICogQnVmZmVycyB0aGUgc291cmNlIE9ic2VydmFibGUgdmFsdWVzIHVudGlsIGBjbG9zaW5nTm90aWZpZXJgIGVtaXRzLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5Db2xsZWN0cyB2YWx1ZXMgZnJvbSB0aGUgcGFzdCBhcyBhbiBhcnJheSwgYW5kIGVtaXRzXG4gKiB0aGF0IGFycmF5IG9ubHkgd2hlbiBhbm90aGVyIE9ic2VydmFibGUgZW1pdHMuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvYnVmZmVyLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEJ1ZmZlcnMgdGhlIGluY29taW5nIE9ic2VydmFibGUgdmFsdWVzIHVudGlsIHRoZSBnaXZlbiBgY2xvc2luZ05vdGlmaWVyYFxuICogT2JzZXJ2YWJsZSBlbWl0cyBhIHZhbHVlLCBhdCB3aGljaCBwb2ludCBpdCBlbWl0cyB0aGUgYnVmZmVyIG9uIHRoZSBvdXRwdXRcbiAqIE9ic2VydmFibGUgYW5kIHN0YXJ0cyBhIG5ldyBidWZmZXIgaW50ZXJuYWxseSwgYXdhaXRpbmcgdGhlIG5leHQgdGltZVxuICogYGNsb3NpbmdOb3RpZmllcmAgZW1pdHMuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+T24gZXZlcnkgY2xpY2ssIGVtaXQgYXJyYXkgb2YgbW9zdCByZWNlbnQgaW50ZXJ2YWwgZXZlbnRzPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBpbnRlcnZhbCA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gKiB2YXIgYnVmZmVyZWQgPSBpbnRlcnZhbC5idWZmZXIoY2xpY2tzKTtcbiAqIGJ1ZmZlcmVkLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBidWZmZXJDb3VudH1cbiAqIEBzZWUge0BsaW5rIGJ1ZmZlclRpbWV9XG4gKiBAc2VlIHtAbGluayBidWZmZXJUb2dnbGV9XG4gKiBAc2VlIHtAbGluayBidWZmZXJXaGVufVxuICogQHNlZSB7QGxpbmsgd2luZG93fVxuICpcbiAqIEBwYXJhbSB7T2JzZXJ2YWJsZTxhbnk+fSBjbG9zaW5nTm90aWZpZXIgQW4gT2JzZXJ2YWJsZSB0aGF0IHNpZ25hbHMgdGhlXG4gKiBidWZmZXIgdG8gYmUgZW1pdHRlZCBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFRbXT59IEFuIE9ic2VydmFibGUgb2YgYnVmZmVycywgd2hpY2ggYXJlIGFycmF5cyBvZlxuICogdmFsdWVzLlxuICogQG1ldGhvZCBidWZmZXJcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGJ1ZmZlcihjbG9zaW5nTm90aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBCdWZmZXJPcGVyYXRvcihjbG9zaW5nTm90aWZpZXIpKTtcbn1cbmV4cG9ydHMuYnVmZmVyID0gYnVmZmVyO1xudmFyIEJ1ZmZlck9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCdWZmZXJPcGVyYXRvcihjbG9zaW5nTm90aWZpZXIpIHtcbiAgICAgICAgdGhpcy5jbG9zaW5nTm90aWZpZXIgPSBjbG9zaW5nTm90aWZpZXI7XG4gICAgfVxuICAgIEJ1ZmZlck9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgQnVmZmVyU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmNsb3NpbmdOb3RpZmllcikpO1xuICAgIH07XG4gICAgcmV0dXJuIEJ1ZmZlck9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgQnVmZmVyU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJ1ZmZlclN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQnVmZmVyU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgY2xvc2luZ05vdGlmaWVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5hZGQoc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBjbG9zaW5nTm90aWZpZXIpKTtcbiAgICB9XG4gICAgQnVmZmVyU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5idWZmZXIucHVzaCh2YWx1ZSk7XG4gICAgfTtcbiAgICBCdWZmZXJTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KGJ1ZmZlcik7XG4gICAgfTtcbiAgICByZXR1cm4gQnVmZmVyU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWZmZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3IvYnVmZmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG4vKipcbiAqIEJ1ZmZlcnMgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHZhbHVlcyB1bnRpbCB0aGUgc2l6ZSBoaXRzIHRoZSBtYXhpbXVtXG4gKiBgYnVmZmVyU2l6ZWAgZ2l2ZW4uXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkNvbGxlY3RzIHZhbHVlcyBmcm9tIHRoZSBwYXN0IGFzIGFuIGFycmF5LCBhbmQgZW1pdHNcbiAqIHRoYXQgYXJyYXkgb25seSB3aGVuIGl0cyBzaXplIHJlYWNoZXMgYGJ1ZmZlclNpemVgLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2J1ZmZlckNvdW50LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEJ1ZmZlcnMgYSBudW1iZXIgb2YgdmFsdWVzIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGJ5IGBidWZmZXJTaXplYCB0aGVuXG4gKiBlbWl0cyB0aGUgYnVmZmVyIGFuZCBjbGVhcnMgaXQsIGFuZCBzdGFydHMgYSBuZXcgYnVmZmVyIGVhY2hcbiAqIGBzdGFydEJ1ZmZlckV2ZXJ5YCB2YWx1ZXMuIElmIGBzdGFydEJ1ZmZlckV2ZXJ5YCBpcyBub3QgcHJvdmlkZWQgb3IgaXNcbiAqIGBudWxsYCwgdGhlbiBuZXcgYnVmZmVycyBhcmUgc3RhcnRlZCBpbW1lZGlhdGVseSBhdCB0aGUgc3RhcnQgb2YgdGhlIHNvdXJjZVxuICogYW5kIHdoZW4gZWFjaCBidWZmZXIgY2xvc2VzIGFuZCBpcyBlbWl0dGVkLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgdGhlIGxhc3QgdHdvIGNsaWNrIGV2ZW50cyBhcyBhbiBhcnJheTwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgYnVmZmVyZWQgPSBjbGlja3MuYnVmZmVyQ291bnQoMik7XG4gKiBidWZmZXJlZC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+T24gZXZlcnkgY2xpY2ssIGVtaXQgdGhlIGxhc3QgdHdvIGNsaWNrIGV2ZW50cyBhcyBhbiBhcnJheTwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgYnVmZmVyZWQgPSBjbGlja3MuYnVmZmVyQ291bnQoMiwgMSk7XG4gKiBidWZmZXJlZC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgYnVmZmVyfVxuICogQHNlZSB7QGxpbmsgYnVmZmVyVGltZX1cbiAqIEBzZWUge0BsaW5rIGJ1ZmZlclRvZ2dsZX1cbiAqIEBzZWUge0BsaW5rIGJ1ZmZlcldoZW59XG4gKiBAc2VlIHtAbGluayBwYWlyd2lzZX1cbiAqIEBzZWUge0BsaW5rIHdpbmRvd0NvdW50fVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBidWZmZXJTaXplIFRoZSBtYXhpbXVtIHNpemUgb2YgdGhlIGJ1ZmZlciBlbWl0dGVkLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydEJ1ZmZlckV2ZXJ5XSBJbnRlcnZhbCBhdCB3aGljaCB0byBzdGFydCBhIG5ldyBidWZmZXIuXG4gKiBGb3IgZXhhbXBsZSBpZiBgc3RhcnRCdWZmZXJFdmVyeWAgaXMgYDJgLCB0aGVuIGEgbmV3IGJ1ZmZlciB3aWxsIGJlIHN0YXJ0ZWRcbiAqIG9uIGV2ZXJ5IG90aGVyIHZhbHVlIGZyb20gdGhlIHNvdXJjZS4gQSBuZXcgYnVmZmVyIGlzIHN0YXJ0ZWQgYXQgdGhlXG4gKiBiZWdpbm5pbmcgb2YgdGhlIHNvdXJjZSBieSBkZWZhdWx0LlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUW10+fSBBbiBPYnNlcnZhYmxlIG9mIGFycmF5cyBvZiBidWZmZXJlZCB2YWx1ZXMuXG4gKiBAbWV0aG9kIGJ1ZmZlckNvdW50XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBidWZmZXJDb3VudChidWZmZXJTaXplLCBzdGFydEJ1ZmZlckV2ZXJ5KSB7XG4gICAgaWYgKHN0YXJ0QnVmZmVyRXZlcnkgPT09IHZvaWQgMCkgeyBzdGFydEJ1ZmZlckV2ZXJ5ID0gbnVsbDsgfVxuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IEJ1ZmZlckNvdW50T3BlcmF0b3IoYnVmZmVyU2l6ZSwgc3RhcnRCdWZmZXJFdmVyeSkpO1xufVxuZXhwb3J0cy5idWZmZXJDb3VudCA9IGJ1ZmZlckNvdW50O1xudmFyIEJ1ZmZlckNvdW50T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJ1ZmZlckNvdW50T3BlcmF0b3IoYnVmZmVyU2l6ZSwgc3RhcnRCdWZmZXJFdmVyeSkge1xuICAgICAgICB0aGlzLmJ1ZmZlclNpemUgPSBidWZmZXJTaXplO1xuICAgICAgICB0aGlzLnN0YXJ0QnVmZmVyRXZlcnkgPSBzdGFydEJ1ZmZlckV2ZXJ5O1xuICAgIH1cbiAgICBCdWZmZXJDb3VudE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgQnVmZmVyQ291bnRTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuYnVmZmVyU2l6ZSwgdGhpcy5zdGFydEJ1ZmZlckV2ZXJ5KSk7XG4gICAgfTtcbiAgICByZXR1cm4gQnVmZmVyQ291bnRPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIEJ1ZmZlckNvdW50U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJ1ZmZlckNvdW50U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCdWZmZXJDb3VudFN1YnNjcmliZXIoZGVzdGluYXRpb24sIGJ1ZmZlclNpemUsIHN0YXJ0QnVmZmVyRXZlcnkpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmJ1ZmZlclNpemUgPSBidWZmZXJTaXplO1xuICAgICAgICB0aGlzLnN0YXJ0QnVmZmVyRXZlcnkgPSBzdGFydEJ1ZmZlckV2ZXJ5O1xuICAgICAgICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgfVxuICAgIEJ1ZmZlckNvdW50U3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5jb3VudCsrO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBkZXN0aW5hdGlvbiA9IF9hLmRlc3RpbmF0aW9uLCBidWZmZXJTaXplID0gX2EuYnVmZmVyU2l6ZSwgc3RhcnRCdWZmZXJFdmVyeSA9IF9hLnN0YXJ0QnVmZmVyRXZlcnksIGJ1ZmZlcnMgPSBfYS5idWZmZXJzO1xuICAgICAgICB2YXIgc3RhcnRPbiA9IChzdGFydEJ1ZmZlckV2ZXJ5ID09IG51bGwpID8gYnVmZmVyU2l6ZSA6IHN0YXJ0QnVmZmVyRXZlcnk7XG4gICAgICAgIGlmIChjb3VudCAlIHN0YXJ0T24gPT09IDApIHtcbiAgICAgICAgICAgIGJ1ZmZlcnMucHVzaChbXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IGJ1ZmZlcnMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgICB2YXIgYnVmZmVyID0gYnVmZmVyc1tpXTtcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChidWZmZXIubGVuZ3RoID09PSBidWZmZXJTaXplKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dChidWZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBCdWZmZXJDb3VudFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgdmFyIGJ1ZmZlcnMgPSB0aGlzLmJ1ZmZlcnM7XG4gICAgICAgIHdoaWxlIChidWZmZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBidWZmZXIgPSBidWZmZXJzLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KGJ1ZmZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fY29tcGxldGUuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBCdWZmZXJDb3VudFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWZmZXJDb3VudC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvci9idWZmZXJDb3VudC5qc1xuLy8gbW9kdWxlIGlkID0gMjU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJy4uL3NjaGVkdWxlci9hc3luYycpO1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBpc1NjaGVkdWxlcl8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc1NjaGVkdWxlcicpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogQnVmZmVycyB0aGUgc291cmNlIE9ic2VydmFibGUgdmFsdWVzIGZvciBhIHNwZWNpZmljIHRpbWUgcGVyaW9kLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5Db2xsZWN0cyB2YWx1ZXMgZnJvbSB0aGUgcGFzdCBhcyBhbiBhcnJheSwgYW5kIGVtaXRzXG4gKiB0aG9zZSBhcnJheXMgcGVyaW9kaWNhbGx5IGluIHRpbWUuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvYnVmZmVyVGltZS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBCdWZmZXJzIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2UgZm9yIGEgc3BlY2lmaWMgdGltZSBkdXJhdGlvbiBgYnVmZmVyVGltZVNwYW5gLlxuICogVW5sZXNzIHRoZSBvcHRpb25hbCBhcmd1bWVudCBgYnVmZmVyQ3JlYXRpb25JbnRlcnZhbGAgaXMgZ2l2ZW4sIGl0IGVtaXRzIGFuZFxuICogcmVzZXRzIHRoZSBidWZmZXIgZXZlcnkgYGJ1ZmZlclRpbWVTcGFuYCBtaWxsaXNlY29uZHMuIElmXG4gKiBgYnVmZmVyQ3JlYXRpb25JbnRlcnZhbGAgaXMgZ2l2ZW4sIHRoaXMgb3BlcmF0b3Igb3BlbnMgdGhlIGJ1ZmZlciBldmVyeVxuICogYGJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWxgIG1pbGxpc2Vjb25kcyBhbmQgY2xvc2VzIChlbWl0cyBhbmQgcmVzZXRzKSB0aGVcbiAqIGJ1ZmZlciBldmVyeSBgYnVmZmVyVGltZVNwYW5gIG1pbGxpc2Vjb25kcy4gV2hlbiB0aGUgb3B0aW9uYWwgYXJndW1lbnRcbiAqIGBtYXhCdWZmZXJTaXplYCBpcyBzcGVjaWZpZWQsIHRoZSBidWZmZXIgd2lsbCBiZSBjbG9zZWQgZWl0aGVyIGFmdGVyXG4gKiBgYnVmZmVyVGltZVNwYW5gIG1pbGxpc2Vjb25kcyBvciB3aGVuIGl0IGNvbnRhaW5zIGBtYXhCdWZmZXJTaXplYCBlbGVtZW50cy5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FdmVyeSBzZWNvbmQsIGVtaXQgYW4gYXJyYXkgb2YgdGhlIHJlY2VudCBjbGljayBldmVudHM8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIGJ1ZmZlcmVkID0gY2xpY2tzLmJ1ZmZlclRpbWUoMTAwMCk7XG4gKiBidWZmZXJlZC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RXZlcnkgNSBzZWNvbmRzLCBlbWl0IHRoZSBjbGljayBldmVudHMgZnJvbSB0aGUgbmV4dCAyIHNlY29uZHM8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIGJ1ZmZlcmVkID0gY2xpY2tzLmJ1ZmZlclRpbWUoMjAwMCwgNTAwMCk7XG4gKiBidWZmZXJlZC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgYnVmZmVyfVxuICogQHNlZSB7QGxpbmsgYnVmZmVyQ291bnR9XG4gKiBAc2VlIHtAbGluayBidWZmZXJUb2dnbGV9XG4gKiBAc2VlIHtAbGluayBidWZmZXJXaGVufVxuICogQHNlZSB7QGxpbmsgd2luZG93VGltZX1cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gYnVmZmVyVGltZVNwYW4gVGhlIGFtb3VudCBvZiB0aW1lIHRvIGZpbGwgZWFjaCBidWZmZXIgYXJyYXkuXG4gKiBAcGFyYW0ge251bWJlcn0gW2J1ZmZlckNyZWF0aW9uSW50ZXJ2YWxdIFRoZSBpbnRlcnZhbCBhdCB3aGljaCB0byBzdGFydCBuZXdcbiAqIGJ1ZmZlcnMuXG4gKiBAcGFyYW0ge251bWJlcn0gW21heEJ1ZmZlclNpemVdIFRoZSBtYXhpbXVtIGJ1ZmZlciBzaXplLlxuICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9YXN5bmNdIFRoZSBzY2hlZHVsZXIgb24gd2hpY2ggdG8gc2NoZWR1bGUgdGhlXG4gKiBpbnRlcnZhbHMgdGhhdCBkZXRlcm1pbmUgYnVmZmVyIGJvdW5kYXJpZXMuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFRbXT59IEFuIG9ic2VydmFibGUgb2YgYXJyYXlzIG9mIGJ1ZmZlcmVkIHZhbHVlcy5cbiAqIEBtZXRob2QgYnVmZmVyVGltZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gYnVmZmVyVGltZShidWZmZXJUaW1lU3Bhbikge1xuICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBzY2hlZHVsZXIgPSBhc3luY18xLmFzeW5jO1xuICAgIGlmIChpc1NjaGVkdWxlcl8xLmlzU2NoZWR1bGVyKGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgIHNjaGVkdWxlciA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGxlbmd0aC0tO1xuICAgIH1cbiAgICB2YXIgYnVmZmVyQ3JlYXRpb25JbnRlcnZhbCA9IG51bGw7XG4gICAgaWYgKGxlbmd0aCA+PSAyKSB7XG4gICAgICAgIGJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWwgPSBhcmd1bWVudHNbMV07XG4gICAgfVxuICAgIHZhciBtYXhCdWZmZXJTaXplID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGlmIChsZW5ndGggPj0gMykge1xuICAgICAgICBtYXhCdWZmZXJTaXplID0gYXJndW1lbnRzWzJdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBCdWZmZXJUaW1lT3BlcmF0b3IoYnVmZmVyVGltZVNwYW4sIGJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWwsIG1heEJ1ZmZlclNpemUsIHNjaGVkdWxlcikpO1xufVxuZXhwb3J0cy5idWZmZXJUaW1lID0gYnVmZmVyVGltZTtcbnZhciBCdWZmZXJUaW1lT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJ1ZmZlclRpbWVPcGVyYXRvcihidWZmZXJUaW1lU3BhbiwgYnVmZmVyQ3JlYXRpb25JbnRlcnZhbCwgbWF4QnVmZmVyU2l6ZSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyVGltZVNwYW4gPSBidWZmZXJUaW1lU3BhbjtcbiAgICAgICAgdGhpcy5idWZmZXJDcmVhdGlvbkludGVydmFsID0gYnVmZmVyQ3JlYXRpb25JbnRlcnZhbDtcbiAgICAgICAgdGhpcy5tYXhCdWZmZXJTaXplID0gbWF4QnVmZmVyU2l6ZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgfVxuICAgIEJ1ZmZlclRpbWVPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IEJ1ZmZlclRpbWVTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuYnVmZmVyVGltZVNwYW4sIHRoaXMuYnVmZmVyQ3JlYXRpb25JbnRlcnZhbCwgdGhpcy5tYXhCdWZmZXJTaXplLCB0aGlzLnNjaGVkdWxlcikpO1xuICAgIH07XG4gICAgcmV0dXJuIEJ1ZmZlclRpbWVPcGVyYXRvcjtcbn0oKSk7XG52YXIgQ29udGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29udGV4dCgpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIENvbnRleHQ7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBCdWZmZXJUaW1lU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJ1ZmZlclRpbWVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJ1ZmZlclRpbWVTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBidWZmZXJUaW1lU3BhbiwgYnVmZmVyQ3JlYXRpb25JbnRlcnZhbCwgbWF4QnVmZmVyU2l6ZSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5idWZmZXJUaW1lU3BhbiA9IGJ1ZmZlclRpbWVTcGFuO1xuICAgICAgICB0aGlzLmJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWwgPSBidWZmZXJDcmVhdGlvbkludGVydmFsO1xuICAgICAgICB0aGlzLm1heEJ1ZmZlclNpemUgPSBtYXhCdWZmZXJTaXplO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgdGhpcy5jb250ZXh0cyA9IFtdO1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMub3BlbkNvbnRleHQoKTtcbiAgICAgICAgdGhpcy50aW1lc3Bhbk9ubHkgPSBidWZmZXJDcmVhdGlvbkludGVydmFsID09IG51bGwgfHwgYnVmZmVyQ3JlYXRpb25JbnRlcnZhbCA8IDA7XG4gICAgICAgIGlmICh0aGlzLnRpbWVzcGFuT25seSkge1xuICAgICAgICAgICAgdmFyIHRpbWVTcGFuT25seVN0YXRlID0geyBzdWJzY3JpYmVyOiB0aGlzLCBjb250ZXh0OiBjb250ZXh0LCBidWZmZXJUaW1lU3BhbjogYnVmZmVyVGltZVNwYW4gfTtcbiAgICAgICAgICAgIHRoaXMuYWRkKGNvbnRleHQuY2xvc2VBY3Rpb24gPSBzY2hlZHVsZXIuc2NoZWR1bGUoZGlzcGF0Y2hCdWZmZXJUaW1lU3Bhbk9ubHksIGJ1ZmZlclRpbWVTcGFuLCB0aW1lU3Bhbk9ubHlTdGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNsb3NlU3RhdGUgPSB7IHN1YnNjcmliZXI6IHRoaXMsIGNvbnRleHQ6IGNvbnRleHQgfTtcbiAgICAgICAgICAgIHZhciBjcmVhdGlvblN0YXRlID0geyBidWZmZXJUaW1lU3BhbjogYnVmZmVyVGltZVNwYW4sIGJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWw6IGJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWwsIHN1YnNjcmliZXI6IHRoaXMsIHNjaGVkdWxlcjogc2NoZWR1bGVyIH07XG4gICAgICAgICAgICB0aGlzLmFkZChjb250ZXh0LmNsb3NlQWN0aW9uID0gc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoQnVmZmVyQ2xvc2UsIGJ1ZmZlclRpbWVTcGFuLCBjbG9zZVN0YXRlKSk7XG4gICAgICAgICAgICB0aGlzLmFkZChzY2hlZHVsZXIuc2NoZWR1bGUoZGlzcGF0Y2hCdWZmZXJDcmVhdGlvbiwgYnVmZmVyQ3JlYXRpb25JbnRlcnZhbCwgY3JlYXRpb25TdGF0ZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIEJ1ZmZlclRpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgY29udGV4dHMgPSB0aGlzLmNvbnRleHRzO1xuICAgICAgICB2YXIgbGVuID0gY29udGV4dHMubGVuZ3RoO1xuICAgICAgICB2YXIgZmlsbGVkQnVmZmVyQ29udGV4dDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBjb250ZXh0c1tpXTtcbiAgICAgICAgICAgIHZhciBidWZmZXIgPSBjb250ZXh0LmJ1ZmZlcjtcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChidWZmZXIubGVuZ3RoID09IHRoaXMubWF4QnVmZmVyU2l6ZSkge1xuICAgICAgICAgICAgICAgIGZpbGxlZEJ1ZmZlckNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmaWxsZWRCdWZmZXJDb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm9uQnVmZmVyRnVsbChmaWxsZWRCdWZmZXJDb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQnVmZmVyVGltZVN1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0cy5sZW5ndGggPSAwO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9lcnJvci5jYWxsKHRoaXMsIGVycik7XG4gICAgfTtcbiAgICBCdWZmZXJUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBjb250ZXh0cyA9IF9hLmNvbnRleHRzLCBkZXN0aW5hdGlvbiA9IF9hLmRlc3RpbmF0aW9uO1xuICAgICAgICB3aGlsZSAoY29udGV4dHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBjb250ZXh0cy5zaGlmdCgpO1xuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dChjb250ZXh0LmJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fY29tcGxldGUuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIEJ1ZmZlclRpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29udGV4dHMgPSBudWxsO1xuICAgIH07XG4gICAgQnVmZmVyVGltZVN1YnNjcmliZXIucHJvdG90eXBlLm9uQnVmZmVyRnVsbCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuY2xvc2VDb250ZXh0KGNvbnRleHQpO1xuICAgICAgICB2YXIgY2xvc2VBY3Rpb24gPSBjb250ZXh0LmNsb3NlQWN0aW9uO1xuICAgICAgICBjbG9zZUFjdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLnJlbW92ZShjbG9zZUFjdGlvbik7XG4gICAgICAgIGlmICghdGhpcy5jbG9zZWQgJiYgdGhpcy50aW1lc3Bhbk9ubHkpIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSB0aGlzLm9wZW5Db250ZXh0KCk7XG4gICAgICAgICAgICB2YXIgYnVmZmVyVGltZVNwYW4gPSB0aGlzLmJ1ZmZlclRpbWVTcGFuO1xuICAgICAgICAgICAgdmFyIHRpbWVTcGFuT25seVN0YXRlID0geyBzdWJzY3JpYmVyOiB0aGlzLCBjb250ZXh0OiBjb250ZXh0LCBidWZmZXJUaW1lU3BhbjogYnVmZmVyVGltZVNwYW4gfTtcbiAgICAgICAgICAgIHRoaXMuYWRkKGNvbnRleHQuY2xvc2VBY3Rpb24gPSB0aGlzLnNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaEJ1ZmZlclRpbWVTcGFuT25seSwgYnVmZmVyVGltZVNwYW4sIHRpbWVTcGFuT25seVN0YXRlKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJ1ZmZlclRpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5vcGVuQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCgpO1xuICAgICAgICB0aGlzLmNvbnRleHRzLnB1c2goY29udGV4dCk7XG4gICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH07XG4gICAgQnVmZmVyVGltZVN1YnNjcmliZXIucHJvdG90eXBlLmNsb3NlQ29udGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChjb250ZXh0LmJ1ZmZlcik7XG4gICAgICAgIHZhciBjb250ZXh0cyA9IHRoaXMuY29udGV4dHM7XG4gICAgICAgIHZhciBzcGxpY2VJbmRleCA9IGNvbnRleHRzID8gY29udGV4dHMuaW5kZXhPZihjb250ZXh0KSA6IC0xO1xuICAgICAgICBpZiAoc3BsaWNlSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgY29udGV4dHMuc3BsaWNlKGNvbnRleHRzLmluZGV4T2YoY29udGV4dCksIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQnVmZmVyVGltZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5mdW5jdGlvbiBkaXNwYXRjaEJ1ZmZlclRpbWVTcGFuT25seShzdGF0ZSkge1xuICAgIHZhciBzdWJzY3JpYmVyID0gc3RhdGUuc3Vic2NyaWJlcjtcbiAgICB2YXIgcHJldkNvbnRleHQgPSBzdGF0ZS5jb250ZXh0O1xuICAgIGlmIChwcmV2Q29udGV4dCkge1xuICAgICAgICBzdWJzY3JpYmVyLmNsb3NlQ29udGV4dChwcmV2Q29udGV4dCk7XG4gICAgfVxuICAgIGlmICghc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgc3RhdGUuY29udGV4dCA9IHN1YnNjcmliZXIub3BlbkNvbnRleHQoKTtcbiAgICAgICAgc3RhdGUuY29udGV4dC5jbG9zZUFjdGlvbiA9IHRoaXMuc2NoZWR1bGUoc3RhdGUsIHN0YXRlLmJ1ZmZlclRpbWVTcGFuKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkaXNwYXRjaEJ1ZmZlckNyZWF0aW9uKHN0YXRlKSB7XG4gICAgdmFyIGJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWwgPSBzdGF0ZS5idWZmZXJDcmVhdGlvbkludGVydmFsLCBidWZmZXJUaW1lU3BhbiA9IHN0YXRlLmJ1ZmZlclRpbWVTcGFuLCBzdWJzY3JpYmVyID0gc3RhdGUuc3Vic2NyaWJlciwgc2NoZWR1bGVyID0gc3RhdGUuc2NoZWR1bGVyO1xuICAgIHZhciBjb250ZXh0ID0gc3Vic2NyaWJlci5vcGVuQ29udGV4dCgpO1xuICAgIHZhciBhY3Rpb24gPSB0aGlzO1xuICAgIGlmICghc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgc3Vic2NyaWJlci5hZGQoY29udGV4dC5jbG9zZUFjdGlvbiA9IHNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaEJ1ZmZlckNsb3NlLCBidWZmZXJUaW1lU3BhbiwgeyBzdWJzY3JpYmVyOiBzdWJzY3JpYmVyLCBjb250ZXh0OiBjb250ZXh0IH0pKTtcbiAgICAgICAgYWN0aW9uLnNjaGVkdWxlKHN0YXRlLCBidWZmZXJDcmVhdGlvbkludGVydmFsKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkaXNwYXRjaEJ1ZmZlckNsb3NlKGFyZykge1xuICAgIHZhciBzdWJzY3JpYmVyID0gYXJnLnN1YnNjcmliZXIsIGNvbnRleHQgPSBhcmcuY29udGV4dDtcbiAgICBzdWJzY3JpYmVyLmNsb3NlQ29udGV4dChjb250ZXh0KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1ZmZlclRpbWUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3IvYnVmZmVyVGltZS5qc1xuLy8gbW9kdWxlIGlkID0gMjU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpcHRpb24nKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG4vKipcbiAqIEJ1ZmZlcnMgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHZhbHVlcyBzdGFydGluZyBmcm9tIGFuIGVtaXNzaW9uIGZyb21cbiAqIGBvcGVuaW5nc2AgYW5kIGVuZGluZyB3aGVuIHRoZSBvdXRwdXQgb2YgYGNsb3NpbmdTZWxlY3RvcmAgZW1pdHMuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkNvbGxlY3RzIHZhbHVlcyBmcm9tIHRoZSBwYXN0IGFzIGFuIGFycmF5LiBTdGFydHNcbiAqIGNvbGxlY3Rpbmcgb25seSB3aGVuIGBvcGVuaW5nYCBlbWl0cywgYW5kIGNhbGxzIHRoZSBgY2xvc2luZ1NlbGVjdG9yYFxuICogZnVuY3Rpb24gdG8gZ2V0IGFuIE9ic2VydmFibGUgdGhhdCB0ZWxscyB3aGVuIHRvIGNsb3NlIHRoZSBidWZmZXIuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvYnVmZmVyVG9nZ2xlLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEJ1ZmZlcnMgdmFsdWVzIGZyb20gdGhlIHNvdXJjZSBieSBvcGVuaW5nIHRoZSBidWZmZXIgdmlhIHNpZ25hbHMgZnJvbSBhblxuICogT2JzZXJ2YWJsZSBwcm92aWRlZCB0byBgb3BlbmluZ3NgLCBhbmQgY2xvc2luZyBhbmQgc2VuZGluZyB0aGUgYnVmZmVycyB3aGVuXG4gKiBhIFN1YnNjcmliYWJsZSBvciBQcm9taXNlIHJldHVybmVkIGJ5IHRoZSBgY2xvc2luZ1NlbGVjdG9yYCBmdW5jdGlvbiBlbWl0cy5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FdmVyeSBvdGhlciBzZWNvbmQsIGVtaXQgdGhlIGNsaWNrIGV2ZW50cyBmcm9tIHRoZSBuZXh0IDUwMG1zPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBvcGVuaW5ncyA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gKiB2YXIgYnVmZmVyZWQgPSBjbGlja3MuYnVmZmVyVG9nZ2xlKG9wZW5pbmdzLCBpID0+XG4gKiAgIGkgJSAyID8gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCg1MDApIDogUnguT2JzZXJ2YWJsZS5lbXB0eSgpXG4gKiApO1xuICogYnVmZmVyZWQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGJ1ZmZlcn1cbiAqIEBzZWUge0BsaW5rIGJ1ZmZlckNvdW50fVxuICogQHNlZSB7QGxpbmsgYnVmZmVyVGltZX1cbiAqIEBzZWUge0BsaW5rIGJ1ZmZlcldoZW59XG4gKiBAc2VlIHtAbGluayB3aW5kb3dUb2dnbGV9XG4gKlxuICogQHBhcmFtIHtTdWJzY3JpYmFibGVPclByb21pc2U8Tz59IG9wZW5pbmdzIEEgU3Vic2NyaWJhYmxlIG9yIFByb21pc2Ugb2Ygbm90aWZpY2F0aW9ucyB0byBzdGFydCBuZXdcbiAqIGJ1ZmZlcnMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBPKTogU3Vic2NyaWJhYmxlT3JQcm9taXNlfSBjbG9zaW5nU2VsZWN0b3IgQSBmdW5jdGlvbiB0aGF0IHRha2VzXG4gKiB0aGUgdmFsdWUgZW1pdHRlZCBieSB0aGUgYG9wZW5pbmdzYCBvYnNlcnZhYmxlIGFuZCByZXR1cm5zIGEgU3Vic2NyaWJhYmxlIG9yIFByb21pc2UsXG4gKiB3aGljaCwgd2hlbiBpdCBlbWl0cywgc2lnbmFscyB0aGF0IHRoZSBhc3NvY2lhdGVkIGJ1ZmZlciBzaG91bGQgYmUgZW1pdHRlZFxuICogYW5kIGNsZWFyZWQuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFRbXT59IEFuIG9ic2VydmFibGUgb2YgYXJyYXlzIG9mIGJ1ZmZlcmVkIHZhbHVlcy5cbiAqIEBtZXRob2QgYnVmZmVyVG9nZ2xlXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBidWZmZXJUb2dnbGUob3BlbmluZ3MsIGNsb3NpbmdTZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IEJ1ZmZlclRvZ2dsZU9wZXJhdG9yKG9wZW5pbmdzLCBjbG9zaW5nU2VsZWN0b3IpKTtcbn1cbmV4cG9ydHMuYnVmZmVyVG9nZ2xlID0gYnVmZmVyVG9nZ2xlO1xudmFyIEJ1ZmZlclRvZ2dsZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCdWZmZXJUb2dnbGVPcGVyYXRvcihvcGVuaW5ncywgY2xvc2luZ1NlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMub3BlbmluZ3MgPSBvcGVuaW5ncztcbiAgICAgICAgdGhpcy5jbG9zaW5nU2VsZWN0b3IgPSBjbG9zaW5nU2VsZWN0b3I7XG4gICAgfVxuICAgIEJ1ZmZlclRvZ2dsZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgQnVmZmVyVG9nZ2xlU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLm9wZW5pbmdzLCB0aGlzLmNsb3NpbmdTZWxlY3RvcikpO1xuICAgIH07XG4gICAgcmV0dXJuIEJ1ZmZlclRvZ2dsZU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgQnVmZmVyVG9nZ2xlU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJ1ZmZlclRvZ2dsZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQnVmZmVyVG9nZ2xlU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgb3BlbmluZ3MsIGNsb3NpbmdTZWxlY3Rvcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMub3BlbmluZ3MgPSBvcGVuaW5ncztcbiAgICAgICAgdGhpcy5jbG9zaW5nU2VsZWN0b3IgPSBjbG9zaW5nU2VsZWN0b3I7XG4gICAgICAgIHRoaXMuY29udGV4dHMgPSBbXTtcbiAgICAgICAgdGhpcy5hZGQoc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBvcGVuaW5ncykpO1xuICAgIH1cbiAgICBCdWZmZXJUb2dnbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgY29udGV4dHMgPSB0aGlzLmNvbnRleHRzO1xuICAgICAgICB2YXIgbGVuID0gY29udGV4dHMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb250ZXh0c1tpXS5idWZmZXIucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJ1ZmZlclRvZ2dsZVN1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIGNvbnRleHRzID0gdGhpcy5jb250ZXh0cztcbiAgICAgICAgd2hpbGUgKGNvbnRleHRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gY29udGV4dHMuc2hpZnQoKTtcbiAgICAgICAgICAgIGNvbnRleHQuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICBjb250ZXh0LmJ1ZmZlciA9IG51bGw7XG4gICAgICAgICAgICBjb250ZXh0LnN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb250ZXh0cyA9IG51bGw7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuX2Vycm9yLmNhbGwodGhpcywgZXJyKTtcbiAgICB9O1xuICAgIEJ1ZmZlclRvZ2dsZVN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbnRleHRzID0gdGhpcy5jb250ZXh0cztcbiAgICAgICAgd2hpbGUgKGNvbnRleHRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gY29udGV4dHMuc2hpZnQoKTtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChjb250ZXh0LmJ1ZmZlcik7XG4gICAgICAgICAgICBjb250ZXh0LnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgY29udGV4dC5idWZmZXIgPSBudWxsO1xuICAgICAgICAgICAgY29udGV4dC5zdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29udGV4dHMgPSBudWxsO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9jb21wbGV0ZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgQnVmZmVyVG9nZ2xlU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICBvdXRlclZhbHVlID8gdGhpcy5jbG9zZUJ1ZmZlcihvdXRlclZhbHVlKSA6IHRoaXMub3BlbkJ1ZmZlcihpbm5lclZhbHVlKTtcbiAgICB9O1xuICAgIEJ1ZmZlclRvZ2dsZVN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMuY2xvc2VCdWZmZXIoaW5uZXJTdWIuY29udGV4dCk7XG4gICAgfTtcbiAgICBCdWZmZXJUb2dnbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5vcGVuQnVmZmVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgY2xvc2luZ1NlbGVjdG9yID0gdGhpcy5jbG9zaW5nU2VsZWN0b3I7XG4gICAgICAgICAgICB2YXIgY2xvc2luZ05vdGlmaWVyID0gY2xvc2luZ1NlbGVjdG9yLmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgaWYgKGNsb3NpbmdOb3RpZmllcikge1xuICAgICAgICAgICAgICAgIHRoaXMudHJ5U3Vic2NyaWJlKGNsb3NpbmdOb3RpZmllcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5fZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQnVmZmVyVG9nZ2xlU3Vic2NyaWJlci5wcm90b3R5cGUuY2xvc2VCdWZmZXIgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICB2YXIgY29udGV4dHMgPSB0aGlzLmNvbnRleHRzO1xuICAgICAgICBpZiAoY29udGV4dHMgJiYgY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IGNvbnRleHQuYnVmZmVyLCBzdWJzY3JpcHRpb24gPSBjb250ZXh0LnN1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChidWZmZXIpO1xuICAgICAgICAgICAgY29udGV4dHMuc3BsaWNlKGNvbnRleHRzLmluZGV4T2YoY29udGV4dCksIDEpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCdWZmZXJUb2dnbGVTdWJzY3JpYmVyLnByb3RvdHlwZS50cnlTdWJzY3JpYmUgPSBmdW5jdGlvbiAoY2xvc2luZ05vdGlmaWVyKSB7XG4gICAgICAgIHZhciBjb250ZXh0cyA9IHRoaXMuY29udGV4dHM7XG4gICAgICAgIHZhciBidWZmZXIgPSBbXTtcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24oKTtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB7IGJ1ZmZlcjogYnVmZmVyLCBzdWJzY3JpcHRpb246IHN1YnNjcmlwdGlvbiB9O1xuICAgICAgICBjb250ZXh0cy5wdXNoKGNvbnRleHQpO1xuICAgICAgICB2YXIgaW5uZXJTdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIGNsb3NpbmdOb3RpZmllciwgY29udGV4dCk7XG4gICAgICAgIGlmICghaW5uZXJTdWJzY3JpcHRpb24gfHwgaW5uZXJTdWJzY3JpcHRpb24uY2xvc2VkKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlQnVmZmVyKGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5uZXJTdWJzY3JpcHRpb24uY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICB0aGlzLmFkZChpbm5lclN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24uYWRkKGlubmVyU3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEJ1ZmZlclRvZ2dsZVN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVmZmVyVG9nZ2xlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9yL2J1ZmZlclRvZ2dsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpcHRpb24nKTtcbnZhciB0cnlDYXRjaF8xID0gcmVxdWlyZSgnLi4vdXRpbC90cnlDYXRjaCcpO1xudmFyIGVycm9yT2JqZWN0XzEgPSByZXF1aXJlKCcuLi91dGlsL2Vycm9yT2JqZWN0Jyk7XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyoqXG4gKiBCdWZmZXJzIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB2YWx1ZXMsIHVzaW5nIGEgZmFjdG9yeSBmdW5jdGlvbiBvZiBjbG9zaW5nXG4gKiBPYnNlcnZhYmxlcyB0byBkZXRlcm1pbmUgd2hlbiB0byBjbG9zZSwgZW1pdCwgYW5kIHJlc2V0IHRoZSBidWZmZXIuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkNvbGxlY3RzIHZhbHVlcyBmcm9tIHRoZSBwYXN0IGFzIGFuIGFycmF5LiBXaGVuIGl0XG4gKiBzdGFydHMgY29sbGVjdGluZyB2YWx1ZXMsIGl0IGNhbGxzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdFxuICogdGVsbHMgd2hlbiB0byBjbG9zZSB0aGUgYnVmZmVyIGFuZCByZXN0YXJ0IGNvbGxlY3RpbmcuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvYnVmZmVyV2hlbi5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBPcGVucyBhIGJ1ZmZlciBpbW1lZGlhdGVseSwgdGhlbiBjbG9zZXMgdGhlIGJ1ZmZlciB3aGVuIHRoZSBvYnNlcnZhYmxlXG4gKiByZXR1cm5lZCBieSBjYWxsaW5nIGBjbG9zaW5nU2VsZWN0b3JgIGZ1bmN0aW9uIGVtaXRzIGEgdmFsdWUuIFdoZW4gaXQgY2xvc2VzXG4gKiB0aGUgYnVmZmVyLCBpdCBpbW1lZGlhdGVseSBvcGVucyBhIG5ldyBidWZmZXIgYW5kIHJlcGVhdHMgdGhlIHByb2Nlc3MuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdCBhbiBhcnJheSBvZiB0aGUgbGFzdCBjbGlja3MgZXZlcnkgWzEtNV0gcmFuZG9tIHNlY29uZHM8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIGJ1ZmZlcmVkID0gY2xpY2tzLmJ1ZmZlcldoZW4oKCkgPT5cbiAqICAgUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwICsgTWF0aC5yYW5kb20oKSAqIDQwMDApXG4gKiApO1xuICogYnVmZmVyZWQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGJ1ZmZlcn1cbiAqIEBzZWUge0BsaW5rIGJ1ZmZlckNvdW50fVxuICogQHNlZSB7QGxpbmsgYnVmZmVyVGltZX1cbiAqIEBzZWUge0BsaW5rIGJ1ZmZlclRvZ2dsZX1cbiAqIEBzZWUge0BsaW5rIHdpbmRvd1doZW59XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbigpOiBPYnNlcnZhYmxlfSBjbG9zaW5nU2VsZWN0b3IgQSBmdW5jdGlvbiB0aGF0IHRha2VzIG5vXG4gKiBhcmd1bWVudHMgYW5kIHJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IHNpZ25hbHMgYnVmZmVyIGNsb3N1cmUuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFRbXT59IEFuIG9ic2VydmFibGUgb2YgYXJyYXlzIG9mIGJ1ZmZlcmVkIHZhbHVlcy5cbiAqIEBtZXRob2QgYnVmZmVyV2hlblxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gYnVmZmVyV2hlbihjbG9zaW5nU2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBCdWZmZXJXaGVuT3BlcmF0b3IoY2xvc2luZ1NlbGVjdG9yKSk7XG59XG5leHBvcnRzLmJ1ZmZlcldoZW4gPSBidWZmZXJXaGVuO1xudmFyIEJ1ZmZlcldoZW5PcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQnVmZmVyV2hlbk9wZXJhdG9yKGNsb3NpbmdTZWxlY3Rvcikge1xuICAgICAgICB0aGlzLmNsb3NpbmdTZWxlY3RvciA9IGNsb3NpbmdTZWxlY3RvcjtcbiAgICB9XG4gICAgQnVmZmVyV2hlbk9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgQnVmZmVyV2hlblN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5jbG9zaW5nU2VsZWN0b3IpKTtcbiAgICB9O1xuICAgIHJldHVybiBCdWZmZXJXaGVuT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBCdWZmZXJXaGVuU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJ1ZmZlcldoZW5TdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJ1ZmZlcldoZW5TdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBjbG9zaW5nU2VsZWN0b3IpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmNsb3NpbmdTZWxlY3RvciA9IGNsb3NpbmdTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9wZW5CdWZmZXIoKTtcbiAgICB9XG4gICAgQnVmZmVyV2hlblN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyLnB1c2godmFsdWUpO1xuICAgIH07XG4gICAgQnVmZmVyV2hlblN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuICAgICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9jb21wbGV0ZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgQnVmZmVyV2hlblN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnN1YnNjcmliaW5nID0gZmFsc2U7XG4gICAgfTtcbiAgICBCdWZmZXJXaGVuU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLm9wZW5CdWZmZXIoKTtcbiAgICB9O1xuICAgIEJ1ZmZlcldoZW5TdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3Vic2NyaWJpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub3BlbkJ1ZmZlcigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCdWZmZXJXaGVuU3Vic2NyaWJlci5wcm90b3R5cGUub3BlbkJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNsb3NpbmdTdWJzY3JpcHRpb24gPSB0aGlzLmNsb3NpbmdTdWJzY3JpcHRpb247XG4gICAgICAgIGlmIChjbG9zaW5nU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZShjbG9zaW5nU3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgIGNsb3NpbmdTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXI7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlcikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICAgICAgdmFyIGNsb3NpbmdOb3RpZmllciA9IHRyeUNhdGNoXzEudHJ5Q2F0Y2godGhpcy5jbG9zaW5nU2VsZWN0b3IpKCk7XG4gICAgICAgIGlmIChjbG9zaW5nTm90aWZpZXIgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsb3NpbmdTdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLmNsb3NpbmdTdWJzY3JpcHRpb24gPSBjbG9zaW5nU3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgdGhpcy5hZGQoY2xvc2luZ1N1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGNsb3NpbmdTdWJzY3JpcHRpb24uYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgY2xvc2luZ05vdGlmaWVyKSk7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBCdWZmZXJXaGVuU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWZmZXJXaGVuLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9yL2J1ZmZlcldoZW4uanNcbi8vIG1vZHVsZSBpZCA9IDI1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qKlxuICogQ2F0Y2hlcyBlcnJvcnMgb24gdGhlIG9ic2VydmFibGUgdG8gYmUgaGFuZGxlZCBieSByZXR1cm5pbmcgYSBuZXcgb2JzZXJ2YWJsZSBvciB0aHJvd2luZyBhbiBlcnJvci5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2NhdGNoLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNvbnRpbnVlcyB3aXRoIGEgZGlmZmVyZW50IE9ic2VydmFibGUgd2hlbiB0aGVyZSdzIGFuIGVycm9yPC9jYXB0aW9uPlxuICpcbiAqIE9ic2VydmFibGUub2YoMSwgMiwgMywgNCwgNSlcbiAqICAgLm1hcChuID0+IHtcbiAqIFx0ICAgaWYgKG4gPT0gNCkge1xuICogXHQgICAgIHRocm93ICdmb3VyISc7XG4gKiAgICAgfVxuICpcdCAgIHJldHVybiBuO1xuICogICB9KVxuICogICAuY2F0Y2goZXJyID0+IE9ic2VydmFibGUub2YoJ0knLCAnSUknLCAnSUlJJywgJ0lWJywgJ1YnKSlcbiAqICAgLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqICAgLy8gMSwgMiwgMywgSSwgSUksIElJSSwgSVYsIFZcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5SZXRyaWVzIHRoZSBjYXVnaHQgc291cmNlIE9ic2VydmFibGUgYWdhaW4gaW4gY2FzZSBvZiBlcnJvciwgc2ltaWxhciB0byByZXRyeSgpIG9wZXJhdG9yPC9jYXB0aW9uPlxuICpcbiAqIE9ic2VydmFibGUub2YoMSwgMiwgMywgNCwgNSlcbiAqICAgLm1hcChuID0+IHtcbiAqIFx0ICAgaWYgKG4gPT09IDQpIHtcbiAqIFx0ICAgICB0aHJvdyAnZm91ciEnO1xuICogICAgIH1cbiAqIFx0ICAgcmV0dXJuIG47XG4gKiAgIH0pXG4gKiAgIC5jYXRjaCgoZXJyLCBjYXVnaHQpID0+IGNhdWdodClcbiAqICAgLnRha2UoMzApXG4gKiAgIC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKiAgIC8vIDEsIDIsIDMsIDEsIDIsIDMsIC4uLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlRocm93cyBhIG5ldyBlcnJvciB3aGVuIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB0aHJvd3MgYW4gZXJyb3I8L2NhcHRpb24+XG4gKlxuICogT2JzZXJ2YWJsZS5vZigxLCAyLCAzLCA0LCA1KVxuICogICAubWFwKG4gPT4ge1xuICogICAgIGlmIChuID09IDQpIHtcbiAqICAgICAgIHRocm93ICdmb3VyISc7XG4gKiAgICAgfVxuICogICAgIHJldHVybiBuO1xuICogICB9KVxuICogICAuY2F0Y2goZXJyID0+IHtcbiAqICAgICB0aHJvdyAnZXJyb3IgaW4gc291cmNlLiBEZXRhaWxzOiAnICsgZXJyO1xuICogICB9KVxuICogICAuc3Vic2NyaWJlKFxuICogICAgIHggPT4gY29uc29sZS5sb2coeCksXG4gKiAgICAgZXJyID0+IGNvbnNvbGUubG9nKGVycilcbiAqICAgKTtcbiAqICAgLy8gMSwgMiwgMywgZXJyb3IgaW4gc291cmNlLiBEZXRhaWxzOiBmb3VyIVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHNlbGVjdG9yIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhcyBhcmd1bWVudHMgYGVycmAsIHdoaWNoIGlzIHRoZSBlcnJvciwgYW5kIGBjYXVnaHRgLCB3aGljaFxuICogIGlzIHRoZSBzb3VyY2Ugb2JzZXJ2YWJsZSwgaW4gY2FzZSB5b3UnZCBsaWtlIHRvIFwicmV0cnlcIiB0aGF0IG9ic2VydmFibGUgYnkgcmV0dXJuaW5nIGl0IGFnYWluLiBXaGF0ZXZlciBvYnNlcnZhYmxlXG4gKiAgaXMgcmV0dXJuZWQgYnkgdGhlIGBzZWxlY3RvcmAgd2lsbCBiZSB1c2VkIHRvIGNvbnRpbnVlIHRoZSBvYnNlcnZhYmxlIGNoYWluLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSB0aGF0IG9yaWdpbmF0ZXMgZnJvbSBlaXRoZXIgdGhlIHNvdXJjZSBvciB0aGUgb2JzZXJ2YWJsZSByZXR1cm5lZCBieSB0aGVcbiAqICBjYXRjaCBgc2VsZWN0b3JgIGZ1bmN0aW9uLlxuICogQG1ldGhvZCBjYXRjaFxuICogQG5hbWUgY2F0Y2hcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIF9jYXRjaChzZWxlY3Rvcikge1xuICAgIHZhciBvcGVyYXRvciA9IG5ldyBDYXRjaE9wZXJhdG9yKHNlbGVjdG9yKTtcbiAgICB2YXIgY2F1Z2h0ID0gdGhpcy5saWZ0KG9wZXJhdG9yKTtcbiAgICByZXR1cm4gKG9wZXJhdG9yLmNhdWdodCA9IGNhdWdodCk7XG59XG5leHBvcnRzLl9jYXRjaCA9IF9jYXRjaDtcbnZhciBDYXRjaE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDYXRjaE9wZXJhdG9yKHNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICB9XG4gICAgQ2F0Y2hPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IENhdGNoU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnNlbGVjdG9yLCB0aGlzLmNhdWdodCkpO1xuICAgIH07XG4gICAgcmV0dXJuIENhdGNoT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBDYXRjaFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDYXRjaFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2F0Y2hTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBzZWxlY3RvciwgY2F1Z2h0KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICB0aGlzLmNhdWdodCA9IGNhdWdodDtcbiAgICB9XG4gICAgLy8gTk9URTogb3ZlcnJpZGluZyBgZXJyb3JgIGluc3RlYWQgb2YgYF9lcnJvcmAgYmVjYXVzZSB3ZSBkb24ndCB3YW50XG4gICAgLy8gdG8gaGF2ZSB0aGlzIGZsYWcgdGhpcyBzdWJzY3JpYmVyIGFzIGBpc1N0b3BwZWRgLiBXZSBjYW4gbWltaWMgdGhlXG4gICAgLy8gYmVoYXZpb3Igb2YgdGhlIFJldHJ5U3Vic2NyaWJlciAoZnJvbSB0aGUgYHJldHJ5YCBvcGVyYXRvciksIHdoZXJlXG4gICAgLy8gd2UgdW5zdWJzY3JpYmUgZnJvbSBvdXIgc291cmNlIGNoYWluLCByZXNldCBvdXIgU3Vic2NyaWJlciBmbGFncyxcbiAgICAvLyB0aGVuIHN1YnNjcmliZSB0byB0aGUgc2VsZWN0b3IgcmVzdWx0LlxuICAgIENhdGNoU3Vic2NyaWJlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB2b2lkIDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuc2VsZWN0b3IoZXJyLCB0aGlzLmNhdWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyMikge1xuICAgICAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZXJyb3IuY2FsbCh0aGlzLCBlcnIyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl91bnN1YnNjcmliZUFuZFJlY3ljbGUoKTtcbiAgICAgICAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgcmVzdWx0KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDYXRjaFN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2F0Y2guanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3IvY2F0Y2guanNcbi8vIG1vZHVsZSBpZCA9IDI1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb21iaW5lTGF0ZXN0XzEgPSByZXF1aXJlKCcuL2NvbWJpbmVMYXRlc3QnKTtcbi8qKlxuICogQ29udmVydHMgYSBoaWdoZXItb3JkZXIgT2JzZXJ2YWJsZSBpbnRvIGEgZmlyc3Qtb3JkZXIgT2JzZXJ2YWJsZSBieSB3YWl0aW5nXG4gKiBmb3IgdGhlIG91dGVyIE9ic2VydmFibGUgdG8gY29tcGxldGUsIHRoZW4gYXBwbHlpbmcge0BsaW5rIGNvbWJpbmVMYXRlc3R9LlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5GbGF0dGVucyBhbiBPYnNlcnZhYmxlLW9mLU9ic2VydmFibGVzIGJ5IGFwcGx5aW5nXG4gKiB7QGxpbmsgY29tYmluZUxhdGVzdH0gd2hlbiB0aGUgT2JzZXJ2YWJsZS1vZi1PYnNlcnZhYmxlcyBjb21wbGV0ZXMuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvY29tYmluZUFsbC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBUYWtlcyBhbiBPYnNlcnZhYmxlIG9mIE9ic2VydmFibGVzLCBhbmQgY29sbGVjdHMgYWxsIE9ic2VydmFibGVzIGZyb20gaXQuXG4gKiBPbmNlIHRoZSBvdXRlciBPYnNlcnZhYmxlIGNvbXBsZXRlcywgaXQgc3Vic2NyaWJlcyB0byBhbGwgY29sbGVjdGVkXG4gKiBPYnNlcnZhYmxlcyBhbmQgY29tYmluZXMgdGhlaXIgdmFsdWVzIHVzaW5nIHRoZSB7QGxpbmsgY29tYmluZUxhdGVzdH1cbiAqIHN0cmF0ZWd5LCBzdWNoIHRoYXQ6XG4gKiAtIEV2ZXJ5IHRpbWUgYW4gaW5uZXIgT2JzZXJ2YWJsZSBlbWl0cywgdGhlIG91dHB1dCBPYnNlcnZhYmxlIGVtaXRzLlxuICogLSBXaGVuIHRoZSByZXR1cm5lZCBvYnNlcnZhYmxlIGVtaXRzLCBpdCBlbWl0cyBhbGwgb2YgdGhlIGxhdGVzdCB2YWx1ZXMgYnk6XG4gKiAgIC0gSWYgYSBgcHJvamVjdGAgZnVuY3Rpb24gaXMgcHJvdmlkZWQsIGl0IGlzIGNhbGxlZCB3aXRoIGVhY2ggcmVjZW50IHZhbHVlXG4gKiAgICAgZnJvbSBlYWNoIGlubmVyIE9ic2VydmFibGUgaW4gd2hhdGV2ZXIgb3JkZXIgdGhleSBhcnJpdmVkLCBhbmQgdGhlIHJlc3VsdFxuICogICAgIG9mIHRoZSBgcHJvamVjdGAgZnVuY3Rpb24gaXMgd2hhdCBpcyBlbWl0dGVkIGJ5IHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAqICAgLSBJZiB0aGVyZSBpcyBubyBgcHJvamVjdGAgZnVuY3Rpb24sIGFuIGFycmF5IG9mIGFsbCBvZiB0aGUgbW9zdCByZWNlbnRcbiAqICAgICB2YWx1ZXMgaXMgZW1pdHRlZCBieSB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+TWFwIHR3byBjbGljayBldmVudHMgdG8gYSBmaW5pdGUgaW50ZXJ2YWwgT2JzZXJ2YWJsZSwgdGhlbiBhcHBseSBjb21iaW5lQWxsPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBoaWdoZXJPcmRlciA9IGNsaWNrcy5tYXAoZXYgPT5cbiAqICAgUnguT2JzZXJ2YWJsZS5pbnRlcnZhbChNYXRoLnJhbmRvbSgpKjIwMDApLnRha2UoMylcbiAqICkudGFrZSgyKTtcbiAqIHZhciByZXN1bHQgPSBoaWdoZXJPcmRlci5jb21iaW5lQWxsKCk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGNvbWJpbmVMYXRlc3R9XG4gKiBAc2VlIHtAbGluayBtZXJnZUFsbH1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbcHJvamVjdF0gQW4gb3B0aW9uYWwgZnVuY3Rpb24gdG8gbWFwIHRoZSBtb3N0IHJlY2VudFxuICogdmFsdWVzIGZyb20gZWFjaCBpbm5lciBPYnNlcnZhYmxlIGludG8gYSBuZXcgcmVzdWx0LiBUYWtlcyBlYWNoIG9mIHRoZSBtb3N0XG4gKiByZWNlbnQgdmFsdWVzIGZyb20gZWFjaCBjb2xsZWN0ZWQgaW5uZXIgT2JzZXJ2YWJsZSBhcyBhcmd1bWVudHMsIGluIG9yZGVyLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSBvZiBwcm9qZWN0ZWQgcmVzdWx0cyBvciBhcnJheXMgb2YgcmVjZW50XG4gKiB2YWx1ZXMuXG4gKiBAbWV0aG9kIGNvbWJpbmVBbGxcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGNvbWJpbmVBbGwocHJvamVjdCkge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IGNvbWJpbmVMYXRlc3RfMS5Db21iaW5lTGF0ZXN0T3BlcmF0b3IocHJvamVjdCkpO1xufVxuZXhwb3J0cy5jb21iaW5lQWxsID0gY29tYmluZUFsbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbWJpbmVBbGwuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3IvY29tYmluZUFsbC5qc1xuLy8gbW9kdWxlIGlkID0gMjU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIG1lcmdlQWxsXzEgPSByZXF1aXJlKCcuL21lcmdlQWxsJyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBDb252ZXJ0cyBhIGhpZ2hlci1vcmRlciBPYnNlcnZhYmxlIGludG8gYSBmaXJzdC1vcmRlciBPYnNlcnZhYmxlIGJ5XG4gKiBjb25jYXRlbmF0aW5nIHRoZSBpbm5lciBPYnNlcnZhYmxlcyBpbiBvcmRlci5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+RmxhdHRlbnMgYW4gT2JzZXJ2YWJsZS1vZi1PYnNlcnZhYmxlcyBieSBwdXR0aW5nIG9uZVxuICogaW5uZXIgT2JzZXJ2YWJsZSBhZnRlciB0aGUgb3RoZXIuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvY29uY2F0QWxsLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEpvaW5zIGV2ZXJ5IE9ic2VydmFibGUgZW1pdHRlZCBieSB0aGUgc291cmNlIChhIGhpZ2hlci1vcmRlciBPYnNlcnZhYmxlKSwgaW5cbiAqIGEgc2VyaWFsIGZhc2hpb24uIEl0IHN1YnNjcmliZXMgdG8gZWFjaCBpbm5lciBPYnNlcnZhYmxlIG9ubHkgYWZ0ZXIgdGhlXG4gKiBwcmV2aW91cyBpbm5lciBPYnNlcnZhYmxlIGhhcyBjb21wbGV0ZWQsIGFuZCBtZXJnZXMgYWxsIG9mIHRoZWlyIHZhbHVlcyBpbnRvXG4gKiB0aGUgcmV0dXJuZWQgb2JzZXJ2YWJsZS5cbiAqXG4gKiBfX1dhcm5pbmc6X18gSWYgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGVtaXRzIE9ic2VydmFibGVzIHF1aWNrbHkgYW5kXG4gKiBlbmRsZXNzbHksIGFuZCB0aGUgaW5uZXIgT2JzZXJ2YWJsZXMgaXQgZW1pdHMgZ2VuZXJhbGx5IGNvbXBsZXRlIHNsb3dlciB0aGFuXG4gKiB0aGUgc291cmNlIGVtaXRzLCB5b3UgY2FuIHJ1biBpbnRvIG1lbW9yeSBpc3N1ZXMgYXMgdGhlIGluY29taW5nIE9ic2VydmFibGVzXG4gKiBjb2xsZWN0IGluIGFuIHVuYm91bmRlZCBidWZmZXIuXG4gKlxuICogTm90ZTogYGNvbmNhdEFsbGAgaXMgZXF1aXZhbGVudCB0byBgbWVyZ2VBbGxgIHdpdGggY29uY3VycmVuY3kgcGFyYW1ldGVyIHNldFxuICogdG8gYDFgLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkZvciBlYWNoIGNsaWNrIGV2ZW50LCB0aWNrIGV2ZXJ5IHNlY29uZCBmcm9tIDAgdG8gMywgd2l0aCBubyBjb25jdXJyZW5jeTwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgaGlnaGVyT3JkZXIgPSBjbGlja3MubWFwKGV2ID0+IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkudGFrZSg0KSk7XG4gKiB2YXIgZmlyc3RPcmRlciA9IGhpZ2hlck9yZGVyLmNvbmNhdEFsbCgpO1xuICogZmlyc3RPcmRlci5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gUmVzdWx0cyBpbiB0aGUgZm9sbG93aW5nOlxuICogLy8gKHJlc3VsdHMgYXJlIG5vdCBjb25jdXJyZW50KVxuICogLy8gRm9yIGV2ZXJ5IGNsaWNrIG9uIHRoZSBcImRvY3VtZW50XCIgaXQgd2lsbCBlbWl0IHZhbHVlcyAwIHRvIDMgc3BhY2VkXG4gKiAvLyBvbiBhIDEwMDBtcyBpbnRlcnZhbFxuICogLy8gb25lIGNsaWNrID0gMTAwMG1zLT4gMCAtMTAwMG1zLT4gMSAtMTAwMG1zLT4gMiAtMTAwMG1zLT4gM1xuICpcbiAqIEBzZWUge0BsaW5rIGNvbWJpbmVBbGx9XG4gKiBAc2VlIHtAbGluayBjb25jYXR9XG4gKiBAc2VlIHtAbGluayBjb25jYXRNYXB9XG4gKiBAc2VlIHtAbGluayBjb25jYXRNYXBUb31cbiAqIEBzZWUge0BsaW5rIGV4aGF1c3R9XG4gKiBAc2VlIHtAbGluayBtZXJnZUFsbH1cbiAqIEBzZWUge0BsaW5rIHN3aXRjaH1cbiAqIEBzZWUge0BsaW5rIHppcEFsbH1cbiAqXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIGVtaXR0aW5nIHZhbHVlcyBmcm9tIGFsbCB0aGUgaW5uZXJcbiAqIE9ic2VydmFibGVzIGNvbmNhdGVuYXRlZC5cbiAqIEBtZXRob2QgY29uY2F0QWxsXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBjb25jYXRBbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgbWVyZ2VBbGxfMS5NZXJnZUFsbE9wZXJhdG9yKDEpKTtcbn1cbmV4cG9ydHMuY29uY2F0QWxsID0gY29uY2F0QWxsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uY2F0QWxsLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9yL2NvbmNhdEFsbC5qc1xuLy8gbW9kdWxlIGlkID0gMjYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIG1lcmdlTWFwXzEgPSByZXF1aXJlKCcuL21lcmdlTWFwJyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBQcm9qZWN0cyBlYWNoIHNvdXJjZSB2YWx1ZSB0byBhbiBPYnNlcnZhYmxlIHdoaWNoIGlzIG1lcmdlZCBpbiB0aGUgb3V0cHV0XG4gKiBPYnNlcnZhYmxlLCBpbiBhIHNlcmlhbGl6ZWQgZmFzaGlvbiB3YWl0aW5nIGZvciBlYWNoIG9uZSB0byBjb21wbGV0ZSBiZWZvcmVcbiAqIG1lcmdpbmcgdGhlIG5leHQuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPk1hcHMgZWFjaCB2YWx1ZSB0byBhbiBPYnNlcnZhYmxlLCB0aGVuIGZsYXR0ZW5zIGFsbCBvZlxuICogdGhlc2UgaW5uZXIgT2JzZXJ2YWJsZXMgdXNpbmcge0BsaW5rIGNvbmNhdEFsbH0uPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvY29uY2F0TWFwLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGl0ZW1zIGJhc2VkIG9uIGFwcGx5aW5nIGEgZnVuY3Rpb24gdGhhdCB5b3VcbiAqIHN1cHBseSB0byBlYWNoIGl0ZW0gZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUsIHdoZXJlIHRoYXQgZnVuY3Rpb25cbiAqIHJldHVybnMgYW4gKHNvLWNhbGxlZCBcImlubmVyXCIpIE9ic2VydmFibGUuIEVhY2ggbmV3IGlubmVyIE9ic2VydmFibGUgaXNcbiAqIGNvbmNhdGVuYXRlZCB3aXRoIHRoZSBwcmV2aW91cyBpbm5lciBPYnNlcnZhYmxlLlxuICpcbiAqIF9fV2FybmluZzpfXyBpZiBzb3VyY2UgdmFsdWVzIGFycml2ZSBlbmRsZXNzbHkgYW5kIGZhc3RlciB0aGFuIHRoZWlyXG4gKiBjb3JyZXNwb25kaW5nIGlubmVyIE9ic2VydmFibGVzIGNhbiBjb21wbGV0ZSwgaXQgd2lsbCByZXN1bHQgaW4gbWVtb3J5IGlzc3Vlc1xuICogYXMgaW5uZXIgT2JzZXJ2YWJsZXMgYW1hc3MgaW4gYW4gdW5ib3VuZGVkIGJ1ZmZlciB3YWl0aW5nIGZvciB0aGVpciB0dXJuIHRvXG4gKiBiZSBzdWJzY3JpYmVkIHRvLlxuICpcbiAqIE5vdGU6IGBjb25jYXRNYXBgIGlzIGVxdWl2YWxlbnQgdG8gYG1lcmdlTWFwYCB3aXRoIGNvbmN1cnJlbmN5IHBhcmFtZXRlciBzZXRcbiAqIHRvIGAxYC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Gb3IgZWFjaCBjbGljayBldmVudCwgdGljayBldmVyeSBzZWNvbmQgZnJvbSAwIHRvIDMsIHdpdGggbm8gY29uY3VycmVuY3k8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy5jb25jYXRNYXAoZXYgPT4gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKS50YWtlKDQpKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gUmVzdWx0cyBpbiB0aGUgZm9sbG93aW5nOlxuICogLy8gKHJlc3VsdHMgYXJlIG5vdCBjb25jdXJyZW50KVxuICogLy8gRm9yIGV2ZXJ5IGNsaWNrIG9uIHRoZSBcImRvY3VtZW50XCIgaXQgd2lsbCBlbWl0IHZhbHVlcyAwIHRvIDMgc3BhY2VkXG4gKiAvLyBvbiBhIDEwMDBtcyBpbnRlcnZhbFxuICogLy8gb25lIGNsaWNrID0gMTAwMG1zLT4gMCAtMTAwMG1zLT4gMSAtMTAwMG1zLT4gMiAtMTAwMG1zLT4gM1xuICpcbiAqIEBzZWUge0BsaW5rIGNvbmNhdH1cbiAqIEBzZWUge0BsaW5rIGNvbmNhdEFsbH1cbiAqIEBzZWUge0BsaW5rIGNvbmNhdE1hcFRvfVxuICogQHNlZSB7QGxpbmsgZXhoYXVzdE1hcH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlTWFwfVxuICogQHNlZSB7QGxpbmsgc3dpdGNoTWFwfVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24odmFsdWU6IFQsID9pbmRleDogbnVtYmVyKTogT2JzZXJ2YWJsZUlucHV0fSBwcm9qZWN0IEEgZnVuY3Rpb25cbiAqIHRoYXQsIHdoZW4gYXBwbGllZCB0byBhbiBpdGVtIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCByZXR1cm5zIGFuXG4gKiBPYnNlcnZhYmxlLlxuICogQHBhcmFtIHtmdW5jdGlvbihvdXRlclZhbHVlOiBULCBpbm5lclZhbHVlOiBJLCBvdXRlckluZGV4OiBudW1iZXIsIGlubmVySW5kZXg6IG51bWJlcik6IGFueX0gW3Jlc3VsdFNlbGVjdG9yXVxuICogQSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB2YWx1ZSBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUgYmFzZWQgb24gdGhlIHZhbHVlc1xuICogYW5kIHRoZSBpbmRpY2VzIG9mIHRoZSBzb3VyY2UgKG91dGVyKSBlbWlzc2lvbiBhbmQgdGhlIGlubmVyIE9ic2VydmFibGVcbiAqIGVtaXNzaW9uLiBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uIGFyZTpcbiAqIC0gYG91dGVyVmFsdWVgOiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHNvdXJjZVxuICogLSBgaW5uZXJWYWx1ZWA6IHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgcHJvamVjdGVkIE9ic2VydmFibGVcbiAqIC0gYG91dGVySW5kZXhgOiB0aGUgXCJpbmRleFwiIG9mIHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgc291cmNlXG4gKiAtIGBpbm5lckluZGV4YDogdGhlIFwiaW5kZXhcIiBvZiB0aGUgdmFsdWUgZnJvbSB0aGUgcHJvamVjdGVkIE9ic2VydmFibGVcbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgb2YgdmFsdWVzIG1lcmdlZCBmcm9tIHRoZSBwcm9qZWN0ZWRcbiAqIE9ic2VydmFibGVzIGFzIHRoZXkgd2VyZSBzdWJzY3JpYmVkIHRvLCBvbmUgYXQgYSB0aW1lLiBPcHRpb25hbGx5LCB0aGVzZVxuICogdmFsdWVzIG1heSBoYXZlIGJlZW4gcHJvamVjdGVkIGZyb20gYSBwYXNzZWQgYHByb2plY3RSZXN1bHRgIGFyZ3VtZW50LlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlXG4gKiBwcm9qZWN0aW9uIGZ1bmN0aW9uIChhbmQgdGhlIG9wdGlvbmFsIGByZXN1bHRTZWxlY3RvcmApIHRvIGVhY2ggaXRlbSBlbWl0dGVkXG4gKiBieSB0aGUgc291cmNlIE9ic2VydmFibGUgYW5kIHRha2luZyB2YWx1ZXMgZnJvbSBlYWNoIHByb2plY3RlZCBpbm5lclxuICogT2JzZXJ2YWJsZSBzZXF1ZW50aWFsbHkuXG4gKiBAbWV0aG9kIGNvbmNhdE1hcFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gY29uY2F0TWFwKHByb2plY3QsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgbWVyZ2VNYXBfMS5NZXJnZU1hcE9wZXJhdG9yKHByb2plY3QsIHJlc3VsdFNlbGVjdG9yLCAxKSk7XG59XG5leHBvcnRzLmNvbmNhdE1hcCA9IGNvbmNhdE1hcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmNhdE1hcC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvci9jb25jYXRNYXAuanNcbi8vIG1vZHVsZSBpZCA9IDI2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBtZXJnZU1hcFRvXzEgPSByZXF1aXJlKCcuL21lcmdlTWFwVG8nKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIFByb2plY3RzIGVhY2ggc291cmNlIHZhbHVlIHRvIHRoZSBzYW1lIE9ic2VydmFibGUgd2hpY2ggaXMgbWVyZ2VkIG11bHRpcGxlXG4gKiB0aW1lcyBpbiBhIHNlcmlhbGl6ZWQgZmFzaGlvbiBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgY29uY2F0TWFwfSwgYnV0IG1hcHMgZWFjaCB2YWx1ZVxuICogYWx3YXlzIHRvIHRoZSBzYW1lIGlubmVyIE9ic2VydmFibGUuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvY29uY2F0TWFwVG8ucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogTWFwcyBlYWNoIHNvdXJjZSB2YWx1ZSB0byB0aGUgZ2l2ZW4gT2JzZXJ2YWJsZSBgaW5uZXJPYnNlcnZhYmxlYCByZWdhcmRsZXNzXG4gKiBvZiB0aGUgc291cmNlIHZhbHVlLCBhbmQgdGhlbiBmbGF0dGVucyB0aG9zZSByZXN1bHRpbmcgT2JzZXJ2YWJsZXMgaW50byBvbmVcbiAqIHNpbmdsZSBPYnNlcnZhYmxlLCB3aGljaCBpcyB0aGUgb3V0cHV0IE9ic2VydmFibGUuIEVhY2ggbmV3IGBpbm5lck9ic2VydmFibGVgXG4gKiBpbnN0YW5jZSBlbWl0dGVkIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBpcyBjb25jYXRlbmF0ZWQgd2l0aCB0aGUgcHJldmlvdXNcbiAqIGBpbm5lck9ic2VydmFibGVgIGluc3RhbmNlLlxuICpcbiAqIF9fV2FybmluZzpfXyBpZiBzb3VyY2UgdmFsdWVzIGFycml2ZSBlbmRsZXNzbHkgYW5kIGZhc3RlciB0aGFuIHRoZWlyXG4gKiBjb3JyZXNwb25kaW5nIGlubmVyIE9ic2VydmFibGVzIGNhbiBjb21wbGV0ZSwgaXQgd2lsbCByZXN1bHQgaW4gbWVtb3J5IGlzc3Vlc1xuICogYXMgaW5uZXIgT2JzZXJ2YWJsZXMgYW1hc3MgaW4gYW4gdW5ib3VuZGVkIGJ1ZmZlciB3YWl0aW5nIGZvciB0aGVpciB0dXJuIHRvXG4gKiBiZSBzdWJzY3JpYmVkIHRvLlxuICpcbiAqIE5vdGU6IGBjb25jYXRNYXBUb2AgaXMgZXF1aXZhbGVudCB0byBgbWVyZ2VNYXBUb2Agd2l0aCBjb25jdXJyZW5jeSBwYXJhbWV0ZXJcbiAqIHNldCB0byBgMWAuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Rm9yIGVhY2ggY2xpY2sgZXZlbnQsIHRpY2sgZXZlcnkgc2Vjb25kIGZyb20gMCB0byAzLCB3aXRoIG5vIGNvbmN1cnJlbmN5PC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3MuY29uY2F0TWFwVG8oUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKS50YWtlKDQpKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gUmVzdWx0cyBpbiB0aGUgZm9sbG93aW5nOlxuICogLy8gKHJlc3VsdHMgYXJlIG5vdCBjb25jdXJyZW50KVxuICogLy8gRm9yIGV2ZXJ5IGNsaWNrIG9uIHRoZSBcImRvY3VtZW50XCIgaXQgd2lsbCBlbWl0IHZhbHVlcyAwIHRvIDMgc3BhY2VkXG4gKiAvLyBvbiBhIDEwMDBtcyBpbnRlcnZhbFxuICogLy8gb25lIGNsaWNrID0gMTAwMG1zLT4gMCAtMTAwMG1zLT4gMSAtMTAwMG1zLT4gMiAtMTAwMG1zLT4gM1xuICpcbiAqIEBzZWUge0BsaW5rIGNvbmNhdH1cbiAqIEBzZWUge0BsaW5rIGNvbmNhdEFsbH1cbiAqIEBzZWUge0BsaW5rIGNvbmNhdE1hcH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlTWFwVG99XG4gKiBAc2VlIHtAbGluayBzd2l0Y2hNYXBUb31cbiAqXG4gKiBAcGFyYW0ge09ic2VydmFibGVJbnB1dH0gaW5uZXJPYnNlcnZhYmxlIEFuIE9ic2VydmFibGUgdG8gcmVwbGFjZSBlYWNoIHZhbHVlIGZyb21cbiAqIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob3V0ZXJWYWx1ZTogVCwgaW5uZXJWYWx1ZTogSSwgb3V0ZXJJbmRleDogbnVtYmVyLCBpbm5lckluZGV4OiBudW1iZXIpOiBhbnl9IFtyZXN1bHRTZWxlY3Rvcl1cbiAqIEEgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdmFsdWUgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlIGJhc2VkIG9uIHRoZSB2YWx1ZXNcbiAqIGFuZCB0aGUgaW5kaWNlcyBvZiB0aGUgc291cmNlIChvdXRlcikgZW1pc3Npb24gYW5kIHRoZSBpbm5lciBPYnNlcnZhYmxlXG4gKiBlbWlzc2lvbi4gVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBhcmU6XG4gKiAtIGBvdXRlclZhbHVlYDogdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBzb3VyY2VcbiAqIC0gYGlubmVyVmFsdWVgOiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiAtIGBvdXRlckluZGV4YDogdGhlIFwiaW5kZXhcIiBvZiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHNvdXJjZVxuICogLSBgaW5uZXJJbmRleGA6IHRoZSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIG9mIHZhbHVlcyBtZXJnZWQgdG9nZXRoZXIgYnkgam9pbmluZyB0aGVcbiAqIHBhc3NlZCBvYnNlcnZhYmxlIHdpdGggaXRzZWxmLCBvbmUgYWZ0ZXIgdGhlIG90aGVyLCBmb3IgZWFjaCB2YWx1ZSBlbWl0dGVkXG4gKiBmcm9tIHRoZSBzb3VyY2UuXG4gKiBAbWV0aG9kIGNvbmNhdE1hcFRvXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBjb25jYXRNYXBUbyhpbm5lck9ic2VydmFibGUsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgbWVyZ2VNYXBUb18xLk1lcmdlTWFwVG9PcGVyYXRvcihpbm5lck9ic2VydmFibGUsIHJlc3VsdFNlbGVjdG9yLCAxKSk7XG59XG5leHBvcnRzLmNvbmNhdE1hcFRvID0gY29uY2F0TWFwVG87XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25jYXRNYXBUby5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvci9jb25jYXRNYXBUby5qc1xuLy8gbW9kdWxlIGlkID0gMjYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xuLyoqXG4gKiBDb3VudHMgdGhlIG51bWJlciBvZiBlbWlzc2lvbnMgb24gdGhlIHNvdXJjZSBhbmQgZW1pdHMgdGhhdCBudW1iZXIgd2hlbiB0aGVcbiAqIHNvdXJjZSBjb21wbGV0ZXMuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPlRlbGxzIGhvdyBtYW55IHZhbHVlcyB3ZXJlIGVtaXR0ZWQsIHdoZW4gdGhlIHNvdXJjZVxuICogY29tcGxldGVzLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2NvdW50LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBjb3VudGAgdHJhbnNmb3JtcyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdmFsdWVzIGludG8gYW4gT2JzZXJ2YWJsZSB0aGF0XG4gKiBlbWl0cyBhIHNpbmdsZSB2YWx1ZSB0aGF0IHJlcHJlc2VudHMgdGhlIG51bWJlciBvZiB2YWx1ZXMgZW1pdHRlZCBieSB0aGVcbiAqIHNvdXJjZSBPYnNlcnZhYmxlLiBJZiB0aGUgc291cmNlIE9ic2VydmFibGUgdGVybWluYXRlcyB3aXRoIGFuIGVycm9yLCBgY291bnRgXG4gKiB3aWxsIHBhc3MgdGhpcyBlcnJvciBub3RpZmljYXRpb24gYWxvbmcgd2l0aG91dCBlbWl0dGluZyBhIHZhbHVlIGZpcnN0LiBJZlxuICogdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGRvZXMgbm90IHRlcm1pbmF0ZSBhdCBhbGwsIGBjb3VudGAgd2lsbCBuZWl0aGVyIGVtaXRcbiAqIGEgdmFsdWUgbm9yIHRlcm1pbmF0ZS4gVGhpcyBvcGVyYXRvciB0YWtlcyBhbiBvcHRpb25hbCBgcHJlZGljYXRlYCBmdW5jdGlvblxuICogYXMgYXJndW1lbnQsIGluIHdoaWNoIGNhc2UgdGhlIG91dHB1dCBlbWlzc2lvbiB3aWxsIHJlcHJlc2VudCB0aGUgbnVtYmVyIG9mXG4gKiBzb3VyY2UgdmFsdWVzIHRoYXQgbWF0Y2hlZCBgdHJ1ZWAgd2l0aCB0aGUgYHByZWRpY2F0ZWAuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q291bnRzIGhvdyBtYW55IHNlY29uZHMgaGF2ZSBwYXNzZWQgYmVmb3JlIHRoZSBmaXJzdCBjbGljayBoYXBwZW5lZDwvY2FwdGlvbj5cbiAqIHZhciBzZWNvbmRzID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgc2Vjb25kc0JlZm9yZUNsaWNrID0gc2Vjb25kcy50YWtlVW50aWwoY2xpY2tzKTtcbiAqIHZhciByZXN1bHQgPSBzZWNvbmRzQmVmb3JlQ2xpY2suY291bnQoKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q291bnRzIGhvdyBtYW55IG9kZCBudW1iZXJzIGFyZSB0aGVyZSBiZXR3ZWVuIDEgYW5kIDc8L2NhcHRpb24+XG4gKiB2YXIgbnVtYmVycyA9IFJ4Lk9ic2VydmFibGUucmFuZ2UoMSwgNyk7XG4gKiB2YXIgcmVzdWx0ID0gbnVtYmVycy5jb3VudChpID0+IGkgJSAyID09PSAxKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gUmVzdWx0cyBpbjpcbiAqIC8vIDRcbiAqXG4gKiBAc2VlIHtAbGluayBtYXh9XG4gKiBAc2VlIHtAbGluayBtaW59XG4gKiBAc2VlIHtAbGluayByZWR1Y2V9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCwgaTogbnVtYmVyLCBzb3VyY2U6IE9ic2VydmFibGU8VD4pOiBib29sZWFufSBbcHJlZGljYXRlXSBBXG4gKiBib29sZWFuIGZ1bmN0aW9uIHRvIHNlbGVjdCB3aGF0IHZhbHVlcyBhcmUgdG8gYmUgY291bnRlZC4gSXQgaXMgcHJvdmlkZWQgd2l0aFxuICogYXJndW1lbnRzIG9mOlxuICogLSBgdmFsdWVgOiB0aGUgdmFsdWUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiAtIGBpbmRleGA6IHRoZSAoemVyby1iYXNlZCkgXCJpbmRleFwiIG9mIHRoZSB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIC0gYHNvdXJjZWA6IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBpbnN0YW5jZSBpdHNlbGYuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIG9mIG9uZSBudW1iZXIgdGhhdCByZXByZXNlbnRzIHRoZSBjb3VudCBhc1xuICogZGVzY3JpYmVkIGFib3ZlLlxuICogQG1ldGhvZCBjb3VudFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gY291bnQocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgQ291bnRPcGVyYXRvcihwcmVkaWNhdGUsIHRoaXMpKTtcbn1cbmV4cG9ydHMuY291bnQgPSBjb3VudDtcbnZhciBDb3VudE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb3VudE9wZXJhdG9yKHByZWRpY2F0ZSwgc291cmNlKSB7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgQ291bnRPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IENvdW50U3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByZWRpY2F0ZSwgdGhpcy5zb3VyY2UpKTtcbiAgICB9O1xuICAgIHJldHVybiBDb3VudE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgQ291bnRTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ291bnRTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvdW50U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcHJlZGljYXRlLCBzb3VyY2UpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB9XG4gICAgQ291bnRTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5wcmVkaWNhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyeVByZWRpY2F0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvdW50Kys7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvdW50U3Vic2NyaWJlci5wcm90b3R5cGUuX3RyeVByZWRpY2F0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wcmVkaWNhdGUodmFsdWUsIHRoaXMuaW5kZXgrKywgdGhpcy5zb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLmNvdW50Kys7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvdW50U3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodGhpcy5jb3VudCk7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9O1xuICAgIHJldHVybiBDb3VudFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb3VudC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvci9jb3VudC5qc1xuLy8gbW9kdWxlIGlkID0gMjYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyoqXG4gKiBFbWl0cyBhIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIG9ubHkgYWZ0ZXIgYSBwYXJ0aWN1bGFyIHRpbWUgc3BhblxuICogZGV0ZXJtaW5lZCBieSBhbm90aGVyIE9ic2VydmFibGUgaGFzIHBhc3NlZCB3aXRob3V0IGFub3RoZXIgc291cmNlIGVtaXNzaW9uLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5JdCdzIGxpa2Uge0BsaW5rIGRlYm91bmNlVGltZX0sIGJ1dCB0aGUgdGltZSBzcGFuIG9mXG4gKiBlbWlzc2lvbiBzaWxlbmNlIGlzIGRldGVybWluZWQgYnkgYSBzZWNvbmQgT2JzZXJ2YWJsZS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9kZWJvdW5jZS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgZGVib3VuY2VgIGRlbGF5cyB2YWx1ZXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUsIGJ1dCBkcm9wcyBwcmV2aW91c1xuICogcGVuZGluZyBkZWxheWVkIGVtaXNzaW9ucyBpZiBhIG5ldyB2YWx1ZSBhcnJpdmVzIG9uIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIFRoaXMgb3BlcmF0b3Iga2VlcHMgdHJhY2sgb2YgdGhlIG1vc3QgcmVjZW50IHZhbHVlIGZyb20gdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSwgYW5kIHNwYXducyBhIGR1cmF0aW9uIE9ic2VydmFibGUgYnkgY2FsbGluZyB0aGVcbiAqIGBkdXJhdGlvblNlbGVjdG9yYCBmdW5jdGlvbi4gVGhlIHZhbHVlIGlzIGVtaXR0ZWQgb25seSB3aGVuIHRoZSBkdXJhdGlvblxuICogT2JzZXJ2YWJsZSBlbWl0cyBhIHZhbHVlIG9yIGNvbXBsZXRlcywgYW5kIGlmIG5vIG90aGVyIHZhbHVlIHdhcyBlbWl0dGVkIG9uXG4gKiB0aGUgc291cmNlIE9ic2VydmFibGUgc2luY2UgdGhlIGR1cmF0aW9uIE9ic2VydmFibGUgd2FzIHNwYXduZWQuIElmIGEgbmV3XG4gKiB2YWx1ZSBhcHBlYXJzIGJlZm9yZSB0aGUgZHVyYXRpb24gT2JzZXJ2YWJsZSBlbWl0cywgdGhlIHByZXZpb3VzIHZhbHVlIHdpbGxcbiAqIGJlIGRyb3BwZWQgYW5kIHdpbGwgbm90IGJlIGVtaXR0ZWQgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIExpa2Uge0BsaW5rIGRlYm91bmNlVGltZX0sIHRoaXMgaXMgYSByYXRlLWxpbWl0aW5nIG9wZXJhdG9yLCBhbmQgYWxzbyBhXG4gKiBkZWxheS1saWtlIG9wZXJhdG9yIHNpbmNlIG91dHB1dCBlbWlzc2lvbnMgZG8gbm90IG5lY2Vzc2FyaWx5IG9jY3VyIGF0IHRoZVxuICogc2FtZSB0aW1lIGFzIHRoZXkgZGlkIG9uIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0IHRoZSBtb3N0IHJlY2VudCBjbGljayBhZnRlciBhIGJ1cnN0IG9mIGNsaWNrczwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLmRlYm91bmNlKCgpID0+IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBhdWRpdH1cbiAqIEBzZWUge0BsaW5rIGRlYm91bmNlVGltZX1cbiAqIEBzZWUge0BsaW5rIGRlbGF5V2hlbn1cbiAqIEBzZWUge0BsaW5rIHRocm90dGxlfVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24odmFsdWU6IFQpOiBTdWJzY3JpYmFibGVPclByb21pc2V9IGR1cmF0aW9uU2VsZWN0b3IgQSBmdW5jdGlvblxuICogdGhhdCByZWNlaXZlcyBhIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCBmb3IgY29tcHV0aW5nIHRoZSB0aW1lb3V0XG4gKiBkdXJhdGlvbiBmb3IgZWFjaCBzb3VyY2UgdmFsdWUsIHJldHVybmVkIGFzIGFuIE9ic2VydmFibGUgb3IgYSBQcm9taXNlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGRlbGF5cyB0aGUgZW1pc3Npb25zIG9mIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUgYnkgdGhlIHNwZWNpZmllZCBkdXJhdGlvbiBPYnNlcnZhYmxlIHJldHVybmVkIGJ5XG4gKiBgZHVyYXRpb25TZWxlY3RvcmAsIGFuZCBtYXkgZHJvcCBzb21lIHZhbHVlcyBpZiB0aGV5IG9jY3VyIHRvbyBmcmVxdWVudGx5LlxuICogQG1ldGhvZCBkZWJvdW5jZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gZGVib3VuY2UoZHVyYXRpb25TZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IERlYm91bmNlT3BlcmF0b3IoZHVyYXRpb25TZWxlY3RvcikpO1xufVxuZXhwb3J0cy5kZWJvdW5jZSA9IGRlYm91bmNlO1xudmFyIERlYm91bmNlT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlYm91bmNlT3BlcmF0b3IoZHVyYXRpb25TZWxlY3Rvcikge1xuICAgICAgICB0aGlzLmR1cmF0aW9uU2VsZWN0b3IgPSBkdXJhdGlvblNlbGVjdG9yO1xuICAgIH1cbiAgICBEZWJvdW5jZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgRGVib3VuY2VTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuZHVyYXRpb25TZWxlY3RvcikpO1xuICAgIH07XG4gICAgcmV0dXJuIERlYm91bmNlT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBEZWJvdW5jZVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEZWJvdW5jZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGVib3VuY2VTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBkdXJhdGlvblNlbGVjdG9yKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5kdXJhdGlvblNlbGVjdG9yID0gZHVyYXRpb25TZWxlY3RvcjtcbiAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmR1cmF0aW9uU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICB9XG4gICAgRGVib3VuY2VTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuZHVyYXRpb25TZWxlY3Rvci5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90cnlOZXh0KHZhbHVlLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVib3VuY2VTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZW1pdFZhbHVlKCk7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9O1xuICAgIERlYm91bmNlU3Vic2NyaWJlci5wcm90b3R5cGUuX3RyeU5leHQgPSBmdW5jdGlvbiAodmFsdWUsIGR1cmF0aW9uKSB7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGlzLmR1cmF0aW9uU3Vic2NyaXB0aW9uO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzVmFsdWUgPSB0cnVlO1xuICAgICAgICBpZiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKHN1YnNjcmlwdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgc3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBkdXJhdGlvbik7XG4gICAgICAgIGlmICghc3Vic2NyaXB0aW9uLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhpcy5hZGQodGhpcy5kdXJhdGlvblN1YnNjcmlwdGlvbiA9IHN1YnNjcmlwdGlvbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlYm91bmNlU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLmVtaXRWYWx1ZSgpO1xuICAgIH07XG4gICAgRGVib3VuY2VTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lbWl0VmFsdWUoKTtcbiAgICB9O1xuICAgIERlYm91bmNlU3Vic2NyaWJlci5wcm90b3R5cGUuZW1pdFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5oYXNWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGlzLmR1cmF0aW9uU3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuZHVyYXRpb25TdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKHN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuaGFzVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuX25leHQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBEZWJvdW5jZVN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVib3VuY2UuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3IvZGVib3VuY2UuanNcbi8vIG1vZHVsZSBpZCA9IDI2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBhc3luY18xID0gcmVxdWlyZSgnLi4vc2NoZWR1bGVyL2FzeW5jJyk7XG4vKipcbiAqIEVtaXRzIGEgdmFsdWUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgb25seSBhZnRlciBhIHBhcnRpY3VsYXIgdGltZSBzcGFuXG4gKiBoYXMgcGFzc2VkIHdpdGhvdXQgYW5vdGhlciBzb3VyY2UgZW1pc3Npb24uXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgZGVsYXl9LCBidXQgcGFzc2VzIG9ubHkgdGhlIG1vc3RcbiAqIHJlY2VudCB2YWx1ZSBmcm9tIGVhY2ggYnVyc3Qgb2YgZW1pc3Npb25zLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2RlYm91bmNlVGltZS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgZGVib3VuY2VUaW1lYCBkZWxheXMgdmFsdWVzIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCBidXQgZHJvcHNcbiAqIHByZXZpb3VzIHBlbmRpbmcgZGVsYXllZCBlbWlzc2lvbnMgaWYgYSBuZXcgdmFsdWUgYXJyaXZlcyBvbiB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLiBUaGlzIG9wZXJhdG9yIGtlZXBzIHRyYWNrIG9mIHRoZSBtb3N0IHJlY2VudCB2YWx1ZSBmcm9tIHRoZVxuICogc291cmNlIE9ic2VydmFibGUsIGFuZCBlbWl0cyB0aGF0IG9ubHkgd2hlbiBgZHVlVGltZWAgZW5vdWdoIHRpbWUgaGFzIHBhc3NlZFxuICogd2l0aG91dCBhbnkgb3RoZXIgdmFsdWUgYXBwZWFyaW5nIG9uIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS4gSWYgYSBuZXcgdmFsdWVcbiAqIGFwcGVhcnMgYmVmb3JlIGBkdWVUaW1lYCBzaWxlbmNlIG9jY3VycywgdGhlIHByZXZpb3VzIHZhbHVlIHdpbGwgYmUgZHJvcHBlZFxuICogYW5kIHdpbGwgbm90IGJlIGVtaXR0ZWQgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIFRoaXMgaXMgYSByYXRlLWxpbWl0aW5nIG9wZXJhdG9yLCBiZWNhdXNlIGl0IGlzIGltcG9zc2libGUgZm9yIG1vcmUgdGhhbiBvbmVcbiAqIHZhbHVlIHRvIGJlIGVtaXR0ZWQgaW4gYW55IHRpbWUgd2luZG93IG9mIGR1cmF0aW9uIGBkdWVUaW1lYCwgYnV0IGl0IGlzIGFsc29cbiAqIGEgZGVsYXktbGlrZSBvcGVyYXRvciBzaW5jZSBvdXRwdXQgZW1pc3Npb25zIGRvIG5vdCBvY2N1ciBhdCB0aGUgc2FtZSB0aW1lIGFzXG4gKiB0aGV5IGRpZCBvbiB0aGUgc291cmNlIE9ic2VydmFibGUuIE9wdGlvbmFsbHkgdGFrZXMgYSB7QGxpbmsgSVNjaGVkdWxlcn0gZm9yXG4gKiBtYW5hZ2luZyB0aW1lcnMuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdCB0aGUgbW9zdCByZWNlbnQgY2xpY2sgYWZ0ZXIgYSBidXJzdCBvZiBjbGlja3M8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy5kZWJvdW5jZVRpbWUoMTAwMCk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGF1ZGl0VGltZX1cbiAqIEBzZWUge0BsaW5rIGRlYm91bmNlfVxuICogQHNlZSB7QGxpbmsgZGVsYXl9XG4gKiBAc2VlIHtAbGluayBzYW1wbGVUaW1lfVxuICogQHNlZSB7QGxpbmsgdGhyb3R0bGVUaW1lfVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBkdWVUaW1lIFRoZSB0aW1lb3V0IGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcyAob3IgdGhlIHRpbWVcbiAqIHVuaXQgZGV0ZXJtaW5lZCBpbnRlcm5hbGx5IGJ5IHRoZSBvcHRpb25hbCBgc2NoZWR1bGVyYCkgZm9yIHRoZSB3aW5kb3cgb2ZcbiAqIHRpbWUgcmVxdWlyZWQgdG8gd2FpdCBmb3IgZW1pc3Npb24gc2lsZW5jZSBiZWZvcmUgZW1pdHRpbmcgdGhlIG1vc3QgcmVjZW50XG4gKiBzb3VyY2UgdmFsdWUuXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcj1hc3luY10gVGhlIHtAbGluayBJU2NoZWR1bGVyfSB0byB1c2UgZm9yXG4gKiBtYW5hZ2luZyB0aGUgdGltZXJzIHRoYXQgaGFuZGxlIHRoZSB0aW1lb3V0IGZvciBlYWNoIHZhbHVlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGRlbGF5cyB0aGUgZW1pc3Npb25zIG9mIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUgYnkgdGhlIHNwZWNpZmllZCBgZHVlVGltZWAsIGFuZCBtYXkgZHJvcCBzb21lIHZhbHVlcyBpZiB0aGV5IG9jY3VyXG4gKiB0b28gZnJlcXVlbnRseS5cbiAqIEBtZXRob2QgZGVib3VuY2VUaW1lXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBkZWJvdW5jZVRpbWUoZHVlVGltZSwgc2NoZWR1bGVyKSB7XG4gICAgaWYgKHNjaGVkdWxlciA9PT0gdm9pZCAwKSB7IHNjaGVkdWxlciA9IGFzeW5jXzEuYXN5bmM7IH1cbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBEZWJvdW5jZVRpbWVPcGVyYXRvcihkdWVUaW1lLCBzY2hlZHVsZXIpKTtcbn1cbmV4cG9ydHMuZGVib3VuY2VUaW1lID0gZGVib3VuY2VUaW1lO1xudmFyIERlYm91bmNlVGltZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWJvdW5jZVRpbWVPcGVyYXRvcihkdWVUaW1lLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgdGhpcy5kdWVUaW1lID0gZHVlVGltZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgfVxuICAgIERlYm91bmNlVGltZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgRGVib3VuY2VUaW1lU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmR1ZVRpbWUsIHRoaXMuc2NoZWR1bGVyKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVib3VuY2VUaW1lT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBEZWJvdW5jZVRpbWVTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGVib3VuY2VUaW1lU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEZWJvdW5jZVRpbWVTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBkdWVUaW1lLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmR1ZVRpbWUgPSBkdWVUaW1lO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgdGhpcy5kZWJvdW5jZWRTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RWYWx1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFzVmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gICAgRGVib3VuY2VUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5jbGVhckRlYm91bmNlKCk7XG4gICAgICAgIHRoaXMubGFzdFZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzVmFsdWUgPSB0cnVlO1xuICAgICAgICB0aGlzLmFkZCh0aGlzLmRlYm91bmNlZFN1YnNjcmlwdGlvbiA9IHRoaXMuc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoTmV4dCwgdGhpcy5kdWVUaW1lLCB0aGlzKSk7XG4gICAgfTtcbiAgICBEZWJvdW5jZVRpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGVib3VuY2VkTmV4dCgpO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICBEZWJvdW5jZVRpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5kZWJvdW5jZWROZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNsZWFyRGVib3VuY2UoKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh0aGlzLmxhc3RWYWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmxhc3RWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmhhc1ZhbHVlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlYm91bmNlVGltZVN1YnNjcmliZXIucHJvdG90eXBlLmNsZWFyRGVib3VuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZWJvdW5jZWRTdWJzY3JpcHRpb24gPSB0aGlzLmRlYm91bmNlZFN1YnNjcmlwdGlvbjtcbiAgICAgICAgaWYgKGRlYm91bmNlZFN1YnNjcmlwdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUoZGVib3VuY2VkU3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgIGRlYm91bmNlZFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5kZWJvdW5jZWRTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRGVib3VuY2VUaW1lU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbmZ1bmN0aW9uIGRpc3BhdGNoTmV4dChzdWJzY3JpYmVyKSB7XG4gICAgc3Vic2NyaWJlci5kZWJvdW5jZWROZXh0KCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWJvdW5jZVRpbWUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3IvZGVib3VuY2VUaW1lLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBFbWl0cyBhIGdpdmVuIHZhbHVlIGlmIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBjb21wbGV0ZXMgd2l0aG91dCBlbWl0dGluZyBhbnlcbiAqIGBuZXh0YCB2YWx1ZSwgb3RoZXJ3aXNlIG1pcnJvcnMgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5JZiB0aGUgc291cmNlIE9ic2VydmFibGUgdHVybnMgb3V0IHRvIGJlIGVtcHR5LCB0aGVuXG4gKiB0aGlzIG9wZXJhdG9yIHdpbGwgZW1pdCBhIGRlZmF1bHQgdmFsdWUuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvZGVmYXVsdElmRW1wdHkucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYGRlZmF1bHRJZkVtcHR5YCBlbWl0cyB0aGUgdmFsdWVzIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIG9yIGFcbiAqIHNwZWNpZmllZCBkZWZhdWx0IHZhbHVlIGlmIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBpcyBlbXB0eSAoY29tcGxldGVzIHdpdGhvdXRcbiAqIGhhdmluZyBlbWl0dGVkIGFueSBgbmV4dGAgdmFsdWUpLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPklmIG5vIGNsaWNrcyBoYXBwZW4gaW4gNSBzZWNvbmRzLCB0aGVuIGVtaXQgXCJubyBjbGlja3NcIjwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgY2xpY2tzQmVmb3JlRml2ZSA9IGNsaWNrcy50YWtlVW50aWwoUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCg1MDAwKSk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzQmVmb3JlRml2ZS5kZWZhdWx0SWZFbXB0eSgnbm8gY2xpY2tzJyk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGVtcHR5fVxuICogQHNlZSB7QGxpbmsgbGFzdH1cbiAqXG4gKiBAcGFyYW0ge2FueX0gW2RlZmF1bHRWYWx1ZT1udWxsXSBUaGUgZGVmYXVsdCB2YWx1ZSB1c2VkIGlmIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUgaXMgZW1wdHkuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgZWl0aGVyIHRoZSBzcGVjaWZpZWRcbiAqIGBkZWZhdWx0VmFsdWVgIGlmIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBlbWl0cyBubyBpdGVtcywgb3IgdGhlIHZhbHVlcyBlbWl0dGVkXG4gKiBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIGRlZmF1bHRJZkVtcHR5XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBkZWZhdWx0SWZFbXB0eShkZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAoZGVmYXVsdFZhbHVlID09PSB2b2lkIDApIHsgZGVmYXVsdFZhbHVlID0gbnVsbDsgfVxuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IERlZmF1bHRJZkVtcHR5T3BlcmF0b3IoZGVmYXVsdFZhbHVlKSk7XG59XG5leHBvcnRzLmRlZmF1bHRJZkVtcHR5ID0gZGVmYXVsdElmRW1wdHk7XG52YXIgRGVmYXVsdElmRW1wdHlPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVmYXVsdElmRW1wdHlPcGVyYXRvcihkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIERlZmF1bHRJZkVtcHR5T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBEZWZhdWx0SWZFbXB0eVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5kZWZhdWx0VmFsdWUpKTtcbiAgICB9O1xuICAgIHJldHVybiBEZWZhdWx0SWZFbXB0eU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgRGVmYXVsdElmRW1wdHlTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGVmYXVsdElmRW1wdHlTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERlZmF1bHRJZkVtcHR5U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIHRoaXMuaXNFbXB0eSA9IHRydWU7XG4gICAgfVxuICAgIERlZmF1bHRJZkVtcHR5U3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5pc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgfTtcbiAgICBEZWZhdWx0SWZFbXB0eVN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHRoaXMuZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVmYXVsdElmRW1wdHlTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdElmRW1wdHkuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3IvZGVmYXVsdElmRW1wdHkuanNcbi8vIG1vZHVsZSBpZCA9IDI2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGFzeW5jXzEgPSByZXF1aXJlKCcuLi9zY2hlZHVsZXIvYXN5bmMnKTtcbnZhciBpc0RhdGVfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNEYXRlJyk7XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIE5vdGlmaWNhdGlvbl8xID0gcmVxdWlyZSgnLi4vTm90aWZpY2F0aW9uJyk7XG4vKipcbiAqIERlbGF5cyB0aGUgZW1pc3Npb24gb2YgaXRlbXMgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgYnkgYSBnaXZlbiB0aW1lb3V0IG9yXG4gKiB1bnRpbCBhIGdpdmVuIERhdGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPlRpbWUgc2hpZnRzIGVhY2ggaXRlbSBieSBzb21lIHNwZWNpZmllZCBhbW91bnQgb2ZcbiAqIG1pbGxpc2Vjb25kcy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9kZWxheS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBJZiB0aGUgZGVsYXkgYXJndW1lbnQgaXMgYSBOdW1iZXIsIHRoaXMgb3BlcmF0b3IgdGltZSBzaGlmdHMgdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSBieSB0aGF0IGFtb3VudCBvZiB0aW1lIGV4cHJlc3NlZCBpbiBtaWxsaXNlY29uZHMuIFRoZSByZWxhdGl2ZVxuICogdGltZSBpbnRlcnZhbHMgYmV0d2VlbiB0aGUgdmFsdWVzIGFyZSBwcmVzZXJ2ZWQuXG4gKlxuICogSWYgdGhlIGRlbGF5IGFyZ3VtZW50IGlzIGEgRGF0ZSwgdGhpcyBvcGVyYXRvciB0aW1lIHNoaWZ0cyB0aGUgc3RhcnQgb2YgdGhlXG4gKiBPYnNlcnZhYmxlIGV4ZWN1dGlvbiB1bnRpbCB0aGUgZ2l2ZW4gZGF0ZSBvY2N1cnMuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RGVsYXkgZWFjaCBjbGljayBieSBvbmUgc2Vjb25kPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBkZWxheWVkQ2xpY2tzID0gY2xpY2tzLmRlbGF5KDEwMDApOyAvLyBlYWNoIGNsaWNrIGVtaXR0ZWQgYWZ0ZXIgMSBzZWNvbmRcbiAqIGRlbGF5ZWRDbGlja3Muc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkRlbGF5IGFsbCBjbGlja3MgdW50aWwgYSBmdXR1cmUgZGF0ZSBoYXBwZW5zPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBkYXRlID0gbmV3IERhdGUoJ01hcmNoIDE1LCAyMDUwIDEyOjAwOjAwJyk7IC8vIGluIHRoZSBmdXR1cmVcbiAqIHZhciBkZWxheWVkQ2xpY2tzID0gY2xpY2tzLmRlbGF5KGRhdGUpOyAvLyBjbGljayBlbWl0dGVkIG9ubHkgYWZ0ZXIgdGhhdCBkYXRlXG4gKiBkZWxheWVkQ2xpY2tzLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBkZWJvdW5jZVRpbWV9XG4gKiBAc2VlIHtAbGluayBkZWxheVdoZW59XG4gKlxuICogQHBhcmFtIHtudW1iZXJ8RGF0ZX0gZGVsYXkgVGhlIGRlbGF5IGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcyAoYSBgbnVtYmVyYCkgb3JcbiAqIGEgYERhdGVgIHVudGlsIHdoaWNoIHRoZSBlbWlzc2lvbiBvZiB0aGUgc291cmNlIGl0ZW1zIGlzIGRlbGF5ZWQuXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcj1hc3luY10gVGhlIElTY2hlZHVsZXIgdG8gdXNlIGZvclxuICogbWFuYWdpbmcgdGhlIHRpbWVycyB0aGF0IGhhbmRsZSB0aGUgdGltZS1zaGlmdCBmb3IgZWFjaCBpdGVtLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGRlbGF5cyB0aGUgZW1pc3Npb25zIG9mIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUgYnkgdGhlIHNwZWNpZmllZCB0aW1lb3V0IG9yIERhdGUuXG4gKiBAbWV0aG9kIGRlbGF5XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBkZWxheShkZWxheSwgc2NoZWR1bGVyKSB7XG4gICAgaWYgKHNjaGVkdWxlciA9PT0gdm9pZCAwKSB7IHNjaGVkdWxlciA9IGFzeW5jXzEuYXN5bmM7IH1cbiAgICB2YXIgYWJzb2x1dGVEZWxheSA9IGlzRGF0ZV8xLmlzRGF0ZShkZWxheSk7XG4gICAgdmFyIGRlbGF5Rm9yID0gYWJzb2x1dGVEZWxheSA/ICgrZGVsYXkgLSBzY2hlZHVsZXIubm93KCkpIDogTWF0aC5hYnMoZGVsYXkpO1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IERlbGF5T3BlcmF0b3IoZGVsYXlGb3IsIHNjaGVkdWxlcikpO1xufVxuZXhwb3J0cy5kZWxheSA9IGRlbGF5O1xudmFyIERlbGF5T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlbGF5T3BlcmF0b3IoZGVsYXksIHNjaGVkdWxlcikge1xuICAgICAgICB0aGlzLmRlbGF5ID0gZGVsYXk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIH1cbiAgICBEZWxheU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgRGVsYXlTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuZGVsYXksIHRoaXMuc2NoZWR1bGVyKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVsYXlPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIERlbGF5U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERlbGF5U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEZWxheVN1YnNjcmliZXIoZGVzdGluYXRpb24sIGRlbGF5LCBzY2hlZHVsZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmRlbGF5ID0gZGVsYXk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXJyb3JlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBEZWxheVN1YnNjcmliZXIuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHN0YXRlLnNvdXJjZTtcbiAgICAgICAgdmFyIHF1ZXVlID0gc291cmNlLnF1ZXVlO1xuICAgICAgICB2YXIgc2NoZWR1bGVyID0gc3RhdGUuc2NoZWR1bGVyO1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSBzdGF0ZS5kZXN0aW5hdGlvbjtcbiAgICAgICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDAgJiYgKHF1ZXVlWzBdLnRpbWUgLSBzY2hlZHVsZXIubm93KCkpIDw9IDApIHtcbiAgICAgICAgICAgIHF1ZXVlLnNoaWZ0KCkubm90aWZpY2F0aW9uLm9ic2VydmUoZGVzdGluYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgZGVsYXlfMSA9IE1hdGgubWF4KDAsIHF1ZXVlWzBdLnRpbWUgLSBzY2hlZHVsZXIubm93KCkpO1xuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZShzdGF0ZSwgZGVsYXlfMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzb3VyY2UuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlbGF5U3Vic2NyaWJlci5wcm90b3R5cGUuX3NjaGVkdWxlID0gZnVuY3Rpb24gKHNjaGVkdWxlcikge1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuYWRkKHNjaGVkdWxlci5zY2hlZHVsZShEZWxheVN1YnNjcmliZXIuZGlzcGF0Y2gsIHRoaXMuZGVsYXksIHtcbiAgICAgICAgICAgIHNvdXJjZTogdGhpcywgZGVzdGluYXRpb246IHRoaXMuZGVzdGluYXRpb24sIHNjaGVkdWxlcjogc2NoZWR1bGVyXG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIERlbGF5U3Vic2NyaWJlci5wcm90b3R5cGUuc2NoZWR1bGVOb3RpZmljYXRpb24gPSBmdW5jdGlvbiAobm90aWZpY2F0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLmVycm9yZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2NoZWR1bGVyID0gdGhpcy5zY2hlZHVsZXI7XG4gICAgICAgIHZhciBtZXNzYWdlID0gbmV3IERlbGF5TWVzc2FnZShzY2hlZHVsZXIubm93KCkgKyB0aGlzLmRlbGF5LCBub3RpZmljYXRpb24pO1xuICAgICAgICB0aGlzLnF1ZXVlLnB1c2gobWVzc2FnZSk7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlKHNjaGVkdWxlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlbGF5U3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZU5vdGlmaWNhdGlvbihOb3RpZmljYXRpb25fMS5Ob3RpZmljYXRpb24uY3JlYXRlTmV4dCh2YWx1ZSkpO1xuICAgIH07XG4gICAgRGVsYXlTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMuZXJyb3JlZCA9IHRydWU7XG4gICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgIH07XG4gICAgRGVsYXlTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVOb3RpZmljYXRpb24oTm90aWZpY2F0aW9uXzEuTm90aWZpY2F0aW9uLmNyZWF0ZUNvbXBsZXRlKCkpO1xuICAgIH07XG4gICAgcmV0dXJuIERlbGF5U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbnZhciBEZWxheU1lc3NhZ2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlbGF5TWVzc2FnZSh0aW1lLCBub3RpZmljYXRpb24pIHtcbiAgICAgICAgdGhpcy50aW1lID0gdGltZTtcbiAgICAgICAgdGhpcy5ub3RpZmljYXRpb24gPSBub3RpZmljYXRpb247XG4gICAgfVxuICAgIHJldHVybiBEZWxheU1lc3NhZ2U7XG59KCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVsYXkuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3IvZGVsYXkuanNcbi8vIG1vZHVsZSBpZCA9IDI2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyoqXG4gKiBEZWxheXMgdGhlIGVtaXNzaW9uIG9mIGl0ZW1zIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGJ5IGEgZ2l2ZW4gdGltZSBzcGFuXG4gKiBkZXRlcm1pbmVkIGJ5IHRoZSBlbWlzc2lvbnMgb2YgYW5vdGhlciBPYnNlcnZhYmxlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5JdCdzIGxpa2Uge0BsaW5rIGRlbGF5fSwgYnV0IHRoZSB0aW1lIHNwYW4gb2YgdGhlXG4gKiBkZWxheSBkdXJhdGlvbiBpcyBkZXRlcm1pbmVkIGJ5IGEgc2Vjb25kIE9ic2VydmFibGUuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvZGVsYXlXaGVuLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBkZWxheVdoZW5gIHRpbWUgc2hpZnRzIGVhY2ggZW1pdHRlZCB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBieSBhXG4gKiB0aW1lIHNwYW4gZGV0ZXJtaW5lZCBieSBhbm90aGVyIE9ic2VydmFibGUuIFdoZW4gdGhlIHNvdXJjZSBlbWl0cyBhIHZhbHVlLFxuICogdGhlIGBkZWxheUR1cmF0aW9uU2VsZWN0b3JgIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIHRoZSBzb3VyY2UgdmFsdWUgYXNcbiAqIGFyZ3VtZW50LCBhbmQgc2hvdWxkIHJldHVybiBhbiBPYnNlcnZhYmxlLCBjYWxsZWQgdGhlIFwiZHVyYXRpb25cIiBPYnNlcnZhYmxlLlxuICogVGhlIHNvdXJjZSB2YWx1ZSBpcyBlbWl0dGVkIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBvbmx5IHdoZW4gdGhlIGR1cmF0aW9uXG4gKiBPYnNlcnZhYmxlIGVtaXRzIGEgdmFsdWUgb3IgY29tcGxldGVzLlxuICpcbiAqIE9wdGlvbmFsbHksIGBkZWxheVdoZW5gIHRha2VzIGEgc2Vjb25kIGFyZ3VtZW50LCBgc3Vic2NyaXB0aW9uRGVsYXlgLCB3aGljaFxuICogaXMgYW4gT2JzZXJ2YWJsZS4gV2hlbiBgc3Vic2NyaXB0aW9uRGVsYXlgIGVtaXRzIGl0cyBmaXJzdCB2YWx1ZSBvclxuICogY29tcGxldGVzLCB0aGUgc291cmNlIE9ic2VydmFibGUgaXMgc3Vic2NyaWJlZCB0byBhbmQgc3RhcnRzIGJlaGF2aW5nIGxpa2VcbiAqIGRlc2NyaWJlZCBpbiB0aGUgcHJldmlvdXMgcGFyYWdyYXBoLiBJZiBgc3Vic2NyaXB0aW9uRGVsYXlgIGlzIG5vdCBwcm92aWRlZCxcbiAqIGBkZWxheVdoZW5gIHdpbGwgc3Vic2NyaWJlIHRvIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBhcyBzb29uIGFzIHRoZSBvdXRwdXRcbiAqIE9ic2VydmFibGUgaXMgc3Vic2NyaWJlZC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5EZWxheSBlYWNoIGNsaWNrIGJ5IGEgcmFuZG9tIGFtb3VudCBvZiB0aW1lLCBiZXR3ZWVuIDAgYW5kIDUgc2Vjb25kczwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgZGVsYXllZENsaWNrcyA9IGNsaWNrcy5kZWxheVdoZW4oZXZlbnQgPT5cbiAqICAgUnguT2JzZXJ2YWJsZS5pbnRlcnZhbChNYXRoLnJhbmRvbSgpICogNTAwMClcbiAqICk7XG4gKiBkZWxheWVkQ2xpY2tzLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBkZWJvdW5jZX1cbiAqIEBzZWUge0BsaW5rIGRlbGF5fVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24odmFsdWU6IFQpOiBPYnNlcnZhYmxlfSBkZWxheUR1cmF0aW9uU2VsZWN0b3IgQSBmdW5jdGlvbiB0aGF0XG4gKiByZXR1cm5zIGFuIE9ic2VydmFibGUgZm9yIGVhY2ggdmFsdWUgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUsIHdoaWNoXG4gKiBpcyB0aGVuIHVzZWQgdG8gZGVsYXkgdGhlIGVtaXNzaW9uIG9mIHRoYXQgaXRlbSBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGVcbiAqIHVudGlsIHRoZSBPYnNlcnZhYmxlIHJldHVybmVkIGZyb20gdGhpcyBmdW5jdGlvbiBlbWl0cyBhIHZhbHVlLlxuICogQHBhcmFtIHtPYnNlcnZhYmxlfSBzdWJzY3JpcHRpb25EZWxheSBBbiBPYnNlcnZhYmxlIHRoYXQgdHJpZ2dlcnMgdGhlXG4gKiBzdWJzY3JpcHRpb24gdG8gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIG9uY2UgaXQgZW1pdHMgYW55IHZhbHVlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGRlbGF5cyB0aGUgZW1pc3Npb25zIG9mIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUgYnkgYW4gYW1vdW50IG9mIHRpbWUgc3BlY2lmaWVkIGJ5IHRoZSBPYnNlcnZhYmxlIHJldHVybmVkIGJ5XG4gKiBgZGVsYXlEdXJhdGlvblNlbGVjdG9yYC5cbiAqIEBtZXRob2QgZGVsYXlXaGVuXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBkZWxheVdoZW4oZGVsYXlEdXJhdGlvblNlbGVjdG9yLCBzdWJzY3JpcHRpb25EZWxheSkge1xuICAgIGlmIChzdWJzY3JpcHRpb25EZWxheSkge1xuICAgICAgICByZXR1cm4gbmV3IFN1YnNjcmlwdGlvbkRlbGF5T2JzZXJ2YWJsZSh0aGlzLCBzdWJzY3JpcHRpb25EZWxheSlcbiAgICAgICAgICAgIC5saWZ0KG5ldyBEZWxheVdoZW5PcGVyYXRvcihkZWxheUR1cmF0aW9uU2VsZWN0b3IpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgRGVsYXlXaGVuT3BlcmF0b3IoZGVsYXlEdXJhdGlvblNlbGVjdG9yKSk7XG59XG5leHBvcnRzLmRlbGF5V2hlbiA9IGRlbGF5V2hlbjtcbnZhciBEZWxheVdoZW5PcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVsYXlXaGVuT3BlcmF0b3IoZGVsYXlEdXJhdGlvblNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuZGVsYXlEdXJhdGlvblNlbGVjdG9yID0gZGVsYXlEdXJhdGlvblNlbGVjdG9yO1xuICAgIH1cbiAgICBEZWxheVdoZW5PcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IERlbGF5V2hlblN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5kZWxheUR1cmF0aW9uU2VsZWN0b3IpKTtcbiAgICB9O1xuICAgIHJldHVybiBEZWxheVdoZW5PcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIERlbGF5V2hlblN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEZWxheVdoZW5TdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERlbGF5V2hlblN1YnNjcmliZXIoZGVzdGluYXRpb24sIGRlbGF5RHVyYXRpb25TZWxlY3Rvcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuZGVsYXlEdXJhdGlvblNlbGVjdG9yID0gZGVsYXlEdXJhdGlvblNlbGVjdG9yO1xuICAgICAgICB0aGlzLmNvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlbGF5Tm90aWZpZXJTdWJzY3JpcHRpb25zID0gW107XG4gICAgICAgIHRoaXMudmFsdWVzID0gW107XG4gICAgfVxuICAgIERlbGF5V2hlblN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KG91dGVyVmFsdWUpO1xuICAgICAgICB0aGlzLnJlbW92ZVN1YnNjcmlwdGlvbihpbm5lclN1Yik7XG4gICAgICAgIHRoaXMudHJ5Q29tcGxldGUoKTtcbiAgICB9O1xuICAgIERlbGF5V2hlblN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUVycm9yID0gZnVuY3Rpb24gKGVycm9yLCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLl9lcnJvcihlcnJvcik7XG4gICAgfTtcbiAgICBEZWxheVdoZW5TdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uIChpbm5lclN1Yikge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnJlbW92ZVN1YnNjcmlwdGlvbihpbm5lclN1Yik7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyeUNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICBEZWxheVdoZW5TdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGRlbGF5Tm90aWZpZXIgPSB0aGlzLmRlbGF5RHVyYXRpb25TZWxlY3Rvcih2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoZGVsYXlOb3RpZmllcikge1xuICAgICAgICAgICAgICAgIHRoaXMudHJ5RGVsYXkoZGVsYXlOb3RpZmllciwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVsYXlXaGVuU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMudHJ5Q29tcGxldGUoKTtcbiAgICB9O1xuICAgIERlbGF5V2hlblN1YnNjcmliZXIucHJvdG90eXBlLnJlbW92ZVN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb25JZHggPSB0aGlzLmRlbGF5Tm90aWZpZXJTdWJzY3JpcHRpb25zLmluZGV4T2Yoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgdmFyIHZhbHVlID0gbnVsbDtcbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvbklkeCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy52YWx1ZXNbc3Vic2NyaXB0aW9uSWR4XTtcbiAgICAgICAgICAgIHRoaXMuZGVsYXlOb3RpZmllclN1YnNjcmlwdGlvbnMuc3BsaWNlKHN1YnNjcmlwdGlvbklkeCwgMSk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5zcGxpY2Uoc3Vic2NyaXB0aW9uSWR4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBEZWxheVdoZW5TdWJzY3JpYmVyLnByb3RvdHlwZS50cnlEZWxheSA9IGZ1bmN0aW9uIChkZWxheU5vdGlmaWVyLCB2YWx1ZSkge1xuICAgICAgICB2YXIgbm90aWZpZXJTdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIGRlbGF5Tm90aWZpZXIsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5hZGQobm90aWZpZXJTdWJzY3JpcHRpb24pO1xuICAgICAgICB0aGlzLmRlbGF5Tm90aWZpZXJTdWJzY3JpcHRpb25zLnB1c2gobm90aWZpZXJTdWJzY3JpcHRpb24pO1xuICAgICAgICB0aGlzLnZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICB9O1xuICAgIERlbGF5V2hlblN1YnNjcmliZXIucHJvdG90eXBlLnRyeUNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jb21wbGV0ZWQgJiYgdGhpcy5kZWxheU5vdGlmaWVyU3Vic2NyaXB0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIERlbGF5V2hlblN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBTdWJzY3JpcHRpb25EZWxheU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdWJzY3JpcHRpb25EZWxheU9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3Vic2NyaXB0aW9uRGVsYXlPYnNlcnZhYmxlKHNvdXJjZSwgc3Vic2NyaXB0aW9uRGVsYXkpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbkRlbGF5ID0gc3Vic2NyaXB0aW9uRGVsYXk7XG4gICAgfVxuICAgIFN1YnNjcmlwdGlvbkRlbGF5T2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uRGVsYXkuc3Vic2NyaWJlKG5ldyBTdWJzY3JpcHRpb25EZWxheVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5zb3VyY2UpKTtcbiAgICB9O1xuICAgIHJldHVybiBTdWJzY3JpcHRpb25EZWxheU9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFN1YnNjcmlwdGlvbkRlbGF5U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN1YnNjcmlwdGlvbkRlbGF5U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdWJzY3JpcHRpb25EZWxheVN1YnNjcmliZXIocGFyZW50LCBzb3VyY2UpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgfVxuICAgIFN1YnNjcmlwdGlvbkRlbGF5U3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodW51c2VkKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlVG9Tb3VyY2UoKTtcbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbkRlbGF5U3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMucGFyZW50LmVycm9yKGVycik7XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb25EZWxheVN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVUb1NvdXJjZSgpO1xuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uRGVsYXlTdWJzY3JpYmVyLnByb3RvdHlwZS5zdWJzY3JpYmVUb1NvdXJjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNvdXJjZVN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlU3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZS5zdWJzY3JpYmUodGhpcy5wYXJlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU3Vic2NyaXB0aW9uRGVsYXlTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVsYXlXaGVuLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9yL2RlbGF5V2hlbi5qc1xuLy8gbW9kdWxlIGlkID0gMjY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xuLyoqXG4gKiBDb252ZXJ0cyBhbiBPYnNlcnZhYmxlIG9mIHtAbGluayBOb3RpZmljYXRpb259IG9iamVjdHMgaW50byB0aGUgZW1pc3Npb25zXG4gKiB0aGF0IHRoZXkgcmVwcmVzZW50LlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5VbndyYXBzIHtAbGluayBOb3RpZmljYXRpb259IG9iamVjdHMgYXMgYWN0dWFsIGBuZXh0YCxcbiAqIGBlcnJvcmAgYW5kIGBjb21wbGV0ZWAgZW1pc3Npb25zLiBUaGUgb3Bwb3NpdGUgb2Yge0BsaW5rIG1hdGVyaWFsaXplfS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9kZW1hdGVyaWFsaXplLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBkZW1hdGVyaWFsaXplYCBpcyBhc3N1bWVkIHRvIG9wZXJhdGUgYW4gT2JzZXJ2YWJsZSB0aGF0IG9ubHkgZW1pdHNcbiAqIHtAbGluayBOb3RpZmljYXRpb259IG9iamVjdHMgYXMgYG5leHRgIGVtaXNzaW9ucywgYW5kIGRvZXMgbm90IGVtaXQgYW55XG4gKiBgZXJyb3JgLiBTdWNoIE9ic2VydmFibGUgaXMgdGhlIG91dHB1dCBvZiBhIGBtYXRlcmlhbGl6ZWAgb3BlcmF0aW9uLiBUaG9zZVxuICogbm90aWZpY2F0aW9ucyBhcmUgdGhlbiB1bndyYXBwZWQgdXNpbmcgdGhlIG1ldGFkYXRhIHRoZXkgY29udGFpbiwgYW5kIGVtaXR0ZWRcbiAqIGFzIGBuZXh0YCwgYGVycm9yYCwgYW5kIGBjb21wbGV0ZWAgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIFVzZSB0aGlzIG9wZXJhdG9yIGluIGNvbmp1bmN0aW9uIHdpdGgge0BsaW5rIG1hdGVyaWFsaXplfS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db252ZXJ0IGFuIE9ic2VydmFibGUgb2YgTm90aWZpY2F0aW9ucyB0byBhbiBhY3R1YWwgT2JzZXJ2YWJsZTwvY2FwdGlvbj5cbiAqIHZhciBub3RpZkEgPSBuZXcgUnguTm90aWZpY2F0aW9uKCdOJywgJ0EnKTtcbiAqIHZhciBub3RpZkIgPSBuZXcgUnguTm90aWZpY2F0aW9uKCdOJywgJ0InKTtcbiAqIHZhciBub3RpZkUgPSBuZXcgUnguTm90aWZpY2F0aW9uKCdFJywgdm9pZCAwLFxuICogICBuZXcgVHlwZUVycm9yKCd4LnRvVXBwZXJDYXNlIGlzIG5vdCBhIGZ1bmN0aW9uJylcbiAqICk7XG4gKiB2YXIgbWF0ZXJpYWxpemVkID0gUnguT2JzZXJ2YWJsZS5vZihub3RpZkEsIG5vdGlmQiwgbm90aWZFKTtcbiAqIHZhciB1cHBlckNhc2UgPSBtYXRlcmlhbGl6ZWQuZGVtYXRlcmlhbGl6ZSgpO1xuICogdXBwZXJDYXNlLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpLCBlID0+IGNvbnNvbGUuZXJyb3IoZSkpO1xuICpcbiAqIC8vIFJlc3VsdHMgaW46XG4gKiAvLyBBXG4gKiAvLyBCXG4gKiAvLyBUeXBlRXJyb3I6IHgudG9VcHBlckNhc2UgaXMgbm90IGEgZnVuY3Rpb25cbiAqXG4gKiBAc2VlIHtAbGluayBOb3RpZmljYXRpb259XG4gKiBAc2VlIHtAbGluayBtYXRlcmlhbGl6ZX1cbiAqXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgaXRlbXMgYW5kIG5vdGlmaWNhdGlvbnNcbiAqIGVtYmVkZGVkIGluIE5vdGlmaWNhdGlvbiBvYmplY3RzIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCBkZW1hdGVyaWFsaXplXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBkZW1hdGVyaWFsaXplKCkge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IERlTWF0ZXJpYWxpemVPcGVyYXRvcigpKTtcbn1cbmV4cG9ydHMuZGVtYXRlcmlhbGl6ZSA9IGRlbWF0ZXJpYWxpemU7XG52YXIgRGVNYXRlcmlhbGl6ZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZU1hdGVyaWFsaXplT3BlcmF0b3IoKSB7XG4gICAgfVxuICAgIERlTWF0ZXJpYWxpemVPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IERlTWF0ZXJpYWxpemVTdWJzY3JpYmVyKHN1YnNjcmliZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBEZU1hdGVyaWFsaXplT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBEZU1hdGVyaWFsaXplU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERlTWF0ZXJpYWxpemVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERlTWF0ZXJpYWxpemVTdWJzY3JpYmVyKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICB9XG4gICAgRGVNYXRlcmlhbGl6ZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhbHVlLm9ic2VydmUodGhpcy5kZXN0aW5hdGlvbik7XG4gICAgfTtcbiAgICByZXR1cm4gRGVNYXRlcmlhbGl6ZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZW1hdGVyaWFsaXplLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9yL2RlbWF0ZXJpYWxpemUuanNcbi8vIG1vZHVsZSBpZCA9IDI2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbnZhciBTZXRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvU2V0Jyk7XG4vKipcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGFsbCBpdGVtcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB0aGF0IGFyZSBkaXN0aW5jdCBieSBjb21wYXJpc29uIGZyb20gcHJldmlvdXMgaXRlbXMuXG4gKlxuICogSWYgYSBrZXlTZWxlY3RvciBmdW5jdGlvbiBpcyBwcm92aWRlZCwgdGhlbiBpdCB3aWxsIHByb2plY3QgZWFjaCB2YWx1ZSBmcm9tIHRoZSBzb3VyY2Ugb2JzZXJ2YWJsZSBpbnRvIGEgbmV3IHZhbHVlIHRoYXQgaXQgd2lsbFxuICogY2hlY2sgZm9yIGVxdWFsaXR5IHdpdGggcHJldmlvdXNseSBwcm9qZWN0ZWQgdmFsdWVzLiBJZiBhIGtleVNlbGVjdG9yIGZ1bmN0aW9uIGlzIG5vdCBwcm92aWRlZCwgaXQgd2lsbCB1c2UgZWFjaCB2YWx1ZSBmcm9tIHRoZVxuICogc291cmNlIG9ic2VydmFibGUgZGlyZWN0bHkgd2l0aCBhbiBlcXVhbGl0eSBjaGVjayBhZ2FpbnN0IHByZXZpb3VzIHZhbHVlcy5cbiAqXG4gKiBJbiBKYXZhU2NyaXB0IHJ1bnRpbWVzIHRoYXQgc3VwcG9ydCBgU2V0YCwgdGhpcyBvcGVyYXRvciB3aWxsIHVzZSBhIGBTZXRgIHRvIGltcHJvdmUgcGVyZm9ybWFuY2Ugb2YgdGhlIGRpc3RpbmN0IHZhbHVlIGNoZWNraW5nLlxuICpcbiAqIEluIG90aGVyIHJ1bnRpbWVzLCB0aGlzIG9wZXJhdG9yIHdpbGwgdXNlIGEgbWluaW1hbCBpbXBsZW1lbnRhdGlvbiBvZiBgU2V0YCB0aGF0IHJlbGllcyBvbiBhbiBgQXJyYXlgIGFuZCBgaW5kZXhPZmAgdW5kZXIgdGhlXG4gKiBob29kLCBzbyBwZXJmb3JtYW5jZSB3aWxsIGRlZ3JhZGUgYXMgbW9yZSB2YWx1ZXMgYXJlIGNoZWNrZWQgZm9yIGRpc3RpbmN0aW9uLiBFdmVuIGluIG5ld2VyIGJyb3dzZXJzLCBhIGxvbmctcnVubmluZyBgZGlzdGluY3RgXG4gKiB1c2UgbWlnaHQgcmVzdWx0IGluIG1lbW9yeSBsZWFrcy4gVG8gaGVscCBhbGxldmlhdGUgdGhpcyBpbiBzb21lIHNjZW5hcmlvcywgYW4gb3B0aW9uYWwgYGZsdXNoZXNgIHBhcmFtZXRlciBpcyBhbHNvIHByb3ZpZGVkIHNvXG4gKiB0aGF0IHRoZSBpbnRlcm5hbCBgU2V0YCBjYW4gYmUgXCJmbHVzaGVkXCIsIGJhc2ljYWxseSBjbGVhcmluZyBpdCBvZiB2YWx1ZXMuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+QSBzaW1wbGUgZXhhbXBsZSB3aXRoIG51bWJlcnM8L2NhcHRpb24+XG4gKiBPYnNlcnZhYmxlLm9mKDEsIDEsIDIsIDIsIDIsIDEsIDIsIDMsIDQsIDMsIDIsIDEpXG4gKiAgIC5kaXN0aW5jdCgpXG4gKiAgIC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7IC8vIDEsIDIsIDMsIDRcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5BbiBleGFtcGxlIHVzaW5nIGEga2V5U2VsZWN0b3IgZnVuY3Rpb248L2NhcHRpb24+XG4gKiBpbnRlcmZhY2UgUGVyc29uIHtcbiAqICAgIGFnZTogbnVtYmVyLFxuICogICAgbmFtZTogc3RyaW5nXG4gKiB9XG4gKlxuICogT2JzZXJ2YWJsZS5vZjxQZXJzb24+KFxuICogICAgIHsgYWdlOiA0LCBuYW1lOiAnRm9vJ30sXG4gKiAgICAgeyBhZ2U6IDcsIG5hbWU6ICdCYXInfSxcbiAqICAgICB7IGFnZTogNSwgbmFtZTogJ0Zvbyd9KVxuICogICAgIC5kaXN0aW5jdCgocDogUGVyc29uKSA9PiBwLm5hbWUpXG4gKiAgICAgLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBkaXNwbGF5czpcbiAqIC8vIHsgYWdlOiA0LCBuYW1lOiAnRm9vJyB9XG4gKiAvLyB7IGFnZTogNywgbmFtZTogJ0JhcicgfVxuICpcbiAqIEBzZWUge0BsaW5rIGRpc3RpbmN0VW50aWxDaGFuZ2VkfVxuICogQHNlZSB7QGxpbmsgZGlzdGluY3RVbnRpbEtleUNoYW5nZWR9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2tleVNlbGVjdG9yXSBPcHRpb25hbCBmdW5jdGlvbiB0byBzZWxlY3Qgd2hpY2ggdmFsdWUgeW91IHdhbnQgdG8gY2hlY2sgYXMgZGlzdGluY3QuXG4gKiBAcGFyYW0ge09ic2VydmFibGV9IFtmbHVzaGVzXSBPcHRpb25hbCBPYnNlcnZhYmxlIGZvciBmbHVzaGluZyB0aGUgaW50ZXJuYWwgSGFzaFNldCBvZiB0aGUgb3BlcmF0b3IuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgaXRlbXMgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgd2l0aCBkaXN0aW5jdCB2YWx1ZXMuXG4gKiBAbWV0aG9kIGRpc3RpbmN0XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBkaXN0aW5jdChrZXlTZWxlY3RvciwgZmx1c2hlcykge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IERpc3RpbmN0T3BlcmF0b3Ioa2V5U2VsZWN0b3IsIGZsdXNoZXMpKTtcbn1cbmV4cG9ydHMuZGlzdGluY3QgPSBkaXN0aW5jdDtcbnZhciBEaXN0aW5jdE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEaXN0aW5jdE9wZXJhdG9yKGtleVNlbGVjdG9yLCBmbHVzaGVzKSB7XG4gICAgICAgIHRoaXMua2V5U2VsZWN0b3IgPSBrZXlTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5mbHVzaGVzID0gZmx1c2hlcztcbiAgICB9XG4gICAgRGlzdGluY3RPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IERpc3RpbmN0U3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmtleVNlbGVjdG9yLCB0aGlzLmZsdXNoZXMpKTtcbiAgICB9O1xuICAgIHJldHVybiBEaXN0aW5jdE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgRGlzdGluY3RTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGlzdGluY3RTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERpc3RpbmN0U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwga2V5U2VsZWN0b3IsIGZsdXNoZXMpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmtleVNlbGVjdG9yID0ga2V5U2VsZWN0b3I7XG4gICAgICAgIHRoaXMudmFsdWVzID0gbmV3IFNldF8xLlNldCgpO1xuICAgICAgICBpZiAoZmx1c2hlcykge1xuICAgICAgICAgICAgdGhpcy5hZGQoc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBmbHVzaGVzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgRGlzdGluY3RTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMudmFsdWVzLmNsZWFyKCk7XG4gICAgfTtcbiAgICBEaXN0aW5jdFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUVycm9yID0gZnVuY3Rpb24gKGVycm9yLCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLl9lcnJvcihlcnJvcik7XG4gICAgfTtcbiAgICBEaXN0aW5jdFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmtleVNlbGVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLl91c2VLZXlTZWxlY3Rvcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9maW5hbGl6ZU5leHQodmFsdWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGlzdGluY3RTdWJzY3JpYmVyLnByb3RvdHlwZS5fdXNlS2V5U2VsZWN0b3IgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGtleSA9IHRoaXMua2V5U2VsZWN0b3IodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZmluYWxpemVOZXh0KGtleSwgdmFsdWUpO1xuICAgIH07XG4gICAgRGlzdGluY3RTdWJzY3JpYmVyLnByb3RvdHlwZS5fZmluYWxpemVOZXh0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuICAgICAgICBpZiAoIXZhbHVlcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgdmFsdWVzLmFkZChrZXkpO1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIERpc3RpbmN0U3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG5leHBvcnRzLkRpc3RpbmN0U3Vic2NyaWJlciA9IERpc3RpbmN0U3Vic2NyaWJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpc3RpbmN0LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9yL2Rpc3RpbmN0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZGlzdGluY3RVbnRpbENoYW5nZWRfMSA9IHJlcXVpcmUoJy4vZGlzdGluY3RVbnRpbENoYW5nZWQnKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGFsbCBpdGVtcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB0aGF0IGFyZSBkaXN0aW5jdCBieSBjb21wYXJpc29uIGZyb20gdGhlIHByZXZpb3VzIGl0ZW0sXG4gKiB1c2luZyBhIHByb3BlcnR5IGFjY2Vzc2VkIGJ5IHVzaW5nIHRoZSBrZXkgcHJvdmlkZWQgdG8gY2hlY2sgaWYgdGhlIHR3byBpdGVtcyBhcmUgZGlzdGluY3QuXG4gKlxuICogSWYgYSBjb21wYXJhdG9yIGZ1bmN0aW9uIGlzIHByb3ZpZGVkLCB0aGVuIGl0IHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIGl0ZW0gdG8gdGVzdCBmb3Igd2hldGhlciBvciBub3QgdGhhdCB2YWx1ZSBzaG91bGQgYmUgZW1pdHRlZC5cbiAqXG4gKiBJZiBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gaXMgbm90IHByb3ZpZGVkLCBhbiBlcXVhbGl0eSBjaGVjayBpcyB1c2VkIGJ5IGRlZmF1bHQuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+QW4gZXhhbXBsZSBjb21wYXJpbmcgdGhlIG5hbWUgb2YgcGVyc29uczwvY2FwdGlvbj5cbiAqXG4gKiAgaW50ZXJmYWNlIFBlcnNvbiB7XG4gKiAgICAgYWdlOiBudW1iZXIsXG4gKiAgICAgbmFtZTogc3RyaW5nXG4gKiAgfVxuICpcbiAqIE9ic2VydmFibGUub2Y8UGVyc29uPihcbiAqICAgICB7IGFnZTogNCwgbmFtZTogJ0Zvbyd9LFxuICogICAgIHsgYWdlOiA3LCBuYW1lOiAnQmFyJ30sXG4gKiAgICAgeyBhZ2U6IDUsIG5hbWU6ICdGb28nfSxcbiAqICAgICB7IGFnZTogNiwgbmFtZTogJ0Zvbyd9KVxuICogICAgIC5kaXN0aW5jdFVudGlsS2V5Q2hhbmdlZCgnbmFtZScpXG4gKiAgICAgLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBkaXNwbGF5czpcbiAqIC8vIHsgYWdlOiA0LCBuYW1lOiAnRm9vJyB9XG4gKiAvLyB7IGFnZTogNywgbmFtZTogJ0JhcicgfVxuICogLy8geyBhZ2U6IDUsIG5hbWU6ICdGb28nIH1cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5BbiBleGFtcGxlIGNvbXBhcmluZyB0aGUgZmlyc3QgbGV0dGVycyBvZiB0aGUgbmFtZTwvY2FwdGlvbj5cbiAqXG4gKiBpbnRlcmZhY2UgUGVyc29uIHtcbiAqICAgICBhZ2U6IG51bWJlcixcbiAqICAgICBuYW1lOiBzdHJpbmdcbiAqICB9XG4gKlxuICogT2JzZXJ2YWJsZS5vZjxQZXJzb24+KFxuICogICAgIHsgYWdlOiA0LCBuYW1lOiAnRm9vMSd9LFxuICogICAgIHsgYWdlOiA3LCBuYW1lOiAnQmFyJ30sXG4gKiAgICAgeyBhZ2U6IDUsIG5hbWU6ICdGb28yJ30sXG4gKiAgICAgeyBhZ2U6IDYsIG5hbWU6ICdGb28zJ30pXG4gKiAgICAgLmRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkKCduYW1lJywgKHg6IHN0cmluZywgeTogc3RyaW5nKSA9PiB4LnN1YnN0cmluZygwLCAzKSA9PT0geS5zdWJzdHJpbmcoMCwgMykpXG4gKiAgICAgLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBkaXNwbGF5czpcbiAqIC8vIHsgYWdlOiA0LCBuYW1lOiAnRm9vMScgfVxuICogLy8geyBhZ2U6IDcsIG5hbWU6ICdCYXInIH1cbiAqIC8vIHsgYWdlOiA1LCBuYW1lOiAnRm9vMicgfVxuICpcbiAqIEBzZWUge0BsaW5rIGRpc3RpbmN0fVxuICogQHNlZSB7QGxpbmsgZGlzdGluY3RVbnRpbENoYW5nZWR9XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBTdHJpbmcga2V5IGZvciBvYmplY3QgcHJvcGVydHkgbG9va3VwIG9uIGVhY2ggaXRlbS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjb21wYXJlXSBPcHRpb25hbCBjb21wYXJpc29uIGZ1bmN0aW9uIGNhbGxlZCB0byB0ZXN0IGlmIGFuIGl0ZW0gaXMgZGlzdGluY3QgZnJvbSB0aGUgcHJldmlvdXMgaXRlbSBpbiB0aGUgc291cmNlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGl0ZW1zIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHdpdGggZGlzdGluY3QgdmFsdWVzIGJhc2VkIG9uIHRoZSBrZXkgc3BlY2lmaWVkLlxuICogQG1ldGhvZCBkaXN0aW5jdFVudGlsS2V5Q2hhbmdlZFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gZGlzdGluY3RVbnRpbEtleUNoYW5nZWQoa2V5LCBjb21wYXJlKSB7XG4gICAgcmV0dXJuIGRpc3RpbmN0VW50aWxDaGFuZ2VkXzEuZGlzdGluY3RVbnRpbENoYW5nZWQuY2FsbCh0aGlzLCBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICBpZiAoY29tcGFyZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmUoeFtrZXldLCB5W2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4W2tleV0gPT09IHlba2V5XTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZGlzdGluY3RVbnRpbEtleUNoYW5nZWQgPSBkaXN0aW5jdFVudGlsS2V5Q2hhbmdlZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9yL2Rpc3RpbmN0VW50aWxLZXlDaGFuZ2VkLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBQZXJmb3JtIGEgc2lkZSBlZmZlY3QgZm9yIGV2ZXJ5IGVtaXNzaW9uIG9uIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgYnV0IHJldHVyblxuICogYW4gT2JzZXJ2YWJsZSB0aGF0IGlzIGlkZW50aWNhbCB0byB0aGUgc291cmNlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5JbnRlcmNlcHRzIGVhY2ggZW1pc3Npb24gb24gdGhlIHNvdXJjZSBhbmQgcnVucyBhXG4gKiBmdW5jdGlvbiwgYnV0IHJldHVybnMgYW4gb3V0cHV0IHdoaWNoIGlzIGlkZW50aWNhbCB0byB0aGUgc291cmNlLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2RvLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFJldHVybnMgYSBtaXJyb3JlZCBPYnNlcnZhYmxlIG9mIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgYnV0IG1vZGlmaWVkIHNvIHRoYXRcbiAqIHRoZSBwcm92aWRlZCBPYnNlcnZlciBpcyBjYWxsZWQgdG8gcGVyZm9ybSBhIHNpZGUgZWZmZWN0IGZvciBldmVyeSB2YWx1ZSxcbiAqIGVycm9yLCBhbmQgY29tcGxldGlvbiBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UuIEFueSBlcnJvcnMgdGhhdCBhcmUgdGhyb3duIGluXG4gKiB0aGUgYWZvcmVtZW50aW9uZWQgT2JzZXJ2ZXIgb3IgaGFuZGxlcnMgYXJlIHNhZmVseSBzZW50IGRvd24gdGhlIGVycm9yIHBhdGhcbiAqIG9mIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAqXG4gKiBUaGlzIG9wZXJhdG9yIGlzIHVzZWZ1bCBmb3IgZGVidWdnaW5nIHlvdXIgT2JzZXJ2YWJsZXMgZm9yIHRoZSBjb3JyZWN0IHZhbHVlc1xuICogb3IgcGVyZm9ybWluZyBvdGhlciBzaWRlIGVmZmVjdHMuXG4gKlxuICogTm90ZTogdGhpcyBpcyBkaWZmZXJlbnQgdG8gYSBgc3Vic2NyaWJlYCBvbiB0aGUgT2JzZXJ2YWJsZS4gSWYgdGhlIE9ic2VydmFibGVcbiAqIHJldHVybmVkIGJ5IGBkb2AgaXMgbm90IHN1YnNjcmliZWQsIHRoZSBzaWRlIGVmZmVjdHMgc3BlY2lmaWVkIGJ5IHRoZVxuICogT2JzZXJ2ZXIgd2lsbCBuZXZlciBoYXBwZW4uIGBkb2AgdGhlcmVmb3JlIHNpbXBseSBzcGllcyBvbiBleGlzdGluZ1xuICogZXhlY3V0aW9uLCBpdCBkb2VzIG5vdCB0cmlnZ2VyIGFuIGV4ZWN1dGlvbiB0byBoYXBwZW4gbGlrZSBgc3Vic2NyaWJlYCBkb2VzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPk1hcCBldmVyeSBldmVyeSBjbGljayB0byB0aGUgY2xpZW50WCBwb3NpdGlvbiBvZiB0aGF0IGNsaWNrLCB3aGlsZSBhbHNvIGxvZ2dpbmcgdGhlIGNsaWNrIGV2ZW50PC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBwb3NpdGlvbnMgPSBjbGlja3NcbiAqICAgLmRvKGV2ID0+IGNvbnNvbGUubG9nKGV2KSlcbiAqICAgLm1hcChldiA9PiBldi5jbGllbnRYKTtcbiAqIHBvc2l0aW9ucy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgbWFwfVxuICogQHNlZSB7QGxpbmsgc3Vic2NyaWJlfVxuICpcbiAqIEBwYXJhbSB7T2JzZXJ2ZXJ8ZnVuY3Rpb259IFtuZXh0T3JPYnNlcnZlcl0gQSBub3JtYWwgT2JzZXJ2ZXIgb2JqZWN0IG9yIGFcbiAqIGNhbGxiYWNrIGZvciBgbmV4dGAuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbZXJyb3JdIENhbGxiYWNrIGZvciBlcnJvcnMgaW4gdGhlIHNvdXJjZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjb21wbGV0ZV0gQ2FsbGJhY2sgZm9yIHRoZSBjb21wbGV0aW9uIG9mIHRoZSBzb3VyY2UuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIGlkZW50aWNhbCB0byB0aGUgc291cmNlLCBidXQgcnVucyB0aGVcbiAqIHNwZWNpZmllZCBPYnNlcnZlciBvciBjYWxsYmFjayhzKSBmb3IgZWFjaCBpdGVtLlxuICogQG1ldGhvZCBkb1xuICogQG5hbWUgZG9cbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIF9kbyhuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgRG9PcGVyYXRvcihuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKSk7XG59XG5leHBvcnRzLl9kbyA9IF9kbztcbnZhciBEb09wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEb09wZXJhdG9yKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgdGhpcy5uZXh0T3JPYnNlcnZlciA9IG5leHRPck9ic2VydmVyO1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgIHRoaXMuY29tcGxldGUgPSBjb21wbGV0ZTtcbiAgICB9XG4gICAgRG9PcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IERvU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLm5leHRPck9ic2VydmVyLCB0aGlzLmVycm9yLCB0aGlzLmNvbXBsZXRlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRG9PcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIERvU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERvU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEb1N1YnNjcmliZXIoZGVzdGluYXRpb24sIG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB2YXIgc2FmZVN1YnNjcmliZXIgPSBuZXcgU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSk7XG4gICAgICAgIHNhZmVTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93YWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuYWRkKHNhZmVTdWJzY3JpYmVyKTtcbiAgICAgICAgdGhpcy5zYWZlU3Vic2NyaWJlciA9IHNhZmVTdWJzY3JpYmVyO1xuICAgIH1cbiAgICBEb1N1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBzYWZlU3Vic2NyaWJlciA9IHRoaXMuc2FmZVN1YnNjcmliZXI7XG4gICAgICAgIHNhZmVTdWJzY3JpYmVyLm5leHQodmFsdWUpO1xuICAgICAgICBpZiAoc2FmZVN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3duKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKHNhZmVTdWJzY3JpYmVyLnN5bmNFcnJvclZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERvU3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB2YXIgc2FmZVN1YnNjcmliZXIgPSB0aGlzLnNhZmVTdWJzY3JpYmVyO1xuICAgICAgICBzYWZlU3Vic2NyaWJlci5lcnJvcihlcnIpO1xuICAgICAgICBpZiAoc2FmZVN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3duKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKHNhZmVTdWJzY3JpYmVyLnN5bmNFcnJvclZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRG9TdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzYWZlU3Vic2NyaWJlciA9IHRoaXMuc2FmZVN1YnNjcmliZXI7XG4gICAgICAgIHNhZmVTdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIGlmIChzYWZlU3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3Ioc2FmZVN1YnNjcmliZXIuc3luY0Vycm9yVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRG9TdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZG8uanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3IvZG8uanNcbi8vIG1vZHVsZSBpZCA9IDI3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcl8xID0gcmVxdWlyZSgnLi4vdXRpbC9Bcmd1bWVudE91dE9mUmFuZ2VFcnJvcicpO1xuLyoqXG4gKiBFbWl0cyB0aGUgc2luZ2xlIHZhbHVlIGF0IHRoZSBzcGVjaWZpZWQgYGluZGV4YCBpbiBhIHNlcXVlbmNlIG9mIGVtaXNzaW9uc1xuICogZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkVtaXRzIG9ubHkgdGhlIGktdGggdmFsdWUsIHRoZW4gY29tcGxldGVzLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2VsZW1lbnRBdC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgZWxlbWVudEF0YCByZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgaXRlbSBhdCB0aGUgc3BlY2lmaWVkXG4gKiBgaW5kZXhgIGluIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgb3IgYSBkZWZhdWx0IHZhbHVlIGlmIHRoYXQgYGluZGV4YCBpcyBvdXRcbiAqIG9mIHJhbmdlIGFuZCB0aGUgYGRlZmF1bHRgIGFyZ3VtZW50IGlzIHByb3ZpZGVkLiBJZiB0aGUgYGRlZmF1bHRgIGFyZ3VtZW50IGlzXG4gKiBub3QgZ2l2ZW4gYW5kIHRoZSBgaW5kZXhgIGlzIG91dCBvZiByYW5nZSwgdGhlIG91dHB1dCBPYnNlcnZhYmxlIHdpbGwgZW1pdCBhblxuICogYEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yYCBlcnJvci5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0IG9ubHkgdGhlIHRoaXJkIGNsaWNrIGV2ZW50PC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3MuZWxlbWVudEF0KDIpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBSZXN1bHRzIGluOlxuICogLy8gY2xpY2sgMSA9IG5vdGhpbmdcbiAqIC8vIGNsaWNrIDIgPSBub3RoaW5nXG4gKiAvLyBjbGljayAzID0gTW91c2VFdmVudCBvYmplY3QgbG9nZ2VkIHRvIGNvbnNvbGVcbiAqXG4gKiBAc2VlIHtAbGluayBmaXJzdH1cbiAqIEBzZWUge0BsaW5rIGxhc3R9XG4gKiBAc2VlIHtAbGluayBza2lwfVxuICogQHNlZSB7QGxpbmsgc2luZ2xlfVxuICogQHNlZSB7QGxpbmsgdGFrZX1cbiAqXG4gKiBAdGhyb3dzIHtBcmd1bWVudE91dE9mUmFuZ2VFcnJvcn0gV2hlbiB1c2luZyBgZWxlbWVudEF0KGkpYCwgaXQgZGVsaXZlcnMgYW5cbiAqIEFyZ3VtZW50T3V0T3JSYW5nZUVycm9yIHRvIHRoZSBPYnNlcnZlcidzIGBlcnJvcmAgY2FsbGJhY2sgaWYgYGkgPCAwYCBvciB0aGVcbiAqIE9ic2VydmFibGUgaGFzIGNvbXBsZXRlZCBiZWZvcmUgZW1pdHRpbmcgdGhlIGktdGggYG5leHRgIG5vdGlmaWNhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSXMgdGhlIG51bWJlciBgaWAgZm9yIHRoZSBpLXRoIHNvdXJjZSBlbWlzc2lvbiB0aGF0IGhhc1xuICogaGFwcGVuZWQgc2luY2UgdGhlIHN1YnNjcmlwdGlvbiwgc3RhcnRpbmcgZnJvbSB0aGUgbnVtYmVyIGAwYC5cbiAqIEBwYXJhbSB7VH0gW2RlZmF1bHRWYWx1ZV0gVGhlIGRlZmF1bHQgdmFsdWUgcmV0dXJuZWQgZm9yIG1pc3NpbmcgaW5kaWNlcy5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBhIHNpbmdsZSBpdGVtLCBpZiBpdCBpcyBmb3VuZC5cbiAqIE90aGVyd2lzZSwgd2lsbCBlbWl0IHRoZSBkZWZhdWx0IHZhbHVlIGlmIGdpdmVuLiBJZiBub3QsIHRoZW4gZW1pdHMgYW4gZXJyb3IuXG4gKiBAbWV0aG9kIGVsZW1lbnRBdFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gZWxlbWVudEF0KGluZGV4LCBkZWZhdWx0VmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBFbGVtZW50QXRPcGVyYXRvcihpbmRleCwgZGVmYXVsdFZhbHVlKSk7XG59XG5leHBvcnRzLmVsZW1lbnRBdCA9IGVsZW1lbnRBdDtcbnZhciBFbGVtZW50QXRPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRWxlbWVudEF0T3BlcmF0b3IoaW5kZXgsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3JfMS5Bcmd1bWVudE91dE9mUmFuZ2VFcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBFbGVtZW50QXRPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IEVsZW1lbnRBdFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5pbmRleCwgdGhpcy5kZWZhdWx0VmFsdWUpKTtcbiAgICB9O1xuICAgIHJldHVybiBFbGVtZW50QXRPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIEVsZW1lbnRBdFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFbGVtZW50QXRTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEVsZW1lbnRBdFN1YnNjcmliZXIoZGVzdGluYXRpb24sIGluZGV4LCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgICBFbGVtZW50QXRTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGlmICh0aGlzLmluZGV4LS0gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh4KTtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRWxlbWVudEF0U3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICBpZiAodGhpcy5pbmRleCA+PSAwKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuZGVmYXVsdFZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQodGhpcy5kZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24uZXJyb3IobmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yXzEuQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gRWxlbWVudEF0U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVsZW1lbnRBdC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvci9lbGVtZW50QXQuanNcbi8vIG1vZHVsZSBpZCA9IDI3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgd2hldGhlciBvciBub3QgZXZlcnkgaXRlbSBvZiB0aGUgc291cmNlIHNhdGlzZmllcyB0aGUgY29uZGl0aW9uIHNwZWNpZmllZC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5BIHNpbXBsZSBleGFtcGxlIGVtaXR0aW5nIHRydWUgaWYgYWxsIGVsZW1lbnRzIGFyZSBsZXNzIHRoYW4gNSwgZmFsc2Ugb3RoZXJ3aXNlPC9jYXB0aW9uPlxuICogIE9ic2VydmFibGUub2YoMSwgMiwgMywgNCwgNSwgNilcbiAqICAgICAuZXZlcnkoeCA9PiB4IDwgNSlcbiAqICAgICAuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpOyAvLyAtPiBmYWxzZVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHByZWRpY2F0ZSBBIGZ1bmN0aW9uIGZvciBkZXRlcm1pbmluZyBpZiBhbiBpdGVtIG1lZXRzIGEgc3BlY2lmaWVkIGNvbmRpdGlvbi5cbiAqIEBwYXJhbSB7YW55fSBbdGhpc0FyZ10gT3B0aW9uYWwgb2JqZWN0IHRvIHVzZSBmb3IgYHRoaXNgIGluIHRoZSBjYWxsYmFjay5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgb2YgYm9vbGVhbnMgdGhhdCBkZXRlcm1pbmVzIGlmIGFsbCBpdGVtcyBvZiB0aGUgc291cmNlIE9ic2VydmFibGUgbWVldCB0aGUgY29uZGl0aW9uIHNwZWNpZmllZC5cbiAqIEBtZXRob2QgZXZlcnlcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGV2ZXJ5KHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IEV2ZXJ5T3BlcmF0b3IocHJlZGljYXRlLCB0aGlzQXJnLCB0aGlzKSk7XG59XG5leHBvcnRzLmV2ZXJ5ID0gZXZlcnk7XG52YXIgRXZlcnlPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXZlcnlPcGVyYXRvcihwcmVkaWNhdGUsIHRoaXNBcmcsIHNvdXJjZSkge1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgdGhpcy50aGlzQXJnID0gdGhpc0FyZztcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIEV2ZXJ5T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAob2JzZXJ2ZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgRXZlcnlTdWJzY3JpYmVyKG9ic2VydmVyLCB0aGlzLnByZWRpY2F0ZSwgdGhpcy50aGlzQXJnLCB0aGlzLnNvdXJjZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIEV2ZXJ5T3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBFdmVyeVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFdmVyeVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXZlcnlTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBwcmVkaWNhdGUsIHRoaXNBcmcsIHNvdXJjZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICB0aGlzLnRoaXNBcmcgPSB0aGlzQXJnO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIHRoaXMudGhpc0FyZyA9IHRoaXNBcmcgfHwgdGhpcztcbiAgICB9XG4gICAgRXZlcnlTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uIChldmVyeVZhbHVlTWF0Y2gpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KGV2ZXJ5VmFsdWVNYXRjaCk7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9O1xuICAgIEV2ZXJ5U3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wcmVkaWNhdGUuY2FsbCh0aGlzLnRoaXNBcmcsIHZhbHVlLCB0aGlzLmluZGV4KyssIHRoaXMuc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5Q29tcGxldGUoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFdmVyeVN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5ub3RpZnlDb21wbGV0ZSh0cnVlKTtcbiAgICB9O1xuICAgIHJldHVybiBFdmVyeVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldmVyeS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvci9ldmVyeS5qc1xuLy8gbW9kdWxlIGlkID0gMjc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyoqXG4gKiBDb252ZXJ0cyBhIGhpZ2hlci1vcmRlciBPYnNlcnZhYmxlIGludG8gYSBmaXJzdC1vcmRlciBPYnNlcnZhYmxlIGJ5IGRyb3BwaW5nXG4gKiBpbm5lciBPYnNlcnZhYmxlcyB3aGlsZSB0aGUgcHJldmlvdXMgaW5uZXIgT2JzZXJ2YWJsZSBoYXMgbm90IHlldCBjb21wbGV0ZWQuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkZsYXR0ZW5zIGFuIE9ic2VydmFibGUtb2YtT2JzZXJ2YWJsZXMgYnkgZHJvcHBpbmcgdGhlXG4gKiBuZXh0IGlubmVyIE9ic2VydmFibGVzIHdoaWxlIHRoZSBjdXJyZW50IGlubmVyIGlzIHN0aWxsIGV4ZWN1dGluZy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9leGhhdXN0LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBleGhhdXN0YCBzdWJzY3JpYmVzIHRvIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBPYnNlcnZhYmxlcywgYWxzbyBrbm93biBhcyBhXG4gKiBoaWdoZXItb3JkZXIgT2JzZXJ2YWJsZS4gRWFjaCB0aW1lIGl0IG9ic2VydmVzIG9uZSBvZiB0aGVzZSBlbWl0dGVkIGlubmVyXG4gKiBPYnNlcnZhYmxlcywgdGhlIG91dHB1dCBPYnNlcnZhYmxlIGJlZ2lucyBlbWl0dGluZyB0aGUgaXRlbXMgZW1pdHRlZCBieSB0aGF0XG4gKiBpbm5lciBPYnNlcnZhYmxlLiBTbyBmYXIsIGl0IGJlaGF2ZXMgbGlrZSB7QGxpbmsgbWVyZ2VBbGx9LiBIb3dldmVyLFxuICogYGV4aGF1c3RgIGlnbm9yZXMgZXZlcnkgbmV3IGlubmVyIE9ic2VydmFibGUgaWYgdGhlIHByZXZpb3VzIE9ic2VydmFibGUgaGFzXG4gKiBub3QgeWV0IGNvbXBsZXRlZC4gT25jZSB0aGF0IG9uZSBjb21wbGV0ZXMsIGl0IHdpbGwgYWNjZXB0IGFuZCBmbGF0dGVuIHRoZVxuICogbmV4dCBpbm5lciBPYnNlcnZhYmxlIGFuZCByZXBlYXQgdGhpcyBwcm9jZXNzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlJ1biBhIGZpbml0ZSB0aW1lciBmb3IgZWFjaCBjbGljaywgb25seSBpZiB0aGVyZSBpcyBubyBjdXJyZW50bHkgYWN0aXZlIHRpbWVyPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBoaWdoZXJPcmRlciA9IGNsaWNrcy5tYXAoKGV2KSA9PiBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApKTtcbiAqIHZhciByZXN1bHQgPSBoaWdoZXJPcmRlci5leGhhdXN0KCk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGNvbWJpbmVBbGx9XG4gKiBAc2VlIHtAbGluayBjb25jYXRBbGx9XG4gKiBAc2VlIHtAbGluayBzd2l0Y2h9XG4gKiBAc2VlIHtAbGluayBtZXJnZUFsbH1cbiAqIEBzZWUge0BsaW5rIGV4aGF1c3RNYXB9XG4gKiBAc2VlIHtAbGluayB6aXBBbGx9XG4gKlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IHRha2VzIGEgc291cmNlIG9mIE9ic2VydmFibGVzIGFuZCBwcm9wYWdhdGVzIHRoZSBmaXJzdCBvYnNlcnZhYmxlXG4gKiBleGNsdXNpdmVseSB1bnRpbCBpdCBjb21wbGV0ZXMgYmVmb3JlIHN1YnNjcmliaW5nIHRvIHRoZSBuZXh0LlxuICogQG1ldGhvZCBleGhhdXN0XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBleGhhdXN0KCkge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFN3aXRjaEZpcnN0T3BlcmF0b3IoKSk7XG59XG5leHBvcnRzLmV4aGF1c3QgPSBleGhhdXN0O1xudmFyIFN3aXRjaEZpcnN0T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN3aXRjaEZpcnN0T3BlcmF0b3IoKSB7XG4gICAgfVxuICAgIFN3aXRjaEZpcnN0T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBTd2l0Y2hGaXJzdFN1YnNjcmliZXIoc3Vic2NyaWJlcikpO1xuICAgIH07XG4gICAgcmV0dXJuIFN3aXRjaEZpcnN0T3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBTd2l0Y2hGaXJzdFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTd2l0Y2hGaXJzdFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3dpdGNoRmlyc3RTdWJzY3JpYmVyKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNTdWJzY3JpcHRpb24gPSBmYWxzZTtcbiAgICB9XG4gICAgU3dpdGNoRmlyc3RTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmhhc1N1YnNjcmlwdGlvbiA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN3aXRjaEZpcnN0U3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmhhc0NvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgIGlmICghdGhpcy5oYXNTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3dpdGNoRmlyc3RTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uIChpbm5lclN1Yikge1xuICAgICAgICB0aGlzLnJlbW92ZShpbm5lclN1Yik7XG4gICAgICAgIHRoaXMuaGFzU3Vic2NyaXB0aW9uID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmhhc0NvbXBsZXRlZCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU3dpdGNoRmlyc3RTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4aGF1c3QuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3IvZXhoYXVzdC5qc1xuLy8gbW9kdWxlIGlkID0gMjc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogUHJvamVjdHMgZWFjaCBzb3VyY2UgdmFsdWUgdG8gYW4gT2JzZXJ2YWJsZSB3aGljaCBpcyBtZXJnZWQgaW4gdGhlIG91dHB1dFxuICogT2JzZXJ2YWJsZSBvbmx5IGlmIHRoZSBwcmV2aW91cyBwcm9qZWN0ZWQgT2JzZXJ2YWJsZSBoYXMgY29tcGxldGVkLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5NYXBzIGVhY2ggdmFsdWUgdG8gYW4gT2JzZXJ2YWJsZSwgdGhlbiBmbGF0dGVucyBhbGwgb2ZcbiAqIHRoZXNlIGlubmVyIE9ic2VydmFibGVzIHVzaW5nIHtAbGluayBleGhhdXN0fS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9leGhhdXN0TWFwLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGl0ZW1zIGJhc2VkIG9uIGFwcGx5aW5nIGEgZnVuY3Rpb24gdGhhdCB5b3VcbiAqIHN1cHBseSB0byBlYWNoIGl0ZW0gZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUsIHdoZXJlIHRoYXQgZnVuY3Rpb25cbiAqIHJldHVybnMgYW4gKHNvLWNhbGxlZCBcImlubmVyXCIpIE9ic2VydmFibGUuIFdoZW4gaXQgcHJvamVjdHMgYSBzb3VyY2UgdmFsdWUgdG9cbiAqIGFuIE9ic2VydmFibGUsIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBiZWdpbnMgZW1pdHRpbmcgdGhlIGl0ZW1zIGVtaXR0ZWQgYnlcbiAqIHRoYXQgcHJvamVjdGVkIE9ic2VydmFibGUuIEhvd2V2ZXIsIGBleGhhdXN0TWFwYCBpZ25vcmVzIGV2ZXJ5IG5ldyBwcm9qZWN0ZWRcbiAqIE9ic2VydmFibGUgaWYgdGhlIHByZXZpb3VzIHByb2plY3RlZCBPYnNlcnZhYmxlIGhhcyBub3QgeWV0IGNvbXBsZXRlZC4gT25jZVxuICogdGhhdCBvbmUgY29tcGxldGVzLCBpdCB3aWxsIGFjY2VwdCBhbmQgZmxhdHRlbiB0aGUgbmV4dCBwcm9qZWN0ZWQgT2JzZXJ2YWJsZVxuICogYW5kIHJlcGVhdCB0aGlzIHByb2Nlc3MuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+UnVuIGEgZmluaXRlIHRpbWVyIGZvciBlYWNoIGNsaWNrLCBvbmx5IGlmIHRoZXJlIGlzIG5vIGN1cnJlbnRseSBhY3RpdmUgdGltZXI8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy5leGhhdXN0TWFwKChldikgPT4gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKSk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGNvbmNhdE1hcH1cbiAqIEBzZWUge0BsaW5rIGV4aGF1c3R9XG4gKiBAc2VlIHtAbGluayBtZXJnZU1hcH1cbiAqIEBzZWUge0BsaW5rIHN3aXRjaE1hcH1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCA/aW5kZXg6IG51bWJlcik6IE9ic2VydmFibGVJbnB1dH0gcHJvamVjdCBBIGZ1bmN0aW9uXG4gKiB0aGF0LCB3aGVuIGFwcGxpZWQgdG8gYW4gaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgcmV0dXJucyBhblxuICogT2JzZXJ2YWJsZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob3V0ZXJWYWx1ZTogVCwgaW5uZXJWYWx1ZTogSSwgb3V0ZXJJbmRleDogbnVtYmVyLCBpbm5lckluZGV4OiBudW1iZXIpOiBhbnl9IFtyZXN1bHRTZWxlY3Rvcl1cbiAqIEEgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdmFsdWUgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlIGJhc2VkIG9uIHRoZSB2YWx1ZXNcbiAqIGFuZCB0aGUgaW5kaWNlcyBvZiB0aGUgc291cmNlIChvdXRlcikgZW1pc3Npb24gYW5kIHRoZSBpbm5lciBPYnNlcnZhYmxlXG4gKiBlbWlzc2lvbi4gVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBhcmU6XG4gKiAtIGBvdXRlclZhbHVlYDogdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBzb3VyY2VcbiAqIC0gYGlubmVyVmFsdWVgOiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiAtIGBvdXRlckluZGV4YDogdGhlIFwiaW5kZXhcIiBvZiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHNvdXJjZVxuICogLSBgaW5uZXJJbmRleGA6IHRoZSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIGNvbnRhaW5pbmcgcHJvamVjdGVkIE9ic2VydmFibGVzXG4gKiBvZiBlYWNoIGl0ZW0gb2YgdGhlIHNvdXJjZSwgaWdub3JpbmcgcHJvamVjdGVkIE9ic2VydmFibGVzIHRoYXQgc3RhcnQgYmVmb3JlXG4gKiB0aGVpciBwcmVjZWRpbmcgT2JzZXJ2YWJsZSBoYXMgY29tcGxldGVkLlxuICogQG1ldGhvZCBleGhhdXN0TWFwXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBleGhhdXN0TWFwKHByb2plY3QsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgU3dpdGNoRmlyc3RNYXBPcGVyYXRvcihwcm9qZWN0LCByZXN1bHRTZWxlY3RvcikpO1xufVxuZXhwb3J0cy5leGhhdXN0TWFwID0gZXhoYXVzdE1hcDtcbnZhciBTd2l0Y2hGaXJzdE1hcE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTd2l0Y2hGaXJzdE1hcE9wZXJhdG9yKHByb2plY3QsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgICAgIHRoaXMucmVzdWx0U2VsZWN0b3IgPSByZXN1bHRTZWxlY3RvcjtcbiAgICB9XG4gICAgU3dpdGNoRmlyc3RNYXBPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFN3aXRjaEZpcnN0TWFwU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByb2plY3QsIHRoaXMucmVzdWx0U2VsZWN0b3IpKTtcbiAgICB9O1xuICAgIHJldHVybiBTd2l0Y2hGaXJzdE1hcE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgU3dpdGNoRmlyc3RNYXBTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3dpdGNoRmlyc3RNYXBTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN3aXRjaEZpcnN0TWFwU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcHJvamVjdCwgcmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgICAgICB0aGlzLnJlc3VsdFNlbGVjdG9yID0gcmVzdWx0U2VsZWN0b3I7XG4gICAgICAgIHRoaXMuaGFzU3Vic2NyaXB0aW9uID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH1cbiAgICBTd2l0Y2hGaXJzdE1hcFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMudHJ5TmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN3aXRjaEZpcnN0TWFwU3Vic2NyaWJlci5wcm90b3R5cGUudHJ5TmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4Kys7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5wcm9qZWN0KHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB0aGlzLmhhc1N1YnNjcmlwdGlvbiA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIHJlc3VsdCwgdmFsdWUsIGluZGV4KSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3dpdGNoRmlyc3RNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTd2l0Y2hGaXJzdE1hcFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcmVzdWx0U2VsZWN0b3IgPSBfYS5yZXN1bHRTZWxlY3RvciwgZGVzdGluYXRpb24gPSBfYS5kZXN0aW5hdGlvbjtcbiAgICAgICAgaWYgKHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnRyeVNlbGVjdFJlc3VsdChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQoaW5uZXJWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN3aXRjaEZpcnN0TWFwU3Vic2NyaWJlci5wcm90b3R5cGUudHJ5U2VsZWN0UmVzdWx0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcmVzdWx0U2VsZWN0b3IgPSBfYS5yZXN1bHRTZWxlY3RvciwgZGVzdGluYXRpb24gPSBfYS5kZXN0aW5hdGlvbjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSByZXN1bHRTZWxlY3RvcihvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4KTtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTd2l0Y2hGaXJzdE1hcFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgfTtcbiAgICBTd2l0Y2hGaXJzdE1hcFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKGlubmVyU3ViKTtcbiAgICAgICAgdGhpcy5oYXNTdWJzY3JpcHRpb24gPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuaGFzQ29tcGxldGVkKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTd2l0Y2hGaXJzdE1hcFN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhoYXVzdE1hcC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvci9leGhhdXN0TWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciB0cnlDYXRjaF8xID0gcmVxdWlyZSgnLi4vdXRpbC90cnlDYXRjaCcpO1xudmFyIGVycm9yT2JqZWN0XzEgPSByZXF1aXJlKCcuLi91dGlsL2Vycm9yT2JqZWN0Jyk7XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogUmVjdXJzaXZlbHkgcHJvamVjdHMgZWFjaCBzb3VyY2UgdmFsdWUgdG8gYW4gT2JzZXJ2YWJsZSB3aGljaCBpcyBtZXJnZWQgaW5cbiAqIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SXQncyBzaW1pbGFyIHRvIHtAbGluayBtZXJnZU1hcH0sIGJ1dCBhcHBsaWVzIHRoZVxuICogcHJvamVjdGlvbiBmdW5jdGlvbiB0byBldmVyeSBzb3VyY2UgdmFsdWUgYXMgd2VsbCBhcyBldmVyeSBvdXRwdXQgdmFsdWUuXG4gKiBJdCdzIHJlY3Vyc2l2ZS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9leHBhbmQucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgaXRlbXMgYmFzZWQgb24gYXBwbHlpbmcgYSBmdW5jdGlvbiB0aGF0IHlvdVxuICogc3VwcGx5IHRvIGVhY2ggaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgd2hlcmUgdGhhdCBmdW5jdGlvblxuICogcmV0dXJucyBhbiBPYnNlcnZhYmxlLCBhbmQgdGhlbiBtZXJnaW5nIHRob3NlIHJlc3VsdGluZyBPYnNlcnZhYmxlcyBhbmRcbiAqIGVtaXR0aW5nIHRoZSByZXN1bHRzIG9mIHRoaXMgbWVyZ2VyLiAqRXhwYW5kKiB3aWxsIHJlLWVtaXQgb24gdGhlIG91dHB1dFxuICogT2JzZXJ2YWJsZSBldmVyeSBzb3VyY2UgdmFsdWUuIFRoZW4sIGVhY2ggb3V0cHV0IHZhbHVlIGlzIGdpdmVuIHRvIHRoZVxuICogYHByb2plY3RgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gaW5uZXIgT2JzZXJ2YWJsZSB0byBiZSBtZXJnZWQgb24gdGhlXG4gKiBvdXRwdXQgT2JzZXJ2YWJsZS4gVGhvc2Ugb3V0cHV0IHZhbHVlcyByZXN1bHRpbmcgZnJvbSB0aGUgcHJvamVjdGlvbiBhcmUgYWxzb1xuICogZ2l2ZW4gdG8gdGhlIGBwcm9qZWN0YCBmdW5jdGlvbiB0byBwcm9kdWNlIG5ldyBvdXRwdXQgdmFsdWVzLiBUaGlzIGlzIGhvd1xuICogKmV4cGFuZCogYmVoYXZlcyByZWN1cnNpdmVseS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5TdGFydCBlbWl0dGluZyB0aGUgcG93ZXJzIG9mIHR3byBvbiBldmVyeSBjbGljaywgYXQgbW9zdCAxMCBvZiB0aGVtPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBwb3dlcnNPZlR3byA9IGNsaWNrc1xuICogICAubWFwVG8oMSlcbiAqICAgLmV4cGFuZCh4ID0+IFJ4Lk9ic2VydmFibGUub2YoMiAqIHgpLmRlbGF5KDEwMDApKVxuICogICAudGFrZSgxMCk7XG4gKiBwb3dlcnNPZlR3by5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgbWVyZ2VNYXB9XG4gKiBAc2VlIHtAbGluayBtZXJnZVNjYW59XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCwgaW5kZXg6IG51bWJlcikgPT4gT2JzZXJ2YWJsZX0gcHJvamVjdCBBIGZ1bmN0aW9uXG4gKiB0aGF0LCB3aGVuIGFwcGxpZWQgdG8gYW4gaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2Ugb3IgdGhlIG91dHB1dCBPYnNlcnZhYmxlLFxuICogcmV0dXJucyBhbiBPYnNlcnZhYmxlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtjb25jdXJyZW50PU51bWJlci5QT1NJVElWRV9JTkZJTklUWV0gTWF4aW11bSBudW1iZXIgb2YgaW5wdXRcbiAqIE9ic2VydmFibGVzIGJlaW5nIHN1YnNjcmliZWQgdG8gY29uY3VycmVudGx5LlxuICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9bnVsbF0gVGhlIElTY2hlZHVsZXIgdG8gdXNlIGZvciBzdWJzY3JpYmluZyB0b1xuICogZWFjaCBwcm9qZWN0ZWQgaW5uZXIgT2JzZXJ2YWJsZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgc291cmNlIHZhbHVlcyBhbmQgYWxzb1xuICogcmVzdWx0IG9mIGFwcGx5aW5nIHRoZSBwcm9qZWN0aW9uIGZ1bmN0aW9uIHRvIGVhY2ggdmFsdWUgZW1pdHRlZCBvbiB0aGVcbiAqIG91dHB1dCBPYnNlcnZhYmxlIGFuZCBhbmQgbWVyZ2luZyB0aGUgcmVzdWx0cyBvZiB0aGUgT2JzZXJ2YWJsZXMgb2J0YWluZWRcbiAqIGZyb20gdGhpcyB0cmFuc2Zvcm1hdGlvbi5cbiAqIEBtZXRob2QgZXhwYW5kXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBleHBhbmQocHJvamVjdCwgY29uY3VycmVudCwgc2NoZWR1bGVyKSB7XG4gICAgaWYgKGNvbmN1cnJlbnQgPT09IHZvaWQgMCkgeyBjb25jdXJyZW50ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZOyB9XG4gICAgaWYgKHNjaGVkdWxlciA9PT0gdm9pZCAwKSB7IHNjaGVkdWxlciA9IHVuZGVmaW5lZDsgfVxuICAgIGNvbmN1cnJlbnQgPSAoY29uY3VycmVudCB8fCAwKSA8IDEgPyBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgOiBjb25jdXJyZW50O1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IEV4cGFuZE9wZXJhdG9yKHByb2plY3QsIGNvbmN1cnJlbnQsIHNjaGVkdWxlcikpO1xufVxuZXhwb3J0cy5leHBhbmQgPSBleHBhbmQ7XG52YXIgRXhwYW5kT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV4cGFuZE9wZXJhdG9yKHByb2plY3QsIGNvbmN1cnJlbnQsIHNjaGVkdWxlcikge1xuICAgICAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgICAgICB0aGlzLmNvbmN1cnJlbnQgPSBjb25jdXJyZW50O1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgRXhwYW5kT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBFeHBhbmRTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMucHJvamVjdCwgdGhpcy5jb25jdXJyZW50LCB0aGlzLnNjaGVkdWxlcikpO1xuICAgIH07XG4gICAgcmV0dXJuIEV4cGFuZE9wZXJhdG9yO1xufSgpKTtcbmV4cG9ydHMuRXhwYW5kT3BlcmF0b3IgPSBFeHBhbmRPcGVyYXRvcjtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgRXhwYW5kU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV4cGFuZFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXhwYW5kU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcHJvamVjdCwgY29uY3VycmVudCwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgICAgICAgdGhpcy5jb25jdXJyZW50ID0gY29uY3VycmVudDtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IDA7XG4gICAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gZmFsc2U7XG4gICAgICAgIGlmIChjb25jdXJyZW50IDwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIEV4cGFuZFN1YnNjcmliZXIuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHZhciBzdWJzY3JpYmVyID0gYXJnLnN1YnNjcmliZXIsIHJlc3VsdCA9IGFyZy5yZXN1bHQsIHZhbHVlID0gYXJnLnZhbHVlLCBpbmRleCA9IGFyZy5pbmRleDtcbiAgICAgICAgc3Vic2NyaWJlci5zdWJzY3JpYmVUb1Byb2plY3Rpb24ocmVzdWx0LCB2YWx1ZSwgaW5kZXgpO1xuICAgIH07XG4gICAgRXhwYW5kU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgaWYgKGRlc3RpbmF0aW9uLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhpcy5fY29tcGxldGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4Kys7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSA8IHRoaXMuY29uY3VycmVudCkge1xuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaCh0aGlzLnByb2plY3QpKHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24uZXJyb3IoZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLnNjaGVkdWxlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlVG9Qcm9qZWN0aW9uKHJlc3VsdCwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IHsgc3Vic2NyaWJlcjogdGhpcywgcmVzdWx0OiByZXN1bHQsIHZhbHVlOiB2YWx1ZSwgaW5kZXg6IGluZGV4IH07XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQodGhpcy5zY2hlZHVsZXIuc2NoZWR1bGUoRXhwYW5kU3Vic2NyaWJlci5kaXNwYXRjaCwgMCwgc3RhdGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFeHBhbmRTdWJzY3JpYmVyLnByb3RvdHlwZS5zdWJzY3JpYmVUb1Byb2plY3Rpb24gPSBmdW5jdGlvbiAocmVzdWx0LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5hY3RpdmUrKztcbiAgICAgICAgdGhpcy5hZGQoc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCByZXN1bHQsIHZhbHVlLCBpbmRleCkpO1xuICAgIH07XG4gICAgRXhwYW5kU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmhhc0NvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmhhc0NvbXBsZXRlZCAmJiB0aGlzLmFjdGl2ZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFeHBhbmRTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMuX25leHQoaW5uZXJWYWx1ZSk7XG4gICAgfTtcbiAgICBFeHBhbmRTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uIChpbm5lclN1Yikge1xuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXI7XG4gICAgICAgIHRoaXMucmVtb3ZlKGlubmVyU3ViKTtcbiAgICAgICAgdGhpcy5hY3RpdmUtLTtcbiAgICAgICAgaWYgKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fbmV4dChidWZmZXIuc2hpZnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGFzQ29tcGxldGVkICYmIHRoaXMuYWN0aXZlID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBFeHBhbmRTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbmV4cG9ydHMuRXhwYW5kU3Vic2NyaWJlciA9IEV4cGFuZFN1YnNjcmliZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHBhbmQuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3IvZXhwYW5kLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpcHRpb24nKTtcbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgbWlycm9ycyB0aGUgc291cmNlIE9ic2VydmFibGUsIGJ1dCB3aWxsIGNhbGwgYSBzcGVjaWZpZWQgZnVuY3Rpb24gd2hlblxuICogdGhlIHNvdXJjZSB0ZXJtaW5hdGVzIG9uIGNvbXBsZXRlIG9yIGVycm9yLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gc291cmNlIHRlcm1pbmF0ZXMuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgbWlycm9ycyB0aGUgc291cmNlLCBidXQgd2lsbCBjYWxsIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24gb24gdGVybWluYXRpb24uXG4gKiBAbWV0aG9kIGZpbmFsbHlcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIF9maW5hbGx5KGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgRmluYWxseU9wZXJhdG9yKGNhbGxiYWNrKSk7XG59XG5leHBvcnRzLl9maW5hbGx5ID0gX2ZpbmFsbHk7XG52YXIgRmluYWxseU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGaW5hbGx5T3BlcmF0b3IoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICBGaW5hbGx5T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBGaW5hbGx5U3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmNhbGxiYWNrKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRmluYWxseU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgRmluYWxseVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGaW5hbGx5U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGaW5hbGx5U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgY2FsbGJhY2spIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmFkZChuZXcgU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKGNhbGxiYWNrKSk7XG4gICAgfVxuICAgIHJldHVybiBGaW5hbGx5U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbmFsbHkuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3IvZmluYWxseS5qc1xuLy8gbW9kdWxlIGlkID0gMjc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGZpbmRfMSA9IHJlcXVpcmUoJy4vZmluZCcpO1xuLyoqXG4gKiBFbWl0cyBvbmx5IHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgdmFsdWUgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgdGhhdFxuICogbWVldHMgc29tZSBjb25kaXRpb24uXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgZmluZH0sIGJ1dCBlbWl0cyB0aGUgaW5kZXggb2YgdGhlXG4gKiBmb3VuZCB2YWx1ZSwgbm90IHRoZSB2YWx1ZSBpdHNlbGYuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvZmluZEluZGV4LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBmaW5kSW5kZXhgIHNlYXJjaGVzIGZvciB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgc291cmNlIE9ic2VydmFibGUgdGhhdCBtYXRjaGVzXG4gKiB0aGUgc3BlY2lmaWVkIGNvbmRpdGlvbiBlbWJvZGllZCBieSB0aGUgYHByZWRpY2F0ZWAsIGFuZCByZXR1cm5zIHRoZVxuICogKHplcm8tYmFzZWQpIGluZGV4IG9mIHRoZSBmaXJzdCBvY2N1cnJlbmNlIGluIHRoZSBzb3VyY2UuIFVubGlrZVxuICoge0BsaW5rIGZpcnN0fSwgdGhlIGBwcmVkaWNhdGVgIGlzIHJlcXVpcmVkIGluIGBmaW5kSW5kZXhgLCBhbmQgZG9lcyBub3QgZW1pdFxuICogYW4gZXJyb3IgaWYgYSB2YWxpZCB2YWx1ZSBpcyBub3QgZm91bmQuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdCB0aGUgaW5kZXggb2YgZmlyc3QgY2xpY2sgdGhhdCBoYXBwZW5zIG9uIGEgRElWIGVsZW1lbnQ8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy5maW5kSW5kZXgoZXYgPT4gZXYudGFyZ2V0LnRhZ05hbWUgPT09ICdESVYnKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgZmlsdGVyfVxuICogQHNlZSB7QGxpbmsgZmluZH1cbiAqIEBzZWUge0BsaW5rIGZpcnN0fVxuICogQHNlZSB7QGxpbmsgdGFrZX1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCBpbmRleDogbnVtYmVyLCBzb3VyY2U6IE9ic2VydmFibGU8VD4pOiBib29sZWFufSBwcmVkaWNhdGVcbiAqIEEgZnVuY3Rpb24gY2FsbGVkIHdpdGggZWFjaCBpdGVtIHRvIHRlc3QgZm9yIGNvbmRpdGlvbiBtYXRjaGluZy5cbiAqIEBwYXJhbSB7YW55fSBbdGhpc0FyZ10gQW4gb3B0aW9uYWwgYXJndW1lbnQgdG8gZGV0ZXJtaW5lIHRoZSB2YWx1ZSBvZiBgdGhpc2BcbiAqIGluIHRoZSBgcHJlZGljYXRlYCBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgb2YgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBpdGVtIHRoYXRcbiAqIG1hdGNoZXMgdGhlIGNvbmRpdGlvbi5cbiAqIEBtZXRob2QgZmluZFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gZmluZEluZGV4KHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IGZpbmRfMS5GaW5kVmFsdWVPcGVyYXRvcihwcmVkaWNhdGUsIHRoaXMsIHRydWUsIHRoaXNBcmcpKTtcbn1cbmV4cG9ydHMuZmluZEluZGV4ID0gZmluZEluZGV4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmluZEluZGV4LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9yL2ZpbmRJbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIEVtcHR5RXJyb3JfMSA9IHJlcXVpcmUoJy4uL3V0aWwvRW1wdHlFcnJvcicpO1xuLyoqXG4gKiBFbWl0cyBvbmx5IHRoZSBmaXJzdCB2YWx1ZSAob3IgdGhlIGZpcnN0IHZhbHVlIHRoYXQgbWVldHMgc29tZSBjb25kaXRpb24pXG4gKiBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+RW1pdHMgb25seSB0aGUgZmlyc3QgdmFsdWUuIE9yIGVtaXRzIG9ubHkgdGhlIGZpcnN0XG4gKiB2YWx1ZSB0aGF0IHBhc3NlcyBzb21lIHRlc3QuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvZmlyc3QucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogSWYgY2FsbGVkIHdpdGggbm8gYXJndW1lbnRzLCBgZmlyc3RgIGVtaXRzIHRoZSBmaXJzdCB2YWx1ZSBvZiB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLCB0aGVuIGNvbXBsZXRlcy4gSWYgY2FsbGVkIHdpdGggYSBgcHJlZGljYXRlYCBmdW5jdGlvbiwgYGZpcnN0YFxuICogZW1pdHMgdGhlIGZpcnN0IHZhbHVlIG9mIHRoZSBzb3VyY2UgdGhhdCBtYXRjaGVzIHRoZSBzcGVjaWZpZWQgY29uZGl0aW9uLiBJdFxuICogbWF5IGFsc28gdGFrZSBhIGByZXN1bHRTZWxlY3RvcmAgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgb3V0cHV0IHZhbHVlIGZyb21cbiAqIHRoZSBpbnB1dCB2YWx1ZSwgYW5kIGEgYGRlZmF1bHRWYWx1ZWAgdG8gZW1pdCBpbiBjYXNlIHRoZSBzb3VyY2UgY29tcGxldGVzXG4gKiBiZWZvcmUgaXQgaXMgYWJsZSB0byBlbWl0IGEgdmFsaWQgdmFsdWUuIFRocm93cyBhbiBlcnJvciBpZiBgZGVmYXVsdFZhbHVlYFxuICogd2FzIG5vdCBwcm92aWRlZCBhbmQgYSBtYXRjaGluZyBlbGVtZW50IGlzIG5vdCBmb3VuZC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0IG9ubHkgdGhlIGZpcnN0IGNsaWNrIHRoYXQgaGFwcGVucyBvbiB0aGUgRE9NPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3MuZmlyc3QoKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdHMgdGhlIGZpcnN0IGNsaWNrIHRoYXQgaGFwcGVucyBvbiBhIERJVjwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLmZpcnN0KGV2ID0+IGV2LnRhcmdldC50YWdOYW1lID09PSAnRElWJyk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGZpbHRlcn1cbiAqIEBzZWUge0BsaW5rIGZpbmR9XG4gKiBAc2VlIHtAbGluayB0YWtlfVxuICpcbiAqIEB0aHJvd3Mge0VtcHR5RXJyb3J9IERlbGl2ZXJzIGFuIEVtcHR5RXJyb3IgdG8gdGhlIE9ic2VydmVyJ3MgYGVycm9yYFxuICogY2FsbGJhY2sgaWYgdGhlIE9ic2VydmFibGUgY29tcGxldGVzIGJlZm9yZSBhbnkgYG5leHRgIG5vdGlmaWNhdGlvbiB3YXMgc2VudC5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCBpbmRleDogbnVtYmVyLCBzb3VyY2U6IE9ic2VydmFibGU8VD4pOiBib29sZWFufSBbcHJlZGljYXRlXVxuICogQW4gb3B0aW9uYWwgZnVuY3Rpb24gY2FsbGVkIHdpdGggZWFjaCBpdGVtIHRvIHRlc3QgZm9yIGNvbmRpdGlvbiBtYXRjaGluZy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24odmFsdWU6IFQsIGluZGV4OiBudW1iZXIpOiBSfSBbcmVzdWx0U2VsZWN0b3JdIEEgZnVuY3Rpb24gdG9cbiAqIHByb2R1Y2UgdGhlIHZhbHVlIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBiYXNlZCBvbiB0aGUgdmFsdWVzXG4gKiBhbmQgdGhlIGluZGljZXMgb2YgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGlzXG4gKiBmdW5jdGlvbiBhcmU6XG4gKiAtIGB2YWx1ZWA6IHRoZSB2YWx1ZSB0aGF0IHdhcyBlbWl0dGVkIG9uIHRoZSBzb3VyY2UuXG4gKiAtIGBpbmRleGA6IHRoZSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIGZyb20gdGhlIHNvdXJjZS5cbiAqIEBwYXJhbSB7Un0gW2RlZmF1bHRWYWx1ZV0gVGhlIGRlZmF1bHQgdmFsdWUgZW1pdHRlZCBpbiBjYXNlIG5vIHZhbGlkIHZhbHVlXG4gKiB3YXMgZm91bmQgb24gdGhlIHNvdXJjZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8VHxSPn0gQW4gT2JzZXJ2YWJsZSBvZiB0aGUgZmlyc3QgaXRlbSB0aGF0IG1hdGNoZXMgdGhlXG4gKiBjb25kaXRpb24uXG4gKiBAbWV0aG9kIGZpcnN0XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBmaXJzdChwcmVkaWNhdGUsIHJlc3VsdFNlbGVjdG9yLCBkZWZhdWx0VmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBGaXJzdE9wZXJhdG9yKHByZWRpY2F0ZSwgcmVzdWx0U2VsZWN0b3IsIGRlZmF1bHRWYWx1ZSwgdGhpcykpO1xufVxuZXhwb3J0cy5maXJzdCA9IGZpcnN0O1xudmFyIEZpcnN0T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZpcnN0T3BlcmF0b3IocHJlZGljYXRlLCByZXN1bHRTZWxlY3RvciwgZGVmYXVsdFZhbHVlLCBzb3VyY2UpIHtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgIHRoaXMucmVzdWx0U2VsZWN0b3IgPSByZXN1bHRTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICBGaXJzdE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKG9ic2VydmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IEZpcnN0U3Vic2NyaWJlcihvYnNlcnZlciwgdGhpcy5wcmVkaWNhdGUsIHRoaXMucmVzdWx0U2VsZWN0b3IsIHRoaXMuZGVmYXVsdFZhbHVlLCB0aGlzLnNvdXJjZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIEZpcnN0T3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBGaXJzdFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGaXJzdFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRmlyc3RTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBwcmVkaWNhdGUsIHJlc3VsdFNlbGVjdG9yLCBkZWZhdWx0VmFsdWUsIHNvdXJjZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICB0aGlzLnJlc3VsdFNlbGVjdG9yID0gcmVzdWx0U2VsZWN0b3I7XG4gICAgICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2VtaXR0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgRmlyc3RTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4Kys7XG4gICAgICAgIGlmICh0aGlzLnByZWRpY2F0ZSkge1xuICAgICAgICAgICAgdGhpcy5fdHJ5UHJlZGljYXRlKHZhbHVlLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0KHZhbHVlLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEZpcnN0U3Vic2NyaWJlci5wcm90b3R5cGUuX3RyeVByZWRpY2F0ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucHJlZGljYXRlKHZhbHVlLCBpbmRleCwgdGhpcy5zb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0KHZhbHVlLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEZpcnN0U3Vic2NyaWJlci5wcm90b3R5cGUuX2VtaXQgPSBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLnJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLl90cnlSZXN1bHRTZWxlY3Rvcih2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2VtaXRGaW5hbCh2YWx1ZSk7XG4gICAgfTtcbiAgICBGaXJzdFN1YnNjcmliZXIucHJvdG90eXBlLl90cnlSZXN1bHRTZWxlY3RvciA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucmVzdWx0U2VsZWN0b3IodmFsdWUsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZW1pdEZpbmFsKHJlc3VsdCk7XG4gICAgfTtcbiAgICBGaXJzdFN1YnNjcmliZXIucHJvdG90eXBlLl9lbWl0RmluYWwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgaWYgKCF0aGlzLl9lbWl0dGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRmlyc3RTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIGlmICghdGhpcy5oYXNDb21wbGV0ZWQgJiYgdHlwZW9mIHRoaXMuZGVmYXVsdFZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dCh0aGlzLmRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLmhhc0NvbXBsZXRlZCkge1xuICAgICAgICAgICAgZGVzdGluYXRpb24uZXJyb3IobmV3IEVtcHR5RXJyb3JfMS5FbXB0eUVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEZpcnN0U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpcnN0LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9yL2ZpcnN0LmpzXG4vLyBtb2R1bGUgaWQgPSAyODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpcHRpb24nKTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG52YXIgU3ViamVjdF8xID0gcmVxdWlyZSgnLi4vU3ViamVjdCcpO1xudmFyIE1hcF8xID0gcmVxdWlyZSgnLi4vdXRpbC9NYXAnKTtcbnZhciBGYXN0TWFwXzEgPSByZXF1aXJlKCcuLi91dGlsL0Zhc3RNYXAnKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIEdyb3VwcyB0aGUgaXRlbXMgZW1pdHRlZCBieSBhbiBPYnNlcnZhYmxlIGFjY29yZGluZyB0byBhIHNwZWNpZmllZCBjcml0ZXJpb24sXG4gKiBhbmQgZW1pdHMgdGhlc2UgZ3JvdXBlZCBpdGVtcyBhcyBgR3JvdXBlZE9ic2VydmFibGVzYCwgb25lXG4gKiB7QGxpbmsgR3JvdXBlZE9ic2VydmFibGV9IHBlciBncm91cC5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2dyb3VwQnkucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCk6IEt9IGtleVNlbGVjdG9yIEEgZnVuY3Rpb24gdGhhdCBleHRyYWN0cyB0aGUga2V5XG4gKiBmb3IgZWFjaCBpdGVtLlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCk6IFJ9IFtlbGVtZW50U2VsZWN0b3JdIEEgZnVuY3Rpb24gdGhhdCBleHRyYWN0cyB0aGVcbiAqIHJldHVybiBlbGVtZW50IGZvciBlYWNoIGl0ZW0uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGdyb3VwZWQ6IEdyb3VwZWRPYnNlcnZhYmxlPEssUj4pOiBPYnNlcnZhYmxlPGFueT59IFtkdXJhdGlvblNlbGVjdG9yXVxuICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gT2JzZXJ2YWJsZSB0byBkZXRlcm1pbmUgaG93IGxvbmcgZWFjaCBncm91cCBzaG91bGRcbiAqIGV4aXN0LlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxHcm91cGVkT2JzZXJ2YWJsZTxLLFI+Pn0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzXG4gKiBHcm91cGVkT2JzZXJ2YWJsZXMsIGVhY2ggb2Ygd2hpY2ggY29ycmVzcG9uZHMgdG8gYSB1bmlxdWUga2V5IHZhbHVlIGFuZCBlYWNoXG4gKiBvZiB3aGljaCBlbWl0cyB0aG9zZSBpdGVtcyBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB0aGF0IHNoYXJlIHRoYXQga2V5XG4gKiB2YWx1ZS5cbiAqIEBtZXRob2QgZ3JvdXBCeVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gZ3JvdXBCeShrZXlTZWxlY3RvciwgZWxlbWVudFNlbGVjdG9yLCBkdXJhdGlvblNlbGVjdG9yLCBzdWJqZWN0U2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBHcm91cEJ5T3BlcmF0b3Ioa2V5U2VsZWN0b3IsIGVsZW1lbnRTZWxlY3RvciwgZHVyYXRpb25TZWxlY3Rvciwgc3ViamVjdFNlbGVjdG9yKSk7XG59XG5leHBvcnRzLmdyb3VwQnkgPSBncm91cEJ5O1xudmFyIEdyb3VwQnlPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR3JvdXBCeU9wZXJhdG9yKGtleVNlbGVjdG9yLCBlbGVtZW50U2VsZWN0b3IsIGR1cmF0aW9uU2VsZWN0b3IsIHN1YmplY3RTZWxlY3Rvcikge1xuICAgICAgICB0aGlzLmtleVNlbGVjdG9yID0ga2V5U2VsZWN0b3I7XG4gICAgICAgIHRoaXMuZWxlbWVudFNlbGVjdG9yID0gZWxlbWVudFNlbGVjdG9yO1xuICAgICAgICB0aGlzLmR1cmF0aW9uU2VsZWN0b3IgPSBkdXJhdGlvblNlbGVjdG9yO1xuICAgICAgICB0aGlzLnN1YmplY3RTZWxlY3RvciA9IHN1YmplY3RTZWxlY3RvcjtcbiAgICB9XG4gICAgR3JvdXBCeU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgR3JvdXBCeVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5rZXlTZWxlY3RvciwgdGhpcy5lbGVtZW50U2VsZWN0b3IsIHRoaXMuZHVyYXRpb25TZWxlY3RvciwgdGhpcy5zdWJqZWN0U2VsZWN0b3IpKTtcbiAgICB9O1xuICAgIHJldHVybiBHcm91cEJ5T3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBHcm91cEJ5U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdyb3VwQnlTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdyb3VwQnlTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBrZXlTZWxlY3RvciwgZWxlbWVudFNlbGVjdG9yLCBkdXJhdGlvblNlbGVjdG9yLCBzdWJqZWN0U2VsZWN0b3IpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmtleVNlbGVjdG9yID0ga2V5U2VsZWN0b3I7XG4gICAgICAgIHRoaXMuZWxlbWVudFNlbGVjdG9yID0gZWxlbWVudFNlbGVjdG9yO1xuICAgICAgICB0aGlzLmR1cmF0aW9uU2VsZWN0b3IgPSBkdXJhdGlvblNlbGVjdG9yO1xuICAgICAgICB0aGlzLnN1YmplY3RTZWxlY3RvciA9IHN1YmplY3RTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5ncm91cHMgPSBudWxsO1xuICAgICAgICB0aGlzLmF0dGVtcHRlZFRvVW5zdWJzY3JpYmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgfVxuICAgIEdyb3VwQnlTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAga2V5ID0gdGhpcy5rZXlTZWxlY3Rvcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2dyb3VwKHZhbHVlLCBrZXkpO1xuICAgIH07XG4gICAgR3JvdXBCeVN1YnNjcmliZXIucHJvdG90eXBlLl9ncm91cCA9IGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgIHZhciBncm91cHMgPSB0aGlzLmdyb3VwcztcbiAgICAgICAgaWYgKCFncm91cHMpIHtcbiAgICAgICAgICAgIGdyb3VwcyA9IHRoaXMuZ3JvdXBzID0gdHlwZW9mIGtleSA9PT0gJ3N0cmluZycgPyBuZXcgRmFzdE1hcF8xLkZhc3RNYXAoKSA6IG5ldyBNYXBfMS5NYXAoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZ3JvdXAgPSBncm91cHMuZ2V0KGtleSk7XG4gICAgICAgIHZhciBlbGVtZW50O1xuICAgICAgICBpZiAodGhpcy5lbGVtZW50U2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IHRoaXMuZWxlbWVudFNlbGVjdG9yKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFncm91cCkge1xuICAgICAgICAgICAgZ3JvdXAgPSB0aGlzLnN1YmplY3RTZWxlY3RvciA/IHRoaXMuc3ViamVjdFNlbGVjdG9yKCkgOiBuZXcgU3ViamVjdF8xLlN1YmplY3QoKTtcbiAgICAgICAgICAgIGdyb3Vwcy5zZXQoa2V5LCBncm91cCk7XG4gICAgICAgICAgICB2YXIgZ3JvdXBlZE9ic2VydmFibGUgPSBuZXcgR3JvdXBlZE9ic2VydmFibGUoa2V5LCBncm91cCwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoZ3JvdXBlZE9ic2VydmFibGUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZHVyYXRpb25TZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IHRoaXMuZHVyYXRpb25TZWxlY3RvcihuZXcgR3JvdXBlZE9ic2VydmFibGUoa2V5LCBncm91cCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmFkZChkdXJhdGlvbi5zdWJzY3JpYmUobmV3IEdyb3VwRHVyYXRpb25TdWJzY3JpYmVyKGtleSwgZ3JvdXAsIHRoaXMpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFncm91cC5jbG9zZWQpIHtcbiAgICAgICAgICAgIGdyb3VwLm5leHQoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdyb3VwQnlTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciBncm91cHMgPSB0aGlzLmdyb3VwcztcbiAgICAgICAgaWYgKGdyb3Vwcykge1xuICAgICAgICAgICAgZ3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKGdyb3VwLCBrZXkpIHtcbiAgICAgICAgICAgICAgICBncm91cC5lcnJvcihlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBncm91cHMuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgfTtcbiAgICBHcm91cEJ5U3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZ3JvdXBzID0gdGhpcy5ncm91cHM7XG4gICAgICAgIGlmIChncm91cHMpIHtcbiAgICAgICAgICAgIGdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChncm91cCwga2V5KSB7XG4gICAgICAgICAgICAgICAgZ3JvdXAuY29tcGxldGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZ3JvdXBzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgR3JvdXBCeVN1YnNjcmliZXIucHJvdG90eXBlLnJlbW92ZUdyb3VwID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB0aGlzLmdyb3Vwcy5kZWxldGUoa2V5KTtcbiAgICB9O1xuICAgIEdyb3VwQnlTdWJzY3JpYmVyLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhpcy5hdHRlbXB0ZWRUb1Vuc3Vic2NyaWJlID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51bnN1YnNjcmliZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gR3JvdXBCeVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIEdyb3VwRHVyYXRpb25TdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoR3JvdXBEdXJhdGlvblN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gR3JvdXBEdXJhdGlvblN1YnNjcmliZXIoa2V5LCBncm91cCwgcGFyZW50KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5ncm91cCA9IGdyb3VwO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB9XG4gICAgR3JvdXBEdXJhdGlvblN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2NvbXBsZXRlKCk7XG4gICAgfTtcbiAgICBHcm91cER1cmF0aW9uU3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgICAgICBpZiAoIWdyb3VwLmNsb3NlZCkge1xuICAgICAgICAgICAgZ3JvdXAuZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcmVudC5yZW1vdmVHcm91cCh0aGlzLmtleSk7XG4gICAgfTtcbiAgICBHcm91cER1cmF0aW9uU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgICAgICBpZiAoIWdyb3VwLmNsb3NlZCkge1xuICAgICAgICAgICAgZ3JvdXAuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcmVudC5yZW1vdmVHcm91cCh0aGlzLmtleSk7XG4gICAgfTtcbiAgICByZXR1cm4gR3JvdXBEdXJhdGlvblN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vKipcbiAqIEFuIE9ic2VydmFibGUgcmVwcmVzZW50aW5nIHZhbHVlcyBiZWxvbmdpbmcgdG8gdGhlIHNhbWUgZ3JvdXAgcmVwcmVzZW50ZWQgYnlcbiAqIGEgY29tbW9uIGtleS4gVGhlIHZhbHVlcyBlbWl0dGVkIGJ5IGEgR3JvdXBlZE9ic2VydmFibGUgY29tZSBmcm9tIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUuIFRoZSBjb21tb24ga2V5IGlzIGF2YWlsYWJsZSBhcyB0aGUgZmllbGQgYGtleWAgb24gYVxuICogR3JvdXBlZE9ic2VydmFibGUgaW5zdGFuY2UuXG4gKlxuICogQGNsYXNzIEdyb3VwZWRPYnNlcnZhYmxlPEssIFQ+XG4gKi9cbnZhciBHcm91cGVkT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdyb3VwZWRPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdyb3VwZWRPYnNlcnZhYmxlKGtleSwgZ3JvdXBTdWJqZWN0LCByZWZDb3VudFN1YnNjcmlwdGlvbikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMuZ3JvdXBTdWJqZWN0ID0gZ3JvdXBTdWJqZWN0O1xuICAgICAgICB0aGlzLnJlZkNvdW50U3Vic2NyaXB0aW9uID0gcmVmQ291bnRTdWJzY3JpcHRpb247XG4gICAgfVxuICAgIEdyb3VwZWRPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24oKTtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcmVmQ291bnRTdWJzY3JpcHRpb24gPSBfYS5yZWZDb3VudFN1YnNjcmlwdGlvbiwgZ3JvdXBTdWJqZWN0ID0gX2EuZ3JvdXBTdWJqZWN0O1xuICAgICAgICBpZiAocmVmQ291bnRTdWJzY3JpcHRpb24gJiYgIXJlZkNvdW50U3Vic2NyaXB0aW9uLmNsb3NlZCkge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLmFkZChuZXcgSW5uZXJSZWZDb3VudFN1YnNjcmlwdGlvbihyZWZDb3VudFN1YnNjcmlwdGlvbikpO1xuICAgICAgICB9XG4gICAgICAgIHN1YnNjcmlwdGlvbi5hZGQoZ3JvdXBTdWJqZWN0LnN1YnNjcmliZShzdWJzY3JpYmVyKSk7XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgfTtcbiAgICByZXR1cm4gR3JvdXBlZE9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLkdyb3VwZWRPYnNlcnZhYmxlID0gR3JvdXBlZE9ic2VydmFibGU7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIElubmVyUmVmQ291bnRTdWJzY3JpcHRpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbm5lclJlZkNvdW50U3Vic2NyaXB0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIElubmVyUmVmQ291bnRTdWJzY3JpcHRpb24ocGFyZW50KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgcGFyZW50LmNvdW50Kys7XG4gICAgfVxuICAgIElubmVyUmVmQ291bnRTdWJzY3JpcHRpb24ucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIGlmICghcGFyZW50LmNsb3NlZCAmJiAhdGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUudW5zdWJzY3JpYmUuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHBhcmVudC5jb3VudCAtPSAxO1xuICAgICAgICAgICAgaWYgKHBhcmVudC5jb3VudCA9PT0gMCAmJiBwYXJlbnQuYXR0ZW1wdGVkVG9VbnN1YnNjcmliZSkge1xuICAgICAgICAgICAgICAgIHBhcmVudC51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gSW5uZXJSZWZDb3VudFN1YnNjcmlwdGlvbjtcbn0oU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncm91cEJ5LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9yL2dyb3VwQnkuanNcbi8vIG1vZHVsZSBpZCA9IDI4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBub29wXzEgPSByZXF1aXJlKCcuLi91dGlsL25vb3AnKTtcbi8qKlxuICogSWdub3JlcyBhbGwgaXRlbXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgYW5kIG9ubHkgcGFzc2VzIGNhbGxzIG9mIGBjb21wbGV0ZWAgb3IgYGVycm9yYC5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2lnbm9yZUVsZW1lbnRzLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIGVtcHR5IE9ic2VydmFibGUgdGhhdCBvbmx5IGNhbGxzIGBjb21wbGV0ZWBcbiAqIG9yIGBlcnJvcmAsIGJhc2VkIG9uIHdoaWNoIG9uZSBpcyBjYWxsZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCBpZ25vcmVFbGVtZW50c1xuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gaWdub3JlRWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgSWdub3JlRWxlbWVudHNPcGVyYXRvcigpKTtcbn1cbmV4cG9ydHMuaWdub3JlRWxlbWVudHMgPSBpZ25vcmVFbGVtZW50cztcbjtcbnZhciBJZ25vcmVFbGVtZW50c09wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJZ25vcmVFbGVtZW50c09wZXJhdG9yKCkge1xuICAgIH1cbiAgICBJZ25vcmVFbGVtZW50c09wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgSWdub3JlRWxlbWVudHNTdWJzY3JpYmVyKHN1YnNjcmliZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBJZ25vcmVFbGVtZW50c09wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgSWdub3JlRWxlbWVudHNTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSWdub3JlRWxlbWVudHNTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIElnbm9yZUVsZW1lbnRzU3Vic2NyaWJlcigpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIElnbm9yZUVsZW1lbnRzU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodW51c2VkKSB7XG4gICAgICAgIG5vb3BfMS5ub29wKCk7XG4gICAgfTtcbiAgICByZXR1cm4gSWdub3JlRWxlbWVudHNTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aWdub3JlRWxlbWVudHMuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3IvaWdub3JlRWxlbWVudHMuanNcbi8vIG1vZHVsZSBpZCA9IDI4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbi8qKlxuICogSWYgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGlzIGVtcHR5IGl0IHJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRydWUsIG90aGVyd2lzZSBpdCBlbWl0cyBmYWxzZS5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2lzRW1wdHkucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGEgQm9vbGVhbi5cbiAqIEBtZXRob2QgaXNFbXB0eVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBJc0VtcHR5T3BlcmF0b3IoKSk7XG59XG5leHBvcnRzLmlzRW1wdHkgPSBpc0VtcHR5O1xudmFyIElzRW1wdHlPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSXNFbXB0eU9wZXJhdG9yKCkge1xuICAgIH1cbiAgICBJc0VtcHR5T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAob2JzZXJ2ZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgSXNFbXB0eVN1YnNjcmliZXIob2JzZXJ2ZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBJc0VtcHR5T3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBJc0VtcHR5U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKElzRW1wdHlTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIElzRW1wdHlTdWJzY3JpYmVyKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICB9XG4gICAgSXNFbXB0eVN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKGlzRW1wdHkpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgZGVzdGluYXRpb24ubmV4dChpc0VtcHR5KTtcbiAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9O1xuICAgIElzRW1wdHlTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLm5vdGlmeUNvbXBsZXRlKGZhbHNlKTtcbiAgICB9O1xuICAgIElzRW1wdHlTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubm90aWZ5Q29tcGxldGUodHJ1ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gSXNFbXB0eVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc0VtcHR5LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9yL2lzRW1wdHkuanNcbi8vIG1vZHVsZSBpZCA9IDI4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBFbXB0eUVycm9yXzEgPSByZXF1aXJlKCcuLi91dGlsL0VtcHR5RXJyb3InKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIG9ubHkgdGhlIGxhc3QgaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEl0IG9wdGlvbmFsbHkgdGFrZXMgYSBwcmVkaWNhdGUgZnVuY3Rpb24gYXMgYSBwYXJhbWV0ZXIsIGluIHdoaWNoIGNhc2UsIHJhdGhlciB0aGFuIGVtaXR0aW5nXG4gKiB0aGUgbGFzdCBpdGVtIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCB0aGUgcmVzdWx0aW5nIE9ic2VydmFibGUgd2lsbCBlbWl0IHRoZSBsYXN0IGl0ZW1cbiAqIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHRoYXQgc2F0aXNmaWVzIHRoZSBwcmVkaWNhdGUuXG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9sYXN0LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEB0aHJvd3Mge0VtcHR5RXJyb3J9IERlbGl2ZXJzIGFuIEVtcHR5RXJyb3IgdG8gdGhlIE9ic2VydmVyJ3MgYGVycm9yYFxuICogY2FsbGJhY2sgaWYgdGhlIE9ic2VydmFibGUgY29tcGxldGVzIGJlZm9yZSBhbnkgYG5leHRgIG5vdGlmaWNhdGlvbiB3YXMgc2VudC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHByZWRpY2F0ZSAtIFRoZSBjb25kaXRpb24gYW55IHNvdXJjZSBlbWl0dGVkIGl0ZW0gaGFzIHRvIHNhdGlzZnkuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgb25seSB0aGUgbGFzdCBpdGVtIHNhdGlzZnlpbmcgdGhlIGdpdmVuIGNvbmRpdGlvblxuICogZnJvbSB0aGUgc291cmNlLCBvciBhbiBOb1N1Y2hFbGVtZW50RXhjZXB0aW9uIGlmIG5vIHN1Y2ggaXRlbXMgYXJlIGVtaXR0ZWQuXG4gKiBAdGhyb3dzIC0gVGhyb3dzIGlmIG5vIGl0ZW1zIHRoYXQgbWF0Y2ggdGhlIHByZWRpY2F0ZSBhcmUgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIGxhc3RcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGxhc3QocHJlZGljYXRlLCByZXN1bHRTZWxlY3RvciwgZGVmYXVsdFZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgTGFzdE9wZXJhdG9yKHByZWRpY2F0ZSwgcmVzdWx0U2VsZWN0b3IsIGRlZmF1bHRWYWx1ZSwgdGhpcykpO1xufVxuZXhwb3J0cy5sYXN0ID0gbGFzdDtcbnZhciBMYXN0T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExhc3RPcGVyYXRvcihwcmVkaWNhdGUsIHJlc3VsdFNlbGVjdG9yLCBkZWZhdWx0VmFsdWUsIHNvdXJjZSkge1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgdGhpcy5yZXN1bHRTZWxlY3RvciA9IHJlc3VsdFNlbGVjdG9yO1xuICAgICAgICB0aGlzLmRlZmF1bHRWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIExhc3RPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChvYnNlcnZlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBMYXN0U3Vic2NyaWJlcihvYnNlcnZlciwgdGhpcy5wcmVkaWNhdGUsIHRoaXMucmVzdWx0U2VsZWN0b3IsIHRoaXMuZGVmYXVsdFZhbHVlLCB0aGlzLnNvdXJjZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIExhc3RPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIExhc3RTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGFzdFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGFzdFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByZWRpY2F0ZSwgcmVzdWx0U2VsZWN0b3IsIGRlZmF1bHRWYWx1ZSwgc291cmNlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgIHRoaXMucmVzdWx0U2VsZWN0b3IgPSByZXN1bHRTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLmhhc1ZhbHVlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICBpZiAodHlwZW9mIGRlZmF1bHRWYWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgTGFzdFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXgrKztcbiAgICAgICAgaWYgKHRoaXMucHJlZGljYXRlKSB7XG4gICAgICAgICAgICB0aGlzLl90cnlQcmVkaWNhdGUodmFsdWUsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJ5UmVzdWx0U2VsZWN0b3IodmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxhc3RWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExhc3RTdWJzY3JpYmVyLnByb3RvdHlwZS5fdHJ5UHJlZGljYXRlID0gZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wcmVkaWNhdGUodmFsdWUsIGluZGV4LCB0aGlzLnNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJ5UmVzdWx0U2VsZWN0b3IodmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxhc3RWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExhc3RTdWJzY3JpYmVyLnByb3RvdHlwZS5fdHJ5UmVzdWx0U2VsZWN0b3IgPSBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnJlc3VsdFNlbGVjdG9yKHZhbHVlLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdFZhbHVlID0gcmVzdWx0O1xuICAgICAgICB0aGlzLmhhc1ZhbHVlID0gdHJ1ZTtcbiAgICB9O1xuICAgIExhc3RTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIGlmICh0aGlzLmhhc1ZhbHVlKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHRoaXMubGFzdFZhbHVlKTtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5lcnJvcihuZXcgRW1wdHlFcnJvcl8xLkVtcHR5RXJyb3IpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTGFzdFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYXN0LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9yL2xhc3QuanNcbi8vIG1vZHVsZSBpZCA9IDI4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQHBhcmFtIGZ1bmNcbiAqIEByZXR1cm4ge09ic2VydmFibGU8Uj59XG4gKiBAbWV0aG9kIGxldFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gbGV0UHJvdG8oZnVuYykge1xuICAgIHJldHVybiBmdW5jKHRoaXMpO1xufVxuZXhwb3J0cy5sZXRQcm90byA9IGxldFByb3RvO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGV0LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9yL2xldC5qc1xuLy8gbW9kdWxlIGlkID0gMjg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xuLyoqXG4gKiBFbWl0cyB0aGUgZ2l2ZW4gY29uc3RhbnQgdmFsdWUgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlIGV2ZXJ5IHRpbWUgdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSBlbWl0cyBhIHZhbHVlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5MaWtlIHtAbGluayBtYXB9LCBidXQgaXQgbWFwcyBldmVyeSBzb3VyY2UgdmFsdWUgdG9cbiAqIHRoZSBzYW1lIG91dHB1dCB2YWx1ZSBldmVyeSB0aW1lLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL21hcFRvLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFRha2VzIGEgY29uc3RhbnQgYHZhbHVlYCBhcyBhcmd1bWVudCwgYW5kIGVtaXRzIHRoYXQgd2hlbmV2ZXIgdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSBlbWl0cyBhIHZhbHVlLiBJbiBvdGhlciB3b3JkcywgaWdub3JlcyB0aGUgYWN0dWFsIHNvdXJjZSB2YWx1ZSxcbiAqIGFuZCBzaW1wbHkgdXNlcyB0aGUgZW1pc3Npb24gbW9tZW50IHRvIGtub3cgd2hlbiB0byBlbWl0IHRoZSBnaXZlbiBgdmFsdWVgLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPk1hcCBldmVyeSBldmVyeSBjbGljayB0byB0aGUgc3RyaW5nICdIaSc8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIGdyZWV0aW5ncyA9IGNsaWNrcy5tYXBUbygnSGknKTtcbiAqIGdyZWV0aW5ncy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgbWFwfVxuICpcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZSBUaGUgdmFsdWUgdG8gbWFwIGVhY2ggc291cmNlIHZhbHVlIHRvLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSBnaXZlbiBgdmFsdWVgIGV2ZXJ5IHRpbWVcbiAqIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBlbWl0cyBzb21ldGhpbmcuXG4gKiBAbWV0aG9kIG1hcFRvXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBtYXBUbyh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IE1hcFRvT3BlcmF0b3IodmFsdWUpKTtcbn1cbmV4cG9ydHMubWFwVG8gPSBtYXBUbztcbnZhciBNYXBUb09wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXBUb09wZXJhdG9yKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgTWFwVG9PcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IE1hcFRvU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnZhbHVlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWFwVG9PcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIE1hcFRvU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1hcFRvU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYXBUb1N1YnNjcmliZXIoZGVzdGluYXRpb24sIHZhbHVlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBNYXBUb1N1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHRoaXMudmFsdWUpO1xuICAgIH07XG4gICAgcmV0dXJuIE1hcFRvU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hcFRvLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9yL21hcFRvLmpzXG4vLyBtb2R1bGUgaWQgPSAyODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgTm90aWZpY2F0aW9uXzEgPSByZXF1aXJlKCcuLi9Ob3RpZmljYXRpb24nKTtcbi8qKlxuICogUmVwcmVzZW50cyBhbGwgb2YgdGhlIG5vdGlmaWNhdGlvbnMgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgYXMgYG5leHRgXG4gKiBlbWlzc2lvbnMgbWFya2VkIHdpdGggdGhlaXIgb3JpZ2luYWwgdHlwZXMgd2l0aGluIHtAbGluayBOb3RpZmljYXRpb259XG4gKiBvYmplY3RzLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5XcmFwcyBgbmV4dGAsIGBlcnJvcmAgYW5kIGBjb21wbGV0ZWAgZW1pc3Npb25zIGluXG4gKiB7QGxpbmsgTm90aWZpY2F0aW9ufSBvYmplY3RzLCBlbWl0dGVkIGFzIGBuZXh0YCBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKiA8L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9tYXRlcmlhbGl6ZS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgbWF0ZXJpYWxpemVgIHJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGEgYG5leHRgIG5vdGlmaWNhdGlvbiBmb3IgZWFjaFxuICogYG5leHRgLCBgZXJyb3JgLCBvciBgY29tcGxldGVgIGVtaXNzaW9uIG9mIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS4gV2hlbiB0aGVcbiAqIHNvdXJjZSBPYnNlcnZhYmxlIGVtaXRzIGBjb21wbGV0ZWAsIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSB3aWxsIGVtaXQgYG5leHRgIGFzXG4gKiBhIE5vdGlmaWNhdGlvbiBvZiB0eXBlIFwiY29tcGxldGVcIiwgYW5kIHRoZW4gaXQgd2lsbCBlbWl0IGBjb21wbGV0ZWAgYXMgd2VsbC5cbiAqIFdoZW4gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGVtaXRzIGBlcnJvcmAsIHRoZSBvdXRwdXQgd2lsbCBlbWl0IGBuZXh0YCBhcyBhXG4gKiBOb3RpZmljYXRpb24gb2YgdHlwZSBcImVycm9yXCIsIGFuZCB0aGVuIGBjb21wbGV0ZWAuXG4gKlxuICogVGhpcyBvcGVyYXRvciBpcyB1c2VmdWwgZm9yIHByb2R1Y2luZyBtZXRhZGF0YSBvZiB0aGUgc291cmNlIE9ic2VydmFibGUsIHRvXG4gKiBiZSBjb25zdW1lZCBhcyBgbmV4dGAgZW1pc3Npb25zLiBVc2UgaXQgaW4gY29uanVuY3Rpb24gd2l0aFxuICoge0BsaW5rIGRlbWF0ZXJpYWxpemV9LlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNvbnZlcnQgYSBmYXVsdHkgT2JzZXJ2YWJsZSB0byBhbiBPYnNlcnZhYmxlIG9mIE5vdGlmaWNhdGlvbnM8L2NhcHRpb24+XG4gKiB2YXIgbGV0dGVycyA9IFJ4Lk9ic2VydmFibGUub2YoJ2EnLCAnYicsIDEzLCAnZCcpO1xuICogdmFyIHVwcGVyQ2FzZSA9IGxldHRlcnMubWFwKHggPT4geC50b1VwcGVyQ2FzZSgpKTtcbiAqIHZhciBtYXRlcmlhbGl6ZWQgPSB1cHBlckNhc2UubWF0ZXJpYWxpemUoKTtcbiAqIG1hdGVyaWFsaXplZC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gUmVzdWx0cyBpbiB0aGUgZm9sbG93aW5nOlxuICogLy8gLSBOb3RpZmljYXRpb24ge2tpbmQ6IFwiTlwiLCB2YWx1ZTogXCJBXCIsIGVycm9yOiB1bmRlZmluZWQsIGhhc1ZhbHVlOiB0cnVlfVxuICogLy8gLSBOb3RpZmljYXRpb24ge2tpbmQ6IFwiTlwiLCB2YWx1ZTogXCJCXCIsIGVycm9yOiB1bmRlZmluZWQsIGhhc1ZhbHVlOiB0cnVlfVxuICogLy8gLSBOb3RpZmljYXRpb24ge2tpbmQ6IFwiRVwiLCB2YWx1ZTogdW5kZWZpbmVkLCBlcnJvcjogVHlwZUVycm9yOlxuICogLy8gICB4LnRvVXBwZXJDYXNlIGlzIG5vdCBhIGZ1bmN0aW9uIGF0IE1hcFN1YnNjcmliZXIubGV0dGVycy5tYXAueFxuICogLy8gICBbYXMgcHJvamVjdF0gKGh0dHA6Ly8x4oCmLCBoYXNWYWx1ZTogZmFsc2V9XG4gKlxuICogQHNlZSB7QGxpbmsgTm90aWZpY2F0aW9ufVxuICogQHNlZSB7QGxpbmsgZGVtYXRlcmlhbGl6ZX1cbiAqXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPE5vdGlmaWNhdGlvbjxUPj59IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0c1xuICoge0BsaW5rIE5vdGlmaWNhdGlvbn0gb2JqZWN0cyB0aGF0IHdyYXAgdGhlIG9yaWdpbmFsIGVtaXNzaW9ucyBmcm9tIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUgd2l0aCBtZXRhZGF0YS5cbiAqIEBtZXRob2QgbWF0ZXJpYWxpemVcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIG1hdGVyaWFsaXplKCkge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IE1hdGVyaWFsaXplT3BlcmF0b3IoKSk7XG59XG5leHBvcnRzLm1hdGVyaWFsaXplID0gbWF0ZXJpYWxpemU7XG52YXIgTWF0ZXJpYWxpemVPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWF0ZXJpYWxpemVPcGVyYXRvcigpIHtcbiAgICB9XG4gICAgTWF0ZXJpYWxpemVPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IE1hdGVyaWFsaXplU3Vic2NyaWJlcihzdWJzY3JpYmVyKSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWF0ZXJpYWxpemVPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIE1hdGVyaWFsaXplU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1hdGVyaWFsaXplU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYXRlcmlhbGl6ZVN1YnNjcmliZXIoZGVzdGluYXRpb24pIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgIH1cbiAgICBNYXRlcmlhbGl6ZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChOb3RpZmljYXRpb25fMS5Ob3RpZmljYXRpb24uY3JlYXRlTmV4dCh2YWx1ZSkpO1xuICAgIH07XG4gICAgTWF0ZXJpYWxpemVTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIGRlc3RpbmF0aW9uLm5leHQoTm90aWZpY2F0aW9uXzEuTm90aWZpY2F0aW9uLmNyZWF0ZUVycm9yKGVycikpO1xuICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgTWF0ZXJpYWxpemVTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIGRlc3RpbmF0aW9uLm5leHQoTm90aWZpY2F0aW9uXzEuTm90aWZpY2F0aW9uLmNyZWF0ZUNvbXBsZXRlKCkpO1xuICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIE1hdGVyaWFsaXplU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGVyaWFsaXplLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9yL21hdGVyaWFsaXplLmpzXG4vLyBtb2R1bGUgaWQgPSAyODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcmVkdWNlXzEgPSByZXF1aXJlKCcuL3JlZHVjZScpO1xuLyoqXG4gKiBUaGUgTWF4IG9wZXJhdG9yIG9wZXJhdGVzIG9uIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBudW1iZXJzIChvciBpdGVtcyB0aGF0IGNhbiBiZSBjb21wYXJlZCB3aXRoIGEgcHJvdmlkZWQgZnVuY3Rpb24pLFxuICogYW5kIHdoZW4gc291cmNlIE9ic2VydmFibGUgY29tcGxldGVzIGl0IGVtaXRzIGEgc2luZ2xlIGl0ZW06IHRoZSBpdGVtIHdpdGggdGhlIGxhcmdlc3QgdmFsdWUuXG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9tYXgucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+R2V0IHRoZSBtYXhpbWFsIHZhbHVlIG9mIGEgc2VyaWVzIG9mIG51bWJlcnM8L2NhcHRpb24+XG4gKiBSeC5PYnNlcnZhYmxlLm9mKDUsIDQsIDcsIDIsIDgpXG4gKiAgIC5tYXgoKVxuICogICAuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpOyAvLyAtPiA4XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+VXNlIGEgY29tcGFyZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBtYXhpbWFsIGl0ZW08L2NhcHRpb24+XG4gKiBpbnRlcmZhY2UgUGVyc29uIHtcbiAqICAgYWdlOiBudW1iZXIsXG4gKiAgIG5hbWU6IHN0cmluZ1xuICogfVxuICogT2JzZXJ2YWJsZS5vZjxQZXJzb24+KHthZ2U6IDcsIG5hbWU6ICdGb28nfSxcbiAqICAgICAgICAgICAgICAgICAgICAgICB7YWdlOiA1LCBuYW1lOiAnQmFyJ30sXG4gKiAgICAgICAgICAgICAgICAgICAgICAge2FnZTogOSwgbmFtZTogJ0JlZXInfSlcbiAqICAgICAgICAgICAubWF4PFBlcnNvbj4oKGE6IFBlcnNvbiwgYjogUGVyc29uKSA9PiBhLmFnZSA8IGIuYWdlID8gLTEgOiAxKVxuICogICAgICAgICAgIC5zdWJzY3JpYmUoKHg6IFBlcnNvbikgPT4gY29uc29sZS5sb2coeC5uYW1lKSk7IC8vIC0+ICdCZWVyJ1xuICogfVxuICpcbiAqIEBzZWUge0BsaW5rIG1pbn1cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyZXJdIC0gT3B0aW9uYWwgY29tcGFyZXIgZnVuY3Rpb24gdGhhdCBpdCB3aWxsIHVzZSBpbnN0ZWFkIG9mIGl0cyBkZWZhdWx0IHRvIGNvbXBhcmUgdGhlXG4gKiB2YWx1ZSBvZiB0d28gaXRlbXMuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgaXRlbSB3aXRoIHRoZSBsYXJnZXN0IHZhbHVlLlxuICogQG1ldGhvZCBtYXhcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIG1heChjb21wYXJlcikge1xuICAgIHZhciBtYXggPSAodHlwZW9mIGNvbXBhcmVyID09PSAnZnVuY3Rpb24nKVxuICAgICAgICA/IGZ1bmN0aW9uICh4LCB5KSB7IHJldHVybiBjb21wYXJlcih4LCB5KSA+IDAgPyB4IDogeTsgfVxuICAgICAgICA6IGZ1bmN0aW9uICh4LCB5KSB7IHJldHVybiB4ID4geSA/IHggOiB5OyB9O1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IHJlZHVjZV8xLlJlZHVjZU9wZXJhdG9yKG1heCkpO1xufVxuZXhwb3J0cy5tYXggPSBtYXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXguanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3IvbWF4LmpzXG4vLyBtb2R1bGUgaWQgPSAyODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciB0cnlDYXRjaF8xID0gcmVxdWlyZSgnLi4vdXRpbC90cnlDYXRjaCcpO1xudmFyIGVycm9yT2JqZWN0XzEgPSByZXF1aXJlKCcuLi91dGlsL2Vycm9yT2JqZWN0Jyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xuLyoqXG4gKiBBcHBsaWVzIGFuIGFjY3VtdWxhdG9yIGZ1bmN0aW9uIG92ZXIgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHdoZXJlIHRoZVxuICogYWNjdW11bGF0b3IgZnVuY3Rpb24gaXRzZWxmIHJldHVybnMgYW4gT2JzZXJ2YWJsZSwgdGhlbiBlYWNoIGludGVybWVkaWF0ZVxuICogT2JzZXJ2YWJsZSByZXR1cm5lZCBpcyBtZXJnZWQgaW50byB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgc2Nhbn0sIGJ1dCB0aGUgT2JzZXJ2YWJsZXMgcmV0dXJuZWRcbiAqIGJ5IHRoZSBhY2N1bXVsYXRvciBhcmUgbWVyZ2VkIGludG8gdGhlIG91dGVyIE9ic2VydmFibGUuPC9zcGFuPlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNvdW50IHRoZSBudW1iZXIgb2YgY2xpY2sgZXZlbnRzPC9jYXB0aW9uPlxuICogY29uc3QgY2xpY2skID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogY29uc3Qgb25lJCA9IGNsaWNrJC5tYXBUbygxKTtcbiAqIGNvbnN0IHNlZWQgPSAwO1xuICogY29uc3QgY291bnQkID0gb25lJC5tZXJnZVNjYW4oKGFjYywgb25lKSA9PiBSeC5PYnNlcnZhYmxlLm9mKGFjYyArIG9uZSksIHNlZWQpO1xuICogY291bnQkLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBSZXN1bHRzOlxuICogMVxuICogMlxuICogM1xuICogNFxuICogLy8gLi4uYW5kIHNvIG9uIGZvciBlYWNoIGNsaWNrXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbihhY2M6IFIsIHZhbHVlOiBUKTogT2JzZXJ2YWJsZTxSPn0gYWNjdW11bGF0b3JcbiAqIFRoZSBhY2N1bXVsYXRvciBmdW5jdGlvbiBjYWxsZWQgb24gZWFjaCBzb3VyY2UgdmFsdWUuXG4gKiBAcGFyYW0gc2VlZCBUaGUgaW5pdGlhbCBhY2N1bXVsYXRpb24gdmFsdWUuXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvbmN1cnJlbnQ9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSBNYXhpbXVtIG51bWJlciBvZlxuICogaW5wdXQgT2JzZXJ2YWJsZXMgYmVpbmcgc3Vic2NyaWJlZCB0byBjb25jdXJyZW50bHkuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFI+fSBBbiBvYnNlcnZhYmxlIG9mIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZXMuXG4gKiBAbWV0aG9kIG1lcmdlU2NhblxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gbWVyZ2VTY2FuKGFjY3VtdWxhdG9yLCBzZWVkLCBjb25jdXJyZW50KSB7XG4gICAgaWYgKGNvbmN1cnJlbnQgPT09IHZvaWQgMCkgeyBjb25jdXJyZW50ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZOyB9XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgTWVyZ2VTY2FuT3BlcmF0b3IoYWNjdW11bGF0b3IsIHNlZWQsIGNvbmN1cnJlbnQpKTtcbn1cbmV4cG9ydHMubWVyZ2VTY2FuID0gbWVyZ2VTY2FuO1xudmFyIE1lcmdlU2Nhbk9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZXJnZVNjYW5PcGVyYXRvcihhY2N1bXVsYXRvciwgc2VlZCwgY29uY3VycmVudCkge1xuICAgICAgICB0aGlzLmFjY3VtdWxhdG9yID0gYWNjdW11bGF0b3I7XG4gICAgICAgIHRoaXMuc2VlZCA9IHNlZWQ7XG4gICAgICAgIHRoaXMuY29uY3VycmVudCA9IGNvbmN1cnJlbnQ7XG4gICAgfVxuICAgIE1lcmdlU2Nhbk9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgTWVyZ2VTY2FuU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmFjY3VtdWxhdG9yLCB0aGlzLnNlZWQsIHRoaXMuY29uY3VycmVudCkpO1xuICAgIH07XG4gICAgcmV0dXJuIE1lcmdlU2Nhbk9wZXJhdG9yO1xufSgpKTtcbmV4cG9ydHMuTWVyZ2VTY2FuT3BlcmF0b3IgPSBNZXJnZVNjYW5PcGVyYXRvcjtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgTWVyZ2VTY2FuU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1lcmdlU2NhblN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVyZ2VTY2FuU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgYWNjdW11bGF0b3IsIGFjYywgY29uY3VycmVudCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuYWNjdW11bGF0b3IgPSBhY2N1bXVsYXRvcjtcbiAgICAgICAgdGhpcy5hY2MgPSBhY2M7XG4gICAgICAgIHRoaXMuY29uY3VycmVudCA9IGNvbmN1cnJlbnQ7XG4gICAgICAgIHRoaXMuaGFzVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSAwO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB9XG4gICAgTWVyZ2VTY2FuU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlIDwgdGhpcy5jb25jdXJyZW50KSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4Kys7XG4gICAgICAgICAgICB2YXIgaXNoID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaCh0aGlzLmFjY3VtdWxhdG9yKSh0aGlzLmFjYywgdmFsdWUpO1xuICAgICAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgICAgIGlmIChpc2ggPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmUrKztcbiAgICAgICAgICAgICAgICB0aGlzLl9pbm5lclN1Yihpc2gsIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWVyZ2VTY2FuU3Vic2NyaWJlci5wcm90b3R5cGUuX2lubmVyU3ViID0gZnVuY3Rpb24gKGlzaCwgdmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgaXNoLCB2YWx1ZSwgaW5kZXgpKTtcbiAgICB9O1xuICAgIE1lcmdlU2NhblN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUgPT09IDAgJiYgdGhpcy5idWZmZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNWYWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodGhpcy5hY2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZXJnZVNjYW5TdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIHRoaXMuYWNjID0gaW5uZXJWYWx1ZTtcbiAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IHRydWU7XG4gICAgICAgIGRlc3RpbmF0aW9uLm5leHQoaW5uZXJWYWx1ZSk7XG4gICAgfTtcbiAgICBNZXJnZVNjYW5TdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uIChpbm5lclN1Yikge1xuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXI7XG4gICAgICAgIHRoaXMucmVtb3ZlKGlubmVyU3ViKTtcbiAgICAgICAgdGhpcy5hY3RpdmUtLTtcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9uZXh0KGJ1ZmZlci5zaGlmdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmFjdGl2ZSA9PT0gMCAmJiB0aGlzLmhhc0NvbXBsZXRlZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzVmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHRoaXMuYWNjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE1lcmdlU2NhblN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuZXhwb3J0cy5NZXJnZVNjYW5TdWJzY3JpYmVyID0gTWVyZ2VTY2FuU3Vic2NyaWJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmdlU2Nhbi5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvci9tZXJnZVNjYW4uanNcbi8vIG1vZHVsZSBpZCA9IDI4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciByZWR1Y2VfMSA9IHJlcXVpcmUoJy4vcmVkdWNlJyk7XG4vKipcbiAqIFRoZSBNaW4gb3BlcmF0b3Igb3BlcmF0ZXMgb24gYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIG51bWJlcnMgKG9yIGl0ZW1zIHRoYXQgY2FuIGJlIGNvbXBhcmVkIHdpdGggYSBwcm92aWRlZCBmdW5jdGlvbiksXG4gKiBhbmQgd2hlbiBzb3VyY2UgT2JzZXJ2YWJsZSBjb21wbGV0ZXMgaXQgZW1pdHMgYSBzaW5nbGUgaXRlbTogdGhlIGl0ZW0gd2l0aCB0aGUgc21hbGxlc3QgdmFsdWUuXG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9taW4ucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+R2V0IHRoZSBtaW5pbWFsIHZhbHVlIG9mIGEgc2VyaWVzIG9mIG51bWJlcnM8L2NhcHRpb24+XG4gKiBSeC5PYnNlcnZhYmxlLm9mKDUsIDQsIDcsIDIsIDgpXG4gKiAgIC5taW4oKVxuICogICAuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpOyAvLyAtPiAyXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+VXNlIGEgY29tcGFyZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBtaW5pbWFsIGl0ZW08L2NhcHRpb24+XG4gKiBpbnRlcmZhY2UgUGVyc29uIHtcbiAqICAgYWdlOiBudW1iZXIsXG4gKiAgIG5hbWU6IHN0cmluZ1xuICogfVxuICogT2JzZXJ2YWJsZS5vZjxQZXJzb24+KHthZ2U6IDcsIG5hbWU6ICdGb28nfSxcbiAqICAgICAgICAgICAgICAgICAgICAgICB7YWdlOiA1LCBuYW1lOiAnQmFyJ30sXG4gKiAgICAgICAgICAgICAgICAgICAgICAge2FnZTogOSwgbmFtZTogJ0JlZXInfSlcbiAqICAgICAgICAgICAubWluPFBlcnNvbj4oIChhOiBQZXJzb24sIGI6IFBlcnNvbikgPT4gYS5hZ2UgPCBiLmFnZSA/IC0xIDogMSlcbiAqICAgICAgICAgICAuc3Vic2NyaWJlKCh4OiBQZXJzb24pID0+IGNvbnNvbGUubG9nKHgubmFtZSkpOyAvLyAtPiAnQmFyJ1xuICogfVxuICpcbiAqIEBzZWUge0BsaW5rIG1heH1cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyZXJdIC0gT3B0aW9uYWwgY29tcGFyZXIgZnVuY3Rpb24gdGhhdCBpdCB3aWxsIHVzZSBpbnN0ZWFkIG9mIGl0cyBkZWZhdWx0IHRvIGNvbXBhcmUgdGhlXG4gKiB2YWx1ZSBvZiB0d28gaXRlbXMuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFI+fSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgaXRlbSB3aXRoIHRoZSBzbWFsbGVzdCB2YWx1ZS5cbiAqIEBtZXRob2QgbWluXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBtaW4oY29tcGFyZXIpIHtcbiAgICB2YXIgbWluID0gKHR5cGVvZiBjb21wYXJlciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgPyBmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4gY29tcGFyZXIoeCwgeSkgPCAwID8geCA6IHk7IH1cbiAgICAgICAgOiBmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4geCA8IHkgPyB4IDogeTsgfTtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyByZWR1Y2VfMS5SZWR1Y2VPcGVyYXRvcihtaW4pKTtcbn1cbmV4cG9ydHMubWluID0gbWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWluLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9yL21pbi5qc1xuLy8gbW9kdWxlIGlkID0gMjkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xuLyoqXG4gKiBHcm91cHMgcGFpcnMgb2YgY29uc2VjdXRpdmUgZW1pc3Npb25zIHRvZ2V0aGVyIGFuZCBlbWl0cyB0aGVtIGFzIGFuIGFycmF5IG9mXG4gKiB0d28gdmFsdWVzLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5QdXRzIHRoZSBjdXJyZW50IHZhbHVlIGFuZCBwcmV2aW91cyB2YWx1ZSB0b2dldGhlciBhc1xuICogYW4gYXJyYXksIGFuZCBlbWl0cyB0aGF0Ljwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3BhaXJ3aXNlLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFRoZSBOdGggZW1pc3Npb24gZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgd2lsbCBjYXVzZSB0aGUgb3V0cHV0IE9ic2VydmFibGVcbiAqIHRvIGVtaXQgYW4gYXJyYXkgWyhOLTEpdGgsIE50aF0gb2YgdGhlIHByZXZpb3VzIGFuZCB0aGUgY3VycmVudCB2YWx1ZSwgYXMgYVxuICogcGFpci4gRm9yIHRoaXMgcmVhc29uLCBgcGFpcndpc2VgIGVtaXRzIG9uIHRoZSBzZWNvbmQgYW5kIHN1YnNlcXVlbnRcbiAqIGVtaXNzaW9ucyBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgYnV0IG5vdCBvbiB0aGUgZmlyc3QgZW1pc3Npb24sIGJlY2F1c2VcbiAqIHRoZXJlIGlzIG5vIHByZXZpb3VzIHZhbHVlIGluIHRoYXQgY2FzZS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5PbiBldmVyeSBjbGljayAoc3RhcnRpbmcgZnJvbSB0aGUgc2Vjb25kKSwgZW1pdCB0aGUgcmVsYXRpdmUgZGlzdGFuY2UgdG8gdGhlIHByZXZpb3VzIGNsaWNrPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBwYWlycyA9IGNsaWNrcy5wYWlyd2lzZSgpO1xuICogdmFyIGRpc3RhbmNlID0gcGFpcnMubWFwKHBhaXIgPT4ge1xuICogICB2YXIgeDAgPSBwYWlyWzBdLmNsaWVudFg7XG4gKiAgIHZhciB5MCA9IHBhaXJbMF0uY2xpZW50WTtcbiAqICAgdmFyIHgxID0gcGFpclsxXS5jbGllbnRYO1xuICogICB2YXIgeTEgPSBwYWlyWzFdLmNsaWVudFk7XG4gKiAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coeDAgLSB4MSwgMikgKyBNYXRoLnBvdyh5MCAtIHkxLCAyKSk7XG4gKiB9KTtcbiAqIGRpc3RhbmNlLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBidWZmZXJ9XG4gKiBAc2VlIHtAbGluayBidWZmZXJDb3VudH1cbiAqXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPEFycmF5PFQ+Pn0gQW4gT2JzZXJ2YWJsZSBvZiBwYWlycyAoYXMgYXJyYXlzKSBvZlxuICogY29uc2VjdXRpdmUgdmFsdWVzIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCBwYWlyd2lzZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gcGFpcndpc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgUGFpcndpc2VPcGVyYXRvcigpKTtcbn1cbmV4cG9ydHMucGFpcndpc2UgPSBwYWlyd2lzZTtcbnZhciBQYWlyd2lzZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYWlyd2lzZU9wZXJhdG9yKCkge1xuICAgIH1cbiAgICBQYWlyd2lzZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgUGFpcndpc2VTdWJzY3JpYmVyKHN1YnNjcmliZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBQYWlyd2lzZU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgUGFpcndpc2VTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGFpcndpc2VTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBhaXJ3aXNlU3Vic2NyaWJlcihkZXN0aW5hdGlvbikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuaGFzUHJldiA9IGZhbHNlO1xuICAgIH1cbiAgICBQYWlyd2lzZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc1ByZXYpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChbdGhpcy5wcmV2LCB2YWx1ZV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oYXNQcmV2ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXYgPSB2YWx1ZTtcbiAgICB9O1xuICAgIHJldHVybiBQYWlyd2lzZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWlyd2lzZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvci9wYWlyd2lzZS5qc1xuLy8gbW9kdWxlIGlkID0gMjkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIG5vdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9ub3QnKTtcbnZhciBmaWx0ZXJfMSA9IHJlcXVpcmUoJy4vZmlsdGVyJyk7XG4vKipcbiAqIFNwbGl0cyB0aGUgc291cmNlIE9ic2VydmFibGUgaW50byB0d28sIG9uZSB3aXRoIHZhbHVlcyB0aGF0IHNhdGlzZnkgYVxuICogcHJlZGljYXRlLCBhbmQgYW5vdGhlciB3aXRoIHZhbHVlcyB0aGF0IGRvbid0IHNhdGlzZnkgdGhlIHByZWRpY2F0ZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SXQncyBsaWtlIHtAbGluayBmaWx0ZXJ9LCBidXQgcmV0dXJucyB0d28gT2JzZXJ2YWJsZXM6XG4gKiBvbmUgbGlrZSB0aGUgb3V0cHV0IG9mIHtAbGluayBmaWx0ZXJ9LCBhbmQgdGhlIG90aGVyIHdpdGggdmFsdWVzIHRoYXQgZGlkIG5vdFxuICogcGFzcyB0aGUgY29uZGl0aW9uLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3BhcnRpdGlvbi5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgcGFydGl0aW9uYCBvdXRwdXRzIGFuIGFycmF5IHdpdGggdHdvIE9ic2VydmFibGVzIHRoYXQgcGFydGl0aW9uIHRoZSB2YWx1ZXNcbiAqIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHRocm91Z2ggdGhlIGdpdmVuIGBwcmVkaWNhdGVgIGZ1bmN0aW9uLiBUaGUgZmlyc3RcbiAqIE9ic2VydmFibGUgaW4gdGhhdCBhcnJheSBlbWl0cyBzb3VyY2UgdmFsdWVzIGZvciB3aGljaCB0aGUgcHJlZGljYXRlIGFyZ3VtZW50XG4gKiByZXR1cm5zIHRydWUuIFRoZSBzZWNvbmQgT2JzZXJ2YWJsZSBlbWl0cyBzb3VyY2UgdmFsdWVzIGZvciB3aGljaCB0aGVcbiAqIHByZWRpY2F0ZSByZXR1cm5zIGZhbHNlLiBUaGUgZmlyc3QgYmVoYXZlcyBsaWtlIHtAbGluayBmaWx0ZXJ9IGFuZCB0aGUgc2Vjb25kXG4gKiBiZWhhdmVzIGxpa2Uge0BsaW5rIGZpbHRlcn0gd2l0aCB0aGUgcHJlZGljYXRlIG5lZ2F0ZWQuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+UGFydGl0aW9uIGNsaWNrIGV2ZW50cyBpbnRvIHRob3NlIG9uIERJViBlbGVtZW50cyBhbmQgdGhvc2UgZWxzZXdoZXJlPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBwYXJ0cyA9IGNsaWNrcy5wYXJ0aXRpb24oZXYgPT4gZXYudGFyZ2V0LnRhZ05hbWUgPT09ICdESVYnKTtcbiAqIHZhciBjbGlja3NPbkRpdnMgPSBwYXJ0c1swXTtcbiAqIHZhciBjbGlja3NFbHNld2hlcmUgPSBwYXJ0c1sxXTtcbiAqIGNsaWNrc09uRGl2cy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZygnRElWIGNsaWNrZWQ6ICcsIHgpKTtcbiAqIGNsaWNrc0Vsc2V3aGVyZS5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZygnT3RoZXIgY2xpY2tlZDogJywgeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGZpbHRlcn1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCBpbmRleDogbnVtYmVyKTogYm9vbGVhbn0gcHJlZGljYXRlIEEgZnVuY3Rpb24gdGhhdFxuICogZXZhbHVhdGVzIGVhY2ggdmFsdWUgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuIElmIGl0IHJldHVybnMgYHRydWVgLFxuICogdGhlIHZhbHVlIGlzIGVtaXR0ZWQgb24gdGhlIGZpcnN0IE9ic2VydmFibGUgaW4gdGhlIHJldHVybmVkIGFycmF5LCBpZlxuICogYGZhbHNlYCB0aGUgdmFsdWUgaXMgZW1pdHRlZCBvbiB0aGUgc2Vjb25kIE9ic2VydmFibGUgaW4gdGhlIGFycmF5LiBUaGVcbiAqIGBpbmRleGAgcGFyYW1ldGVyIGlzIHRoZSBudW1iZXIgYGlgIGZvciB0aGUgaS10aCBzb3VyY2UgZW1pc3Npb24gdGhhdCBoYXNcbiAqIGhhcHBlbmVkIHNpbmNlIHRoZSBzdWJzY3JpcHRpb24sIHN0YXJ0aW5nIGZyb20gdGhlIG51bWJlciBgMGAuXG4gKiBAcGFyYW0ge2FueX0gW3RoaXNBcmddIEFuIG9wdGlvbmFsIGFyZ3VtZW50IHRvIGRldGVybWluZSB0aGUgdmFsdWUgb2YgYHRoaXNgXG4gKiBpbiB0aGUgYHByZWRpY2F0ZWAgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtbT2JzZXJ2YWJsZTxUPiwgT2JzZXJ2YWJsZTxUPl19IEFuIGFycmF5IHdpdGggdHdvIE9ic2VydmFibGVzOiBvbmVcbiAqIHdpdGggdmFsdWVzIHRoYXQgcGFzc2VkIHRoZSBwcmVkaWNhdGUsIGFuZCBhbm90aGVyIHdpdGggdmFsdWVzIHRoYXQgZGlkIG5vdFxuICogcGFzcyB0aGUgcHJlZGljYXRlLlxuICogQG1ldGhvZCBwYXJ0aXRpb25cbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHBhcnRpdGlvbihwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBmaWx0ZXJfMS5maWx0ZXIuY2FsbCh0aGlzLCBwcmVkaWNhdGUsIHRoaXNBcmcpLFxuICAgICAgICBmaWx0ZXJfMS5maWx0ZXIuY2FsbCh0aGlzLCBub3RfMS5ub3QocHJlZGljYXRlLCB0aGlzQXJnKSlcbiAgICBdO1xufVxuZXhwb3J0cy5wYXJ0aXRpb24gPSBwYXJ0aXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJ0aXRpb24uanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3IvcGFydGl0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAyOTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgbWFwXzEgPSByZXF1aXJlKCcuL21hcCcpO1xuLyoqXG4gKiBNYXBzIGVhY2ggc291cmNlIHZhbHVlIChhbiBvYmplY3QpIHRvIGl0cyBzcGVjaWZpZWQgbmVzdGVkIHByb3BlcnR5LlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5MaWtlIHtAbGluayBtYXB9LCBidXQgbWVhbnQgb25seSBmb3IgcGlja2luZyBvbmUgb2ZcbiAqIHRoZSBuZXN0ZWQgcHJvcGVydGllcyBvZiBldmVyeSBlbWl0dGVkIG9iamVjdC48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9wbHVjay5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBHaXZlbiBhIGxpc3Qgb2Ygc3RyaW5ncyBkZXNjcmliaW5nIGEgcGF0aCB0byBhbiBvYmplY3QgcHJvcGVydHksIHJldHJpZXZlc1xuICogdGhlIHZhbHVlIG9mIGEgc3BlY2lmaWVkIG5lc3RlZCBwcm9wZXJ0eSBmcm9tIGFsbCB2YWx1ZXMgaW4gdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZS4gSWYgYSBwcm9wZXJ0eSBjYW4ndCBiZSByZXNvbHZlZCwgaXQgd2lsbCByZXR1cm4gYHVuZGVmaW5lZGAgZm9yXG4gKiB0aGF0IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPk1hcCBldmVyeSBldmVyeSBjbGljayB0byB0aGUgdGFnTmFtZSBvZiB0aGUgY2xpY2tlZCB0YXJnZXQgZWxlbWVudDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgdGFnTmFtZXMgPSBjbGlja3MucGx1Y2soJ3RhcmdldCcsICd0YWdOYW1lJyk7XG4gKiB0YWdOYW1lcy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgbWFwfVxuICpcbiAqIEBwYXJhbSB7Li4uc3RyaW5nfSBwcm9wZXJ0aWVzIFRoZSBuZXN0ZWQgcHJvcGVydGllcyB0byBwbHVjayBmcm9tIGVhY2ggc291cmNlXG4gKiB2YWx1ZSAoYW4gb2JqZWN0KS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEEgbmV3IE9ic2VydmFibGUgb2YgcHJvcGVydHkgdmFsdWVzIGZyb20gdGhlIHNvdXJjZSB2YWx1ZXMuXG4gKiBAbWV0aG9kIHBsdWNrXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBwbHVjaygpIHtcbiAgICB2YXIgcHJvcGVydGllcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHByb3BlcnRpZXNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBwcm9wZXJ0aWVzLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbGlzdCBvZiBwcm9wZXJ0aWVzIGNhbm5vdCBiZSBlbXB0eS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcF8xLm1hcC5jYWxsKHRoaXMsIHBsdWNrZXIocHJvcGVydGllcywgbGVuZ3RoKSk7XG59XG5leHBvcnRzLnBsdWNrID0gcGx1Y2s7XG5mdW5jdGlvbiBwbHVja2VyKHByb3BzLCBsZW5ndGgpIHtcbiAgICB2YXIgbWFwcGVyID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRQcm9wID0geDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHAgPSBjdXJyZW50UHJvcFtwcm9wc1tpXV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHAgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFByb3AgPSBwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VycmVudFByb3A7XG4gICAgfTtcbiAgICByZXR1cm4gbWFwcGVyO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGx1Y2suanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3IvcGx1Y2suanNcbi8vIG1vZHVsZSBpZCA9IDI5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBTdWJqZWN0XzEgPSByZXF1aXJlKCcuLi9TdWJqZWN0Jyk7XG52YXIgbXVsdGljYXN0XzEgPSByZXF1aXJlKCcuL211bHRpY2FzdCcpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogUmV0dXJucyBhIENvbm5lY3RhYmxlT2JzZXJ2YWJsZSwgd2hpY2ggaXMgYSB2YXJpZXR5IG9mIE9ic2VydmFibGUgdGhhdCB3YWl0cyB1bnRpbCBpdHMgY29ubmVjdCBtZXRob2QgaXMgY2FsbGVkXG4gKiBiZWZvcmUgaXQgYmVnaW5zIGVtaXR0aW5nIGl0ZW1zIHRvIHRob3NlIE9ic2VydmVycyB0aGF0IGhhdmUgc3Vic2NyaWJlZCB0byBpdC5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3B1Ymxpc2gucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3NlbGVjdG9yXSAtIE9wdGlvbmFsIHNlbGVjdG9yIGZ1bmN0aW9uIHdoaWNoIGNhbiB1c2UgdGhlIG11bHRpY2FzdGVkIHNvdXJjZSBzZXF1ZW5jZSBhcyBtYW55IHRpbWVzXG4gKiBhcyBuZWVkZWQsIHdpdGhvdXQgY2F1c2luZyBtdWx0aXBsZSBzdWJzY3JpcHRpb25zIHRvIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gKiBTdWJzY3JpYmVycyB0byB0aGUgZ2l2ZW4gc291cmNlIHdpbGwgcmVjZWl2ZSBhbGwgbm90aWZpY2F0aW9ucyBvZiB0aGUgc291cmNlIGZyb20gdGhlIHRpbWUgb2YgdGhlIHN1YnNjcmlwdGlvbiBvbi5cbiAqIEByZXR1cm4gQSBDb25uZWN0YWJsZU9ic2VydmFibGUgdGhhdCB1cG9uIGNvbm5lY3Rpb24gY2F1c2VzIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB0byBlbWl0IGl0ZW1zIHRvIGl0cyBPYnNlcnZlcnMuXG4gKiBAbWV0aG9kIHB1Ymxpc2hcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2goc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gc2VsZWN0b3IgPyBtdWx0aWNhc3RfMS5tdWx0aWNhc3QuY2FsbCh0aGlzLCBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgU3ViamVjdF8xLlN1YmplY3QoKTsgfSwgc2VsZWN0b3IpIDpcbiAgICAgICAgbXVsdGljYXN0XzEubXVsdGljYXN0LmNhbGwodGhpcywgbmV3IFN1YmplY3RfMS5TdWJqZWN0KCkpO1xufVxuZXhwb3J0cy5wdWJsaXNoID0gcHVibGlzaDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXB1Ymxpc2guanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3IvcHVibGlzaC5qc1xuLy8gbW9kdWxlIGlkID0gMjk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIEJlaGF2aW9yU3ViamVjdF8xID0gcmVxdWlyZSgnLi4vQmVoYXZpb3JTdWJqZWN0Jyk7XG52YXIgbXVsdGljYXN0XzEgPSByZXF1aXJlKCcuL211bHRpY2FzdCcpO1xuLyoqXG4gKiBAcGFyYW0gdmFsdWVcbiAqIEByZXR1cm4ge0Nvbm5lY3RhYmxlT2JzZXJ2YWJsZTxUPn1cbiAqIEBtZXRob2QgcHVibGlzaEJlaGF2aW9yXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBwdWJsaXNoQmVoYXZpb3IodmFsdWUpIHtcbiAgICByZXR1cm4gbXVsdGljYXN0XzEubXVsdGljYXN0LmNhbGwodGhpcywgbmV3IEJlaGF2aW9yU3ViamVjdF8xLkJlaGF2aW9yU3ViamVjdCh2YWx1ZSkpO1xufVxuZXhwb3J0cy5wdWJsaXNoQmVoYXZpb3IgPSBwdWJsaXNoQmVoYXZpb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wdWJsaXNoQmVoYXZpb3IuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3IvcHVibGlzaEJlaGF2aW9yLmpzXG4vLyBtb2R1bGUgaWQgPSAyOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQXN5bmNTdWJqZWN0XzEgPSByZXF1aXJlKCcuLi9Bc3luY1N1YmplY3QnKTtcbnZhciBtdWx0aWNhc3RfMSA9IHJlcXVpcmUoJy4vbXVsdGljYXN0Jyk7XG4vKipcbiAqIEByZXR1cm4ge0Nvbm5lY3RhYmxlT2JzZXJ2YWJsZTxUPn1cbiAqIEBtZXRob2QgcHVibGlzaExhc3RcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hMYXN0KCkge1xuICAgIHJldHVybiBtdWx0aWNhc3RfMS5tdWx0aWNhc3QuY2FsbCh0aGlzLCBuZXcgQXN5bmNTdWJqZWN0XzEuQXN5bmNTdWJqZWN0KCkpO1xufVxuZXhwb3J0cy5wdWJsaXNoTGFzdCA9IHB1Ymxpc2hMYXN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHVibGlzaExhc3QuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3IvcHVibGlzaExhc3QuanNcbi8vIG1vZHVsZSBpZCA9IDI5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBSZXBsYXlTdWJqZWN0XzEgPSByZXF1aXJlKCcuLi9SZXBsYXlTdWJqZWN0Jyk7XG52YXIgbXVsdGljYXN0XzEgPSByZXF1aXJlKCcuL211bHRpY2FzdCcpO1xuLyoqXG4gKiBAcGFyYW0gYnVmZmVyU2l6ZVxuICogQHBhcmFtIHdpbmRvd1RpbWVcbiAqIEBwYXJhbSBzY2hlZHVsZXJcbiAqIEByZXR1cm4ge0Nvbm5lY3RhYmxlT2JzZXJ2YWJsZTxUPn1cbiAqIEBtZXRob2QgcHVibGlzaFJlcGxheVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gcHVibGlzaFJlcGxheShidWZmZXJTaXplLCB3aW5kb3dUaW1lLCBzY2hlZHVsZXIpIHtcbiAgICBpZiAoYnVmZmVyU2l6ZSA9PT0gdm9pZCAwKSB7IGJ1ZmZlclNpemUgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7IH1cbiAgICBpZiAod2luZG93VGltZSA9PT0gdm9pZCAwKSB7IHdpbmRvd1RpbWUgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7IH1cbiAgICByZXR1cm4gbXVsdGljYXN0XzEubXVsdGljYXN0LmNhbGwodGhpcywgbmV3IFJlcGxheVN1YmplY3RfMS5SZXBsYXlTdWJqZWN0KGJ1ZmZlclNpemUsIHdpbmRvd1RpbWUsIHNjaGVkdWxlcikpO1xufVxuZXhwb3J0cy5wdWJsaXNoUmVwbGF5ID0gcHVibGlzaFJlcGxheTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXB1Ymxpc2hSZXBsYXkuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3IvcHVibGlzaFJlcGxheS5qc1xuLy8gbW9kdWxlIGlkID0gMjk3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIEVtcHR5T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vb2JzZXJ2YWJsZS9FbXB0eU9ic2VydmFibGUnKTtcbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgcmVwZWF0cyB0aGUgc3RyZWFtIG9mIGl0ZW1zIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGF0IG1vc3QgY291bnQgdGltZXMuXG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9yZXBlYXQucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFtjb3VudF0gVGhlIG51bWJlciBvZiB0aW1lcyB0aGUgc291cmNlIE9ic2VydmFibGUgaXRlbXMgYXJlIHJlcGVhdGVkLCBhIGNvdW50IG9mIDAgd2lsbCB5aWVsZFxuICogYW4gZW1wdHkgT2JzZXJ2YWJsZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCByZXBlYXRzIHRoZSBzdHJlYW0gb2YgaXRlbXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgYXQgbW9zdFxuICogY291bnQgdGltZXMuXG4gKiBAbWV0aG9kIHJlcGVhdFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gcmVwZWF0KGNvdW50KSB7XG4gICAgaWYgKGNvdW50ID09PSB2b2lkIDApIHsgY291bnQgPSAtMTsgfVxuICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IEVtcHR5T2JzZXJ2YWJsZV8xLkVtcHR5T2JzZXJ2YWJsZSgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb3VudCA8IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlmdChuZXcgUmVwZWF0T3BlcmF0b3IoLTEsIHRoaXMpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFJlcGVhdE9wZXJhdG9yKGNvdW50IC0gMSwgdGhpcykpO1xuICAgIH1cbn1cbmV4cG9ydHMucmVwZWF0ID0gcmVwZWF0O1xudmFyIFJlcGVhdE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXBlYXRPcGVyYXRvcihjb3VudCwgc291cmNlKSB7XG4gICAgICAgIHRoaXMuY291bnQgPSBjb3VudDtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIFJlcGVhdE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgUmVwZWF0U3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmNvdW50LCB0aGlzLnNvdXJjZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlcGVhdE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgUmVwZWF0U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlcGVhdFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVwZWF0U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgY291bnQsIHNvdXJjZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuY291bnQgPSBjb3VudDtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIFJlcGVhdFN1YnNjcmliZXIucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSB0aGlzLCBzb3VyY2UgPSBfYS5zb3VyY2UsIGNvdW50ID0gX2EuY291bnQ7XG4gICAgICAgICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5jb21wbGV0ZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY291bnQgPiAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY291bnQgPSBjb3VudCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzb3VyY2Uuc3Vic2NyaWJlKHRoaXMuX3Vuc3Vic2NyaWJlQW5kUmVjeWNsZSgpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFJlcGVhdFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXBlYXQuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3IvcmVwZWF0LmpzXG4vLyBtb2R1bGUgaWQgPSAyOThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJqZWN0XzEgPSByZXF1aXJlKCcuLi9TdWJqZWN0Jyk7XG52YXIgdHJ5Q2F0Y2hfMSA9IHJlcXVpcmUoJy4uL3V0aWwvdHJ5Q2F0Y2gnKTtcbnZhciBlcnJvck9iamVjdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9lcnJvck9iamVjdCcpO1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgbWlycm9ycyB0aGUgc291cmNlIE9ic2VydmFibGUgd2l0aCB0aGUgZXhjZXB0aW9uIG9mIGEgYGNvbXBsZXRlYC4gSWYgdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSBjYWxscyBgY29tcGxldGVgLCB0aGlzIG1ldGhvZCB3aWxsIGVtaXQgdG8gdGhlIE9ic2VydmFibGUgcmV0dXJuZWQgZnJvbSBgbm90aWZpZXJgLiBJZiB0aGF0IE9ic2VydmFibGVcbiAqIGNhbGxzIGBjb21wbGV0ZWAgb3IgYGVycm9yYCwgdGhlbiB0aGlzIG1ldGhvZCB3aWxsIGNhbGwgYGNvbXBsZXRlYCBvciBgZXJyb3JgIG9uIHRoZSBjaGlsZCBzdWJzY3JpcHRpb24uIE90aGVyd2lzZVxuICogdGhpcyBtZXRob2Qgd2lsbCByZXN1YnNjcmliZSB0byB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9yZXBlYXRXaGVuLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24obm90aWZpY2F0aW9uczogT2JzZXJ2YWJsZSk6IE9ic2VydmFibGV9IG5vdGlmaWVyIC0gUmVjZWl2ZXMgYW4gT2JzZXJ2YWJsZSBvZiBub3RpZmljYXRpb25zIHdpdGhcbiAqIHdoaWNoIGEgdXNlciBjYW4gYGNvbXBsZXRlYCBvciBgZXJyb3JgLCBhYm9ydGluZyB0aGUgcmVwZXRpdGlvbi5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IFRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBtb2RpZmllZCB3aXRoIHJlcGVhdCBsb2dpYy5cbiAqIEBtZXRob2QgcmVwZWF0V2hlblxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gcmVwZWF0V2hlbihub3RpZmllcikge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFJlcGVhdFdoZW5PcGVyYXRvcihub3RpZmllcikpO1xufVxuZXhwb3J0cy5yZXBlYXRXaGVuID0gcmVwZWF0V2hlbjtcbnZhciBSZXBlYXRXaGVuT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlcGVhdFdoZW5PcGVyYXRvcihub3RpZmllcikge1xuICAgICAgICB0aGlzLm5vdGlmaWVyID0gbm90aWZpZXI7XG4gICAgfVxuICAgIFJlcGVhdFdoZW5PcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFJlcGVhdFdoZW5TdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMubm90aWZpZXIsIHNvdXJjZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlcGVhdFdoZW5PcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFJlcGVhdFdoZW5TdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVwZWF0V2hlblN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVwZWF0V2hlblN1YnNjcmliZXIoZGVzdGluYXRpb24sIG5vdGlmaWVyLCBzb3VyY2UpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLm5vdGlmaWVyID0gbm90aWZpZXI7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLnNvdXJjZUlzQmVpbmdTdWJzY3JpYmVkVG8gPSB0cnVlO1xuICAgIH1cbiAgICBSZXBlYXRXaGVuU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLnNvdXJjZUlzQmVpbmdTdWJzY3JpYmVkVG8gPSB0cnVlO1xuICAgICAgICB0aGlzLnNvdXJjZS5zdWJzY3JpYmUodGhpcyk7XG4gICAgfTtcbiAgICBSZXBlYXRXaGVuU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoaW5uZXJTdWIpIHtcbiAgICAgICAgaWYgKHRoaXMuc291cmNlSXNCZWluZ1N1YnNjcmliZWRUbyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmNvbXBsZXRlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlcGVhdFdoZW5TdWJzY3JpYmVyLnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zb3VyY2VJc0JlaW5nU3Vic2NyaWJlZFRvID0gZmFsc2U7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5yZXRyaWVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVUb1JldHJpZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucmV0cmllc1N1YnNjcmlwdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5jb21wbGV0ZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmVBbmRSZWN5Y2xlKCk7XG4gICAgICAgICAgICB0aGlzLm5vdGlmaWNhdGlvbnMubmV4dCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZXBlYXRXaGVuU3Vic2NyaWJlci5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBub3RpZmljYXRpb25zID0gX2Eubm90aWZpY2F0aW9ucywgcmV0cmllc1N1YnNjcmlwdGlvbiA9IF9hLnJldHJpZXNTdWJzY3JpcHRpb247XG4gICAgICAgIGlmIChub3RpZmljYXRpb25zKSB7XG4gICAgICAgICAgICBub3RpZmljYXRpb25zLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLm5vdGlmaWNhdGlvbnMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXRyaWVzU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICByZXRyaWVzU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLnJldHJpZXNTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmV0cmllcyA9IG51bGw7XG4gICAgfTtcbiAgICBSZXBlYXRXaGVuU3Vic2NyaWJlci5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlQW5kUmVjeWNsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgbm90aWZpY2F0aW9ucyA9IF9hLm5vdGlmaWNhdGlvbnMsIHJldHJpZXMgPSBfYS5yZXRyaWVzLCByZXRyaWVzU3Vic2NyaXB0aW9uID0gX2EucmV0cmllc1N1YnNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy5ub3RpZmljYXRpb25zID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXRyaWVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXRyaWVzU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmVBbmRSZWN5Y2xlLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMubm90aWZpY2F0aW9ucyA9IG5vdGlmaWNhdGlvbnM7XG4gICAgICAgIHRoaXMucmV0cmllcyA9IHJldHJpZXM7XG4gICAgICAgIHRoaXMucmV0cmllc1N1YnNjcmlwdGlvbiA9IHJldHJpZXNTdWJzY3JpcHRpb247XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgUmVwZWF0V2hlblN1YnNjcmliZXIucHJvdG90eXBlLnN1YnNjcmliZVRvUmV0cmllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5ub3RpZmljYXRpb25zID0gbmV3IFN1YmplY3RfMS5TdWJqZWN0KCk7XG4gICAgICAgIHZhciByZXRyaWVzID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaCh0aGlzLm5vdGlmaWVyKSh0aGlzLm5vdGlmaWNhdGlvbnMpO1xuICAgICAgICBpZiAocmV0cmllcyA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuY29tcGxldGUuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJldHJpZXMgPSByZXRyaWVzO1xuICAgICAgICB0aGlzLnJldHJpZXNTdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIHJldHJpZXMpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlcGVhdFdoZW5TdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlcGVhdFdoZW4uanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3IvcmVwZWF0V2hlbi5qc1xuLy8gbW9kdWxlIGlkID0gMjk5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xuLyoqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBtaXJyb3JzIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB3aXRoIHRoZSBleGNlcHRpb24gb2YgYW4gYGVycm9yYC4gSWYgdGhlIHNvdXJjZSBPYnNlcnZhYmxlXG4gKiBjYWxscyBgZXJyb3JgLCB0aGlzIG1ldGhvZCB3aWxsIHJlc3Vic2NyaWJlIHRvIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBmb3IgYSBtYXhpbXVtIG9mIGBjb3VudGAgcmVzdWJzY3JpcHRpb25zIChnaXZlblxuICogYXMgYSBudW1iZXIgcGFyYW1ldGVyKSByYXRoZXIgdGhhbiBwcm9wYWdhdGluZyB0aGUgYGVycm9yYCBjYWxsLlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvcmV0cnkucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQW55IGFuZCBhbGwgaXRlbXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgd2lsbCBiZSBlbWl0dGVkIGJ5IHRoZSByZXN1bHRpbmcgT2JzZXJ2YWJsZSwgZXZlbiB0aG9zZSBlbWl0dGVkXG4gKiBkdXJpbmcgZmFpbGVkIHN1YnNjcmlwdGlvbnMuIEZvciBleGFtcGxlLCBpZiBhbiBPYnNlcnZhYmxlIGZhaWxzIGF0IGZpcnN0IGJ1dCBlbWl0cyBbMSwgMl0gdGhlbiBzdWNjZWVkcyB0aGUgc2Vjb25kXG4gKiB0aW1lIGFuZCBlbWl0czogWzEsIDIsIDMsIDQsIDVdIHRoZW4gdGhlIGNvbXBsZXRlIHN0cmVhbSBvZiBlbWlzc2lvbnMgYW5kIG5vdGlmaWNhdGlvbnNcbiAqIHdvdWxkIGJlOiBbMSwgMiwgMSwgMiwgMywgNCwgNSwgYGNvbXBsZXRlYF0uXG4gKiBAcGFyYW0ge251bWJlcn0gY291bnQgLSBOdW1iZXIgb2YgcmV0cnkgYXR0ZW1wdHMgYmVmb3JlIGZhaWxpbmcuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBUaGUgc291cmNlIE9ic2VydmFibGUgbW9kaWZpZWQgd2l0aCB0aGUgcmV0cnkgbG9naWMuXG4gKiBAbWV0aG9kIHJldHJ5XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiByZXRyeShjb3VudCkge1xuICAgIGlmIChjb3VudCA9PT0gdm9pZCAwKSB7IGNvdW50ID0gLTE7IH1cbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBSZXRyeU9wZXJhdG9yKGNvdW50LCB0aGlzKSk7XG59XG5leHBvcnRzLnJldHJ5ID0gcmV0cnk7XG52YXIgUmV0cnlPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmV0cnlPcGVyYXRvcihjb3VudCwgc291cmNlKSB7XG4gICAgICAgIHRoaXMuY291bnQgPSBjb3VudDtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIFJldHJ5T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBSZXRyeVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5jb3VudCwgdGhpcy5zb3VyY2UpKTtcbiAgICB9O1xuICAgIHJldHVybiBSZXRyeU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgUmV0cnlTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmV0cnlTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJldHJ5U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgY291bnQsIHNvdXJjZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuY291bnQgPSBjb3VudDtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIFJldHJ5U3Vic2NyaWJlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMsIHNvdXJjZSA9IF9hLnNvdXJjZSwgY291bnQgPSBfYS5jb3VudDtcbiAgICAgICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmVycm9yLmNhbGwodGhpcywgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvdW50ID4gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50ID0gY291bnQgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc291cmNlLnN1YnNjcmliZSh0aGlzLl91bnN1YnNjcmliZUFuZFJlY3ljbGUoKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBSZXRyeVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXRyeS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvci9yZXRyeS5qc1xuLy8gbW9kdWxlIGlkID0gMzAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3ViamVjdF8xID0gcmVxdWlyZSgnLi4vU3ViamVjdCcpO1xudmFyIHRyeUNhdGNoXzEgPSByZXF1aXJlKCcuLi91dGlsL3RyeUNhdGNoJyk7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvZXJyb3JPYmplY3QnKTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKipcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IG1pcnJvcnMgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiBhbiBgZXJyb3JgLiBJZiB0aGUgc291cmNlIE9ic2VydmFibGVcbiAqIGNhbGxzIGBlcnJvcmAsIHRoaXMgbWV0aG9kIHdpbGwgZW1pdCB0aGUgVGhyb3dhYmxlIHRoYXQgY2F1c2VkIHRoZSBlcnJvciB0byB0aGUgT2JzZXJ2YWJsZSByZXR1cm5lZCBmcm9tIGBub3RpZmllcmAuXG4gKiBJZiB0aGF0IE9ic2VydmFibGUgY2FsbHMgYGNvbXBsZXRlYCBvciBgZXJyb3JgIHRoZW4gdGhpcyBtZXRob2Qgd2lsbCBjYWxsIGBjb21wbGV0ZWAgb3IgYGVycm9yYCBvbiB0aGUgY2hpbGRcbiAqIHN1YnNjcmlwdGlvbi4gT3RoZXJ3aXNlIHRoaXMgbWV0aG9kIHdpbGwgcmVzdWJzY3JpYmUgdG8gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvcmV0cnlXaGVuLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oZXJyb3JzOiBPYnNlcnZhYmxlKTogT2JzZXJ2YWJsZX0gbm90aWZpZXIgLSBSZWNlaXZlcyBhbiBPYnNlcnZhYmxlIG9mIG5vdGlmaWNhdGlvbnMgd2l0aCB3aGljaCBhXG4gKiB1c2VyIGNhbiBgY29tcGxldGVgIG9yIGBlcnJvcmAsIGFib3J0aW5nIHRoZSByZXRyeS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IFRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBtb2RpZmllZCB3aXRoIHJldHJ5IGxvZ2ljLlxuICogQG1ldGhvZCByZXRyeVdoZW5cbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHJldHJ5V2hlbihub3RpZmllcikge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFJldHJ5V2hlbk9wZXJhdG9yKG5vdGlmaWVyLCB0aGlzKSk7XG59XG5leHBvcnRzLnJldHJ5V2hlbiA9IHJldHJ5V2hlbjtcbnZhciBSZXRyeVdoZW5PcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmV0cnlXaGVuT3BlcmF0b3Iobm90aWZpZXIsIHNvdXJjZSkge1xuICAgICAgICB0aGlzLm5vdGlmaWVyID0gbm90aWZpZXI7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICBSZXRyeVdoZW5PcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFJldHJ5V2hlblN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5ub3RpZmllciwgdGhpcy5zb3VyY2UpKTtcbiAgICB9O1xuICAgIHJldHVybiBSZXRyeVdoZW5PcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFJldHJ5V2hlblN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZXRyeVdoZW5TdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJldHJ5V2hlblN1YnNjcmliZXIoZGVzdGluYXRpb24sIG5vdGlmaWVyLCBzb3VyY2UpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLm5vdGlmaWVyID0gbm90aWZpZXI7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICBSZXRyeVdoZW5TdWJzY3JpYmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdmFyIGVycm9ycyA9IHRoaXMuZXJyb3JzO1xuICAgICAgICAgICAgdmFyIHJldHJpZXMgPSB0aGlzLnJldHJpZXM7XG4gICAgICAgICAgICB2YXIgcmV0cmllc1N1YnNjcmlwdGlvbiA9IHRoaXMucmV0cmllc1N1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgIGlmICghcmV0cmllcykge1xuICAgICAgICAgICAgICAgIGVycm9ycyA9IG5ldyBTdWJqZWN0XzEuU3ViamVjdCgpO1xuICAgICAgICAgICAgICAgIHJldHJpZXMgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKHRoaXMubm90aWZpZXIpKGVycm9ycyk7XG4gICAgICAgICAgICAgICAgaWYgKHJldHJpZXMgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuZXJyb3IuY2FsbCh0aGlzLCBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXRyaWVzU3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCByZXRyaWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnJldHJpZXNTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmVBbmRSZWN5Y2xlKCk7XG4gICAgICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgICAgIHRoaXMucmV0cmllcyA9IHJldHJpZXM7XG4gICAgICAgICAgICB0aGlzLnJldHJpZXNTdWJzY3JpcHRpb24gPSByZXRyaWVzU3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgZXJyb3JzLm5leHQoZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmV0cnlXaGVuU3Vic2NyaWJlci5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBlcnJvcnMgPSBfYS5lcnJvcnMsIHJldHJpZXNTdWJzY3JpcHRpb24gPSBfYS5yZXRyaWVzU3Vic2NyaXB0aW9uO1xuICAgICAgICBpZiAoZXJyb3JzKSB7XG4gICAgICAgICAgICBlcnJvcnMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmV0cmllc1N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgcmV0cmllc1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5yZXRyaWVzU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJldHJpZXMgPSBudWxsO1xuICAgIH07XG4gICAgUmV0cnlXaGVuU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBlcnJvcnMgPSBfYS5lcnJvcnMsIHJldHJpZXMgPSBfYS5yZXRyaWVzLCByZXRyaWVzU3Vic2NyaXB0aW9uID0gX2EucmV0cmllc1N1YnNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBudWxsO1xuICAgICAgICB0aGlzLnJldHJpZXMgPSBudWxsO1xuICAgICAgICB0aGlzLnJldHJpZXNTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLl91bnN1YnNjcmliZUFuZFJlY3ljbGUoKTtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIHRoaXMucmV0cmllcyA9IHJldHJpZXM7XG4gICAgICAgIHRoaXMucmV0cmllc1N1YnNjcmlwdGlvbiA9IHJldHJpZXNTdWJzY3JpcHRpb247XG4gICAgICAgIHRoaXMuc291cmNlLnN1YnNjcmliZSh0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBSZXRyeVdoZW5TdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJldHJ5V2hlbi5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvci9yZXRyeVdoZW4uanNcbi8vIG1vZHVsZSBpZCA9IDMwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qKlxuICogRW1pdHMgdGhlIG1vc3QgcmVjZW50bHkgZW1pdHRlZCB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB3aGVuZXZlclxuICogYW5vdGhlciBPYnNlcnZhYmxlLCB0aGUgYG5vdGlmaWVyYCwgZW1pdHMuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgc2FtcGxlVGltZX0sIGJ1dCBzYW1wbGVzIHdoZW5ldmVyXG4gKiB0aGUgYG5vdGlmaWVyYCBPYnNlcnZhYmxlIGVtaXRzIHNvbWV0aGluZy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9zYW1wbGUucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogV2hlbmV2ZXIgdGhlIGBub3RpZmllcmAgT2JzZXJ2YWJsZSBlbWl0cyBhIHZhbHVlIG9yIGNvbXBsZXRlcywgYHNhbXBsZWBcbiAqIGxvb2tzIGF0IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBhbmQgZW1pdHMgd2hpY2hldmVyIHZhbHVlIGl0IGhhcyBtb3N0IHJlY2VudGx5XG4gKiBlbWl0dGVkIHNpbmNlIHRoZSBwcmV2aW91cyBzYW1wbGluZywgdW5sZXNzIHRoZSBzb3VyY2UgaGFzIG5vdCBlbWl0dGVkXG4gKiBhbnl0aGluZyBzaW5jZSB0aGUgcHJldmlvdXMgc2FtcGxpbmcuIFRoZSBgbm90aWZpZXJgIGlzIHN1YnNjcmliZWQgdG8gYXMgc29vblxuICogYXMgdGhlIG91dHB1dCBPYnNlcnZhYmxlIGlzIHN1YnNjcmliZWQuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+T24gZXZlcnkgY2xpY2ssIHNhbXBsZSB0aGUgbW9zdCByZWNlbnQgXCJzZWNvbmRzXCIgdGltZXI8L2NhcHRpb24+XG4gKiB2YXIgc2Vjb25kcyA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IHNlY29uZHMuc2FtcGxlKGNsaWNrcyk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGF1ZGl0fVxuICogQHNlZSB7QGxpbmsgZGVib3VuY2V9XG4gKiBAc2VlIHtAbGluayBzYW1wbGVUaW1lfVxuICogQHNlZSB7QGxpbmsgdGhyb3R0bGV9XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlPGFueT59IG5vdGlmaWVyIFRoZSBPYnNlcnZhYmxlIHRvIHVzZSBmb3Igc2FtcGxpbmcgdGhlXG4gKiBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgcmVzdWx0cyBvZiBzYW1wbGluZyB0aGVcbiAqIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB3aGVuZXZlciB0aGUgbm90aWZpZXIgT2JzZXJ2YWJsZVxuICogZW1pdHMgdmFsdWUgb3IgY29tcGxldGVzLlxuICogQG1ldGhvZCBzYW1wbGVcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHNhbXBsZShub3RpZmllcikge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFNhbXBsZU9wZXJhdG9yKG5vdGlmaWVyKSk7XG59XG5leHBvcnRzLnNhbXBsZSA9IHNhbXBsZTtcbnZhciBTYW1wbGVPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2FtcGxlT3BlcmF0b3Iobm90aWZpZXIpIHtcbiAgICAgICAgdGhpcy5ub3RpZmllciA9IG5vdGlmaWVyO1xuICAgIH1cbiAgICBTYW1wbGVPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgdmFyIHNhbXBsZVN1YnNjcmliZXIgPSBuZXcgU2FtcGxlU3Vic2NyaWJlcihzdWJzY3JpYmVyKTtcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHNvdXJjZS5zdWJzY3JpYmUoc2FtcGxlU3Vic2NyaWJlcik7XG4gICAgICAgIHN1YnNjcmlwdGlvbi5hZGQoc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdChzYW1wbGVTdWJzY3JpYmVyLCB0aGlzLm5vdGlmaWVyKSk7XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgfTtcbiAgICByZXR1cm4gU2FtcGxlT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBTYW1wbGVTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2FtcGxlU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTYW1wbGVTdWJzY3JpYmVyKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBTYW1wbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzVmFsdWUgPSB0cnVlO1xuICAgIH07XG4gICAgU2FtcGxlU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLmVtaXRWYWx1ZSgpO1xuICAgIH07XG4gICAgU2FtcGxlU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZW1pdFZhbHVlKCk7XG4gICAgfTtcbiAgICBTYW1wbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5lbWl0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc1ZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmhhc1ZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodGhpcy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTYW1wbGVTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNhbXBsZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvci9zYW1wbGUuanNcbi8vIG1vZHVsZSBpZCA9IDMwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBhc3luY18xID0gcmVxdWlyZSgnLi4vc2NoZWR1bGVyL2FzeW5jJyk7XG4vKipcbiAqIEVtaXRzIHRoZSBtb3N0IHJlY2VudGx5IGVtaXR0ZWQgdmFsdWUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgd2l0aGluXG4gKiBwZXJpb2RpYyB0aW1lIGludGVydmFscy5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+U2FtcGxlcyB0aGUgc291cmNlIE9ic2VydmFibGUgYXQgcGVyaW9kaWMgdGltZVxuICogaW50ZXJ2YWxzLCBlbWl0dGluZyB3aGF0IGl0IHNhbXBsZXMuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvc2FtcGxlVGltZS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgc2FtcGxlVGltZWAgcGVyaW9kaWNhbGx5IGxvb2tzIGF0IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBhbmQgZW1pdHMgd2hpY2hldmVyXG4gKiB2YWx1ZSBpdCBoYXMgbW9zdCByZWNlbnRseSBlbWl0dGVkIHNpbmNlIHRoZSBwcmV2aW91cyBzYW1wbGluZywgdW5sZXNzIHRoZVxuICogc291cmNlIGhhcyBub3QgZW1pdHRlZCBhbnl0aGluZyBzaW5jZSB0aGUgcHJldmlvdXMgc2FtcGxpbmcuIFRoZSBzYW1wbGluZ1xuICogaGFwcGVucyBwZXJpb2RpY2FsbHkgaW4gdGltZSBldmVyeSBgcGVyaW9kYCBtaWxsaXNlY29uZHMgKG9yIHRoZSB0aW1lIHVuaXRcbiAqIGRlZmluZWQgYnkgdGhlIG9wdGlvbmFsIGBzY2hlZHVsZXJgIGFyZ3VtZW50KS4gVGhlIHNhbXBsaW5nIHN0YXJ0cyBhcyBzb29uIGFzXG4gKiB0aGUgb3V0cHV0IE9ic2VydmFibGUgaXMgc3Vic2NyaWJlZC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FdmVyeSBzZWNvbmQsIGVtaXQgdGhlIG1vc3QgcmVjZW50IGNsaWNrIGF0IG1vc3Qgb25jZTwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLnNhbXBsZVRpbWUoMTAwMCk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGF1ZGl0VGltZX1cbiAqIEBzZWUge0BsaW5rIGRlYm91bmNlVGltZX1cbiAqIEBzZWUge0BsaW5rIGRlbGF5fVxuICogQHNlZSB7QGxpbmsgc2FtcGxlfVxuICogQHNlZSB7QGxpbmsgdGhyb3R0bGVUaW1lfVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBwZXJpb2QgVGhlIHNhbXBsaW5nIHBlcmlvZCBleHByZXNzZWQgaW4gbWlsbGlzZWNvbmRzIG9yIHRoZVxuICogdGltZSB1bml0IGRldGVybWluZWQgaW50ZXJuYWxseSBieSB0aGUgb3B0aW9uYWwgYHNjaGVkdWxlcmAuXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcj1hc3luY10gVGhlIHtAbGluayBJU2NoZWR1bGVyfSB0byB1c2UgZm9yXG4gKiBtYW5hZ2luZyB0aGUgdGltZXJzIHRoYXQgaGFuZGxlIHRoZSBzYW1wbGluZy5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgcmVzdWx0cyBvZiBzYW1wbGluZyB0aGVcbiAqIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBhdCB0aGUgc3BlY2lmaWVkIHRpbWUgaW50ZXJ2YWwuXG4gKiBAbWV0aG9kIHNhbXBsZVRpbWVcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHNhbXBsZVRpbWUocGVyaW9kLCBzY2hlZHVsZXIpIHtcbiAgICBpZiAoc2NoZWR1bGVyID09PSB2b2lkIDApIHsgc2NoZWR1bGVyID0gYXN5bmNfMS5hc3luYzsgfVxuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFNhbXBsZVRpbWVPcGVyYXRvcihwZXJpb2QsIHNjaGVkdWxlcikpO1xufVxuZXhwb3J0cy5zYW1wbGVUaW1lID0gc2FtcGxlVGltZTtcbnZhciBTYW1wbGVUaW1lT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNhbXBsZVRpbWVPcGVyYXRvcihwZXJpb2QsIHNjaGVkdWxlcikge1xuICAgICAgICB0aGlzLnBlcmlvZCA9IHBlcmlvZDtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgfVxuICAgIFNhbXBsZVRpbWVPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFNhbXBsZVRpbWVTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMucGVyaW9kLCB0aGlzLnNjaGVkdWxlcikpO1xuICAgIH07XG4gICAgcmV0dXJuIFNhbXBsZVRpbWVPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFNhbXBsZVRpbWVTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2FtcGxlVGltZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2FtcGxlVGltZVN1YnNjcmliZXIoZGVzdGluYXRpb24sIHBlcmlvZCwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wZXJpb2QgPSBwZXJpb2Q7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLmhhc1ZhbHVlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWRkKHNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaE5vdGlmaWNhdGlvbiwgcGVyaW9kLCB7IHN1YnNjcmliZXI6IHRoaXMsIHBlcmlvZDogcGVyaW9kIH0pKTtcbiAgICB9XG4gICAgU2FtcGxlVGltZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubGFzdFZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzVmFsdWUgPSB0cnVlO1xuICAgIH07XG4gICAgU2FtcGxlVGltZVN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc1ZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmhhc1ZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodGhpcy5sYXN0VmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU2FtcGxlVGltZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5mdW5jdGlvbiBkaXNwYXRjaE5vdGlmaWNhdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdWJzY3JpYmVyID0gc3RhdGUuc3Vic2NyaWJlciwgcGVyaW9kID0gc3RhdGUucGVyaW9kO1xuICAgIHN1YnNjcmliZXIubm90aWZ5TmV4dCgpO1xuICAgIHRoaXMuc2NoZWR1bGUoc3RhdGUsIHBlcmlvZCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zYW1wbGVUaW1lLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9yL3NhbXBsZVRpbWUuanNcbi8vIG1vZHVsZSBpZCA9IDMwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIEFwcGxpZXMgYW4gYWNjdW11bGF0b3IgZnVuY3Rpb24gb3ZlciB0aGUgc291cmNlIE9ic2VydmFibGUsIGFuZCByZXR1cm5zIGVhY2hcbiAqIGludGVybWVkaWF0ZSByZXN1bHQsIHdpdGggYW4gb3B0aW9uYWwgc2VlZCB2YWx1ZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SXQncyBsaWtlIHtAbGluayByZWR1Y2V9LCBidXQgZW1pdHMgdGhlIGN1cnJlbnRcbiAqIGFjY3VtdWxhdGlvbiB3aGVuZXZlciB0aGUgc291cmNlIGVtaXRzIGEgdmFsdWUuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvc2Nhbi5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBDb21iaW5lcyB0b2dldGhlciBhbGwgdmFsdWVzIGVtaXR0ZWQgb24gdGhlIHNvdXJjZSwgdXNpbmcgYW4gYWNjdW11bGF0b3JcbiAqIGZ1bmN0aW9uIHRoYXQga25vd3MgaG93IHRvIGpvaW4gYSBuZXcgc291cmNlIHZhbHVlIGludG8gdGhlIGFjY3VtdWxhdGlvbiBmcm9tXG4gKiB0aGUgcGFzdC4gSXMgc2ltaWxhciB0byB7QGxpbmsgcmVkdWNlfSwgYnV0IGVtaXRzIHRoZSBpbnRlcm1lZGlhdGVcbiAqIGFjY3VtdWxhdGlvbnMuXG4gKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgYXBwbGllcyBhIHNwZWNpZmllZCBgYWNjdW11bGF0b3JgIGZ1bmN0aW9uIHRvIGVhY2hcbiAqIGl0ZW0gZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuIElmIGEgYHNlZWRgIHZhbHVlIGlzIHNwZWNpZmllZCwgdGhlblxuICogdGhhdCB2YWx1ZSB3aWxsIGJlIHVzZWQgYXMgdGhlIGluaXRpYWwgdmFsdWUgZm9yIHRoZSBhY2N1bXVsYXRvci4gSWYgbm8gc2VlZFxuICogdmFsdWUgaXMgc3BlY2lmaWVkLCB0aGUgZmlyc3QgaXRlbSBvZiB0aGUgc291cmNlIGlzIHVzZWQgYXMgdGhlIHNlZWQuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q291bnQgdGhlIG51bWJlciBvZiBjbGljayBldmVudHM8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIG9uZXMgPSBjbGlja3MubWFwVG8oMSk7XG4gKiB2YXIgc2VlZCA9IDA7XG4gKiB2YXIgY291bnQgPSBvbmVzLnNjYW4oKGFjYywgb25lKSA9PiBhY2MgKyBvbmUsIHNlZWQpO1xuICogY291bnQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGV4cGFuZH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlU2Nhbn1cbiAqIEBzZWUge0BsaW5rIHJlZHVjZX1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGFjYzogUiwgdmFsdWU6IFQsIGluZGV4OiBudW1iZXIpOiBSfSBhY2N1bXVsYXRvclxuICogVGhlIGFjY3VtdWxhdG9yIGZ1bmN0aW9uIGNhbGxlZCBvbiBlYWNoIHNvdXJjZSB2YWx1ZS5cbiAqIEBwYXJhbSB7VHxSfSBbc2VlZF0gVGhlIGluaXRpYWwgYWNjdW11bGF0aW9uIHZhbHVlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxSPn0gQW4gb2JzZXJ2YWJsZSBvZiB0aGUgYWNjdW11bGF0ZWQgdmFsdWVzLlxuICogQG1ldGhvZCBzY2FuXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBzY2FuKGFjY3VtdWxhdG9yLCBzZWVkKSB7XG4gICAgdmFyIGhhc1NlZWQgPSBmYWxzZTtcbiAgICAvLyBwcm92aWRpbmcgYSBzZWVkIG9mIGB1bmRlZmluZWRgICpzaG91bGQqIGJlIHZhbGlkIGFuZCB0cmlnZ2VyXG4gICAgLy8gaGFzU2VlZCEgc28gZG9uJ3QgdXNlIGBzZWVkICE9PSB1bmRlZmluZWRgIGNoZWNrcyFcbiAgICAvLyBGb3IgdGhpcyByZWFzb24sIHdlIGhhdmUgdG8gY2hlY2sgaXQgaGVyZSBhdCB0aGUgb3JpZ2luYWwgY2FsbCBzaXRlXG4gICAgLy8gb3RoZXJ3aXNlIGluc2lkZSBPcGVyYXRvci9TdWJzY3JpYmVyIHdlIHdvbid0IGtub3cgaWYgYHVuZGVmaW5lZGBcbiAgICAvLyBtZWFucyB0aGV5IGRpZG4ndCBwcm92aWRlIGFueXRoaW5nIG9yIGlmIHRoZXkgbGl0ZXJhbGx5IHByb3ZpZGVkIGB1bmRlZmluZWRgXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgICBoYXNTZWVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgU2Nhbk9wZXJhdG9yKGFjY3VtdWxhdG9yLCBzZWVkLCBoYXNTZWVkKSk7XG59XG5leHBvcnRzLnNjYW4gPSBzY2FuO1xudmFyIFNjYW5PcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2Nhbk9wZXJhdG9yKGFjY3VtdWxhdG9yLCBzZWVkLCBoYXNTZWVkKSB7XG4gICAgICAgIGlmIChoYXNTZWVkID09PSB2b2lkIDApIHsgaGFzU2VlZCA9IGZhbHNlOyB9XG4gICAgICAgIHRoaXMuYWNjdW11bGF0b3IgPSBhY2N1bXVsYXRvcjtcbiAgICAgICAgdGhpcy5zZWVkID0gc2VlZDtcbiAgICAgICAgdGhpcy5oYXNTZWVkID0gaGFzU2VlZDtcbiAgICB9XG4gICAgU2Nhbk9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgU2NhblN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5hY2N1bXVsYXRvciwgdGhpcy5zZWVkLCB0aGlzLmhhc1NlZWQpKTtcbiAgICB9O1xuICAgIHJldHVybiBTY2FuT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBTY2FuU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNjYW5TdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNjYW5TdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBhY2N1bXVsYXRvciwgX3NlZWQsIGhhc1NlZWQpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmFjY3VtdWxhdG9yID0gYWNjdW11bGF0b3I7XG4gICAgICAgIHRoaXMuX3NlZWQgPSBfc2VlZDtcbiAgICAgICAgdGhpcy5oYXNTZWVkID0gaGFzU2VlZDtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2FuU3Vic2NyaWJlci5wcm90b3R5cGUsIFwic2VlZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmhhc1NlZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fc2VlZCA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBTY2FuU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1NlZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2VlZCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90cnlOZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2NhblN1YnNjcmliZXIucHJvdG90eXBlLl90cnlOZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXgrKztcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuYWNjdW11bGF0b3IodGhpcy5zZWVkLCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlZWQgPSByZXN1bHQ7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChyZXN1bHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFNjYW5TdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2Nhbi5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvci9zY2FuLmpzXG4vLyBtb2R1bGUgaWQgPSAzMDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgdHJ5Q2F0Y2hfMSA9IHJlcXVpcmUoJy4uL3V0aWwvdHJ5Q2F0Y2gnKTtcbnZhciBlcnJvck9iamVjdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9lcnJvck9iamVjdCcpO1xuLyoqXG4gKiBDb21wYXJlcyBhbGwgdmFsdWVzIG9mIHR3byBvYnNlcnZhYmxlcyBpbiBzZXF1ZW5jZSB1c2luZyBhbiBvcHRpb25hbCBjb21wYXJvciBmdW5jdGlvblxuICogYW5kIHJldHVybnMgYW4gb2JzZXJ2YWJsZSBvZiBhIHNpbmdsZSBib29sZWFuIHZhbHVlIHJlcHJlc2VudGluZyB3aGV0aGVyIG9yIG5vdCB0aGUgdHdvIHNlcXVlbmNlc1xuICogYXJlIGVxdWFsLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5DaGVja3MgdG8gc2VlIG9mIGFsbCB2YWx1ZXMgZW1pdHRlZCBieSBib3RoIG9ic2VydmFibGVzIGFyZSBlcXVhbCwgaW4gb3JkZXIuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvc2VxdWVuY2VFcXVhbC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgc2VxdWVuY2VFcXVhbGAgc3Vic2NyaWJlcyB0byB0d28gb2JzZXJ2YWJsZXMgYW5kIGJ1ZmZlcnMgaW5jb21pbmcgdmFsdWVzIGZyb20gZWFjaCBvYnNlcnZhYmxlLiBXaGVuZXZlciBlaXRoZXJcbiAqIG9ic2VydmFibGUgZW1pdHMgYSB2YWx1ZSwgdGhlIHZhbHVlIGlzIGJ1ZmZlcmVkIGFuZCB0aGUgYnVmZmVycyBhcmUgc2hpZnRlZCBhbmQgY29tcGFyZWQgZnJvbSB0aGUgYm90dG9tXG4gKiB1cDsgSWYgYW55IHZhbHVlIHBhaXIgZG9lc24ndCBtYXRjaCwgdGhlIHJldHVybmVkIG9ic2VydmFibGUgd2lsbCBlbWl0IGBmYWxzZWAgYW5kIGNvbXBsZXRlLiBJZiBvbmUgb2YgdGhlXG4gKiBvYnNlcnZhYmxlcyBjb21wbGV0ZXMsIHRoZSBvcGVyYXRvciB3aWxsIHdhaXQgZm9yIHRoZSBvdGhlciBvYnNlcnZhYmxlIHRvIGNvbXBsZXRlOyBJZiB0aGUgb3RoZXJcbiAqIG9ic2VydmFibGUgZW1pdHMgYmVmb3JlIGNvbXBsZXRpbmcsIHRoZSByZXR1cm5lZCBvYnNlcnZhYmxlIHdpbGwgZW1pdCBgZmFsc2VgIGFuZCBjb21wbGV0ZS4gSWYgb25lIG9ic2VydmFibGUgbmV2ZXJcbiAqIGNvbXBsZXRlcyBvciBlbWl0cyBhZnRlciB0aGUgb3RoZXIgY29tcGxldHMsIHRoZSByZXR1cm5lZCBvYnNlcnZhYmxlIHdpbGwgbmV2ZXIgY29tcGxldGUuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+ZmlndXJlIG91dCBpZiB0aGUgS29uYW1pIGNvZGUgbWF0Y2hlczwvY2FwdGlvbj5cbiAqIHZhciBjb2RlID0gUnguT2JzZXJ2YWJsZS5mcm9tKFtcbiAqICBcIkFycm93VXBcIixcbiAqICBcIkFycm93VXBcIixcbiAqICBcIkFycm93RG93blwiLFxuICogIFwiQXJyb3dEb3duXCIsXG4gKiAgXCJBcnJvd0xlZnRcIixcbiAqICBcIkFycm93UmlnaHRcIixcbiAqICBcIkFycm93TGVmdFwiLFxuICogIFwiQXJyb3dSaWdodFwiLFxuICogIFwiS2V5QlwiLFxuICogIFwiS2V5QVwiLFxuICogIFwiRW50ZXJcIiAvLyBubyBzdGFydCBrZXksIGNsZWFybHkuXG4gKiBdKTtcbiAqXG4gKiB2YXIga2V5cyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAna2V5dXAnKVxuICogIC5tYXAoZSA9PiBlLmNvZGUpO1xuICogdmFyIG1hdGNoZXMgPSBrZXlzLmJ1ZmZlckNvdW50KDExLCAxKVxuICogIC5tZXJnZU1hcChcbiAqICAgIGxhc3QxMSA9PlxuICogICAgICBSeC5PYnNlcnZhYmxlLmZyb20obGFzdDExKVxuICogICAgICAgIC5zZXF1ZW5jZUVxdWFsKGNvZGUpXG4gKiAgICk7XG4gKiBtYXRjaGVzLnN1YnNjcmliZShtYXRjaGVkID0+IGNvbnNvbGUubG9nKCdTdWNjZXNzZnVsIGNoZWF0IGF0IENvbnRyYT8gJywgbWF0Y2hlZCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGNvbWJpbmVMYXRlc3R9XG4gKiBAc2VlIHtAbGluayB6aXB9XG4gKiBAc2VlIHtAbGluayB3aXRoTGF0ZXN0RnJvbX1cbiAqXG4gKiBAcGFyYW0ge09ic2VydmFibGV9IGNvbXBhcmVUbyBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0byBjb21wYXJlIHRoZSBzb3VyY2Ugc2VxdWVuY2UgdG8uXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY29tcGFyb3JdIEFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIGNvbXBhcmUgZWFjaCB2YWx1ZSBwYWlyXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIG9mIGEgc2luZ2xlIGJvb2xlYW4gdmFsdWUgcmVwcmVzZW50aW5nIHdoZXRoZXIgb3Igbm90XG4gKiB0aGUgdmFsdWVzIGVtaXR0ZWQgYnkgYm90aCBvYnNlcnZhYmxlcyB3ZXJlIGVxdWFsIGluIHNlcXVlbmNlLlxuICogQG1ldGhvZCBzZXF1ZW5jZUVxdWFsXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBzZXF1ZW5jZUVxdWFsKGNvbXBhcmVUbywgY29tcGFyb3IpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBTZXF1ZW5jZUVxdWFsT3BlcmF0b3IoY29tcGFyZVRvLCBjb21wYXJvcikpO1xufVxuZXhwb3J0cy5zZXF1ZW5jZUVxdWFsID0gc2VxdWVuY2VFcXVhbDtcbnZhciBTZXF1ZW5jZUVxdWFsT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlcXVlbmNlRXF1YWxPcGVyYXRvcihjb21wYXJlVG8sIGNvbXBhcm9yKSB7XG4gICAgICAgIHRoaXMuY29tcGFyZVRvID0gY29tcGFyZVRvO1xuICAgICAgICB0aGlzLmNvbXBhcm9yID0gY29tcGFyb3I7XG4gICAgfVxuICAgIFNlcXVlbmNlRXF1YWxPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFNlcXVlbmNlRXF1YWxTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuY29tcGFyZVRvLCB0aGlzLmNvbXBhcm9yKSk7XG4gICAgfTtcbiAgICByZXR1cm4gU2VxdWVuY2VFcXVhbE9wZXJhdG9yO1xufSgpKTtcbmV4cG9ydHMuU2VxdWVuY2VFcXVhbE9wZXJhdG9yID0gU2VxdWVuY2VFcXVhbE9wZXJhdG9yO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBTZXF1ZW5jZUVxdWFsU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNlcXVlbmNlRXF1YWxTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNlcXVlbmNlRXF1YWxTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBjb21wYXJlVG8sIGNvbXBhcm9yKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5jb21wYXJlVG8gPSBjb21wYXJlVG87XG4gICAgICAgIHRoaXMuY29tcGFyb3IgPSBjb21wYXJvcjtcbiAgICAgICAgdGhpcy5fYSA9IFtdO1xuICAgICAgICB0aGlzLl9iID0gW107XG4gICAgICAgIHRoaXMuX29uZUNvbXBsZXRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWRkKGNvbXBhcmVUby5zdWJzY3JpYmUobmV3IFNlcXVlbmNlRXF1YWxDb21wYXJlVG9TdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCB0aGlzKSkpO1xuICAgIH1cbiAgICBTZXF1ZW5jZUVxdWFsU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX29uZUNvbXBsZXRlICYmIHRoaXMuX2IubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fYS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tWYWx1ZXMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2VxdWVuY2VFcXVhbFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX29uZUNvbXBsZXRlKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQodGhpcy5fYS5sZW5ndGggPT09IDAgJiYgdGhpcy5fYi5sZW5ndGggPT09IDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fb25lQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTZXF1ZW5jZUVxdWFsU3Vic2NyaWJlci5wcm90b3R5cGUuY2hlY2tWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYyA9IHRoaXMsIF9hID0gX2MuX2EsIF9iID0gX2MuX2IsIGNvbXBhcm9yID0gX2MuY29tcGFyb3I7XG4gICAgICAgIHdoaWxlIChfYS5sZW5ndGggPiAwICYmIF9iLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBhID0gX2Euc2hpZnQoKTtcbiAgICAgICAgICAgIHZhciBiID0gX2Iuc2hpZnQoKTtcbiAgICAgICAgICAgIHZhciBhcmVFcXVhbCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGNvbXBhcm9yKSB7XG4gICAgICAgICAgICAgICAgYXJlRXF1YWwgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKGNvbXBhcm9yKShhLCBiKTtcbiAgICAgICAgICAgICAgICBpZiAoYXJlRXF1YWwgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFyZUVxdWFsID0gYSA9PT0gYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYXJlRXF1YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTZXF1ZW5jZUVxdWFsU3Vic2NyaWJlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9O1xuICAgIFNlcXVlbmNlRXF1YWxTdWJzY3JpYmVyLnByb3RvdHlwZS5uZXh0QiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fb25lQ29tcGxldGUgJiYgdGhpcy5fYS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9iLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5jaGVja1ZhbHVlcygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU2VxdWVuY2VFcXVhbFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5leHBvcnRzLlNlcXVlbmNlRXF1YWxTdWJzY3JpYmVyID0gU2VxdWVuY2VFcXVhbFN1YnNjcmliZXI7XG52YXIgU2VxdWVuY2VFcXVhbENvbXBhcmVUb1N1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTZXF1ZW5jZUVxdWFsQ29tcGFyZVRvU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTZXF1ZW5jZUVxdWFsQ29tcGFyZVRvU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcGFyZW50KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICAgIFNlcXVlbmNlRXF1YWxDb21wYXJlVG9TdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnBhcmVudC5uZXh0Qih2YWx1ZSk7XG4gICAgfTtcbiAgICBTZXF1ZW5jZUVxdWFsQ29tcGFyZVRvU3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLnBhcmVudC5lcnJvcihlcnIpO1xuICAgIH07XG4gICAgU2VxdWVuY2VFcXVhbENvbXBhcmVUb1N1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQuX2NvbXBsZXRlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gU2VxdWVuY2VFcXVhbENvbXBhcmVUb1N1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXF1ZW5jZUVxdWFsLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9yL3NlcXVlbmNlRXF1YWwuanNcbi8vIG1vZHVsZSBpZCA9IDMwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBtdWx0aWNhc3RfMSA9IHJlcXVpcmUoJy4vbXVsdGljYXN0Jyk7XG52YXIgU3ViamVjdF8xID0gcmVxdWlyZSgnLi4vU3ViamVjdCcpO1xuZnVuY3Rpb24gc2hhcmVTdWJqZWN0RmFjdG9yeSgpIHtcbiAgICByZXR1cm4gbmV3IFN1YmplY3RfMS5TdWJqZWN0KCk7XG59XG4vKipcbiAqIFJldHVybnMgYSBuZXcgT2JzZXJ2YWJsZSB0aGF0IG11bHRpY2FzdHMgKHNoYXJlcykgdGhlIG9yaWdpbmFsIE9ic2VydmFibGUuIEFzIGxvbmcgYXMgdGhlcmUgaXMgYXQgbGVhc3Qgb25lXG4gKiBTdWJzY3JpYmVyIHRoaXMgT2JzZXJ2YWJsZSB3aWxsIGJlIHN1YnNjcmliZWQgYW5kIGVtaXR0aW5nIGRhdGEuIFdoZW4gYWxsIHN1YnNjcmliZXJzIGhhdmUgdW5zdWJzY3JpYmVkIGl0IHdpbGxcbiAqIHVuc3Vic2NyaWJlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiBCZWNhdXNlIHRoZSBPYnNlcnZhYmxlIGlzIG11bHRpY2FzdGluZyBpdCBtYWtlcyB0aGUgc3RyZWFtIGBob3RgLlxuICogVGhpcyBpcyBhbiBhbGlhcyBmb3IgLnB1Ymxpc2goKS5yZWZDb3VudCgpLlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvc2hhcmUucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn0gQW4gT2JzZXJ2YWJsZSB0aGF0IHVwb24gY29ubmVjdGlvbiBjYXVzZXMgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHRvIGVtaXQgaXRlbXMgdG8gaXRzIE9ic2VydmVycy5cbiAqIEBtZXRob2Qgc2hhcmVcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHNoYXJlKCkge1xuICAgIHJldHVybiBtdWx0aWNhc3RfMS5tdWx0aWNhc3QuY2FsbCh0aGlzLCBzaGFyZVN1YmplY3RGYWN0b3J5KS5yZWZDb3VudCgpO1xufVxuZXhwb3J0cy5zaGFyZSA9IHNoYXJlO1xuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhcmUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3Ivc2hhcmUuanNcbi8vIG1vZHVsZSBpZCA9IDMwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBFbXB0eUVycm9yXzEgPSByZXF1aXJlKCcuLi91dGlsL0VtcHR5RXJyb3InKTtcbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHNpbmdsZSBpdGVtIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHRoYXQgbWF0Y2hlcyBhIHNwZWNpZmllZFxuICogcHJlZGljYXRlLCBpZiB0aGF0IE9ic2VydmFibGUgZW1pdHMgb25lIHN1Y2ggaXRlbS4gSWYgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGVtaXRzIG1vcmUgdGhhbiBvbmUgc3VjaCBpdGVtIG9yIG5vXG4gKiBzdWNoIGl0ZW1zLCBub3RpZnkgb2YgYW4gSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uIG9yIE5vU3VjaEVsZW1lbnRFeGNlcHRpb24gcmVzcGVjdGl2ZWx5LlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvc2luZ2xlLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEB0aHJvd3Mge0VtcHR5RXJyb3J9IERlbGl2ZXJzIGFuIEVtcHR5RXJyb3IgdG8gdGhlIE9ic2VydmVyJ3MgYGVycm9yYFxuICogY2FsbGJhY2sgaWYgdGhlIE9ic2VydmFibGUgY29tcGxldGVzIGJlZm9yZSBhbnkgYG5leHRgIG5vdGlmaWNhdGlvbiB3YXMgc2VudC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSAtIEEgcHJlZGljYXRlIGZ1bmN0aW9uIHRvIGV2YWx1YXRlIGl0ZW1zIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSBzaW5nbGUgaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB0aGF0IG1hdGNoZXNcbiAqIHRoZSBwcmVkaWNhdGUuXG4gLlxuICogQG1ldGhvZCBzaW5nbGVcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHNpbmdsZShwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBTaW5nbGVPcGVyYXRvcihwcmVkaWNhdGUsIHRoaXMpKTtcbn1cbmV4cG9ydHMuc2luZ2xlID0gc2luZ2xlO1xudmFyIFNpbmdsZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTaW5nbGVPcGVyYXRvcihwcmVkaWNhdGUsIHNvdXJjZSkge1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIFNpbmdsZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgU2luZ2xlU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByZWRpY2F0ZSwgdGhpcy5zb3VyY2UpKTtcbiAgICB9O1xuICAgIHJldHVybiBTaW5nbGVPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFNpbmdsZVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTaW5nbGVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNpbmdsZVN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByZWRpY2F0ZSwgc291cmNlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLnNlZW5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB9XG4gICAgU2luZ2xlU3Vic2NyaWJlci5wcm90b3R5cGUuYXBwbHlTaW5nbGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5zZWVuVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoJ1NlcXVlbmNlIGNvbnRhaW5zIG1vcmUgdGhhbiBvbmUgZWxlbWVudCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZWVuVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zaW5nbGVWYWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTaW5nbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4Kys7XG4gICAgICAgIGlmICh0aGlzLnByZWRpY2F0ZSkge1xuICAgICAgICAgICAgdGhpcy50cnlOZXh0KHZhbHVlLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFwcGx5U2luZ2xlVmFsdWUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTaW5nbGVTdWJzY3JpYmVyLnByb3RvdHlwZS50cnlOZXh0ID0gZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJlZGljYXRlKHZhbHVlLCBpbmRleCwgdGhpcy5zb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseVNpbmdsZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNpbmdsZVN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPiAwKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHRoaXMuc2VlblZhbHVlID8gdGhpcy5zaW5nbGVWYWx1ZSA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVzdGluYXRpb24uZXJyb3IobmV3IEVtcHR5RXJyb3JfMS5FbXB0eUVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFNpbmdsZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaW5nbGUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3Ivc2luZ2xlLmpzXG4vLyBtb2R1bGUgaWQgPSAzMDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG4vKipcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IHNraXBzIHRoZSBmaXJzdCBgY291bnRgIGl0ZW1zIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvc2tpcC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgLSBUaGUgbnVtYmVyIG9mIHRpbWVzLCBpdGVtcyBlbWl0dGVkIGJ5IHNvdXJjZSBPYnNlcnZhYmxlIHNob3VsZCBiZSBza2lwcGVkLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IHNraXBzIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqXG4gKiBAbWV0aG9kIHNraXBcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHNraXAoY291bnQpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBTa2lwT3BlcmF0b3IoY291bnQpKTtcbn1cbmV4cG9ydHMuc2tpcCA9IHNraXA7XG52YXIgU2tpcE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTa2lwT3BlcmF0b3IodG90YWwpIHtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgIH1cbiAgICBTa2lwT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBTa2lwU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnRvdGFsKSk7XG4gICAgfTtcbiAgICByZXR1cm4gU2tpcE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgU2tpcFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTa2lwU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTa2lwU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgdG90YWwpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnRvdGFsID0gdG90YWw7XG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgIH1cbiAgICBTa2lwU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICBpZiAoKyt0aGlzLmNvdW50ID4gdGhpcy50b3RhbCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU2tpcFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1za2lwLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9yL3NraXAuanNcbi8vIG1vZHVsZSBpZCA9IDMwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgc2tpcHMgaXRlbXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgdW50aWwgYSBzZWNvbmQgT2JzZXJ2YWJsZSBlbWl0cyBhbiBpdGVtLlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvc2tpcFVudGlsLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEBwYXJhbSB7T2JzZXJ2YWJsZX0gbm90aWZpZXIgLSBUaGUgc2Vjb25kIE9ic2VydmFibGUgdGhhdCBoYXMgdG8gZW1pdCBhbiBpdGVtIGJlZm9yZSB0aGUgc291cmNlIE9ic2VydmFibGUncyBlbGVtZW50cyBiZWdpbiB0b1xuICogYmUgbWlycm9yZWQgYnkgdGhlIHJlc3VsdGluZyBPYnNlcnZhYmxlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn0gQW4gT2JzZXJ2YWJsZSB0aGF0IHNraXBzIGl0ZW1zIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHVudGlsIHRoZSBzZWNvbmQgT2JzZXJ2YWJsZSBlbWl0c1xuICogYW4gaXRlbSwgdGhlbiBlbWl0cyB0aGUgcmVtYWluaW5nIGl0ZW1zLlxuICogQG1ldGhvZCBza2lwVW50aWxcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHNraXBVbnRpbChub3RpZmllcikge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFNraXBVbnRpbE9wZXJhdG9yKG5vdGlmaWVyKSk7XG59XG5leHBvcnRzLnNraXBVbnRpbCA9IHNraXBVbnRpbDtcbnZhciBTa2lwVW50aWxPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2tpcFVudGlsT3BlcmF0b3Iobm90aWZpZXIpIHtcbiAgICAgICAgdGhpcy5ub3RpZmllciA9IG5vdGlmaWVyO1xuICAgIH1cbiAgICBTa2lwVW50aWxPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFNraXBVbnRpbFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5ub3RpZmllcikpO1xuICAgIH07XG4gICAgcmV0dXJuIFNraXBVbnRpbE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgU2tpcFVudGlsU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNraXBVbnRpbFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2tpcFVudGlsU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgbm90aWZpZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmhhc1ZhbHVlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNJbm5lclN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hZGQoc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBub3RpZmllcikpO1xuICAgIH1cbiAgICBTa2lwVW50aWxTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5oYXNWYWx1ZSkge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fbmV4dC5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2tpcFVudGlsU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0lubmVyU3RvcHBlZCkge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fY29tcGxldGUuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2tpcFVudGlsU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLmhhc1ZhbHVlID0gdHJ1ZTtcbiAgICB9O1xuICAgIFNraXBVbnRpbFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzSW5uZXJTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9jb21wbGV0ZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU2tpcFVudGlsU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1za2lwVW50aWwuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3Ivc2tpcFVudGlsLmpzXG4vLyBtb2R1bGUgaWQgPSAzMDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG4vKipcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IHNraXBzIGFsbCBpdGVtcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBhcyBsb25nIGFzIGEgc3BlY2lmaWVkIGNvbmRpdGlvbiBob2xkc1xuICogdHJ1ZSwgYnV0IGVtaXRzIGFsbCBmdXJ0aGVyIHNvdXJjZSBpdGVtcyBhcyBzb29uIGFzIHRoZSBjb25kaXRpb24gYmVjb21lcyBmYWxzZS5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3NraXBXaGlsZS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgLSBBIGZ1bmN0aW9uIHRvIHRlc3QgZWFjaCBpdGVtIGVtaXR0ZWQgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBBbiBPYnNlcnZhYmxlIHRoYXQgYmVnaW5zIGVtaXR0aW5nIGl0ZW1zIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHdoZW4gdGhlXG4gKiBzcGVjaWZpZWQgcHJlZGljYXRlIGJlY29tZXMgZmFsc2UuXG4gKiBAbWV0aG9kIHNraXBXaGlsZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gc2tpcFdoaWxlKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFNraXBXaGlsZU9wZXJhdG9yKHByZWRpY2F0ZSkpO1xufVxuZXhwb3J0cy5za2lwV2hpbGUgPSBza2lwV2hpbGU7XG52YXIgU2tpcFdoaWxlT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNraXBXaGlsZU9wZXJhdG9yKHByZWRpY2F0ZSkge1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICB9XG4gICAgU2tpcFdoaWxlT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBTa2lwV2hpbGVTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMucHJlZGljYXRlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gU2tpcFdoaWxlT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBTa2lwV2hpbGVTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2tpcFdoaWxlU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTa2lwV2hpbGVTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgdGhpcy5za2lwcGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH1cbiAgICBTa2lwV2hpbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICBpZiAodGhpcy5za2lwcGluZykge1xuICAgICAgICAgICAgdGhpcy50cnlDYWxsUHJlZGljYXRlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuc2tpcHBpbmcpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTa2lwV2hpbGVTdWJzY3JpYmVyLnByb3RvdHlwZS50cnlDYWxsUHJlZGljYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5wcmVkaWNhdGUodmFsdWUsIHRoaXMuaW5kZXgrKyk7XG4gICAgICAgICAgICB0aGlzLnNraXBwaW5nID0gQm9vbGVhbihyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFNraXBXaGlsZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1za2lwV2hpbGUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3Ivc2tpcFdoaWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAzMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQXJyYXlPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9vYnNlcnZhYmxlL0FycmF5T2JzZXJ2YWJsZScpO1xudmFyIFNjYWxhck9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL29ic2VydmFibGUvU2NhbGFyT2JzZXJ2YWJsZScpO1xudmFyIEVtcHR5T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vb2JzZXJ2YWJsZS9FbXB0eU9ic2VydmFibGUnKTtcbnZhciBjb25jYXRfMSA9IHJlcXVpcmUoJy4vY29uY2F0Jyk7XG52YXIgaXNTY2hlZHVsZXJfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNTY2hlZHVsZXInKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSBpdGVtcyB5b3Ugc3BlY2lmeSBhcyBhcmd1bWVudHMgYmVmb3JlIGl0IGJlZ2lucyB0byBlbWl0XG4gKiBpdGVtcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3N0YXJ0V2l0aC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBAcGFyYW0gey4uLlR9IHZhbHVlcyAtIEl0ZW1zIHlvdSB3YW50IHRoZSBtb2RpZmllZCBPYnNlcnZhYmxlIHRvIGVtaXQgZmlyc3QuXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gLSBBIHtAbGluayBJU2NoZWR1bGVyfSB0byB1c2UgZm9yIHNjaGVkdWxpbmdcbiAqIHRoZSBlbWlzc2lvbnMgb2YgdGhlIGBuZXh0YCBub3RpZmljYXRpb25zLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSBpdGVtcyBpbiB0aGUgc3BlY2lmaWVkIEl0ZXJhYmxlIGFuZCB0aGVuIGVtaXRzIHRoZSBpdGVtc1xuICogZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIHN0YXJ0V2l0aFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gc3RhcnRXaXRoKCkge1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFycmF5W19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgc2NoZWR1bGVyID0gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG4gICAgaWYgKGlzU2NoZWR1bGVyXzEuaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSkge1xuICAgICAgICBhcnJheS5wb3AoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNjaGVkdWxlciA9IG51bGw7XG4gICAgfVxuICAgIHZhciBsZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgaWYgKGxlbiA9PT0gMSkge1xuICAgICAgICByZXR1cm4gY29uY2F0XzEuY29uY2F0U3RhdGljKG5ldyBTY2FsYXJPYnNlcnZhYmxlXzEuU2NhbGFyT2JzZXJ2YWJsZShhcnJheVswXSwgc2NoZWR1bGVyKSwgdGhpcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgcmV0dXJuIGNvbmNhdF8xLmNvbmNhdFN0YXRpYyhuZXcgQXJyYXlPYnNlcnZhYmxlXzEuQXJyYXlPYnNlcnZhYmxlKGFycmF5LCBzY2hlZHVsZXIpLCB0aGlzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBjb25jYXRfMS5jb25jYXRTdGF0aWMobmV3IEVtcHR5T2JzZXJ2YWJsZV8xLkVtcHR5T2JzZXJ2YWJsZShzY2hlZHVsZXIpLCB0aGlzKTtcbiAgICB9XG59XG5leHBvcnRzLnN0YXJ0V2l0aCA9IHN0YXJ0V2l0aDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXJ0V2l0aC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvci9zdGFydFdpdGguanNcbi8vIG1vZHVsZSBpZCA9IDMxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBTdWJzY3JpYmVPbk9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL29ic2VydmFibGUvU3Vic2NyaWJlT25PYnNlcnZhYmxlJyk7XG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IHN1YnNjcmliZXMgT2JzZXJ2ZXJzIHRvIHRoaXMgT2JzZXJ2YWJsZSBvbiB0aGUgc3BlY2lmaWVkIElTY2hlZHVsZXIuXG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9zdWJzY3JpYmVPbi5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gc2NoZWR1bGVyIC0gVGhlIElTY2hlZHVsZXIgdG8gcGVyZm9ybSBzdWJzY3JpcHRpb24gYWN0aW9ucyBvbi5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IFRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBtb2RpZmllZCBzbyB0aGF0IGl0cyBzdWJzY3JpcHRpb25zIGhhcHBlbiBvbiB0aGUgc3BlY2lmaWVkIElTY2hlZHVsZXIuXG4gLlxuICogQG1ldGhvZCBzdWJzY3JpYmVPblxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gc3Vic2NyaWJlT24oc2NoZWR1bGVyLCBkZWxheSkge1xuICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFN1YnNjcmliZU9uT3BlcmF0b3Ioc2NoZWR1bGVyLCBkZWxheSkpO1xufVxuZXhwb3J0cy5zdWJzY3JpYmVPbiA9IHN1YnNjcmliZU9uO1xudmFyIFN1YnNjcmliZU9uT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN1YnNjcmliZU9uT3BlcmF0b3Ioc2NoZWR1bGVyLCBkZWxheSkge1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgdGhpcy5kZWxheSA9IGRlbGF5O1xuICAgIH1cbiAgICBTdWJzY3JpYmVPbk9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gbmV3IFN1YnNjcmliZU9uT2JzZXJ2YWJsZV8xLlN1YnNjcmliZU9uT2JzZXJ2YWJsZShzb3VyY2UsIHRoaXMuZGVsYXksIHRoaXMuc2NoZWR1bGVyKS5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgfTtcbiAgICByZXR1cm4gU3Vic2NyaWJlT25PcGVyYXRvcjtcbn0oKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJzY3JpYmVPbi5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvci9zdWJzY3JpYmVPbi5qc1xuLy8gbW9kdWxlIGlkID0gMzEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyoqXG4gKiBDb252ZXJ0cyBhIGhpZ2hlci1vcmRlciBPYnNlcnZhYmxlIGludG8gYSBmaXJzdC1vcmRlciBPYnNlcnZhYmxlIGJ5XG4gKiBzdWJzY3JpYmluZyB0byBvbmx5IHRoZSBtb3N0IHJlY2VudGx5IGVtaXR0ZWQgb2YgdGhvc2UgaW5uZXIgT2JzZXJ2YWJsZXMuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkZsYXR0ZW5zIGFuIE9ic2VydmFibGUtb2YtT2JzZXJ2YWJsZXMgYnkgZHJvcHBpbmcgdGhlXG4gKiBwcmV2aW91cyBpbm5lciBPYnNlcnZhYmxlIG9uY2UgYSBuZXcgb25lIGFwcGVhcnMuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvc3dpdGNoLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBzd2l0Y2hgIHN1YnNjcmliZXMgdG8gYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIE9ic2VydmFibGVzLCBhbHNvIGtub3duIGFzIGFcbiAqIGhpZ2hlci1vcmRlciBPYnNlcnZhYmxlLiBFYWNoIHRpbWUgaXQgb2JzZXJ2ZXMgb25lIG9mIHRoZXNlIGVtaXR0ZWQgaW5uZXJcbiAqIE9ic2VydmFibGVzLCB0aGUgb3V0cHV0IE9ic2VydmFibGUgc3Vic2NyaWJlcyB0byB0aGUgaW5uZXIgT2JzZXJ2YWJsZSBhbmRcbiAqIGJlZ2lucyBlbWl0dGluZyB0aGUgaXRlbXMgZW1pdHRlZCBieSB0aGF0LiBTbyBmYXIsIGl0IGJlaGF2ZXNcbiAqIGxpa2Uge0BsaW5rIG1lcmdlQWxsfS4gSG93ZXZlciwgd2hlbiBhIG5ldyBpbm5lciBPYnNlcnZhYmxlIGlzIGVtaXR0ZWQsXG4gKiBgc3dpdGNoYCB1bnN1YnNjcmliZXMgZnJvbSB0aGUgZWFybGllci1lbWl0dGVkIGlubmVyIE9ic2VydmFibGUgYW5kXG4gKiBzdWJzY3JpYmVzIHRvIHRoZSBuZXcgaW5uZXIgT2JzZXJ2YWJsZSBhbmQgYmVnaW5zIGVtaXR0aW5nIGl0ZW1zIGZyb20gaXQuIEl0XG4gKiBjb250aW51ZXMgdG8gYmVoYXZlIGxpa2UgdGhpcyBmb3Igc3Vic2VxdWVudCBpbm5lciBPYnNlcnZhYmxlcy5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5SZXJ1biBhbiBpbnRlcnZhbCBPYnNlcnZhYmxlIG9uIGV2ZXJ5IGNsaWNrIGV2ZW50PC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIC8vIEVhY2ggY2xpY2sgZXZlbnQgaXMgbWFwcGVkIHRvIGFuIE9ic2VydmFibGUgdGhhdCB0aWNrcyBldmVyeSBzZWNvbmRcbiAqIHZhciBoaWdoZXJPcmRlciA9IGNsaWNrcy5tYXAoKGV2KSA9PiBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApKTtcbiAqIHZhciBzd2l0Y2hlZCA9IGhpZ2hlck9yZGVyLnN3aXRjaCgpO1xuICogLy8gVGhlIG91dGNvbWUgaXMgdGhhdCBgc3dpdGNoZWRgIGlzIGVzc2VudGlhbGx5IGEgdGltZXIgdGhhdCByZXN0YXJ0c1xuICogLy8gb24gZXZlcnkgY2xpY2suIFRoZSBpbnRlcnZhbCBPYnNlcnZhYmxlcyBmcm9tIG9sZGVyIGNsaWNrcyBkbyBub3QgbWVyZ2VcbiAqIC8vIHdpdGggdGhlIGN1cnJlbnQgaW50ZXJ2YWwgT2JzZXJ2YWJsZS5cbiAqIHN3aXRjaGVkLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBjb21iaW5lQWxsfVxuICogQHNlZSB7QGxpbmsgY29uY2F0QWxsfVxuICogQHNlZSB7QGxpbmsgZXhoYXVzdH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlQWxsfVxuICogQHNlZSB7QGxpbmsgc3dpdGNoTWFwfVxuICogQHNlZSB7QGxpbmsgc3dpdGNoTWFwVG99XG4gKiBAc2VlIHtAbGluayB6aXBBbGx9XG4gKlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSBpdGVtcyBlbWl0dGVkIGJ5IHRoZVxuICogT2JzZXJ2YWJsZSBtb3N0IHJlY2VudGx5IGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCBzd2l0Y2hcbiAqIEBuYW1lIHN3aXRjaFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gX3N3aXRjaCgpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBTd2l0Y2hPcGVyYXRvcigpKTtcbn1cbmV4cG9ydHMuX3N3aXRjaCA9IF9zd2l0Y2g7XG52YXIgU3dpdGNoT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN3aXRjaE9wZXJhdG9yKCkge1xuICAgIH1cbiAgICBTd2l0Y2hPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFN3aXRjaFN1YnNjcmliZXIoc3Vic2NyaWJlcikpO1xuICAgIH07XG4gICAgcmV0dXJuIFN3aXRjaE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgU3dpdGNoU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN3aXRjaFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3dpdGNoU3Vic2NyaWJlcihkZXN0aW5hdGlvbikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gMDtcbiAgICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgU3dpdGNoU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZUlubmVyKCk7XG4gICAgICAgIHRoaXMuYWN0aXZlKys7XG4gICAgICAgIHRoaXMuYWRkKHRoaXMuaW5uZXJTdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIHZhbHVlKSk7XG4gICAgfTtcbiAgICBTd2l0Y2hTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN3aXRjaFN1YnNjcmliZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlSW5uZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gdGhpcy5hY3RpdmUgPiAwID8gdGhpcy5hY3RpdmUgLSAxIDogMDtcbiAgICAgICAgdmFyIGlubmVyU3Vic2NyaXB0aW9uID0gdGhpcy5pbm5lclN1YnNjcmlwdGlvbjtcbiAgICAgICAgaWYgKGlubmVyU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICBpbm5lclN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUoaW5uZXJTdWJzY3JpcHRpb24pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTd2l0Y2hTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChpbm5lclZhbHVlKTtcbiAgICB9O1xuICAgIFN3aXRjaFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgfTtcbiAgICBTd2l0Y2hTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZUlubmVyKCk7XG4gICAgICAgIGlmICh0aGlzLmhhc0NvbXBsZXRlZCAmJiB0aGlzLmFjdGl2ZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU3dpdGNoU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zd2l0Y2guanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3Ivc3dpdGNoLmpzXG4vLyBtb2R1bGUgaWQgPSAzMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBQcm9qZWN0cyBlYWNoIHNvdXJjZSB2YWx1ZSB0byBhbiBPYnNlcnZhYmxlIHdoaWNoIGlzIG1lcmdlZCBpbiB0aGUgb3V0cHV0XG4gKiBPYnNlcnZhYmxlLCBlbWl0dGluZyB2YWx1ZXMgb25seSBmcm9tIHRoZSBtb3N0IHJlY2VudGx5IHByb2plY3RlZCBPYnNlcnZhYmxlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5NYXBzIGVhY2ggdmFsdWUgdG8gYW4gT2JzZXJ2YWJsZSwgdGhlbiBmbGF0dGVucyBhbGwgb2ZcbiAqIHRoZXNlIGlubmVyIE9ic2VydmFibGVzIHVzaW5nIHtAbGluayBzd2l0Y2h9Ljwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3N3aXRjaE1hcC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBpdGVtcyBiYXNlZCBvbiBhcHBseWluZyBhIGZ1bmN0aW9uIHRoYXQgeW91XG4gKiBzdXBwbHkgdG8gZWFjaCBpdGVtIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCB3aGVyZSB0aGF0IGZ1bmN0aW9uXG4gKiByZXR1cm5zIGFuIChzby1jYWxsZWQgXCJpbm5lclwiKSBPYnNlcnZhYmxlLiBFYWNoIHRpbWUgaXQgb2JzZXJ2ZXMgb25lIG9mIHRoZXNlXG4gKiBpbm5lciBPYnNlcnZhYmxlcywgdGhlIG91dHB1dCBPYnNlcnZhYmxlIGJlZ2lucyBlbWl0dGluZyB0aGUgaXRlbXMgZW1pdHRlZCBieVxuICogdGhhdCBpbm5lciBPYnNlcnZhYmxlLiBXaGVuIGEgbmV3IGlubmVyIE9ic2VydmFibGUgaXMgZW1pdHRlZCwgYHN3aXRjaE1hcGBcbiAqIHN0b3BzIGVtaXR0aW5nIGl0ZW1zIGZyb20gdGhlIGVhcmxpZXItZW1pdHRlZCBpbm5lciBPYnNlcnZhYmxlIGFuZCBiZWdpbnNcbiAqIGVtaXR0aW5nIGl0ZW1zIGZyb20gdGhlIG5ldyBvbmUuIEl0IGNvbnRpbnVlcyB0byBiZWhhdmUgbGlrZSB0aGlzIGZvclxuICogc3Vic2VxdWVudCBpbm5lciBPYnNlcnZhYmxlcy5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5SZXJ1biBhbiBpbnRlcnZhbCBPYnNlcnZhYmxlIG9uIGV2ZXJ5IGNsaWNrIGV2ZW50PC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3Muc3dpdGNoTWFwKChldikgPT4gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKSk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGNvbmNhdE1hcH1cbiAqIEBzZWUge0BsaW5rIGV4aGF1c3RNYXB9XG4gKiBAc2VlIHtAbGluayBtZXJnZU1hcH1cbiAqIEBzZWUge0BsaW5rIHN3aXRjaH1cbiAqIEBzZWUge0BsaW5rIHN3aXRjaE1hcFRvfVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24odmFsdWU6IFQsID9pbmRleDogbnVtYmVyKTogT2JzZXJ2YWJsZUlucHV0fSBwcm9qZWN0IEEgZnVuY3Rpb25cbiAqIHRoYXQsIHdoZW4gYXBwbGllZCB0byBhbiBpdGVtIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCByZXR1cm5zIGFuXG4gKiBPYnNlcnZhYmxlLlxuICogQHBhcmFtIHtmdW5jdGlvbihvdXRlclZhbHVlOiBULCBpbm5lclZhbHVlOiBJLCBvdXRlckluZGV4OiBudW1iZXIsIGlubmVySW5kZXg6IG51bWJlcik6IGFueX0gW3Jlc3VsdFNlbGVjdG9yXVxuICogQSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB2YWx1ZSBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUgYmFzZWQgb24gdGhlIHZhbHVlc1xuICogYW5kIHRoZSBpbmRpY2VzIG9mIHRoZSBzb3VyY2UgKG91dGVyKSBlbWlzc2lvbiBhbmQgdGhlIGlubmVyIE9ic2VydmFibGVcbiAqIGVtaXNzaW9uLiBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uIGFyZTpcbiAqIC0gYG91dGVyVmFsdWVgOiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHNvdXJjZVxuICogLSBgaW5uZXJWYWx1ZWA6IHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgcHJvamVjdGVkIE9ic2VydmFibGVcbiAqIC0gYG91dGVySW5kZXhgOiB0aGUgXCJpbmRleFwiIG9mIHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgc291cmNlXG4gKiAtIGBpbm5lckluZGV4YDogdGhlIFwiaW5kZXhcIiBvZiB0aGUgdmFsdWUgZnJvbSB0aGUgcHJvamVjdGVkIE9ic2VydmFibGVcbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIHRoZVxuICogcHJvamVjdGlvbiBmdW5jdGlvbiAoYW5kIHRoZSBvcHRpb25hbCBgcmVzdWx0U2VsZWN0b3JgKSB0byBlYWNoIGl0ZW0gZW1pdHRlZFxuICogYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGFuZCB0YWtpbmcgb25seSB0aGUgdmFsdWVzIGZyb20gdGhlIG1vc3QgcmVjZW50bHlcbiAqIHByb2plY3RlZCBpbm5lciBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCBzd2l0Y2hNYXBcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHN3aXRjaE1hcChwcm9qZWN0LCByZXN1bHRTZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFN3aXRjaE1hcE9wZXJhdG9yKHByb2plY3QsIHJlc3VsdFNlbGVjdG9yKSk7XG59XG5leHBvcnRzLnN3aXRjaE1hcCA9IHN3aXRjaE1hcDtcbnZhciBTd2l0Y2hNYXBPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3dpdGNoTWFwT3BlcmF0b3IocHJvamVjdCwgcmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgICAgICAgdGhpcy5yZXN1bHRTZWxlY3RvciA9IHJlc3VsdFNlbGVjdG9yO1xuICAgIH1cbiAgICBTd2l0Y2hNYXBPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFN3aXRjaE1hcFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5wcm9qZWN0LCB0aGlzLnJlc3VsdFNlbGVjdG9yKSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3dpdGNoTWFwT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBTd2l0Y2hNYXBTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3dpdGNoTWFwU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTd2l0Y2hNYXBTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBwcm9qZWN0LCByZXN1bHRTZWxlY3Rvcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgICAgIHRoaXMucmVzdWx0U2VsZWN0b3IgPSByZXN1bHRTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgfVxuICAgIFN3aXRjaE1hcFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXgrKztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucHJvamVjdCh2YWx1ZSwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW5uZXJTdWIocmVzdWx0LCB2YWx1ZSwgaW5kZXgpO1xuICAgIH07XG4gICAgU3dpdGNoTWFwU3Vic2NyaWJlci5wcm90b3R5cGUuX2lubmVyU3ViID0gZnVuY3Rpb24gKHJlc3VsdCwgdmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHZhciBpbm5lclN1YnNjcmlwdGlvbiA9IHRoaXMuaW5uZXJTdWJzY3JpcHRpb247XG4gICAgICAgIGlmIChpbm5lclN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgaW5uZXJTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZCh0aGlzLmlubmVyU3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCByZXN1bHQsIHZhbHVlLCBpbmRleCkpO1xuICAgIH07XG4gICAgU3dpdGNoTWFwU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5uZXJTdWJzY3JpcHRpb24gPSB0aGlzLmlubmVyU3Vic2NyaXB0aW9uO1xuICAgICAgICBpZiAoIWlubmVyU3Vic2NyaXB0aW9uIHx8IGlubmVyU3Vic2NyaXB0aW9uLmNsb3NlZCkge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fY29tcGxldGUuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3dpdGNoTWFwU3Vic2NyaWJlci5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlubmVyU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICB9O1xuICAgIFN3aXRjaE1hcFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKGlubmVyU3ViKTtcbiAgICAgICAgdGhpcy5pbm5lclN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fY29tcGxldGUuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3dpdGNoTWFwU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICBpZiAodGhpcy5yZXN1bHRTZWxlY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5fdHJ5Tm90aWZ5TmV4dChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChpbm5lclZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3dpdGNoTWFwU3Vic2NyaWJlci5wcm90b3R5cGUuX3RyeU5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5yZXN1bHRTZWxlY3RvcihvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHJlc3VsdCk7XG4gICAgfTtcbiAgICByZXR1cm4gU3dpdGNoTWFwU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zd2l0Y2hNYXAuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3Ivc3dpdGNoTWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAzMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBQcm9qZWN0cyBlYWNoIHNvdXJjZSB2YWx1ZSB0byB0aGUgc2FtZSBPYnNlcnZhYmxlIHdoaWNoIGlzIGZsYXR0ZW5lZCBtdWx0aXBsZVxuICogdGltZXMgd2l0aCB7QGxpbmsgc3dpdGNofSBpbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgc3dpdGNoTWFwfSwgYnV0IG1hcHMgZWFjaCB2YWx1ZVxuICogYWx3YXlzIHRvIHRoZSBzYW1lIGlubmVyIE9ic2VydmFibGUuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvc3dpdGNoTWFwVG8ucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogTWFwcyBlYWNoIHNvdXJjZSB2YWx1ZSB0byB0aGUgZ2l2ZW4gT2JzZXJ2YWJsZSBgaW5uZXJPYnNlcnZhYmxlYCByZWdhcmRsZXNzXG4gKiBvZiB0aGUgc291cmNlIHZhbHVlLCBhbmQgdGhlbiBmbGF0dGVucyB0aG9zZSByZXN1bHRpbmcgT2JzZXJ2YWJsZXMgaW50byBvbmVcbiAqIHNpbmdsZSBPYnNlcnZhYmxlLCB3aGljaCBpcyB0aGUgb3V0cHV0IE9ic2VydmFibGUuIFRoZSBvdXRwdXQgT2JzZXJ2YWJsZXNcbiAqIGVtaXRzIHZhbHVlcyBvbmx5IGZyb20gdGhlIG1vc3QgcmVjZW50bHkgZW1pdHRlZCBpbnN0YW5jZSBvZlxuICogYGlubmVyT2JzZXJ2YWJsZWAuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+UmVydW4gYW4gaW50ZXJ2YWwgT2JzZXJ2YWJsZSBvbiBldmVyeSBjbGljayBldmVudDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLnN3aXRjaE1hcFRvKFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBjb25jYXRNYXBUb31cbiAqIEBzZWUge0BsaW5rIHN3aXRjaH1cbiAqIEBzZWUge0BsaW5rIHN3aXRjaE1hcH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlTWFwVG99XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlSW5wdXR9IGlubmVyT2JzZXJ2YWJsZSBBbiBPYnNlcnZhYmxlIHRvIHJlcGxhY2UgZWFjaCB2YWx1ZSBmcm9tXG4gKiB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG91dGVyVmFsdWU6IFQsIGlubmVyVmFsdWU6IEksIG91dGVySW5kZXg6IG51bWJlciwgaW5uZXJJbmRleDogbnVtYmVyKTogYW55fSBbcmVzdWx0U2VsZWN0b3JdXG4gKiBBIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHZhbHVlIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBiYXNlZCBvbiB0aGUgdmFsdWVzXG4gKiBhbmQgdGhlIGluZGljZXMgb2YgdGhlIHNvdXJjZSAob3V0ZXIpIGVtaXNzaW9uIGFuZCB0aGUgaW5uZXIgT2JzZXJ2YWJsZVxuICogZW1pc3Npb24uIFRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24gYXJlOlxuICogLSBgb3V0ZXJWYWx1ZWA6IHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgc291cmNlXG4gKiAtIGBpbm5lclZhbHVlYDogdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBwcm9qZWN0ZWQgT2JzZXJ2YWJsZVxuICogLSBgb3V0ZXJJbmRleGA6IHRoZSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBzb3VyY2VcbiAqIC0gYGlubmVySW5kZXhgOiB0aGUgXCJpbmRleFwiIG9mIHRoZSB2YWx1ZSBmcm9tIHRoZSBwcm9qZWN0ZWQgT2JzZXJ2YWJsZVxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGl0ZW1zIGZyb20gdGhlIGdpdmVuXG4gKiBgaW5uZXJPYnNlcnZhYmxlYCAoYW5kIG9wdGlvbmFsbHkgdHJhbnNmb3JtZWQgdGhyb3VnaCBgcmVzdWx0U2VsZWN0b3JgKSBldmVyeVxuICogdGltZSBhIHZhbHVlIGlzIGVtaXR0ZWQgb24gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCBhbmQgdGFraW5nIG9ubHkgdGhlIHZhbHVlc1xuICogZnJvbSB0aGUgbW9zdCByZWNlbnRseSBwcm9qZWN0ZWQgaW5uZXIgT2JzZXJ2YWJsZS5cbiAqIEBtZXRob2Qgc3dpdGNoTWFwVG9cbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHN3aXRjaE1hcFRvKGlubmVyT2JzZXJ2YWJsZSwgcmVzdWx0U2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBTd2l0Y2hNYXBUb09wZXJhdG9yKGlubmVyT2JzZXJ2YWJsZSwgcmVzdWx0U2VsZWN0b3IpKTtcbn1cbmV4cG9ydHMuc3dpdGNoTWFwVG8gPSBzd2l0Y2hNYXBUbztcbnZhciBTd2l0Y2hNYXBUb09wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTd2l0Y2hNYXBUb09wZXJhdG9yKG9ic2VydmFibGUsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZSA9IG9ic2VydmFibGU7XG4gICAgICAgIHRoaXMucmVzdWx0U2VsZWN0b3IgPSByZXN1bHRTZWxlY3RvcjtcbiAgICB9XG4gICAgU3dpdGNoTWFwVG9PcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFN3aXRjaE1hcFRvU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLm9ic2VydmFibGUsIHRoaXMucmVzdWx0U2VsZWN0b3IpKTtcbiAgICB9O1xuICAgIHJldHVybiBTd2l0Y2hNYXBUb09wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgU3dpdGNoTWFwVG9TdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3dpdGNoTWFwVG9TdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN3aXRjaE1hcFRvU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgaW5uZXIsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5pbm5lciA9IGlubmVyO1xuICAgICAgICB0aGlzLnJlc3VsdFNlbGVjdG9yID0gcmVzdWx0U2VsZWN0b3I7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH1cbiAgICBTd2l0Y2hNYXBUb1N1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBpbm5lclN1YnNjcmlwdGlvbiA9IHRoaXMuaW5uZXJTdWJzY3JpcHRpb247XG4gICAgICAgIGlmIChpbm5lclN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgaW5uZXJTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZCh0aGlzLmlubmVyU3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCB0aGlzLmlubmVyLCB2YWx1ZSwgdGhpcy5pbmRleCsrKSk7XG4gICAgfTtcbiAgICBTd2l0Y2hNYXBUb1N1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlubmVyU3Vic2NyaXB0aW9uID0gdGhpcy5pbm5lclN1YnNjcmlwdGlvbjtcbiAgICAgICAgaWYgKCFpbm5lclN1YnNjcmlwdGlvbiB8fCBpbm5lclN1YnNjcmlwdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuX2NvbXBsZXRlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN3aXRjaE1hcFRvU3Vic2NyaWJlci5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlubmVyU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICB9O1xuICAgIFN3aXRjaE1hcFRvU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoaW5uZXJTdWIpO1xuICAgICAgICB0aGlzLmlubmVyU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9jb21wbGV0ZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTd2l0Y2hNYXBUb1N1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcmVzdWx0U2VsZWN0b3IgPSBfYS5yZXN1bHRTZWxlY3RvciwgZGVzdGluYXRpb24gPSBfYS5kZXN0aW5hdGlvbjtcbiAgICAgICAgaWYgKHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnRyeVJlc3VsdFNlbGVjdG9yKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dChpbm5lclZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3dpdGNoTWFwVG9TdWJzY3JpYmVyLnByb3RvdHlwZS50cnlSZXN1bHRTZWxlY3RvciA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4KSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHJlc3VsdFNlbGVjdG9yID0gX2EucmVzdWx0U2VsZWN0b3IsIGRlc3RpbmF0aW9uID0gX2EuZGVzdGluYXRpb247XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHRTZWxlY3RvcihvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlc3RpbmF0aW9uLm5leHQocmVzdWx0KTtcbiAgICB9O1xuICAgIHJldHVybiBTd2l0Y2hNYXBUb1N1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3dpdGNoTWFwVG8uanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3Ivc3dpdGNoTWFwVG8uanNcbi8vIG1vZHVsZSBpZCA9IDMxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcl8xID0gcmVxdWlyZSgnLi4vdXRpbC9Bcmd1bWVudE91dE9mUmFuZ2VFcnJvcicpO1xudmFyIEVtcHR5T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vb2JzZXJ2YWJsZS9FbXB0eU9ic2VydmFibGUnKTtcbi8qKlxuICogRW1pdHMgb25seSB0aGUgZmlyc3QgYGNvdW50YCB2YWx1ZXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPlRha2VzIHRoZSBmaXJzdCBgY291bnRgIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2UsIHRoZW5cbiAqIGNvbXBsZXRlcy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy90YWtlLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGB0YWtlYCByZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBvbmx5IHRoZSBmaXJzdCBgY291bnRgIHZhbHVlcyBlbWl0dGVkXG4gKiBieSB0aGUgc291cmNlIE9ic2VydmFibGUuIElmIHRoZSBzb3VyY2UgZW1pdHMgZmV3ZXIgdGhhbiBgY291bnRgIHZhbHVlcyB0aGVuXG4gKiBhbGwgb2YgaXRzIHZhbHVlcyBhcmUgZW1pdHRlZC4gQWZ0ZXIgdGhhdCwgaXQgY29tcGxldGVzLCByZWdhcmRsZXNzIGlmIHRoZVxuICogc291cmNlIGNvbXBsZXRlcy5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5UYWtlIHRoZSBmaXJzdCA1IHNlY29uZHMgb2YgYW4gaW5maW5pdGUgMS1zZWNvbmQgaW50ZXJ2YWwgT2JzZXJ2YWJsZTwvY2FwdGlvbj5cbiAqIHZhciBpbnRlcnZhbCA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gKiB2YXIgZml2ZSA9IGludGVydmFsLnRha2UoNSk7XG4gKiBmaXZlLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayB0YWtlTGFzdH1cbiAqIEBzZWUge0BsaW5rIHRha2VVbnRpbH1cbiAqIEBzZWUge0BsaW5rIHRha2VXaGlsZX1cbiAqIEBzZWUge0BsaW5rIHNraXB9XG4gKlxuICogQHRocm93cyB7QXJndW1lbnRPdXRPZlJhbmdlRXJyb3J9IFdoZW4gdXNpbmcgYHRha2UoaSlgLCBpdCBkZWxpdmVycyBhblxuICogQXJndW1lbnRPdXRPclJhbmdlRXJyb3IgdG8gdGhlIE9ic2VydmVyJ3MgYGVycm9yYCBjYWxsYmFjayBpZiBgaSA8IDBgLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCBUaGUgbWF4aW11bSBudW1iZXIgb2YgYG5leHRgIHZhbHVlcyB0byBlbWl0LlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIG9ubHkgdGhlIGZpcnN0IGBjb3VudGBcbiAqIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgb3IgYWxsIG9mIHRoZSB2YWx1ZXMgZnJvbSB0aGUgc291cmNlXG4gKiBpZiB0aGUgc291cmNlIGVtaXRzIGZld2VyIHRoYW4gYGNvdW50YCB2YWx1ZXMuXG4gKiBAbWV0aG9kIHRha2VcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHRha2UoY291bnQpIHtcbiAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFbXB0eU9ic2VydmFibGVfMS5FbXB0eU9ic2VydmFibGUoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFRha2VPcGVyYXRvcihjb3VudCkpO1xuICAgIH1cbn1cbmV4cG9ydHMudGFrZSA9IHRha2U7XG52YXIgVGFrZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYWtlT3BlcmF0b3IodG90YWwpIHtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgICAgICBpZiAodGhpcy50b3RhbCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcl8xLkFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIFRha2VPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFRha2VTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMudG90YWwpKTtcbiAgICB9O1xuICAgIHJldHVybiBUYWtlT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBUYWtlU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRha2VTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRha2VTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCB0b3RhbCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMudG90YWwgPSB0b3RhbDtcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgfVxuICAgIFRha2VTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgdG90YWwgPSB0aGlzLnRvdGFsO1xuICAgICAgICB2YXIgY291bnQgPSArK3RoaXMuY291bnQ7XG4gICAgICAgIGlmIChjb3VudCA8PSB0b3RhbCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjb3VudCA9PT0gdG90YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVGFrZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWtlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9yL3Rha2UuanNcbi8vIG1vZHVsZSBpZCA9IDMxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcl8xID0gcmVxdWlyZSgnLi4vdXRpbC9Bcmd1bWVudE91dE9mUmFuZ2VFcnJvcicpO1xudmFyIEVtcHR5T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vb2JzZXJ2YWJsZS9FbXB0eU9ic2VydmFibGUnKTtcbi8qKlxuICogRW1pdHMgb25seSB0aGUgbGFzdCBgY291bnRgIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+UmVtZW1iZXJzIHRoZSBsYXRlc3QgYGNvdW50YCB2YWx1ZXMsIHRoZW4gZW1pdHMgdGhvc2VcbiAqIG9ubHkgd2hlbiB0aGUgc291cmNlIGNvbXBsZXRlcy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy90YWtlTGFzdC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgdGFrZUxhc3RgIHJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGF0IG1vc3QgdGhlIGxhc3QgYGNvdW50YCB2YWx1ZXNcbiAqIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiBJZiB0aGUgc291cmNlIGVtaXRzIGZld2VyIHRoYW4gYGNvdW50YFxuICogdmFsdWVzIHRoZW4gYWxsIG9mIGl0cyB2YWx1ZXMgYXJlIGVtaXR0ZWQuIFRoaXMgb3BlcmF0b3IgbXVzdCB3YWl0IHVudGlsIHRoZVxuICogYGNvbXBsZXRlYCBub3RpZmljYXRpb24gZW1pc3Npb24gZnJvbSB0aGUgc291cmNlIGluIG9yZGVyIHRvIGVtaXQgdGhlIGBuZXh0YFxuICogdmFsdWVzIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSwgYmVjYXVzZSBvdGhlcndpc2UgaXQgaXMgaW1wb3NzaWJsZSB0byBrbm93XG4gKiB3aGV0aGVyIG9yIG5vdCBtb3JlIHZhbHVlcyB3aWxsIGJlIGVtaXR0ZWQgb24gdGhlIHNvdXJjZS4gRm9yIHRoaXMgcmVhc29uLFxuICogYWxsIHZhbHVlcyBhcmUgZW1pdHRlZCBzeW5jaHJvbm91c2x5LCBmb2xsb3dlZCBieSB0aGUgY29tcGxldGUgbm90aWZpY2F0aW9uLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlRha2UgdGhlIGxhc3QgMyB2YWx1ZXMgb2YgYW4gT2JzZXJ2YWJsZSB3aXRoIG1hbnkgdmFsdWVzPC9jYXB0aW9uPlxuICogdmFyIG1hbnkgPSBSeC5PYnNlcnZhYmxlLnJhbmdlKDEsIDEwMCk7XG4gKiB2YXIgbGFzdFRocmVlID0gbWFueS50YWtlTGFzdCgzKTtcbiAqIGxhc3RUaHJlZS5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgdGFrZX1cbiAqIEBzZWUge0BsaW5rIHRha2VVbnRpbH1cbiAqIEBzZWUge0BsaW5rIHRha2VXaGlsZX1cbiAqIEBzZWUge0BsaW5rIHNraXB9XG4gKlxuICogQHRocm93cyB7QXJndW1lbnRPdXRPZlJhbmdlRXJyb3J9IFdoZW4gdXNpbmcgYHRha2VMYXN0KGkpYCwgaXQgZGVsaXZlcnMgYW5cbiAqIEFyZ3VtZW50T3V0T3JSYW5nZUVycm9yIHRvIHRoZSBPYnNlcnZlcidzIGBlcnJvcmAgY2FsbGJhY2sgaWYgYGkgPCAwYC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gY291bnQgVGhlIG1heGltdW0gbnVtYmVyIG9mIHZhbHVlcyB0byBlbWl0IGZyb20gdGhlIGVuZCBvZlxuICogdGhlIHNlcXVlbmNlIG9mIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBhdCBtb3N0IHRoZSBsYXN0IGNvdW50XG4gKiB2YWx1ZXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIHRha2VMYXN0XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiB0YWtlTGFzdChjb3VudCkge1xuICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IEVtcHR5T2JzZXJ2YWJsZV8xLkVtcHR5T2JzZXJ2YWJsZSgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlmdChuZXcgVGFrZUxhc3RPcGVyYXRvcihjb3VudCkpO1xuICAgIH1cbn1cbmV4cG9ydHMudGFrZUxhc3QgPSB0YWtlTGFzdDtcbnZhciBUYWtlTGFzdE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYWtlTGFzdE9wZXJhdG9yKHRvdGFsKSB7XG4gICAgICAgIHRoaXMudG90YWwgPSB0b3RhbDtcbiAgICAgICAgaWYgKHRoaXMudG90YWwgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3JfMS5Bcmd1bWVudE91dE9mUmFuZ2VFcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBUYWtlTGFzdE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgVGFrZUxhc3RTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMudG90YWwpKTtcbiAgICB9O1xuICAgIHJldHVybiBUYWtlTGFzdE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgVGFrZUxhc3RTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGFrZUxhc3RTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRha2VMYXN0U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgdG90YWwpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnRvdGFsID0gdG90YWw7XG4gICAgICAgIHRoaXMucmluZyA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICB9XG4gICAgVGFrZUxhc3RTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmluZyA9IHRoaXMucmluZztcbiAgICAgICAgdmFyIHRvdGFsID0gdGhpcy50b3RhbDtcbiAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5jb3VudCsrO1xuICAgICAgICBpZiAocmluZy5sZW5ndGggPCB0b3RhbCkge1xuICAgICAgICAgICAgcmluZy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGNvdW50ICUgdG90YWw7XG4gICAgICAgICAgICByaW5nW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUYWtlTGFzdFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5jb3VudDtcbiAgICAgICAgaWYgKGNvdW50ID4gMCkge1xuICAgICAgICAgICAgdmFyIHRvdGFsID0gdGhpcy5jb3VudCA+PSB0aGlzLnRvdGFsID8gdGhpcy50b3RhbCA6IHRoaXMuY291bnQ7XG4gICAgICAgICAgICB2YXIgcmluZyA9IHRoaXMucmluZztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG90YWw7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpZHggPSAoY291bnQrKykgJSB0b3RhbDtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHJpbmdbaWR4XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9O1xuICAgIHJldHVybiBUYWtlTGFzdFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWtlTGFzdC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvci90YWtlTGFzdC5qc1xuLy8gbW9kdWxlIGlkID0gMzE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyoqXG4gKiBFbWl0cyB0aGUgdmFsdWVzIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHVudGlsIGEgYG5vdGlmaWVyYFxuICogT2JzZXJ2YWJsZSBlbWl0cyBhIHZhbHVlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5MZXRzIHZhbHVlcyBwYXNzIHVudGlsIGEgc2Vjb25kIE9ic2VydmFibGUsXG4gKiBgbm90aWZpZXJgLCBlbWl0cyBzb21ldGhpbmcuIFRoZW4sIGl0IGNvbXBsZXRlcy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy90YWtlVW50aWwucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYHRha2VVbnRpbGAgc3Vic2NyaWJlcyBhbmQgYmVnaW5zIG1pcnJvcmluZyB0aGUgc291cmNlIE9ic2VydmFibGUuIEl0IGFsc29cbiAqIG1vbml0b3JzIGEgc2Vjb25kIE9ic2VydmFibGUsIGBub3RpZmllcmAgdGhhdCB5b3UgcHJvdmlkZS4gSWYgdGhlIGBub3RpZmllcmBcbiAqIGVtaXRzIGEgdmFsdWUgb3IgYSBjb21wbGV0ZSBub3RpZmljYXRpb24sIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBzdG9wc1xuICogbWlycm9yaW5nIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBhbmQgY29tcGxldGVzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlRpY2sgZXZlcnkgc2Vjb25kIHVudGlsIHRoZSBmaXJzdCBjbGljayBoYXBwZW5zPC9jYXB0aW9uPlxuICogdmFyIGludGVydmFsID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gaW50ZXJ2YWwudGFrZVVudGlsKGNsaWNrcyk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIHRha2V9XG4gKiBAc2VlIHtAbGluayB0YWtlTGFzdH1cbiAqIEBzZWUge0BsaW5rIHRha2VXaGlsZX1cbiAqIEBzZWUge0BsaW5rIHNraXB9XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlfSBub3RpZmllciBUaGUgT2JzZXJ2YWJsZSB3aG9zZSBmaXJzdCBlbWl0dGVkIHZhbHVlIHdpbGxcbiAqIGNhdXNlIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBvZiBgdGFrZVVudGlsYCB0byBzdG9wIGVtaXR0aW5nIHZhbHVlcyBmcm9tIHRoZVxuICogc291cmNlIE9ic2VydmFibGUuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUgdW50aWwgc3VjaCB0aW1lIGFzIGBub3RpZmllcmAgZW1pdHMgaXRzIGZpcnN0IHZhbHVlLlxuICogQG1ldGhvZCB0YWtlVW50aWxcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHRha2VVbnRpbChub3RpZmllcikge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFRha2VVbnRpbE9wZXJhdG9yKG5vdGlmaWVyKSk7XG59XG5leHBvcnRzLnRha2VVbnRpbCA9IHRha2VVbnRpbDtcbnZhciBUYWtlVW50aWxPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGFrZVVudGlsT3BlcmF0b3Iobm90aWZpZXIpIHtcbiAgICAgICAgdGhpcy5ub3RpZmllciA9IG5vdGlmaWVyO1xuICAgIH1cbiAgICBUYWtlVW50aWxPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFRha2VVbnRpbFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5ub3RpZmllcikpO1xuICAgIH07XG4gICAgcmV0dXJuIFRha2VVbnRpbE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgVGFrZVVudGlsU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRha2VVbnRpbFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFrZVVudGlsU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgbm90aWZpZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLm5vdGlmaWVyID0gbm90aWZpZXI7XG4gICAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgbm90aWZpZXIpKTtcbiAgICB9XG4gICAgVGFrZVVudGlsU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLmNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICBUYWtlVW50aWxTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gbm9vcFxuICAgIH07XG4gICAgcmV0dXJuIFRha2VVbnRpbFN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFrZVVudGlsLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9yL3Rha2VVbnRpbC5qc1xuLy8gbW9kdWxlIGlkID0gMzE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xuLyoqXG4gKiBFbWl0cyB2YWx1ZXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgc28gbG9uZyBhcyBlYWNoIHZhbHVlIHNhdGlzZmllc1xuICogdGhlIGdpdmVuIGBwcmVkaWNhdGVgLCBhbmQgdGhlbiBjb21wbGV0ZXMgYXMgc29vbiBhcyB0aGlzIGBwcmVkaWNhdGVgIGlzIG5vdFxuICogc2F0aXNmaWVkLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5UYWtlcyB2YWx1ZXMgZnJvbSB0aGUgc291cmNlIG9ubHkgd2hpbGUgdGhleSBwYXNzIHRoZVxuICogY29uZGl0aW9uIGdpdmVuLiBXaGVuIHRoZSBmaXJzdCB2YWx1ZSBkb2VzIG5vdCBzYXRpc2Z5LCBpdCBjb21wbGV0ZXMuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvdGFrZVdoaWxlLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGB0YWtlV2hpbGVgIHN1YnNjcmliZXMgYW5kIGJlZ2lucyBtaXJyb3JpbmcgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiBFYWNoIHZhbHVlXG4gKiBlbWl0dGVkIG9uIHRoZSBzb3VyY2UgaXMgZ2l2ZW4gdG8gdGhlIGBwcmVkaWNhdGVgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYVxuICogYm9vbGVhbiwgcmVwcmVzZW50aW5nIGEgY29uZGl0aW9uIHRvIGJlIHNhdGlzZmllZCBieSB0aGUgc291cmNlIHZhbHVlcy4gVGhlXG4gKiBvdXRwdXQgT2JzZXJ2YWJsZSBlbWl0cyB0aGUgc291cmNlIHZhbHVlcyB1bnRpbCBzdWNoIHRpbWUgYXMgdGhlIGBwcmVkaWNhdGVgXG4gKiByZXR1cm5zIGZhbHNlLCBhdCB3aGljaCBwb2ludCBgdGFrZVdoaWxlYCBzdG9wcyBtaXJyb3JpbmcgdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSBhbmQgY29tcGxldGVzIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0IGNsaWNrIGV2ZW50cyBvbmx5IHdoaWxlIHRoZSBjbGllbnRYIHByb3BlcnR5IGlzIGdyZWF0ZXIgdGhhbiAyMDA8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy50YWtlV2hpbGUoZXYgPT4gZXYuY2xpZW50WCA+IDIwMCk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIHRha2V9XG4gKiBAc2VlIHtAbGluayB0YWtlTGFzdH1cbiAqIEBzZWUge0BsaW5rIHRha2VVbnRpbH1cbiAqIEBzZWUge0BsaW5rIHNraXB9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCwgaW5kZXg6IG51bWJlcik6IGJvb2xlYW59IHByZWRpY2F0ZSBBIGZ1bmN0aW9uIHRoYXRcbiAqIGV2YWx1YXRlcyBhIHZhbHVlIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGFuZCByZXR1cm5zIGEgYm9vbGVhbi5cbiAqIEFsc28gdGFrZXMgdGhlICh6ZXJvLWJhc2VkKSBpbmRleCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSB2YWx1ZXMgZnJvbSB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlIHNvIGxvbmcgYXMgZWFjaCB2YWx1ZSBzYXRpc2ZpZXMgdGhlIGNvbmRpdGlvbiBkZWZpbmVkIGJ5IHRoZVxuICogYHByZWRpY2F0ZWAsIHRoZW4gY29tcGxldGVzLlxuICogQG1ldGhvZCB0YWtlV2hpbGVcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHRha2VXaGlsZShwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBUYWtlV2hpbGVPcGVyYXRvcihwcmVkaWNhdGUpKTtcbn1cbmV4cG9ydHMudGFrZVdoaWxlID0gdGFrZVdoaWxlO1xudmFyIFRha2VXaGlsZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYWtlV2hpbGVPcGVyYXRvcihwcmVkaWNhdGUpIHtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgfVxuICAgIFRha2VXaGlsZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgVGFrZVdoaWxlU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByZWRpY2F0ZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFRha2VXaGlsZU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgVGFrZVdoaWxlU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRha2VXaGlsZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFrZVdoaWxlU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH1cbiAgICBUYWtlV2hpbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wcmVkaWNhdGUodmFsdWUsIHRoaXMuaW5kZXgrKyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5leHRPckNvbXBsZXRlKHZhbHVlLCByZXN1bHQpO1xuICAgIH07XG4gICAgVGFrZVdoaWxlU3Vic2NyaWJlci5wcm90b3R5cGUubmV4dE9yQ29tcGxldGUgPSBmdW5jdGlvbiAodmFsdWUsIHByZWRpY2F0ZVJlc3VsdCkge1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICBpZiAoQm9vbGVhbihwcmVkaWNhdGVSZXN1bHQpKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUYWtlV2hpbGVTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFrZVdoaWxlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9yL3Rha2VXaGlsZS5qc1xuLy8gbW9kdWxlIGlkID0gMzE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyoqXG4gKiBFbWl0cyBhIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCB0aGVuIGlnbm9yZXMgc3Vic2VxdWVudCBzb3VyY2VcbiAqIHZhbHVlcyBmb3IgYSBkdXJhdGlvbiBkZXRlcm1pbmVkIGJ5IGFub3RoZXIgT2JzZXJ2YWJsZSwgdGhlbiByZXBlYXRzIHRoaXNcbiAqIHByb2Nlc3MuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgdGhyb3R0bGVUaW1lfSwgYnV0IHRoZSBzaWxlbmNpbmdcbiAqIGR1cmF0aW9uIGlzIGRldGVybWluZWQgYnkgYSBzZWNvbmQgT2JzZXJ2YWJsZS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy90aHJvdHRsZS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgdGhyb3R0bGVgIGVtaXRzIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB2YWx1ZXMgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlXG4gKiB3aGVuIGl0cyBpbnRlcm5hbCB0aW1lciBpcyBkaXNhYmxlZCwgYW5kIGlnbm9yZXMgc291cmNlIHZhbHVlcyB3aGVuIHRoZSB0aW1lclxuICogaXMgZW5hYmxlZC4gSW5pdGlhbGx5LCB0aGUgdGltZXIgaXMgZGlzYWJsZWQuIEFzIHNvb24gYXMgdGhlIGZpcnN0IHNvdXJjZVxuICogdmFsdWUgYXJyaXZlcywgaXQgaXMgZm9yd2FyZGVkIHRvIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSwgYW5kIHRoZW4gdGhlIHRpbWVyXG4gKiBpcyBlbmFibGVkIGJ5IGNhbGxpbmcgdGhlIGBkdXJhdGlvblNlbGVjdG9yYCBmdW5jdGlvbiB3aXRoIHRoZSBzb3VyY2UgdmFsdWUsXG4gKiB3aGljaCByZXR1cm5zIHRoZSBcImR1cmF0aW9uXCIgT2JzZXJ2YWJsZS4gV2hlbiB0aGUgZHVyYXRpb24gT2JzZXJ2YWJsZSBlbWl0cyBhXG4gKiB2YWx1ZSBvciBjb21wbGV0ZXMsIHRoZSB0aW1lciBpcyBkaXNhYmxlZCwgYW5kIHRoaXMgcHJvY2VzcyByZXBlYXRzIGZvciB0aGVcbiAqIG5leHQgc291cmNlIHZhbHVlLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgY2xpY2tzIGF0IGEgcmF0ZSBvZiBhdCBtb3N0IG9uZSBjbGljayBwZXIgc2Vjb25kPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3MudGhyb3R0bGUoZXYgPT4gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKSk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGF1ZGl0fVxuICogQHNlZSB7QGxpbmsgZGVib3VuY2V9XG4gKiBAc2VlIHtAbGluayBkZWxheVdoZW59XG4gKiBAc2VlIHtAbGluayBzYW1wbGV9XG4gKiBAc2VlIHtAbGluayB0aHJvdHRsZVRpbWV9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCk6IFN1YnNjcmliYWJsZU9yUHJvbWlzZX0gZHVyYXRpb25TZWxlY3RvciBBIGZ1bmN0aW9uXG4gKiB0aGF0IHJlY2VpdmVzIGEgdmFsdWUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUsIGZvciBjb21wdXRpbmcgdGhlIHNpbGVuY2luZ1xuICogZHVyYXRpb24gZm9yIGVhY2ggc291cmNlIHZhbHVlLCByZXR1cm5lZCBhcyBhbiBPYnNlcnZhYmxlIG9yIGEgUHJvbWlzZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IEFuIE9ic2VydmFibGUgdGhhdCBwZXJmb3JtcyB0aGUgdGhyb3R0bGUgb3BlcmF0aW9uIHRvXG4gKiBsaW1pdCB0aGUgcmF0ZSBvZiBlbWlzc2lvbnMgZnJvbSB0aGUgc291cmNlLlxuICogQG1ldGhvZCB0aHJvdHRsZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gdGhyb3R0bGUoZHVyYXRpb25TZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFRocm90dGxlT3BlcmF0b3IoZHVyYXRpb25TZWxlY3RvcikpO1xufVxuZXhwb3J0cy50aHJvdHRsZSA9IHRocm90dGxlO1xudmFyIFRocm90dGxlT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRocm90dGxlT3BlcmF0b3IoZHVyYXRpb25TZWxlY3Rvcikge1xuICAgICAgICB0aGlzLmR1cmF0aW9uU2VsZWN0b3IgPSBkdXJhdGlvblNlbGVjdG9yO1xuICAgIH1cbiAgICBUaHJvdHRsZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgVGhyb3R0bGVTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuZHVyYXRpb25TZWxlY3RvcikpO1xuICAgIH07XG4gICAgcmV0dXJuIFRocm90dGxlT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBUaHJvdHRsZVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUaHJvdHRsZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGhyb3R0bGVTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBkdXJhdGlvblNlbGVjdG9yKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uO1xuICAgICAgICB0aGlzLmR1cmF0aW9uU2VsZWN0b3IgPSBkdXJhdGlvblNlbGVjdG9yO1xuICAgIH1cbiAgICBUaHJvdHRsZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy50aHJvdHRsZWQpIHtcbiAgICAgICAgICAgIHRoaXMudHJ5RHVyYXRpb25TZWxlY3Rvcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRocm90dGxlU3Vic2NyaWJlci5wcm90b3R5cGUudHJ5RHVyYXRpb25TZWxlY3RvciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uU2VsZWN0b3IodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXRBbmRUaHJvdHRsZSh2YWx1ZSwgZHVyYXRpb24pO1xuICAgIH07XG4gICAgVGhyb3R0bGVTdWJzY3JpYmVyLnByb3RvdHlwZS5lbWl0QW5kVGhyb3R0bGUgPSBmdW5jdGlvbiAodmFsdWUsIGR1cmF0aW9uKSB7XG4gICAgICAgIHRoaXMuYWRkKHRoaXMudGhyb3R0bGVkID0gc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBkdXJhdGlvbikpO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgIH07XG4gICAgVGhyb3R0bGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aHJvdHRsZWQgPSB0aGlzLnRocm90dGxlZDtcbiAgICAgICAgaWYgKHRocm90dGxlZCkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUodGhyb3R0bGVkKTtcbiAgICAgICAgICAgIHRoaXMudGhyb3R0bGVkID0gbnVsbDtcbiAgICAgICAgICAgIHRocm90dGxlZC51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUaHJvdHRsZVN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICAgIFRocm90dGxlU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gVGhyb3R0bGVTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRocm90dGxlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9yL3Rocm90dGxlLmpzXG4vLyBtb2R1bGUgaWQgPSAzMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJy4uL3NjaGVkdWxlci9hc3luYycpO1xuLyoqXG4gKiBFbWl0cyBhIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCB0aGVuIGlnbm9yZXMgc3Vic2VxdWVudCBzb3VyY2VcbiAqIHZhbHVlcyBmb3IgYGR1cmF0aW9uYCBtaWxsaXNlY29uZHMsIHRoZW4gcmVwZWF0cyB0aGlzIHByb2Nlc3MuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkxldHMgYSB2YWx1ZSBwYXNzLCB0aGVuIGlnbm9yZXMgc291cmNlIHZhbHVlcyBmb3IgdGhlXG4gKiBuZXh0IGBkdXJhdGlvbmAgbWlsbGlzZWNvbmRzLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3Rocm90dGxlVGltZS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgdGhyb3R0bGVUaW1lYCBlbWl0cyB0aGUgc291cmNlIE9ic2VydmFibGUgdmFsdWVzIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZVxuICogd2hlbiBpdHMgaW50ZXJuYWwgdGltZXIgaXMgZGlzYWJsZWQsIGFuZCBpZ25vcmVzIHNvdXJjZSB2YWx1ZXMgd2hlbiB0aGUgdGltZXJcbiAqIGlzIGVuYWJsZWQuIEluaXRpYWxseSwgdGhlIHRpbWVyIGlzIGRpc2FibGVkLiBBcyBzb29uIGFzIHRoZSBmaXJzdCBzb3VyY2VcbiAqIHZhbHVlIGFycml2ZXMsIGl0IGlzIGZvcndhcmRlZCB0byB0aGUgb3V0cHV0IE9ic2VydmFibGUsIGFuZCB0aGVuIHRoZSB0aW1lclxuICogaXMgZW5hYmxlZC4gQWZ0ZXIgYGR1cmF0aW9uYCBtaWxsaXNlY29uZHMgKG9yIHRoZSB0aW1lIHVuaXQgZGV0ZXJtaW5lZFxuICogaW50ZXJuYWxseSBieSB0aGUgb3B0aW9uYWwgYHNjaGVkdWxlcmApIGhhcyBwYXNzZWQsIHRoZSB0aW1lciBpcyBkaXNhYmxlZCxcbiAqIGFuZCB0aGlzIHByb2Nlc3MgcmVwZWF0cyBmb3IgdGhlIG5leHQgc291cmNlIHZhbHVlLiBPcHRpb25hbGx5IHRha2VzIGFcbiAqIHtAbGluayBJU2NoZWR1bGVyfSBmb3IgbWFuYWdpbmcgdGltZXJzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgY2xpY2tzIGF0IGEgcmF0ZSBvZiBhdCBtb3N0IG9uZSBjbGljayBwZXIgc2Vjb25kPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3MudGhyb3R0bGVUaW1lKDEwMDApO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBhdWRpdFRpbWV9XG4gKiBAc2VlIHtAbGluayBkZWJvdW5jZVRpbWV9XG4gKiBAc2VlIHtAbGluayBkZWxheX1cbiAqIEBzZWUge0BsaW5rIHNhbXBsZVRpbWV9XG4gKiBAc2VlIHtAbGluayB0aHJvdHRsZX1cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb24gVGltZSB0byB3YWl0IGJlZm9yZSBlbWl0dGluZyBhbm90aGVyIHZhbHVlIGFmdGVyXG4gKiBlbWl0dGluZyB0aGUgbGFzdCB2YWx1ZSwgbWVhc3VyZWQgaW4gbWlsbGlzZWNvbmRzIG9yIHRoZSB0aW1lIHVuaXQgZGV0ZXJtaW5lZFxuICogaW50ZXJuYWxseSBieSB0aGUgb3B0aW9uYWwgYHNjaGVkdWxlcmAuXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcj1hc3luY10gVGhlIHtAbGluayBJU2NoZWR1bGVyfSB0byB1c2UgZm9yXG4gKiBtYW5hZ2luZyB0aGUgdGltZXJzIHRoYXQgaGFuZGxlIHRoZSBzYW1wbGluZy5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IEFuIE9ic2VydmFibGUgdGhhdCBwZXJmb3JtcyB0aGUgdGhyb3R0bGUgb3BlcmF0aW9uIHRvXG4gKiBsaW1pdCB0aGUgcmF0ZSBvZiBlbWlzc2lvbnMgZnJvbSB0aGUgc291cmNlLlxuICogQG1ldGhvZCB0aHJvdHRsZVRpbWVcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHRocm90dGxlVGltZShkdXJhdGlvbiwgc2NoZWR1bGVyKSB7XG4gICAgaWYgKHNjaGVkdWxlciA9PT0gdm9pZCAwKSB7IHNjaGVkdWxlciA9IGFzeW5jXzEuYXN5bmM7IH1cbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBUaHJvdHRsZVRpbWVPcGVyYXRvcihkdXJhdGlvbiwgc2NoZWR1bGVyKSk7XG59XG5leHBvcnRzLnRocm90dGxlVGltZSA9IHRocm90dGxlVGltZTtcbnZhciBUaHJvdHRsZVRpbWVPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGhyb3R0bGVUaW1lT3BlcmF0b3IoZHVyYXRpb24sIHNjaGVkdWxlcikge1xuICAgICAgICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIH1cbiAgICBUaHJvdHRsZVRpbWVPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFRocm90dGxlVGltZVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5kdXJhdGlvbiwgdGhpcy5zY2hlZHVsZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBUaHJvdHRsZVRpbWVPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFRocm90dGxlVGltZVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUaHJvdHRsZVRpbWVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRocm90dGxlVGltZVN1YnNjcmliZXIoZGVzdGluYXRpb24sIGR1cmF0aW9uLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIH1cbiAgICBUaHJvdHRsZVRpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMudGhyb3R0bGVkKSB7XG4gICAgICAgICAgICB0aGlzLmFkZCh0aGlzLnRocm90dGxlZCA9IHRoaXMuc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoTmV4dCwgdGhpcy5kdXJhdGlvbiwgeyBzdWJzY3JpYmVyOiB0aGlzIH0pKTtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRocm90dGxlVGltZVN1YnNjcmliZXIucHJvdG90eXBlLmNsZWFyVGhyb3R0bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aHJvdHRsZWQgPSB0aGlzLnRocm90dGxlZDtcbiAgICAgICAgaWYgKHRocm90dGxlZCkge1xuICAgICAgICAgICAgdGhyb3R0bGVkLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZSh0aHJvdHRsZWQpO1xuICAgICAgICAgICAgdGhpcy50aHJvdHRsZWQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVGhyb3R0bGVUaW1lU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbmZ1bmN0aW9uIGRpc3BhdGNoTmV4dChhcmcpIHtcbiAgICB2YXIgc3Vic2NyaWJlciA9IGFyZy5zdWJzY3JpYmVyO1xuICAgIHN1YnNjcmliZXIuY2xlYXJUaHJvdHRsZSgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGhyb3R0bGVUaW1lLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9yL3Rocm90dGxlVGltZS5qc1xuLy8gbW9kdWxlIGlkID0gMzIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJy4uL3NjaGVkdWxlci9hc3luYycpO1xudmFyIGlzRGF0ZV8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc0RhdGUnKTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgVGltZW91dEVycm9yXzEgPSByZXF1aXJlKCcuLi91dGlsL1RpbWVvdXRFcnJvcicpO1xuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gZHVlXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl1cbiAqIEByZXR1cm4ge09ic2VydmFibGU8Uj58V2ViU29ja2V0U3ViamVjdDxUPnxPYnNlcnZhYmxlPFQ+fVxuICogQG1ldGhvZCB0aW1lb3V0XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiB0aW1lb3V0KGR1ZSwgc2NoZWR1bGVyKSB7XG4gICAgaWYgKHNjaGVkdWxlciA9PT0gdm9pZCAwKSB7IHNjaGVkdWxlciA9IGFzeW5jXzEuYXN5bmM7IH1cbiAgICB2YXIgYWJzb2x1dGVUaW1lb3V0ID0gaXNEYXRlXzEuaXNEYXRlKGR1ZSk7XG4gICAgdmFyIHdhaXRGb3IgPSBhYnNvbHV0ZVRpbWVvdXQgPyAoK2R1ZSAtIHNjaGVkdWxlci5ub3coKSkgOiBNYXRoLmFicyhkdWUpO1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFRpbWVvdXRPcGVyYXRvcih3YWl0Rm9yLCBhYnNvbHV0ZVRpbWVvdXQsIHNjaGVkdWxlciwgbmV3IFRpbWVvdXRFcnJvcl8xLlRpbWVvdXRFcnJvcigpKSk7XG59XG5leHBvcnRzLnRpbWVvdXQgPSB0aW1lb3V0O1xudmFyIFRpbWVvdXRPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGltZW91dE9wZXJhdG9yKHdhaXRGb3IsIGFic29sdXRlVGltZW91dCwgc2NoZWR1bGVyLCBlcnJvckluc3RhbmNlKSB7XG4gICAgICAgIHRoaXMud2FpdEZvciA9IHdhaXRGb3I7XG4gICAgICAgIHRoaXMuYWJzb2x1dGVUaW1lb3V0ID0gYWJzb2x1dGVUaW1lb3V0O1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgdGhpcy5lcnJvckluc3RhbmNlID0gZXJyb3JJbnN0YW5jZTtcbiAgICB9XG4gICAgVGltZW91dE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgVGltZW91dFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5hYnNvbHV0ZVRpbWVvdXQsIHRoaXMud2FpdEZvciwgdGhpcy5zY2hlZHVsZXIsIHRoaXMuZXJyb3JJbnN0YW5jZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFRpbWVvdXRPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFRpbWVvdXRTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGltZW91dFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGltZW91dFN1YnNjcmliZXIoZGVzdGluYXRpb24sIGFic29sdXRlVGltZW91dCwgd2FpdEZvciwgc2NoZWR1bGVyLCBlcnJvckluc3RhbmNlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5hYnNvbHV0ZVRpbWVvdXQgPSBhYnNvbHV0ZVRpbWVvdXQ7XG4gICAgICAgIHRoaXMud2FpdEZvciA9IHdhaXRGb3I7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLmVycm9ySW5zdGFuY2UgPSBlcnJvckluc3RhbmNlO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5fcHJldmlvdXNJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuX2hhc0NvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNjaGVkdWxlVGltZW91dCgpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGltZW91dFN1YnNjcmliZXIucHJvdG90eXBlLCBcInByZXZpb3VzSW5kZXhcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcmV2aW91c0luZGV4O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGltZW91dFN1YnNjcmliZXIucHJvdG90eXBlLCBcImhhc0NvbXBsZXRlZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhc0NvbXBsZXRlZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgVGltZW91dFN1YnNjcmliZXIuZGlzcGF0Y2hUaW1lb3V0ID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBzdGF0ZS5zdWJzY3JpYmVyO1xuICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gc3RhdGUuaW5kZXg7XG4gICAgICAgIGlmICghc291cmNlLmhhc0NvbXBsZXRlZCAmJiBzb3VyY2UucHJldmlvdXNJbmRleCA9PT0gY3VycmVudEluZGV4KSB7XG4gICAgICAgICAgICBzb3VyY2Uubm90aWZ5VGltZW91dCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUaW1lb3V0U3Vic2NyaWJlci5wcm90b3R5cGUuc2NoZWR1bGVUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIuc2NoZWR1bGUoVGltZW91dFN1YnNjcmliZXIuZGlzcGF0Y2hUaW1lb3V0LCB0aGlzLndhaXRGb3IsIHsgc3Vic2NyaWJlcjogdGhpcywgaW5kZXg6IGN1cnJlbnRJbmRleCB9KTtcbiAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICB0aGlzLl9wcmV2aW91c0luZGV4ID0gY3VycmVudEluZGV4O1xuICAgIH07XG4gICAgVGltZW91dFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgICAgIGlmICghdGhpcy5hYnNvbHV0ZVRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVUaW1lb3V0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRpbWVvdXRTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgdGhpcy5faGFzQ29tcGxldGVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIFRpbWVvdXRTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgdGhpcy5faGFzQ29tcGxldGVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIFRpbWVvdXRTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVycm9yKHRoaXMuZXJyb3JJbnN0YW5jZSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGltZW91dFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lb3V0LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9yL3RpbWVvdXQuanNcbi8vIG1vZHVsZSBpZCA9IDMyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGFzeW5jXzEgPSByZXF1aXJlKCcuLi9zY2hlZHVsZXIvYXN5bmMnKTtcbnZhciBpc0RhdGVfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNEYXRlJyk7XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogQHBhcmFtIGR1ZVxuICogQHBhcmFtIHdpdGhPYnNlcnZhYmxlXG4gKiBAcGFyYW0gc2NoZWR1bGVyXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFI+fFdlYlNvY2tldFN1YmplY3Q8VD58T2JzZXJ2YWJsZTxUPn1cbiAqIEBtZXRob2QgdGltZW91dFdpdGhcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHRpbWVvdXRXaXRoKGR1ZSwgd2l0aE9ic2VydmFibGUsIHNjaGVkdWxlcikge1xuICAgIGlmIChzY2hlZHVsZXIgPT09IHZvaWQgMCkgeyBzY2hlZHVsZXIgPSBhc3luY18xLmFzeW5jOyB9XG4gICAgdmFyIGFic29sdXRlVGltZW91dCA9IGlzRGF0ZV8xLmlzRGF0ZShkdWUpO1xuICAgIHZhciB3YWl0Rm9yID0gYWJzb2x1dGVUaW1lb3V0ID8gKCtkdWUgLSBzY2hlZHVsZXIubm93KCkpIDogTWF0aC5hYnMoZHVlKTtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBUaW1lb3V0V2l0aE9wZXJhdG9yKHdhaXRGb3IsIGFic29sdXRlVGltZW91dCwgd2l0aE9ic2VydmFibGUsIHNjaGVkdWxlcikpO1xufVxuZXhwb3J0cy50aW1lb3V0V2l0aCA9IHRpbWVvdXRXaXRoO1xudmFyIFRpbWVvdXRXaXRoT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRpbWVvdXRXaXRoT3BlcmF0b3Iod2FpdEZvciwgYWJzb2x1dGVUaW1lb3V0LCB3aXRoT2JzZXJ2YWJsZSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIHRoaXMud2FpdEZvciA9IHdhaXRGb3I7XG4gICAgICAgIHRoaXMuYWJzb2x1dGVUaW1lb3V0ID0gYWJzb2x1dGVUaW1lb3V0O1xuICAgICAgICB0aGlzLndpdGhPYnNlcnZhYmxlID0gd2l0aE9ic2VydmFibGU7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIH1cbiAgICBUaW1lb3V0V2l0aE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgVGltZW91dFdpdGhTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuYWJzb2x1dGVUaW1lb3V0LCB0aGlzLndhaXRGb3IsIHRoaXMud2l0aE9ic2VydmFibGUsIHRoaXMuc2NoZWR1bGVyKSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGltZW91dFdpdGhPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFRpbWVvdXRXaXRoU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRpbWVvdXRXaXRoU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUaW1lb3V0V2l0aFN1YnNjcmliZXIoZGVzdGluYXRpb24sIGFic29sdXRlVGltZW91dCwgd2FpdEZvciwgd2l0aE9ic2VydmFibGUsIHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uO1xuICAgICAgICB0aGlzLmFic29sdXRlVGltZW91dCA9IGFic29sdXRlVGltZW91dDtcbiAgICAgICAgdGhpcy53YWl0Rm9yID0gd2FpdEZvcjtcbiAgICAgICAgdGhpcy53aXRoT2JzZXJ2YWJsZSA9IHdpdGhPYnNlcnZhYmxlO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgdGhpcy50aW1lb3V0U3Vic2NyaXB0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5fcHJldmlvdXNJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuX2hhc0NvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICBkZXN0aW5hdGlvbi5hZGQodGhpcyk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVUaW1lb3V0KCk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUaW1lb3V0V2l0aFN1YnNjcmliZXIucHJvdG90eXBlLCBcInByZXZpb3VzSW5kZXhcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcmV2aW91c0luZGV4O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGltZW91dFdpdGhTdWJzY3JpYmVyLnByb3RvdHlwZSwgXCJoYXNDb21wbGV0ZWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYXNDb21wbGV0ZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFRpbWVvdXRXaXRoU3Vic2NyaWJlci5kaXNwYXRjaFRpbWVvdXQgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHN0YXRlLnN1YnNjcmliZXI7XG4gICAgICAgIHZhciBjdXJyZW50SW5kZXggPSBzdGF0ZS5pbmRleDtcbiAgICAgICAgaWYgKCFzb3VyY2UuaGFzQ29tcGxldGVkICYmIHNvdXJjZS5wcmV2aW91c0luZGV4ID09PSBjdXJyZW50SW5kZXgpIHtcbiAgICAgICAgICAgIHNvdXJjZS5oYW5kbGVUaW1lb3V0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRpbWVvdXRXaXRoU3Vic2NyaWJlci5wcm90b3R5cGUuc2NoZWR1bGVUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgdmFyIHRpbWVvdXRTdGF0ZSA9IHsgc3Vic2NyaWJlcjogdGhpcywgaW5kZXg6IGN1cnJlbnRJbmRleCB9O1xuICAgICAgICB0aGlzLnNjaGVkdWxlci5zY2hlZHVsZShUaW1lb3V0V2l0aFN1YnNjcmliZXIuZGlzcGF0Y2hUaW1lb3V0LCB0aGlzLndhaXRGb3IsIHRpbWVvdXRTdGF0ZSk7XG4gICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgdGhpcy5fcHJldmlvdXNJbmRleCA9IGN1cnJlbnRJbmRleDtcbiAgICB9O1xuICAgIFRpbWVvdXRXaXRoU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgaWYgKCF0aGlzLmFic29sdXRlVGltZW91dCkge1xuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVRpbWVvdXQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGltZW91dFdpdGhTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgdGhpcy5faGFzQ29tcGxldGVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIFRpbWVvdXRXaXRoU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMuX2hhc0NvbXBsZXRlZCA9IHRydWU7XG4gICAgfTtcbiAgICBUaW1lb3V0V2l0aFN1YnNjcmliZXIucHJvdG90eXBlLmhhbmRsZVRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHZhciB3aXRoT2JzZXJ2YWJsZSA9IHRoaXMud2l0aE9ic2VydmFibGU7XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmFkZCh0aGlzLnRpbWVvdXRTdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIHdpdGhPYnNlcnZhYmxlKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUaW1lb3V0V2l0aFN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGltZW91dFdpdGguanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3IvdGltZW91dFdpdGguanNcbi8vIG1vZHVsZSBpZCA9IDMyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbi8qKlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxhbnlbXT58V2ViU29ja2V0U3ViamVjdDxUPnxPYnNlcnZhYmxlPFQ+fVxuICogQG1ldGhvZCB0b0FycmF5XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiB0b0FycmF5KCkge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFRvQXJyYXlPcGVyYXRvcigpKTtcbn1cbmV4cG9ydHMudG9BcnJheSA9IHRvQXJyYXk7XG52YXIgVG9BcnJheU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUb0FycmF5T3BlcmF0b3IoKSB7XG4gICAgfVxuICAgIFRvQXJyYXlPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFRvQXJyYXlTdWJzY3JpYmVyKHN1YnNjcmliZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBUb0FycmF5T3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBUb0FycmF5U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRvQXJyYXlTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRvQXJyYXlTdWJzY3JpYmVyKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5hcnJheSA9IFtdO1xuICAgIH1cbiAgICBUb0FycmF5U3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLmFycmF5LnB1c2goeCk7XG4gICAgfTtcbiAgICBUb0FycmF5U3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodGhpcy5hcnJheSk7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9O1xuICAgIHJldHVybiBUb0FycmF5U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvQXJyYXkuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3IvdG9BcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMzI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHJvb3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvcm9vdCcpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogQ29udmVydHMgYW4gT2JzZXJ2YWJsZSBzZXF1ZW5jZSB0byBhIEVTMjAxNSBjb21wbGlhbnQgcHJvbWlzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gVXNpbmcgbm9ybWFsIEVTMjAxNVxuICogbGV0IHNvdXJjZSA9IFJ4Lk9ic2VydmFibGVcbiAqICAgLmp1c3QoNDIpXG4gKiAgIC50b1Byb21pc2UoKTtcbiAqXG4gKiBzb3VyY2UudGhlbigodmFsdWUpID0+IGNvbnNvbGUubG9nKCdWYWx1ZTogJXMnLCB2YWx1ZSkpO1xuICogLy8gPT4gVmFsdWU6IDQyXG4gKlxuICogLy8gUmVqZWN0ZWQgUHJvbWlzZVxuICogLy8gVXNpbmcgbm9ybWFsIEVTMjAxNVxuICogbGV0IHNvdXJjZSA9IFJ4Lk9ic2VydmFibGVcbiAqICAgLnRocm93KG5ldyBFcnJvcignd29vcHMnKSlcbiAqICAgLnRvUHJvbWlzZSgpO1xuICpcbiAqIHNvdXJjZVxuICogICAudGhlbigodmFsdWUpID0+IGNvbnNvbGUubG9nKCdWYWx1ZTogJXMnLCB2YWx1ZSkpXG4gKiAgIC5jYXRjaCgoZXJyKSA9PiBjb25zb2xlLmxvZygnRXJyb3I6ICVzJywgZXJyKSk7XG4gKiAvLyA9PiBFcnJvcjogRXJyb3I6IHdvb3BzXG4gKlxuICogLy8gU2V0dGluZyB2aWEgdGhlIGNvbmZpZ1xuICogUnguY29uZmlnLlByb21pc2UgPSBSU1ZQLlByb21pc2U7XG4gKlxuICogbGV0IHNvdXJjZSA9IFJ4Lk9ic2VydmFibGVcbiAqICAgLm9mKDQyKVxuICogICAudG9Qcm9taXNlKCk7XG4gKlxuICogc291cmNlLnRoZW4oKHZhbHVlKSA9PiBjb25zb2xlLmxvZygnVmFsdWU6ICVzJywgdmFsdWUpKTtcbiAqIC8vID0+IFZhbHVlOiA0MlxuICpcbiAqIC8vIFNldHRpbmcgdmlhIHRoZSBtZXRob2RcbiAqIGxldCBzb3VyY2UgPSBSeC5PYnNlcnZhYmxlXG4gKiAgIC5qdXN0KDQyKVxuICogICAudG9Qcm9taXNlKFJTVlAuUHJvbWlzZSk7XG4gKlxuICogc291cmNlLnRoZW4oKHZhbHVlKSA9PiBjb25zb2xlLmxvZygnVmFsdWU6ICVzJywgdmFsdWUpKTtcbiAqIC8vID0+IFZhbHVlOiA0MlxuICpcbiAqIEBwYXJhbSBQcm9taXNlQ3RvciBwcm9taXNlIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgcHJvbWlzZS4gSWYgbm90IHByb3ZpZGVkLFxuICogaXQgd2lsbCBsb29rIGZvciBhIGNvbnN0cnVjdG9yIGZpcnN0IGluIFJ4LmNvbmZpZy5Qcm9taXNlIHRoZW4gZmFsbCBiYWNrIHRvXG4gKiB0aGUgbmF0aXZlIFByb21pc2UgY29uc3RydWN0b3IgaWYgYXZhaWxhYmxlLlxuICogQHJldHVybiB7UHJvbWlzZTxUPn0gQW4gRVMyMDE1IGNvbXBhdGlibGUgcHJvbWlzZSB3aXRoIHRoZSBsYXN0IHZhbHVlIGZyb21cbiAqIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICogQG1ldGhvZCB0b1Byb21pc2VcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHRvUHJvbWlzZShQcm9taXNlQ3Rvcikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKCFQcm9taXNlQ3Rvcikge1xuICAgICAgICBpZiAocm9vdF8xLnJvb3QuUnggJiYgcm9vdF8xLnJvb3QuUnguY29uZmlnICYmIHJvb3RfMS5yb290LlJ4LmNvbmZpZy5Qcm9taXNlKSB7XG4gICAgICAgICAgICBQcm9taXNlQ3RvciA9IHJvb3RfMS5yb290LlJ4LmNvbmZpZy5Qcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJvb3RfMS5yb290LlByb21pc2UpIHtcbiAgICAgICAgICAgIFByb21pc2VDdG9yID0gcm9vdF8xLnJvb3QuUHJvbWlzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIVByb21pc2VDdG9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm8gUHJvbWlzZSBpbXBsIGZvdW5kJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZUN0b3IoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIF90aGlzLnN1YnNjcmliZShmdW5jdGlvbiAoeCkgeyByZXR1cm4gdmFsdWUgPSB4OyB9LCBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiByZWplY3QoZXJyKTsgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZSh2YWx1ZSk7IH0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy50b1Byb21pc2UgPSB0b1Byb21pc2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b1Byb21pc2UuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3IvdG9Qcm9taXNlLmpzXG4vLyBtb2R1bGUgaWQgPSAzMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJqZWN0XzEgPSByZXF1aXJlKCcuLi9TdWJqZWN0Jyk7XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyoqXG4gKiBCcmFuY2ggb3V0IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB2YWx1ZXMgYXMgYSBuZXN0ZWQgT2JzZXJ2YWJsZSB3aGVuZXZlclxuICogYHdpbmRvd0JvdW5kYXJpZXNgIGVtaXRzLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5JdCdzIGxpa2Uge0BsaW5rIGJ1ZmZlcn0sIGJ1dCBlbWl0cyBhIG5lc3RlZCBPYnNlcnZhYmxlXG4gKiBpbnN0ZWFkIG9mIGFuIGFycmF5Ljwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3dpbmRvdy5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB3aW5kb3dzIG9mIGl0ZW1zIGl0IGNvbGxlY3RzIGZyb20gdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZS4gVGhlIG91dHB1dCBPYnNlcnZhYmxlIGVtaXRzIGNvbm5lY3RlZCwgbm9uLW92ZXJsYXBwaW5nXG4gKiB3aW5kb3dzLiBJdCBlbWl0cyB0aGUgY3VycmVudCB3aW5kb3cgYW5kIG9wZW5zIGEgbmV3IG9uZSB3aGVuZXZlciB0aGVcbiAqIE9ic2VydmFibGUgYHdpbmRvd0JvdW5kYXJpZXNgIGVtaXRzIGFuIGl0ZW0uIEJlY2F1c2UgZWFjaCB3aW5kb3cgaXMgYW5cbiAqIE9ic2VydmFibGUsIHRoZSBvdXRwdXQgaXMgYSBoaWdoZXItb3JkZXIgT2JzZXJ2YWJsZS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5JbiBldmVyeSB3aW5kb3cgb2YgMSBzZWNvbmQgZWFjaCwgZW1pdCBhdCBtb3N0IDIgY2xpY2sgZXZlbnRzPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBpbnRlcnZhbCA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLndpbmRvdyhpbnRlcnZhbClcbiAqICAgLm1hcCh3aW4gPT4gd2luLnRha2UoMikpIC8vIGVhY2ggd2luZG93IGhhcyBhdCBtb3N0IDIgZW1pc3Npb25zXG4gKiAgIC5tZXJnZUFsbCgpOyAvLyBmbGF0dGVuIHRoZSBPYnNlcnZhYmxlLW9mLU9ic2VydmFibGVzXG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIHdpbmRvd0NvdW50fVxuICogQHNlZSB7QGxpbmsgd2luZG93VGltZX1cbiAqIEBzZWUge0BsaW5rIHdpbmRvd1RvZ2dsZX1cbiAqIEBzZWUge0BsaW5rIHdpbmRvd1doZW59XG4gKiBAc2VlIHtAbGluayBidWZmZXJ9XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlPGFueT59IHdpbmRvd0JvdW5kYXJpZXMgQW4gT2JzZXJ2YWJsZSB0aGF0IGNvbXBsZXRlcyB0aGVcbiAqIHByZXZpb3VzIHdpbmRvdyBhbmQgc3RhcnRzIGEgbmV3IHdpbmRvdy5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8T2JzZXJ2YWJsZTxUPj59IEFuIE9ic2VydmFibGUgb2Ygd2luZG93cywgd2hpY2ggYXJlXG4gKiBPYnNlcnZhYmxlcyBlbWl0dGluZyB2YWx1ZXMgb2YgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCB3aW5kb3dcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHdpbmRvdyh3aW5kb3dCb3VuZGFyaWVzKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgV2luZG93T3BlcmF0b3Iod2luZG93Qm91bmRhcmllcykpO1xufVxuZXhwb3J0cy53aW5kb3cgPSB3aW5kb3c7XG52YXIgV2luZG93T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFdpbmRvd09wZXJhdG9yKHdpbmRvd0JvdW5kYXJpZXMpIHtcbiAgICAgICAgdGhpcy53aW5kb3dCb3VuZGFyaWVzID0gd2luZG93Qm91bmRhcmllcztcbiAgICB9XG4gICAgV2luZG93T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHZhciB3aW5kb3dTdWJzY3JpYmVyID0gbmV3IFdpbmRvd1N1YnNjcmliZXIoc3Vic2NyaWJlcik7XG4gICAgICAgIHZhciBzb3VyY2VTdWJzY3JpcHRpb24gPSBzb3VyY2Uuc3Vic2NyaWJlKHdpbmRvd1N1YnNjcmliZXIpO1xuICAgICAgICBpZiAoIXNvdXJjZVN1YnNjcmlwdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgIHdpbmRvd1N1YnNjcmliZXIuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQod2luZG93U3Vic2NyaWJlciwgdGhpcy53aW5kb3dCb3VuZGFyaWVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNvdXJjZVN1YnNjcmlwdGlvbjtcbiAgICB9O1xuICAgIHJldHVybiBXaW5kb3dPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFdpbmRvd1N1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhXaW5kb3dTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFdpbmRvd1N1YnNjcmliZXIoZGVzdGluYXRpb24pIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLndpbmRvdyA9IG5ldyBTdWJqZWN0XzEuU3ViamVjdCgpO1xuICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHRoaXMud2luZG93KTtcbiAgICB9XG4gICAgV2luZG93U3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLm9wZW5XaW5kb3coKTtcbiAgICB9O1xuICAgIFdpbmRvd1N1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUVycm9yID0gZnVuY3Rpb24gKGVycm9yLCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLl9lcnJvcihlcnJvcik7XG4gICAgfTtcbiAgICBXaW5kb3dTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uIChpbm5lclN1Yikge1xuICAgICAgICB0aGlzLl9jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgV2luZG93U3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy53aW5kb3cubmV4dCh2YWx1ZSk7XG4gICAgfTtcbiAgICBXaW5kb3dTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMud2luZG93LmVycm9yKGVycik7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICB9O1xuICAgIFdpbmRvd1N1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy53aW5kb3cuY29tcGxldGUoKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgV2luZG93U3Vic2NyaWJlci5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLndpbmRvdyA9IG51bGw7XG4gICAgfTtcbiAgICBXaW5kb3dTdWJzY3JpYmVyLnByb3RvdHlwZS5vcGVuV2luZG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJldldpbmRvdyA9IHRoaXMud2luZG93O1xuICAgICAgICBpZiAocHJldldpbmRvdykge1xuICAgICAgICAgICAgcHJldldpbmRvdy5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIHZhciBuZXdXaW5kb3cgPSB0aGlzLndpbmRvdyA9IG5ldyBTdWJqZWN0XzEuU3ViamVjdCgpO1xuICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KG5ld1dpbmRvdyk7XG4gICAgfTtcbiAgICByZXR1cm4gV2luZG93U3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13aW5kb3cuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3Ivd2luZG93LmpzXG4vLyBtb2R1bGUgaWQgPSAzMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgU3ViamVjdF8xID0gcmVxdWlyZSgnLi4vU3ViamVjdCcpO1xuLyoqXG4gKiBCcmFuY2ggb3V0IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB2YWx1ZXMgYXMgYSBuZXN0ZWQgT2JzZXJ2YWJsZSB3aXRoIGVhY2hcbiAqIG5lc3RlZCBPYnNlcnZhYmxlIGVtaXR0aW5nIGF0IG1vc3QgYHdpbmRvd1NpemVgIHZhbHVlcy5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SXQncyBsaWtlIHtAbGluayBidWZmZXJDb3VudH0sIGJ1dCBlbWl0cyBhIG5lc3RlZFxuICogT2JzZXJ2YWJsZSBpbnN0ZWFkIG9mIGFuIGFycmF5Ljwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3dpbmRvd0NvdW50LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHdpbmRvd3Mgb2YgaXRlbXMgaXQgY29sbGVjdHMgZnJvbSB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLiBUaGUgb3V0cHV0IE9ic2VydmFibGUgZW1pdHMgd2luZG93cyBldmVyeSBgc3RhcnRXaW5kb3dFdmVyeWBcbiAqIGl0ZW1zLCBlYWNoIGNvbnRhaW5pbmcgbm8gbW9yZSB0aGFuIGB3aW5kb3dTaXplYCBpdGVtcy4gV2hlbiB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlIGNvbXBsZXRlcyBvciBlbmNvdW50ZXJzIGFuIGVycm9yLCB0aGUgb3V0cHV0IE9ic2VydmFibGUgZW1pdHNcbiAqIHRoZSBjdXJyZW50IHdpbmRvdyBhbmQgcHJvcGFnYXRlcyB0aGUgbm90aWZpY2F0aW9uIGZyb20gdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZS4gSWYgYHN0YXJ0V2luZG93RXZlcnlgIGlzIG5vdCBwcm92aWRlZCwgdGhlbiBuZXcgd2luZG93cyBhcmVcbiAqIHN0YXJ0ZWQgaW1tZWRpYXRlbHkgYXQgdGhlIHN0YXJ0IG9mIHRoZSBzb3VyY2UgYW5kIHdoZW4gZWFjaCB3aW5kb3cgY29tcGxldGVzXG4gKiB3aXRoIHNpemUgYHdpbmRvd1NpemVgLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPklnbm9yZSBldmVyeSAzcmQgY2xpY2sgZXZlbnQsIHN0YXJ0aW5nIGZyb20gdGhlIGZpcnN0IG9uZTwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLndpbmRvd0NvdW50KDMpXG4gKiAgIC5tYXAod2luID0+IHdpbi5za2lwKDEpKSAvLyBza2lwIGZpcnN0IG9mIGV2ZXJ5IDMgY2xpY2tzXG4gKiAgIC5tZXJnZUFsbCgpOyAvLyBmbGF0dGVuIHRoZSBPYnNlcnZhYmxlLW9mLU9ic2VydmFibGVzXG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPklnbm9yZSBldmVyeSAzcmQgY2xpY2sgZXZlbnQsIHN0YXJ0aW5nIGZyb20gdGhlIHRoaXJkIG9uZTwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLndpbmRvd0NvdW50KDIsIDMpXG4gKiAgIC5tZXJnZUFsbCgpOyAvLyBmbGF0dGVuIHRoZSBPYnNlcnZhYmxlLW9mLU9ic2VydmFibGVzXG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIHdpbmRvd31cbiAqIEBzZWUge0BsaW5rIHdpbmRvd1RpbWV9XG4gKiBAc2VlIHtAbGluayB3aW5kb3dUb2dnbGV9XG4gKiBAc2VlIHtAbGluayB3aW5kb3dXaGVufVxuICogQHNlZSB7QGxpbmsgYnVmZmVyQ291bnR9XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHdpbmRvd1NpemUgVGhlIG1heGltdW0gbnVtYmVyIG9mIHZhbHVlcyBlbWl0dGVkIGJ5IGVhY2hcbiAqIHdpbmRvdy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRXaW5kb3dFdmVyeV0gSW50ZXJ2YWwgYXQgd2hpY2ggdG8gc3RhcnQgYSBuZXcgd2luZG93LlxuICogRm9yIGV4YW1wbGUgaWYgYHN0YXJ0V2luZG93RXZlcnlgIGlzIGAyYCwgdGhlbiBhIG5ldyB3aW5kb3cgd2lsbCBiZSBzdGFydGVkXG4gKiBvbiBldmVyeSBvdGhlciB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UuIEEgbmV3IHdpbmRvdyBpcyBzdGFydGVkIGF0IHRoZVxuICogYmVnaW5uaW5nIG9mIHRoZSBzb3VyY2UgYnkgZGVmYXVsdC5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8T2JzZXJ2YWJsZTxUPj59IEFuIE9ic2VydmFibGUgb2Ygd2luZG93cywgd2hpY2ggaW4gdHVyblxuICogYXJlIE9ic2VydmFibGUgb2YgdmFsdWVzLlxuICogQG1ldGhvZCB3aW5kb3dDb3VudFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gd2luZG93Q291bnQod2luZG93U2l6ZSwgc3RhcnRXaW5kb3dFdmVyeSkge1xuICAgIGlmIChzdGFydFdpbmRvd0V2ZXJ5ID09PSB2b2lkIDApIHsgc3RhcnRXaW5kb3dFdmVyeSA9IDA7IH1cbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBXaW5kb3dDb3VudE9wZXJhdG9yKHdpbmRvd1NpemUsIHN0YXJ0V2luZG93RXZlcnkpKTtcbn1cbmV4cG9ydHMud2luZG93Q291bnQgPSB3aW5kb3dDb3VudDtcbnZhciBXaW5kb3dDb3VudE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBXaW5kb3dDb3VudE9wZXJhdG9yKHdpbmRvd1NpemUsIHN0YXJ0V2luZG93RXZlcnkpIHtcbiAgICAgICAgdGhpcy53aW5kb3dTaXplID0gd2luZG93U2l6ZTtcbiAgICAgICAgdGhpcy5zdGFydFdpbmRvd0V2ZXJ5ID0gc3RhcnRXaW5kb3dFdmVyeTtcbiAgICB9XG4gICAgV2luZG93Q291bnRPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFdpbmRvd0NvdW50U3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLndpbmRvd1NpemUsIHRoaXMuc3RhcnRXaW5kb3dFdmVyeSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFdpbmRvd0NvdW50T3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBXaW5kb3dDb3VudFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhXaW5kb3dDb3VudFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gV2luZG93Q291bnRTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCB3aW5kb3dTaXplLCBzdGFydFdpbmRvd0V2ZXJ5KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uO1xuICAgICAgICB0aGlzLndpbmRvd1NpemUgPSB3aW5kb3dTaXplO1xuICAgICAgICB0aGlzLnN0YXJ0V2luZG93RXZlcnkgPSBzdGFydFdpbmRvd0V2ZXJ5O1xuICAgICAgICB0aGlzLndpbmRvd3MgPSBbbmV3IFN1YmplY3RfMS5TdWJqZWN0KCldO1xuICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICAgICAgZGVzdGluYXRpb24ubmV4dCh0aGlzLndpbmRvd3NbMF0pO1xuICAgIH1cbiAgICBXaW5kb3dDb3VudFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBzdGFydFdpbmRvd0V2ZXJ5ID0gKHRoaXMuc3RhcnRXaW5kb3dFdmVyeSA+IDApID8gdGhpcy5zdGFydFdpbmRvd0V2ZXJ5IDogdGhpcy53aW5kb3dTaXplO1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICB2YXIgd2luZG93U2l6ZSA9IHRoaXMud2luZG93U2l6ZTtcbiAgICAgICAgdmFyIHdpbmRvd3MgPSB0aGlzLndpbmRvd3M7XG4gICAgICAgIHZhciBsZW4gPSB3aW5kb3dzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW4gJiYgIXRoaXMuY2xvc2VkOyBpKyspIHtcbiAgICAgICAgICAgIHdpbmRvd3NbaV0ubmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGMgPSB0aGlzLmNvdW50IC0gd2luZG93U2l6ZSArIDE7XG4gICAgICAgIGlmIChjID49IDAgJiYgYyAlIHN0YXJ0V2luZG93RXZlcnkgPT09IDAgJiYgIXRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICB3aW5kb3dzLnNoaWZ0KCkuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKyt0aGlzLmNvdW50ICUgc3RhcnRXaW5kb3dFdmVyeSA9PT0gMCAmJiAhdGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHZhciB3aW5kb3dfMSA9IG5ldyBTdWJqZWN0XzEuU3ViamVjdCgpO1xuICAgICAgICAgICAgd2luZG93cy5wdXNoKHdpbmRvd18xKTtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQod2luZG93XzEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBXaW5kb3dDb3VudFN1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIHdpbmRvd3MgPSB0aGlzLndpbmRvd3M7XG4gICAgICAgIGlmICh3aW5kb3dzKSB7XG4gICAgICAgICAgICB3aGlsZSAod2luZG93cy5sZW5ndGggPiAwICYmICF0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgIHdpbmRvd3Muc2hpZnQoKS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICB9O1xuICAgIFdpbmRvd0NvdW50U3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd2luZG93cyA9IHRoaXMud2luZG93cztcbiAgICAgICAgaWYgKHdpbmRvd3MpIHtcbiAgICAgICAgICAgIHdoaWxlICh3aW5kb3dzLmxlbmd0aCA+IDAgJiYgIXRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgd2luZG93cy5zaGlmdCgpLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgV2luZG93Q291bnRTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICB0aGlzLndpbmRvd3MgPSBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIFdpbmRvd0NvdW50U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdpbmRvd0NvdW50LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9yL3dpbmRvd0NvdW50LmpzXG4vLyBtb2R1bGUgaWQgPSAzMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJqZWN0XzEgPSByZXF1aXJlKCcuLi9TdWJqZWN0Jyk7XG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJy4uL3NjaGVkdWxlci9hc3luYycpO1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBpc051bWVyaWNfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNOdW1lcmljJyk7XG52YXIgaXNTY2hlZHVsZXJfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNTY2hlZHVsZXInKTtcbmZ1bmN0aW9uIHdpbmRvd1RpbWUod2luZG93VGltZVNwYW4pIHtcbiAgICB2YXIgc2NoZWR1bGVyID0gYXN5bmNfMS5hc3luYztcbiAgICB2YXIgd2luZG93Q3JlYXRpb25JbnRlcnZhbCA9IG51bGw7XG4gICAgdmFyIG1heFdpbmRvd1NpemUgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgaWYgKGlzU2NoZWR1bGVyXzEuaXNTY2hlZHVsZXIoYXJndW1lbnRzWzNdKSkge1xuICAgICAgICBzY2hlZHVsZXIgPSBhcmd1bWVudHNbM107XG4gICAgfVxuICAgIGlmIChpc1NjaGVkdWxlcl8xLmlzU2NoZWR1bGVyKGFyZ3VtZW50c1syXSkpIHtcbiAgICAgICAgc2NoZWR1bGVyID0gYXJndW1lbnRzWzJdO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc051bWVyaWNfMS5pc051bWVyaWMoYXJndW1lbnRzWzJdKSkge1xuICAgICAgICBtYXhXaW5kb3dTaXplID0gYXJndW1lbnRzWzJdO1xuICAgIH1cbiAgICBpZiAoaXNTY2hlZHVsZXJfMS5pc1NjaGVkdWxlcihhcmd1bWVudHNbMV0pKSB7XG4gICAgICAgIHNjaGVkdWxlciA9IGFyZ3VtZW50c1sxXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNOdW1lcmljXzEuaXNOdW1lcmljKGFyZ3VtZW50c1sxXSkpIHtcbiAgICAgICAgd2luZG93Q3JlYXRpb25JbnRlcnZhbCA9IGFyZ3VtZW50c1sxXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgV2luZG93VGltZU9wZXJhdG9yKHdpbmRvd1RpbWVTcGFuLCB3aW5kb3dDcmVhdGlvbkludGVydmFsLCBtYXhXaW5kb3dTaXplLCBzY2hlZHVsZXIpKTtcbn1cbmV4cG9ydHMud2luZG93VGltZSA9IHdpbmRvd1RpbWU7XG52YXIgV2luZG93VGltZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBXaW5kb3dUaW1lT3BlcmF0b3Iod2luZG93VGltZVNwYW4sIHdpbmRvd0NyZWF0aW9uSW50ZXJ2YWwsIG1heFdpbmRvd1NpemUsIHNjaGVkdWxlcikge1xuICAgICAgICB0aGlzLndpbmRvd1RpbWVTcGFuID0gd2luZG93VGltZVNwYW47XG4gICAgICAgIHRoaXMud2luZG93Q3JlYXRpb25JbnRlcnZhbCA9IHdpbmRvd0NyZWF0aW9uSW50ZXJ2YWw7XG4gICAgICAgIHRoaXMubWF4V2luZG93U2l6ZSA9IG1heFdpbmRvd1NpemU7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIH1cbiAgICBXaW5kb3dUaW1lT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBXaW5kb3dUaW1lU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLndpbmRvd1RpbWVTcGFuLCB0aGlzLndpbmRvd0NyZWF0aW9uSW50ZXJ2YWwsIHRoaXMubWF4V2luZG93U2l6ZSwgdGhpcy5zY2hlZHVsZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBXaW5kb3dUaW1lT3BlcmF0b3I7XG59KCkpO1xudmFyIENvdW50ZWRTdWJqZWN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ291bnRlZFN1YmplY3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ291bnRlZFN1YmplY3QoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9udW1iZXJPZk5leHRlZFZhbHVlcyA9IDA7XG4gICAgfVxuICAgIENvdW50ZWRTdWJqZWN0LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX251bWJlck9mTmV4dGVkVmFsdWVzKys7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmV4dC5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb3VudGVkU3ViamVjdC5wcm90b3R5cGUsIFwibnVtYmVyT2ZOZXh0ZWRWYWx1ZXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9udW1iZXJPZk5leHRlZFZhbHVlcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIENvdW50ZWRTdWJqZWN0O1xufShTdWJqZWN0XzEuU3ViamVjdCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBXaW5kb3dUaW1lU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFdpbmRvd1RpbWVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFdpbmRvd1RpbWVTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCB3aW5kb3dUaW1lU3Bhbiwgd2luZG93Q3JlYXRpb25JbnRlcnZhbCwgbWF4V2luZG93U2l6ZSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uO1xuICAgICAgICB0aGlzLndpbmRvd1RpbWVTcGFuID0gd2luZG93VGltZVNwYW47XG4gICAgICAgIHRoaXMud2luZG93Q3JlYXRpb25JbnRlcnZhbCA9IHdpbmRvd0NyZWF0aW9uSW50ZXJ2YWw7XG4gICAgICAgIHRoaXMubWF4V2luZG93U2l6ZSA9IG1heFdpbmRvd1NpemU7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLndpbmRvd3MgPSBbXTtcbiAgICAgICAgdmFyIHdpbmRvdyA9IHRoaXMub3BlbldpbmRvdygpO1xuICAgICAgICBpZiAod2luZG93Q3JlYXRpb25JbnRlcnZhbCAhPT0gbnVsbCAmJiB3aW5kb3dDcmVhdGlvbkludGVydmFsID49IDApIHtcbiAgICAgICAgICAgIHZhciBjbG9zZVN0YXRlID0geyBzdWJzY3JpYmVyOiB0aGlzLCB3aW5kb3c6IHdpbmRvdywgY29udGV4dDogbnVsbCB9O1xuICAgICAgICAgICAgdmFyIGNyZWF0aW9uU3RhdGUgPSB7IHdpbmRvd1RpbWVTcGFuOiB3aW5kb3dUaW1lU3Bhbiwgd2luZG93Q3JlYXRpb25JbnRlcnZhbDogd2luZG93Q3JlYXRpb25JbnRlcnZhbCwgc3Vic2NyaWJlcjogdGhpcywgc2NoZWR1bGVyOiBzY2hlZHVsZXIgfTtcbiAgICAgICAgICAgIHRoaXMuYWRkKHNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaFdpbmRvd0Nsb3NlLCB3aW5kb3dUaW1lU3BhbiwgY2xvc2VTdGF0ZSkpO1xuICAgICAgICAgICAgdGhpcy5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoV2luZG93Q3JlYXRpb24sIHdpbmRvd0NyZWF0aW9uSW50ZXJ2YWwsIGNyZWF0aW9uU3RhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0aW1lU3Bhbk9ubHlTdGF0ZSA9IHsgc3Vic2NyaWJlcjogdGhpcywgd2luZG93OiB3aW5kb3csIHdpbmRvd1RpbWVTcGFuOiB3aW5kb3dUaW1lU3BhbiB9O1xuICAgICAgICAgICAgdGhpcy5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoV2luZG93VGltZVNwYW5Pbmx5LCB3aW5kb3dUaW1lU3BhbiwgdGltZVNwYW5Pbmx5U3RhdGUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBXaW5kb3dUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHdpbmRvd3MgPSB0aGlzLndpbmRvd3M7XG4gICAgICAgIHZhciBsZW4gPSB3aW5kb3dzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHdpbmRvd18xID0gd2luZG93c1tpXTtcbiAgICAgICAgICAgIGlmICghd2luZG93XzEuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgd2luZG93XzEubmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvd18xLm51bWJlck9mTmV4dGVkVmFsdWVzID49IHRoaXMubWF4V2luZG93U2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlV2luZG93KHdpbmRvd18xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFdpbmRvd1RpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciB3aW5kb3dzID0gdGhpcy53aW5kb3dzO1xuICAgICAgICB3aGlsZSAod2luZG93cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB3aW5kb3dzLnNoaWZ0KCkuZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgfTtcbiAgICBXaW5kb3dUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd2luZG93cyA9IHRoaXMud2luZG93cztcbiAgICAgICAgd2hpbGUgKHdpbmRvd3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIHdpbmRvd18yID0gd2luZG93cy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKCF3aW5kb3dfMi5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3dfMi5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9O1xuICAgIFdpbmRvd1RpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5vcGVuV2luZG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd2luZG93ID0gbmV3IENvdW50ZWRTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMud2luZG93cy5wdXNoKHdpbmRvdyk7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIGRlc3RpbmF0aW9uLm5leHQod2luZG93KTtcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICB9O1xuICAgIFdpbmRvd1RpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5jbG9zZVdpbmRvdyA9IGZ1bmN0aW9uICh3aW5kb3cpIHtcbiAgICAgICAgd2luZG93LmNvbXBsZXRlKCk7XG4gICAgICAgIHZhciB3aW5kb3dzID0gdGhpcy53aW5kb3dzO1xuICAgICAgICB3aW5kb3dzLnNwbGljZSh3aW5kb3dzLmluZGV4T2Yod2luZG93KSwgMSk7XG4gICAgfTtcbiAgICByZXR1cm4gV2luZG93VGltZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5mdW5jdGlvbiBkaXNwYXRjaFdpbmRvd1RpbWVTcGFuT25seShzdGF0ZSkge1xuICAgIHZhciBzdWJzY3JpYmVyID0gc3RhdGUuc3Vic2NyaWJlciwgd2luZG93VGltZVNwYW4gPSBzdGF0ZS53aW5kb3dUaW1lU3Bhbiwgd2luZG93ID0gc3RhdGUud2luZG93O1xuICAgIGlmICh3aW5kb3cpIHtcbiAgICAgICAgc3Vic2NyaWJlci5jbG9zZVdpbmRvdyh3aW5kb3cpO1xuICAgIH1cbiAgICBzdGF0ZS53aW5kb3cgPSBzdWJzY3JpYmVyLm9wZW5XaW5kb3coKTtcbiAgICB0aGlzLnNjaGVkdWxlKHN0YXRlLCB3aW5kb3dUaW1lU3Bhbik7XG59XG5mdW5jdGlvbiBkaXNwYXRjaFdpbmRvd0NyZWF0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHdpbmRvd1RpbWVTcGFuID0gc3RhdGUud2luZG93VGltZVNwYW4sIHN1YnNjcmliZXIgPSBzdGF0ZS5zdWJzY3JpYmVyLCBzY2hlZHVsZXIgPSBzdGF0ZS5zY2hlZHVsZXIsIHdpbmRvd0NyZWF0aW9uSW50ZXJ2YWwgPSBzdGF0ZS53aW5kb3dDcmVhdGlvbkludGVydmFsO1xuICAgIHZhciB3aW5kb3cgPSBzdWJzY3JpYmVyLm9wZW5XaW5kb3coKTtcbiAgICB2YXIgYWN0aW9uID0gdGhpcztcbiAgICB2YXIgY29udGV4dCA9IHsgYWN0aW9uOiBhY3Rpb24sIHN1YnNjcmlwdGlvbjogbnVsbCB9O1xuICAgIHZhciB0aW1lU3BhblN0YXRlID0geyBzdWJzY3JpYmVyOiBzdWJzY3JpYmVyLCB3aW5kb3c6IHdpbmRvdywgY29udGV4dDogY29udGV4dCB9O1xuICAgIGNvbnRleHQuc3Vic2NyaXB0aW9uID0gc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoV2luZG93Q2xvc2UsIHdpbmRvd1RpbWVTcGFuLCB0aW1lU3BhblN0YXRlKTtcbiAgICBhY3Rpb24uYWRkKGNvbnRleHQuc3Vic2NyaXB0aW9uKTtcbiAgICBhY3Rpb24uc2NoZWR1bGUoc3RhdGUsIHdpbmRvd0NyZWF0aW9uSW50ZXJ2YWwpO1xufVxuZnVuY3Rpb24gZGlzcGF0Y2hXaW5kb3dDbG9zZShzdGF0ZSkge1xuICAgIHZhciBzdWJzY3JpYmVyID0gc3RhdGUuc3Vic2NyaWJlciwgd2luZG93ID0gc3RhdGUud2luZG93LCBjb250ZXh0ID0gc3RhdGUuY29udGV4dDtcbiAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0LmFjdGlvbiAmJiBjb250ZXh0LnN1YnNjcmlwdGlvbikge1xuICAgICAgICBjb250ZXh0LmFjdGlvbi5yZW1vdmUoY29udGV4dC5zdWJzY3JpcHRpb24pO1xuICAgIH1cbiAgICBzdWJzY3JpYmVyLmNsb3NlV2luZG93KHdpbmRvdyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13aW5kb3dUaW1lLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9yL3dpbmRvd1RpbWUuanNcbi8vIG1vZHVsZSBpZCA9IDMyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YmplY3RfMSA9IHJlcXVpcmUoJy4uL1N1YmplY3QnKTtcbnZhciBTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmlwdGlvbicpO1xudmFyIHRyeUNhdGNoXzEgPSByZXF1aXJlKCcuLi91dGlsL3RyeUNhdGNoJyk7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvZXJyb3JPYmplY3QnKTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKipcbiAqIEJyYW5jaCBvdXQgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHZhbHVlcyBhcyBhIG5lc3RlZCBPYnNlcnZhYmxlIHN0YXJ0aW5nIGZyb21cbiAqIGFuIGVtaXNzaW9uIGZyb20gYG9wZW5pbmdzYCBhbmQgZW5kaW5nIHdoZW4gdGhlIG91dHB1dCBvZiBgY2xvc2luZ1NlbGVjdG9yYFxuICogZW1pdHMuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgYnVmZmVyVG9nZ2xlfSwgYnV0IGVtaXRzIGEgbmVzdGVkXG4gKiBPYnNlcnZhYmxlIGluc3RlYWQgb2YgYW4gYXJyYXkuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvd2luZG93VG9nZ2xlLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHdpbmRvd3Mgb2YgaXRlbXMgaXQgY29sbGVjdHMgZnJvbSB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLiBUaGUgb3V0cHV0IE9ic2VydmFibGUgZW1pdHMgd2luZG93cyB0aGF0IGNvbnRhaW4gdGhvc2UgaXRlbXNcbiAqIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGJldHdlZW4gdGhlIHRpbWUgd2hlbiB0aGUgYG9wZW5pbmdzYFxuICogT2JzZXJ2YWJsZSBlbWl0cyBhbiBpdGVtIGFuZCB3aGVuIHRoZSBPYnNlcnZhYmxlIHJldHVybmVkIGJ5XG4gKiBgY2xvc2luZ1NlbGVjdG9yYCBlbWl0cyBhbiBpdGVtLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkV2ZXJ5IG90aGVyIHNlY29uZCwgZW1pdCB0aGUgY2xpY2sgZXZlbnRzIGZyb20gdGhlIG5leHQgNTAwbXM8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIG9wZW5pbmdzID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3Mud2luZG93VG9nZ2xlKG9wZW5pbmdzLCBpID0+XG4gKiAgIGkgJSAyID8gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCg1MDApIDogUnguT2JzZXJ2YWJsZS5lbXB0eSgpXG4gKiApLm1lcmdlQWxsKCk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIHdpbmRvd31cbiAqIEBzZWUge0BsaW5rIHdpbmRvd0NvdW50fVxuICogQHNlZSB7QGxpbmsgd2luZG93VGltZX1cbiAqIEBzZWUge0BsaW5rIHdpbmRvd1doZW59XG4gKiBAc2VlIHtAbGluayBidWZmZXJUb2dnbGV9XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlPE8+fSBvcGVuaW5ncyBBbiBvYnNlcnZhYmxlIG9mIG5vdGlmaWNhdGlvbnMgdG8gc3RhcnQgbmV3XG4gKiB3aW5kb3dzLlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogTyk6IE9ic2VydmFibGV9IGNsb3NpbmdTZWxlY3RvciBBIGZ1bmN0aW9uIHRoYXQgdGFrZXNcbiAqIHRoZSB2YWx1ZSBlbWl0dGVkIGJ5IHRoZSBgb3BlbmluZ3NgIG9ic2VydmFibGUgYW5kIHJldHVybnMgYW4gT2JzZXJ2YWJsZSxcbiAqIHdoaWNoLCB3aGVuIGl0IGVtaXRzIChlaXRoZXIgYG5leHRgIG9yIGBjb21wbGV0ZWApLCBzaWduYWxzIHRoYXQgdGhlXG4gKiBhc3NvY2lhdGVkIHdpbmRvdyBzaG91bGQgY29tcGxldGUuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPE9ic2VydmFibGU8VD4+fSBBbiBvYnNlcnZhYmxlIG9mIHdpbmRvd3MsIHdoaWNoIGluIHR1cm5cbiAqIGFyZSBPYnNlcnZhYmxlcy5cbiAqIEBtZXRob2Qgd2luZG93VG9nZ2xlXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiB3aW5kb3dUb2dnbGUob3BlbmluZ3MsIGNsb3NpbmdTZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFdpbmRvd1RvZ2dsZU9wZXJhdG9yKG9wZW5pbmdzLCBjbG9zaW5nU2VsZWN0b3IpKTtcbn1cbmV4cG9ydHMud2luZG93VG9nZ2xlID0gd2luZG93VG9nZ2xlO1xudmFyIFdpbmRvd1RvZ2dsZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBXaW5kb3dUb2dnbGVPcGVyYXRvcihvcGVuaW5ncywgY2xvc2luZ1NlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMub3BlbmluZ3MgPSBvcGVuaW5ncztcbiAgICAgICAgdGhpcy5jbG9zaW5nU2VsZWN0b3IgPSBjbG9zaW5nU2VsZWN0b3I7XG4gICAgfVxuICAgIFdpbmRvd1RvZ2dsZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgV2luZG93VG9nZ2xlU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLm9wZW5pbmdzLCB0aGlzLmNsb3NpbmdTZWxlY3RvcikpO1xuICAgIH07XG4gICAgcmV0dXJuIFdpbmRvd1RvZ2dsZU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgV2luZG93VG9nZ2xlU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFdpbmRvd1RvZ2dsZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gV2luZG93VG9nZ2xlU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgb3BlbmluZ3MsIGNsb3NpbmdTZWxlY3Rvcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMub3BlbmluZ3MgPSBvcGVuaW5ncztcbiAgICAgICAgdGhpcy5jbG9zaW5nU2VsZWN0b3IgPSBjbG9zaW5nU2VsZWN0b3I7XG4gICAgICAgIHRoaXMuY29udGV4dHMgPSBbXTtcbiAgICAgICAgdGhpcy5hZGQodGhpcy5vcGVuU3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBvcGVuaW5ncywgb3BlbmluZ3MpKTtcbiAgICB9XG4gICAgV2luZG93VG9nZ2xlU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGNvbnRleHRzID0gdGhpcy5jb250ZXh0cztcbiAgICAgICAgaWYgKGNvbnRleHRzKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gY29udGV4dHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnRleHRzW2ldLndpbmRvdy5uZXh0KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgV2luZG93VG9nZ2xlU3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB2YXIgY29udGV4dHMgPSB0aGlzLmNvbnRleHRzO1xuICAgICAgICB0aGlzLmNvbnRleHRzID0gbnVsbDtcbiAgICAgICAgaWYgKGNvbnRleHRzKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gY29udGV4dHMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbikge1xuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gY29udGV4dHNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGNvbnRleHQud2luZG93LmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9lcnJvci5jYWxsKHRoaXMsIGVycik7XG4gICAgfTtcbiAgICBXaW5kb3dUb2dnbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb250ZXh0cyA9IHRoaXMuY29udGV4dHM7XG4gICAgICAgIHRoaXMuY29udGV4dHMgPSBudWxsO1xuICAgICAgICBpZiAoY29udGV4dHMpIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSBjb250ZXh0cy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBjb250ZXh0c1tpbmRleF07XG4gICAgICAgICAgICAgICAgY29udGV4dC53aW5kb3cuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuX2NvbXBsZXRlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBXaW5kb3dUb2dnbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb250ZXh0cyA9IHRoaXMuY29udGV4dHM7XG4gICAgICAgIHRoaXMuY29udGV4dHMgPSBudWxsO1xuICAgICAgICBpZiAoY29udGV4dHMpIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSBjb250ZXh0cy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBjb250ZXh0c1tpbmRleF07XG4gICAgICAgICAgICAgICAgY29udGV4dC53aW5kb3cudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBXaW5kb3dUb2dnbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIGlmIChvdXRlclZhbHVlID09PSB0aGlzLm9wZW5pbmdzKSB7XG4gICAgICAgICAgICB2YXIgY2xvc2luZ1NlbGVjdG9yID0gdGhpcy5jbG9zaW5nU2VsZWN0b3I7XG4gICAgICAgICAgICB2YXIgY2xvc2luZ05vdGlmaWVyID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaChjbG9zaW5nU2VsZWN0b3IpKGlubmVyVmFsdWUpO1xuICAgICAgICAgICAgaWYgKGNsb3NpbmdOb3RpZmllciA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgd2luZG93XzEgPSBuZXcgU3ViamVjdF8xLlN1YmplY3QoKTtcbiAgICAgICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbigpO1xuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0geyB3aW5kb3c6IHdpbmRvd18xLCBzdWJzY3JpcHRpb246IHN1YnNjcmlwdGlvbiB9O1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dHMucHVzaChjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB2YXIgaW5uZXJTdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIGNsb3NpbmdOb3RpZmllciwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyU3Vic2NyaXB0aW9uLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlV2luZG93KHRoaXMuY29udGV4dHMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbm5lclN1YnNjcmlwdGlvbi5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLmFkZChpbm5lclN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh3aW5kb3dfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlV2luZG93KHRoaXMuY29udGV4dHMuaW5kZXhPZihvdXRlclZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFdpbmRvd1RvZ2dsZVN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLmVycm9yKGVycik7XG4gICAgfTtcbiAgICBXaW5kb3dUb2dnbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uIChpbm5lcikge1xuICAgICAgICBpZiAoaW5uZXIgIT09IHRoaXMub3BlblN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5jbG9zZVdpbmRvdyh0aGlzLmNvbnRleHRzLmluZGV4T2YoaW5uZXIuY29udGV4dCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBXaW5kb3dUb2dnbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5jbG9zZVdpbmRvdyA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnRleHRzID0gdGhpcy5jb250ZXh0cztcbiAgICAgICAgdmFyIGNvbnRleHQgPSBjb250ZXh0c1tpbmRleF07XG4gICAgICAgIHZhciB3aW5kb3cgPSBjb250ZXh0LndpbmRvdywgc3Vic2NyaXB0aW9uID0gY29udGV4dC5zdWJzY3JpcHRpb247XG4gICAgICAgIGNvbnRleHRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIHdpbmRvdy5jb21wbGV0ZSgpO1xuICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICAgIHJldHVybiBXaW5kb3dUb2dnbGVTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdpbmRvd1RvZ2dsZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvci93aW5kb3dUb2dnbGUuanNcbi8vIG1vZHVsZSBpZCA9IDMyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YmplY3RfMSA9IHJlcXVpcmUoJy4uL1N1YmplY3QnKTtcbnZhciB0cnlDYXRjaF8xID0gcmVxdWlyZSgnLi4vdXRpbC90cnlDYXRjaCcpO1xudmFyIGVycm9yT2JqZWN0XzEgPSByZXF1aXJlKCcuLi91dGlsL2Vycm9yT2JqZWN0Jyk7XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyoqXG4gKiBCcmFuY2ggb3V0IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB2YWx1ZXMgYXMgYSBuZXN0ZWQgT2JzZXJ2YWJsZSB1c2luZyBhXG4gKiBmYWN0b3J5IGZ1bmN0aW9uIG9mIGNsb3NpbmcgT2JzZXJ2YWJsZXMgdG8gZGV0ZXJtaW5lIHdoZW4gdG8gc3RhcnQgYSBuZXdcbiAqIHdpbmRvdy5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SXQncyBsaWtlIHtAbGluayBidWZmZXJXaGVufSwgYnV0IGVtaXRzIGEgbmVzdGVkXG4gKiBPYnNlcnZhYmxlIGluc3RlYWQgb2YgYW4gYXJyYXkuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvd2luZG93V2hlbi5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB3aW5kb3dzIG9mIGl0ZW1zIGl0IGNvbGxlY3RzIGZyb20gdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZS4gVGhlIG91dHB1dCBPYnNlcnZhYmxlIGVtaXRzIGNvbm5lY3RlZCwgbm9uLW92ZXJsYXBwaW5nIHdpbmRvd3MuXG4gKiBJdCBlbWl0cyB0aGUgY3VycmVudCB3aW5kb3cgYW5kIG9wZW5zIGEgbmV3IG9uZSB3aGVuZXZlciB0aGUgT2JzZXJ2YWJsZVxuICogcHJvZHVjZWQgYnkgdGhlIHNwZWNpZmllZCBgY2xvc2luZ1NlbGVjdG9yYCBmdW5jdGlvbiBlbWl0cyBhbiBpdGVtLiBUaGUgZmlyc3RcbiAqIHdpbmRvdyBpcyBvcGVuZWQgaW1tZWRpYXRlbHkgd2hlbiBzdWJzY3JpYmluZyB0byB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdCBvbmx5IHRoZSBmaXJzdCB0d28gY2xpY2tzIGV2ZW50cyBpbiBldmVyeSB3aW5kb3cgb2YgWzEtNV0gcmFuZG9tIHNlY29uZHM8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrc1xuICogICAud2luZG93V2hlbigoKSA9PiBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDAgKyBNYXRoLnJhbmRvbSgpICogNDAwMCkpXG4gKiAgIC5tYXAod2luID0+IHdpbi50YWtlKDIpKSAvLyBlYWNoIHdpbmRvdyBoYXMgYXQgbW9zdCAyIGVtaXNzaW9uc1xuICogICAubWVyZ2VBbGwoKTsgLy8gZmxhdHRlbiB0aGUgT2JzZXJ2YWJsZS1vZi1PYnNlcnZhYmxlc1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayB3aW5kb3d9XG4gKiBAc2VlIHtAbGluayB3aW5kb3dDb3VudH1cbiAqIEBzZWUge0BsaW5rIHdpbmRvd1RpbWV9XG4gKiBAc2VlIHtAbGluayB3aW5kb3dUb2dnbGV9XG4gKiBAc2VlIHtAbGluayBidWZmZXJXaGVufVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogT2JzZXJ2YWJsZX0gY2xvc2luZ1NlbGVjdG9yIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBub1xuICogYXJndW1lbnRzIGFuZCByZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBzaWduYWxzIChvbiBlaXRoZXIgYG5leHRgIG9yXG4gKiBgY29tcGxldGVgKSB3aGVuIHRvIGNsb3NlIHRoZSBwcmV2aW91cyB3aW5kb3cgYW5kIHN0YXJ0IGEgbmV3IG9uZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8T2JzZXJ2YWJsZTxUPj59IEFuIG9ic2VydmFibGUgb2Ygd2luZG93cywgd2hpY2ggaW4gdHVyblxuICogYXJlIE9ic2VydmFibGVzLlxuICogQG1ldGhvZCB3aW5kb3dXaGVuXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiB3aW5kb3dXaGVuKGNsb3NpbmdTZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFdpbmRvd09wZXJhdG9yKGNsb3NpbmdTZWxlY3RvcikpO1xufVxuZXhwb3J0cy53aW5kb3dXaGVuID0gd2luZG93V2hlbjtcbnZhciBXaW5kb3dPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gV2luZG93T3BlcmF0b3IoY2xvc2luZ1NlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuY2xvc2luZ1NlbGVjdG9yID0gY2xvc2luZ1NlbGVjdG9yO1xuICAgIH1cbiAgICBXaW5kb3dPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFdpbmRvd1N1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5jbG9zaW5nU2VsZWN0b3IpKTtcbiAgICB9O1xuICAgIHJldHVybiBXaW5kb3dPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFdpbmRvd1N1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhXaW5kb3dTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFdpbmRvd1N1YnNjcmliZXIoZGVzdGluYXRpb24sIGNsb3NpbmdTZWxlY3Rvcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgdGhpcy5jbG9zaW5nU2VsZWN0b3IgPSBjbG9zaW5nU2VsZWN0b3I7XG4gICAgICAgIHRoaXMub3BlbldpbmRvdygpO1xuICAgIH1cbiAgICBXaW5kb3dTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMub3BlbldpbmRvdyhpbm5lclN1Yik7XG4gICAgfTtcbiAgICBXaW5kb3dTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlFcnJvciA9IGZ1bmN0aW9uIChlcnJvciwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5fZXJyb3IoZXJyb3IpO1xuICAgIH07XG4gICAgV2luZG93U3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5vcGVuV2luZG93KGlubmVyU3ViKTtcbiAgICB9O1xuICAgIFdpbmRvd1N1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMud2luZG93Lm5leHQodmFsdWUpO1xuICAgIH07XG4gICAgV2luZG93U3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLndpbmRvdy5lcnJvcihlcnIpO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmVDbG9zaW5nTm90aWZpY2F0aW9uKCk7XG4gICAgfTtcbiAgICBXaW5kb3dTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMud2luZG93LmNvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZUNsb3NpbmdOb3RpZmljYXRpb24oKTtcbiAgICB9O1xuICAgIFdpbmRvd1N1YnNjcmliZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlQ2xvc2luZ05vdGlmaWNhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2luZ05vdGlmaWNhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5jbG9zaW5nTm90aWZpY2F0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFdpbmRvd1N1YnNjcmliZXIucHJvdG90eXBlLm9wZW5XaW5kb3cgPSBmdW5jdGlvbiAoaW5uZXJTdWIpIHtcbiAgICAgICAgaWYgKGlubmVyU3ViID09PSB2b2lkIDApIHsgaW5uZXJTdWIgPSBudWxsOyB9XG4gICAgICAgIGlmIChpbm5lclN1Yikge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUoaW5uZXJTdWIpO1xuICAgICAgICAgICAgaW5uZXJTdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJldldpbmRvdyA9IHRoaXMud2luZG93O1xuICAgICAgICBpZiAocHJldldpbmRvdykge1xuICAgICAgICAgICAgcHJldldpbmRvdy5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3aW5kb3cgPSB0aGlzLndpbmRvdyA9IG5ldyBTdWJqZWN0XzEuU3ViamVjdCgpO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQod2luZG93KTtcbiAgICAgICAgdmFyIGNsb3NpbmdOb3RpZmllciA9IHRyeUNhdGNoXzEudHJ5Q2F0Y2godGhpcy5jbG9zaW5nU2VsZWN0b3IpKCk7XG4gICAgICAgIGlmIChjbG9zaW5nTm90aWZpZXIgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmU7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICB0aGlzLndpbmRvdy5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hZGQodGhpcy5jbG9zaW5nTm90aWZpY2F0aW9uID0gc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBjbG9zaW5nTm90aWZpZXIpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFdpbmRvd1N1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2luZG93V2hlbi5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvci93aW5kb3dXaGVuLmpzXG4vLyBtb2R1bGUgaWQgPSAzMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBDb21iaW5lcyB0aGUgc291cmNlIE9ic2VydmFibGUgd2l0aCBvdGhlciBPYnNlcnZhYmxlcyB0byBjcmVhdGUgYW4gT2JzZXJ2YWJsZVxuICogd2hvc2UgdmFsdWVzIGFyZSBjYWxjdWxhdGVkIGZyb20gdGhlIGxhdGVzdCB2YWx1ZXMgb2YgZWFjaCwgb25seSB3aGVuIHRoZVxuICogc291cmNlIGVtaXRzLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5XaGVuZXZlciB0aGUgc291cmNlIE9ic2VydmFibGUgZW1pdHMgYSB2YWx1ZSwgaXRcbiAqIGNvbXB1dGVzIGEgZm9ybXVsYSB1c2luZyB0aGF0IHZhbHVlIHBsdXMgdGhlIGxhdGVzdCB2YWx1ZXMgZnJvbSBvdGhlciBpbnB1dFxuICogT2JzZXJ2YWJsZXMsIHRoZW4gZW1pdHMgdGhlIG91dHB1dCBvZiB0aGF0IGZvcm11bGEuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvd2l0aExhdGVzdEZyb20ucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYHdpdGhMYXRlc3RGcm9tYCBjb21iaW5lcyBlYWNoIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlICh0aGVcbiAqIGluc3RhbmNlKSB3aXRoIHRoZSBsYXRlc3QgdmFsdWVzIGZyb20gdGhlIG90aGVyIGlucHV0IE9ic2VydmFibGVzIG9ubHkgd2hlblxuICogdGhlIHNvdXJjZSBlbWl0cyBhIHZhbHVlLCBvcHRpb25hbGx5IHVzaW5nIGEgYHByb2plY3RgIGZ1bmN0aW9uIHRvIGRldGVybWluZVxuICogdGhlIHZhbHVlIHRvIGJlIGVtaXR0ZWQgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLiBBbGwgaW5wdXQgT2JzZXJ2YWJsZXMgbXVzdFxuICogZW1pdCBhdCBsZWFzdCBvbmUgdmFsdWUgYmVmb3JlIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSB3aWxsIGVtaXQgYSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5PbiBldmVyeSBjbGljayBldmVudCwgZW1pdCBhbiBhcnJheSB3aXRoIHRoZSBsYXRlc3QgdGltZXIgZXZlbnQgcGx1cyB0aGUgY2xpY2sgZXZlbnQ8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHRpbWVyID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3Mud2l0aExhdGVzdEZyb20odGltZXIpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBjb21iaW5lTGF0ZXN0fVxuICpcbiAqIEBwYXJhbSB7T2JzZXJ2YWJsZUlucHV0fSBvdGhlciBBbiBpbnB1dCBPYnNlcnZhYmxlIHRvIGNvbWJpbmUgd2l0aCB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLiBNb3JlIHRoYW4gb25lIGlucHV0IE9ic2VydmFibGVzIG1heSBiZSBnaXZlbiBhcyBhcmd1bWVudC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcm9qZWN0XSBQcm9qZWN0aW9uIGZ1bmN0aW9uIGZvciBjb21iaW5pbmcgdmFsdWVzXG4gKiB0b2dldGhlci4gUmVjZWl2ZXMgYWxsIHZhbHVlcyBpbiBvcmRlciBvZiB0aGUgT2JzZXJ2YWJsZXMgcGFzc2VkLCB3aGVyZSB0aGVcbiAqIGZpcnN0IHBhcmFtZXRlciBpcyBhIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiAoZS5nLlxuICogYGEud2l0aExhdGVzdEZyb20oYiwgYywgKGExLCBiMSwgYzEpID0+IGExICsgYjEgKyBjMSlgKS4gSWYgdGhpcyBpcyBub3RcbiAqIHBhc3NlZCwgYXJyYXlzIHdpbGwgYmUgZW1pdHRlZCBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIG9mIHByb2plY3RlZCB2YWx1ZXMgZnJvbSB0aGUgbW9zdCByZWNlbnRcbiAqIHZhbHVlcyBmcm9tIGVhY2ggaW5wdXQgT2JzZXJ2YWJsZSwgb3IgYW4gYXJyYXkgb2YgdGhlIG1vc3QgcmVjZW50IHZhbHVlcyBmcm9tXG4gKiBlYWNoIGlucHV0IE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIHdpdGhMYXRlc3RGcm9tXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiB3aXRoTGF0ZXN0RnJvbSgpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBwcm9qZWN0O1xuICAgIGlmICh0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHByb2plY3QgPSBhcmdzLnBvcCgpO1xuICAgIH1cbiAgICB2YXIgb2JzZXJ2YWJsZXMgPSBhcmdzO1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFdpdGhMYXRlc3RGcm9tT3BlcmF0b3Iob2JzZXJ2YWJsZXMsIHByb2plY3QpKTtcbn1cbmV4cG9ydHMud2l0aExhdGVzdEZyb20gPSB3aXRoTGF0ZXN0RnJvbTtcbnZhciBXaXRoTGF0ZXN0RnJvbU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBXaXRoTGF0ZXN0RnJvbU9wZXJhdG9yKG9ic2VydmFibGVzLCBwcm9qZWN0KSB7XG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZXMgPSBvYnNlcnZhYmxlcztcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgICB9XG4gICAgV2l0aExhdGVzdEZyb21PcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFdpdGhMYXRlc3RGcm9tU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLm9ic2VydmFibGVzLCB0aGlzLnByb2plY3QpKTtcbiAgICB9O1xuICAgIHJldHVybiBXaXRoTGF0ZXN0RnJvbU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgV2l0aExhdGVzdEZyb21TdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoV2l0aExhdGVzdEZyb21TdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFdpdGhMYXRlc3RGcm9tU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgb2JzZXJ2YWJsZXMsIHByb2plY3QpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLm9ic2VydmFibGVzID0gb2JzZXJ2YWJsZXM7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgICAgIHRoaXMudG9SZXNwb25kID0gW107XG4gICAgICAgIHZhciBsZW4gPSBvYnNlcnZhYmxlcy5sZW5ndGg7XG4gICAgICAgIHRoaXMudmFsdWVzID0gbmV3IEFycmF5KGxlbik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMudG9SZXNwb25kLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIG9ic2VydmFibGUgPSBvYnNlcnZhYmxlc1tpXTtcbiAgICAgICAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgb2JzZXJ2YWJsZSwgb2JzZXJ2YWJsZSwgaSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFdpdGhMYXRlc3RGcm9tU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLnZhbHVlc1tvdXRlckluZGV4XSA9IGlubmVyVmFsdWU7XG4gICAgICAgIHZhciB0b1Jlc3BvbmQgPSB0aGlzLnRvUmVzcG9uZDtcbiAgICAgICAgaWYgKHRvUmVzcG9uZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgZm91bmQgPSB0b1Jlc3BvbmQuaW5kZXhPZihvdXRlckluZGV4KTtcbiAgICAgICAgICAgIGlmIChmb3VuZCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0b1Jlc3BvbmQuc3BsaWNlKGZvdW5kLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgV2l0aExhdGVzdEZyb21TdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gbm9vcFxuICAgIH07XG4gICAgV2l0aExhdGVzdEZyb21TdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy50b1Jlc3BvbmQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFt2YWx1ZV0uY29uY2F0KHRoaXMudmFsdWVzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb2plY3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90cnlQcm9qZWN0KGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBXaXRoTGF0ZXN0RnJvbVN1YnNjcmliZXIucHJvdG90eXBlLl90cnlQcm9qZWN0ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucHJvamVjdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHJlc3VsdCk7XG4gICAgfTtcbiAgICByZXR1cm4gV2l0aExhdGVzdEZyb21TdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdpdGhMYXRlc3RGcm9tLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9yL3dpdGhMYXRlc3RGcm9tLmpzXG4vLyBtb2R1bGUgaWQgPSAzMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgemlwXzEgPSByZXF1aXJlKCcuL3ppcCcpO1xuLyoqXG4gKiBAcGFyYW0gcHJvamVjdFxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxSPnxXZWJTb2NrZXRTdWJqZWN0PFQ+fE9ic2VydmFibGU8VD59XG4gKiBAbWV0aG9kIHppcEFsbFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gemlwQWxsKHByb2plY3QpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyB6aXBfMS5aaXBPcGVyYXRvcihwcm9qZWN0KSk7XG59XG5leHBvcnRzLnppcEFsbCA9IHppcEFsbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXppcEFsbC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvci96aXBBbGwuanNcbi8vIG1vZHVsZSBpZCA9IDMzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaXB0aW9uJyk7XG4vKipcbiAqIEEgdW5pdCBvZiB3b3JrIHRvIGJlIGV4ZWN1dGVkIGluIGEge0BsaW5rIFNjaGVkdWxlcn0uIEFuIGFjdGlvbiBpcyB0eXBpY2FsbHlcbiAqIGNyZWF0ZWQgZnJvbSB3aXRoaW4gYSBTY2hlZHVsZXIgYW5kIGFuIFJ4SlMgdXNlciBkb2VzIG5vdCBuZWVkIHRvIGNvbmNlcm5cbiAqIHRoZW1zZWx2ZXMgYWJvdXQgY3JlYXRpbmcgYW5kIG1hbmlwdWxhdGluZyBhbiBBY3Rpb24uXG4gKlxuICogYGBgdHNcbiAqIGNsYXNzIEFjdGlvbjxUPiBleHRlbmRzIFN1YnNjcmlwdGlvbiB7XG4gKiAgIG5ldyAoc2NoZWR1bGVyOiBTY2hlZHVsZXIsIHdvcms6IChzdGF0ZT86IFQpID0+IHZvaWQpO1xuICogICBzY2hlZHVsZShzdGF0ZT86IFQsIGRlbGF5OiBudW1iZXIgPSAwKTogU3Vic2NyaXB0aW9uO1xuICogfVxuICogYGBgXG4gKlxuICogQGNsYXNzIEFjdGlvbjxUPlxuICovXG52YXIgQWN0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWN0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFjdGlvbihzY2hlZHVsZXIsIHdvcmspIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlcyB0aGlzIGFjdGlvbiBvbiBpdHMgcGFyZW50IFNjaGVkdWxlciBmb3IgZXhlY3V0aW9uLiBNYXkgYmUgcGFzc2VkXG4gICAgICogc29tZSBjb250ZXh0IG9iamVjdCwgYHN0YXRlYC4gTWF5IGhhcHBlbiBhdCBzb21lIHBvaW50IGluIHRoZSBmdXR1cmUsXG4gICAgICogYWNjb3JkaW5nIHRvIHRoZSBgZGVsYXlgIHBhcmFtZXRlciwgaWYgc3BlY2lmaWVkLlxuICAgICAqIEBwYXJhbSB7VH0gW3N0YXRlXSBTb21lIGNvbnRleHR1YWwgZGF0YSB0aGF0IHRoZSBgd29ya2AgZnVuY3Rpb24gdXNlcyB3aGVuXG4gICAgICogY2FsbGVkIGJ5IHRoZSBTY2hlZHVsZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheV0gVGltZSB0byB3YWl0IGJlZm9yZSBleGVjdXRpbmcgdGhlIHdvcmssIHdoZXJlIHRoZVxuICAgICAqIHRpbWUgdW5pdCBpcyBpbXBsaWNpdCBhbmQgZGVmaW5lZCBieSB0aGUgU2NoZWR1bGVyLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgQWN0aW9uLnByb3RvdHlwZS5zY2hlZHVsZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZGVsYXkpIHtcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSAwOyB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIEFjdGlvbjtcbn0oU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKSk7XG5leHBvcnRzLkFjdGlvbiA9IEFjdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFjdGlvbi5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9zY2hlZHVsZXIvQWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAzMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBBc3luY0FjdGlvbl8xID0gcmVxdWlyZSgnLi9Bc3luY0FjdGlvbicpO1xudmFyIEFuaW1hdGlvbkZyYW1lXzEgPSByZXF1aXJlKCcuLi91dGlsL0FuaW1hdGlvbkZyYW1lJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIEFuaW1hdGlvbkZyYW1lQWN0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQW5pbWF0aW9uRnJhbWVBY3Rpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQW5pbWF0aW9uRnJhbWVBY3Rpb24oc2NoZWR1bGVyLCB3b3JrKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHNjaGVkdWxlciwgd29yayk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLndvcmsgPSB3b3JrO1xuICAgIH1cbiAgICBBbmltYXRpb25GcmFtZUFjdGlvbi5wcm90b3R5cGUucmVxdWVzdEFzeW5jSWQgPSBmdW5jdGlvbiAoc2NoZWR1bGVyLCBpZCwgZGVsYXkpIHtcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSAwOyB9XG4gICAgICAgIC8vIElmIGRlbGF5IGlzIGdyZWF0ZXIgdGhhbiAwLCByZXF1ZXN0IGFzIGFuIGFzeW5jIGFjdGlvbi5cbiAgICAgICAgaWYgKGRlbGF5ICE9PSBudWxsICYmIGRlbGF5ID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUucmVxdWVzdEFzeW5jSWQuY2FsbCh0aGlzLCBzY2hlZHVsZXIsIGlkLCBkZWxheSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHVzaCB0aGUgYWN0aW9uIHRvIHRoZSBlbmQgb2YgdGhlIHNjaGVkdWxlciBxdWV1ZS5cbiAgICAgICAgc2NoZWR1bGVyLmFjdGlvbnMucHVzaCh0aGlzKTtcbiAgICAgICAgLy8gSWYgYW4gYW5pbWF0aW9uIGZyYW1lIGhhcyBhbHJlYWR5IGJlZW4gcmVxdWVzdGVkLCBkb24ndCByZXF1ZXN0IGFub3RoZXJcbiAgICAgICAgLy8gb25lLiBJZiBhbiBhbmltYXRpb24gZnJhbWUgaGFzbid0IGJlZW4gcmVxdWVzdGVkIHlldCwgcmVxdWVzdCBvbmUuIFJldHVyblxuICAgICAgICAvLyB0aGUgY3VycmVudCBhbmltYXRpb24gZnJhbWUgcmVxdWVzdCBpZC5cbiAgICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZWQgfHwgKHNjaGVkdWxlci5zY2hlZHVsZWQgPSBBbmltYXRpb25GcmFtZV8xLkFuaW1hdGlvbkZyYW1lLnJlcXVlc3RBbmltYXRpb25GcmFtZShzY2hlZHVsZXIuZmx1c2guYmluZChzY2hlZHVsZXIsIG51bGwpKSk7XG4gICAgfTtcbiAgICBBbmltYXRpb25GcmFtZUFjdGlvbi5wcm90b3R5cGUucmVjeWNsZUFzeW5jSWQgPSBmdW5jdGlvbiAoc2NoZWR1bGVyLCBpZCwgZGVsYXkpIHtcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSAwOyB9XG4gICAgICAgIC8vIElmIGRlbGF5IGV4aXN0cyBhbmQgaXMgZ3JlYXRlciB0aGFuIDAsIG9yIGlmIHRoZSBkZWxheSBpcyBudWxsICh0aGVcbiAgICAgICAgLy8gYWN0aW9uIHdhc24ndCByZXNjaGVkdWxlZCkgYnV0IHdhcyBvcmlnaW5hbGx5IHNjaGVkdWxlZCBhcyBhbiBhc3luY1xuICAgICAgICAvLyBhY3Rpb24sIHRoZW4gcmVjeWNsZSBhcyBhbiBhc3luYyBhY3Rpb24uXG4gICAgICAgIGlmICgoZGVsYXkgIT09IG51bGwgJiYgZGVsYXkgPiAwKSB8fCAoZGVsYXkgPT09IG51bGwgJiYgdGhpcy5kZWxheSA+IDApKSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5yZWN5Y2xlQXN5bmNJZC5jYWxsKHRoaXMsIHNjaGVkdWxlciwgaWQsIGRlbGF5KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgc2NoZWR1bGVyIHF1ZXVlIGlzIGVtcHR5LCBjYW5jZWwgdGhlIHJlcXVlc3RlZCBhbmltYXRpb24gZnJhbWUgYW5kXG4gICAgICAgIC8vIHNldCB0aGUgc2NoZWR1bGVkIGZsYWcgdG8gdW5kZWZpbmVkIHNvIHRoZSBuZXh0IEFuaW1hdGlvbkZyYW1lQWN0aW9uIHdpbGxcbiAgICAgICAgLy8gcmVxdWVzdCBpdHMgb3duLlxuICAgICAgICBpZiAoc2NoZWR1bGVyLmFjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBBbmltYXRpb25GcmFtZV8xLkFuaW1hdGlvbkZyYW1lLmNhbmNlbEFuaW1hdGlvbkZyYW1lKGlkKTtcbiAgICAgICAgICAgIHNjaGVkdWxlci5zY2hlZHVsZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIHVuZGVmaW5lZCBzbyB0aGUgYWN0aW9uIGtub3dzIHRvIHJlcXVlc3QgYSBuZXcgYXN5bmMgaWQgaWYgaXQncyByZXNjaGVkdWxlZC5cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIHJldHVybiBBbmltYXRpb25GcmFtZUFjdGlvbjtcbn0oQXN5bmNBY3Rpb25fMS5Bc3luY0FjdGlvbikpO1xuZXhwb3J0cy5BbmltYXRpb25GcmFtZUFjdGlvbiA9IEFuaW1hdGlvbkZyYW1lQWN0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QW5pbWF0aW9uRnJhbWVBY3Rpb24uanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvc2NoZWR1bGVyL0FuaW1hdGlvbkZyYW1lQWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAzMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBBc3luY1NjaGVkdWxlcl8xID0gcmVxdWlyZSgnLi9Bc3luY1NjaGVkdWxlcicpO1xudmFyIEFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQW5pbWF0aW9uRnJhbWVTY2hlZHVsZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQW5pbWF0aW9uRnJhbWVTY2hlZHVsZXIoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBBbmltYXRpb25GcmFtZVNjaGVkdWxlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBhY3Rpb25zID0gdGhpcy5hY3Rpb25zO1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICB2YXIgY291bnQgPSBhY3Rpb25zLmxlbmd0aDtcbiAgICAgICAgYWN0aW9uID0gYWN0aW9uIHx8IGFjdGlvbnMuc2hpZnQoKTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKGVycm9yID0gYWN0aW9uLmV4ZWN1dGUoYWN0aW9uLnN0YXRlLCBhY3Rpb24uZGVsYXkpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKCsraW5kZXggPCBjb3VudCAmJiAoYWN0aW9uID0gYWN0aW9ucy5zaGlmdCgpKSk7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBjb3VudCAmJiAoYWN0aW9uID0gYWN0aW9ucy5zaGlmdCgpKSkge1xuICAgICAgICAgICAgICAgIGFjdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBBbmltYXRpb25GcmFtZVNjaGVkdWxlcjtcbn0oQXN5bmNTY2hlZHVsZXJfMS5Bc3luY1NjaGVkdWxlcikpO1xuZXhwb3J0cy5BbmltYXRpb25GcmFtZVNjaGVkdWxlciA9IEFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QW5pbWF0aW9uRnJhbWVTY2hlZHVsZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvc2NoZWR1bGVyL0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBJbW1lZGlhdGVfMSA9IHJlcXVpcmUoJy4uL3V0aWwvSW1tZWRpYXRlJyk7XG52YXIgQXN5bmNBY3Rpb25fMSA9IHJlcXVpcmUoJy4vQXN5bmNBY3Rpb24nKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgQXNhcEFjdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFzYXBBY3Rpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXNhcEFjdGlvbihzY2hlZHVsZXIsIHdvcmspIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc2NoZWR1bGVyLCB3b3JrKTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIHRoaXMud29yayA9IHdvcms7XG4gICAgfVxuICAgIEFzYXBBY3Rpb24ucHJvdG90eXBlLnJlcXVlc3RBc3luY0lkID0gZnVuY3Rpb24gKHNjaGVkdWxlciwgaWQsIGRlbGF5KSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxuICAgICAgICAvLyBJZiBkZWxheSBpcyBncmVhdGVyIHRoYW4gMCwgcmVxdWVzdCBhcyBhbiBhc3luYyBhY3Rpb24uXG4gICAgICAgIGlmIChkZWxheSAhPT0gbnVsbCAmJiBkZWxheSA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnJlcXVlc3RBc3luY0lkLmNhbGwodGhpcywgc2NoZWR1bGVyLCBpZCwgZGVsYXkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFB1c2ggdGhlIGFjdGlvbiB0byB0aGUgZW5kIG9mIHRoZSBzY2hlZHVsZXIgcXVldWUuXG4gICAgICAgIHNjaGVkdWxlci5hY3Rpb25zLnB1c2godGhpcyk7XG4gICAgICAgIC8vIElmIGEgbWljcm90YXNrIGhhcyBhbHJlYWR5IGJlZW4gc2NoZWR1bGVkLCBkb24ndCBzY2hlZHVsZSBhbm90aGVyXG4gICAgICAgIC8vIG9uZS4gSWYgYSBtaWNyb3Rhc2sgaGFzbid0IGJlZW4gc2NoZWR1bGVkIHlldCwgc2NoZWR1bGUgb25lIG5vdy4gUmV0dXJuXG4gICAgICAgIC8vIHRoZSBjdXJyZW50IHNjaGVkdWxlZCBtaWNyb3Rhc2sgaWQuXG4gICAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGVkIHx8IChzY2hlZHVsZXIuc2NoZWR1bGVkID0gSW1tZWRpYXRlXzEuSW1tZWRpYXRlLnNldEltbWVkaWF0ZShzY2hlZHVsZXIuZmx1c2guYmluZChzY2hlZHVsZXIsIG51bGwpKSk7XG4gICAgfTtcbiAgICBBc2FwQWN0aW9uLnByb3RvdHlwZS5yZWN5Y2xlQXN5bmNJZCA9IGZ1bmN0aW9uIChzY2hlZHVsZXIsIGlkLCBkZWxheSkge1xuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cbiAgICAgICAgLy8gSWYgZGVsYXkgZXhpc3RzIGFuZCBpcyBncmVhdGVyIHRoYW4gMCwgb3IgaWYgdGhlIGRlbGF5IGlzIG51bGwgKHRoZVxuICAgICAgICAvLyBhY3Rpb24gd2Fzbid0IHJlc2NoZWR1bGVkKSBidXQgd2FzIG9yaWdpbmFsbHkgc2NoZWR1bGVkIGFzIGFuIGFzeW5jXG4gICAgICAgIC8vIGFjdGlvbiwgdGhlbiByZWN5Y2xlIGFzIGFuIGFzeW5jIGFjdGlvbi5cbiAgICAgICAgaWYgKChkZWxheSAhPT0gbnVsbCAmJiBkZWxheSA+IDApIHx8IChkZWxheSA9PT0gbnVsbCAmJiB0aGlzLmRlbGF5ID4gMCkpIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnJlY3ljbGVBc3luY0lkLmNhbGwodGhpcywgc2NoZWR1bGVyLCBpZCwgZGVsYXkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBzY2hlZHVsZXIgcXVldWUgaXMgZW1wdHksIGNhbmNlbCB0aGUgcmVxdWVzdGVkIG1pY3JvdGFzayBhbmRcbiAgICAgICAgLy8gc2V0IHRoZSBzY2hlZHVsZWQgZmxhZyB0byB1bmRlZmluZWQgc28gdGhlIG5leHQgQXNhcEFjdGlvbiB3aWxsIHNjaGVkdWxlXG4gICAgICAgIC8vIGl0cyBvd24uXG4gICAgICAgIGlmIChzY2hlZHVsZXIuYWN0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIEltbWVkaWF0ZV8xLkltbWVkaWF0ZS5jbGVhckltbWVkaWF0ZShpZCk7XG4gICAgICAgICAgICBzY2hlZHVsZXIuc2NoZWR1bGVkID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiB1bmRlZmluZWQgc28gdGhlIGFjdGlvbiBrbm93cyB0byByZXF1ZXN0IGEgbmV3IGFzeW5jIGlkIGlmIGl0J3MgcmVzY2hlZHVsZWQuXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICByZXR1cm4gQXNhcEFjdGlvbjtcbn0oQXN5bmNBY3Rpb25fMS5Bc3luY0FjdGlvbikpO1xuZXhwb3J0cy5Bc2FwQWN0aW9uID0gQXNhcEFjdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFzYXBBY3Rpb24uanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvc2NoZWR1bGVyL0FzYXBBY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDMzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIEFzeW5jU2NoZWR1bGVyXzEgPSByZXF1aXJlKCcuL0FzeW5jU2NoZWR1bGVyJyk7XG52YXIgQXNhcFNjaGVkdWxlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFzYXBTY2hlZHVsZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXNhcFNjaGVkdWxlcigpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEFzYXBTY2hlZHVsZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVkID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgYWN0aW9ucyA9IHRoaXMuYWN0aW9ucztcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgdmFyIGNvdW50ID0gYWN0aW9ucy5sZW5ndGg7XG4gICAgICAgIGFjdGlvbiA9IGFjdGlvbiB8fCBhY3Rpb25zLnNoaWZ0KCk7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChlcnJvciA9IGFjdGlvbi5leGVjdXRlKGFjdGlvbi5zdGF0ZSwgYWN0aW9uLmRlbGF5KSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlICgrK2luZGV4IDwgY291bnQgJiYgKGFjdGlvbiA9IGFjdGlvbnMuc2hpZnQoKSkpO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgY291bnQgJiYgKGFjdGlvbiA9IGFjdGlvbnMuc2hpZnQoKSkpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQXNhcFNjaGVkdWxlcjtcbn0oQXN5bmNTY2hlZHVsZXJfMS5Bc3luY1NjaGVkdWxlcikpO1xuZXhwb3J0cy5Bc2FwU2NoZWR1bGVyID0gQXNhcFNjaGVkdWxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFzYXBTY2hlZHVsZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvc2NoZWR1bGVyL0FzYXBTY2hlZHVsZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIEFzeW5jQWN0aW9uXzEgPSByZXF1aXJlKCcuL0FzeW5jQWN0aW9uJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFF1ZXVlQWN0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUXVldWVBY3Rpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUXVldWVBY3Rpb24oc2NoZWR1bGVyLCB3b3JrKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHNjaGVkdWxlciwgd29yayk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLndvcmsgPSB3b3JrO1xuICAgIH1cbiAgICBRdWV1ZUFjdGlvbi5wcm90b3R5cGUuc2NoZWR1bGUgPSBmdW5jdGlvbiAoc3RhdGUsIGRlbGF5KSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxuICAgICAgICBpZiAoZGVsYXkgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5zY2hlZHVsZS5jYWxsKHRoaXMsIHN0YXRlLCBkZWxheSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWxheSA9IGRlbGF5O1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyLmZsdXNoKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFF1ZXVlQWN0aW9uLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKHN0YXRlLCBkZWxheSkge1xuICAgICAgICByZXR1cm4gKGRlbGF5ID4gMCB8fCB0aGlzLmNsb3NlZCkgP1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5leGVjdXRlLmNhbGwodGhpcywgc3RhdGUsIGRlbGF5KSA6XG4gICAgICAgICAgICB0aGlzLl9leGVjdXRlKHN0YXRlLCBkZWxheSk7XG4gICAgfTtcbiAgICBRdWV1ZUFjdGlvbi5wcm90b3R5cGUucmVxdWVzdEFzeW5jSWQgPSBmdW5jdGlvbiAoc2NoZWR1bGVyLCBpZCwgZGVsYXkpIHtcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSAwOyB9XG4gICAgICAgIC8vIElmIGRlbGF5IGV4aXN0cyBhbmQgaXMgZ3JlYXRlciB0aGFuIDAsIG9yIGlmIHRoZSBkZWxheSBpcyBudWxsICh0aGVcbiAgICAgICAgLy8gYWN0aW9uIHdhc24ndCByZXNjaGVkdWxlZCkgYnV0IHdhcyBvcmlnaW5hbGx5IHNjaGVkdWxlZCBhcyBhbiBhc3luY1xuICAgICAgICAvLyBhY3Rpb24sIHRoZW4gcmVjeWNsZSBhcyBhbiBhc3luYyBhY3Rpb24uXG4gICAgICAgIGlmICgoZGVsYXkgIT09IG51bGwgJiYgZGVsYXkgPiAwKSB8fCAoZGVsYXkgPT09IG51bGwgJiYgdGhpcy5kZWxheSA+IDApKSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5yZXF1ZXN0QXN5bmNJZC5jYWxsKHRoaXMsIHNjaGVkdWxlciwgaWQsIGRlbGF5KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UgZmx1c2ggdGhlIHNjaGVkdWxlciBzdGFydGluZyB3aXRoIHRoaXMgYWN0aW9uLlxuICAgICAgICByZXR1cm4gc2NoZWR1bGVyLmZsdXNoKHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIFF1ZXVlQWN0aW9uO1xufShBc3luY0FjdGlvbl8xLkFzeW5jQWN0aW9uKSk7XG5leHBvcnRzLlF1ZXVlQWN0aW9uID0gUXVldWVBY3Rpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1RdWV1ZUFjdGlvbi5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9zY2hlZHVsZXIvUXVldWVBY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDMzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIEFzeW5jU2NoZWR1bGVyXzEgPSByZXF1aXJlKCcuL0FzeW5jU2NoZWR1bGVyJyk7XG52YXIgUXVldWVTY2hlZHVsZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhRdWV1ZVNjaGVkdWxlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBRdWV1ZVNjaGVkdWxlcigpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBRdWV1ZVNjaGVkdWxlcjtcbn0oQXN5bmNTY2hlZHVsZXJfMS5Bc3luY1NjaGVkdWxlcikpO1xuZXhwb3J0cy5RdWV1ZVNjaGVkdWxlciA9IFF1ZXVlU2NoZWR1bGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UXVldWVTY2hlZHVsZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvc2NoZWR1bGVyL1F1ZXVlU2NoZWR1bGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQW5pbWF0aW9uRnJhbWVBY3Rpb25fMSA9IHJlcXVpcmUoJy4vQW5pbWF0aW9uRnJhbWVBY3Rpb24nKTtcbnZhciBBbmltYXRpb25GcmFtZVNjaGVkdWxlcl8xID0gcmVxdWlyZSgnLi9BbmltYXRpb25GcmFtZVNjaGVkdWxlcicpO1xuLyoqXG4gKlxuICogQW5pbWF0aW9uIEZyYW1lIFNjaGVkdWxlclxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5QZXJmb3JtIHRhc2sgd2hlbiBgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZWAgd291bGQgZmlyZTwvc3Bhbj5cbiAqXG4gKiBXaGVuIGBhbmltYXRpb25GcmFtZWAgc2NoZWR1bGVyIGlzIHVzZWQgd2l0aCBkZWxheSwgaXQgd2lsbCBmYWxsIGJhY2sgdG8ge0BsaW5rIGFzeW5jfSBzY2hlZHVsZXJcbiAqIGJlaGF2aW91ci5cbiAqXG4gKiBXaXRob3V0IGRlbGF5LCBgYW5pbWF0aW9uRnJhbWVgIHNjaGVkdWxlciBjYW4gYmUgdXNlZCB0byBjcmVhdGUgc21vb3RoIGJyb3dzZXIgYW5pbWF0aW9ucy5cbiAqIEl0IG1ha2VzIHN1cmUgc2NoZWR1bGVkIHRhc2sgd2lsbCBoYXBwZW4ganVzdCBiZWZvcmUgbmV4dCBicm93c2VyIGNvbnRlbnQgcmVwYWludCxcbiAqIHRodXMgcGVyZm9ybWluZyBhbmltYXRpb25zIGFzIGVmZmljaWVudGx5IGFzIHBvc3NpYmxlLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlNjaGVkdWxlIGRpdiBoZWlnaHQgYW5pbWF0aW9uPC9jYXB0aW9uPlxuICogY29uc3QgZGl2ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnNvbWUtZGl2Jyk7XG4gKlxuICogUnguU2NoZWR1bGVyLnNjaGVkdWxlKGZ1bmN0aW9uKGhlaWdodCkge1xuICogICBkaXYuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgXCJweFwiO1xuICpcbiAqICAgdGhpcy5zY2hlZHVsZShoZWlnaHQgKyAxKTsgIC8vIGB0aGlzYCByZWZlcmVuY2VzIGN1cnJlbnRseSBleGVjdXRpbmcgQWN0aW9uLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggd2UgcmVzY2hlZHVsZSB3aXRoIG5ldyBzdGF0ZVxuICogfSwgMCwgMCk7XG4gKlxuICogLy8gWW91IHdpbGwgc2VlIC5zb21lLWRpdiBlbGVtZW50IGdyb3dpbmcgaW4gaGVpZ2h0XG4gKlxuICpcbiAqIEBzdGF0aWMgdHJ1ZVxuICogQG5hbWUgYW5pbWF0aW9uRnJhbWVcbiAqIEBvd25lciBTY2hlZHVsZXJcbiAqL1xuZXhwb3J0cy5hbmltYXRpb25GcmFtZSA9IG5ldyBBbmltYXRpb25GcmFtZVNjaGVkdWxlcl8xLkFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyKEFuaW1hdGlvbkZyYW1lQWN0aW9uXzEuQW5pbWF0aW9uRnJhbWVBY3Rpb24pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW5pbWF0aW9uRnJhbWUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvc2NoZWR1bGVyL2FuaW1hdGlvbkZyYW1lLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpcHRpb24nKTtcbnZhciBTdWJzY3JpcHRpb25Mb2dnYWJsZV8xID0gcmVxdWlyZSgnLi9TdWJzY3JpcHRpb25Mb2dnYWJsZScpO1xudmFyIGFwcGx5TWl4aW5zXzEgPSByZXF1aXJlKCcuLi91dGlsL2FwcGx5TWl4aW5zJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIENvbGRPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29sZE9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29sZE9ic2VydmFibGUobWVzc2FnZXMsIHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgdmFyIG9ic2VydmFibGUgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gb2JzZXJ2YWJsZS5sb2dTdWJzY3JpYmVkRnJhbWUoKTtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuYWRkKG5ldyBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG9ic2VydmFibGUubG9nVW5zdWJzY3JpYmVkRnJhbWUoaW5kZXgpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgb2JzZXJ2YWJsZS5zY2hlZHVsZU1lc3NhZ2VzKHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmliZXI7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1lc3NhZ2VzID0gbWVzc2FnZXM7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgQ29sZE9ic2VydmFibGUucHJvdG90eXBlLnNjaGVkdWxlTWVzc2FnZXMgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgbWVzc2FnZXNMZW5ndGggPSB0aGlzLm1lc3NhZ2VzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IHRoaXMubWVzc2FnZXNbaV07XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmFkZCh0aGlzLnNjaGVkdWxlci5zY2hlZHVsZShmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IF9hLm1lc3NhZ2UsIHN1YnNjcmliZXIgPSBfYS5zdWJzY3JpYmVyO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2Uubm90aWZpY2F0aW9uLm9ic2VydmUoc3Vic2NyaWJlcik7XG4gICAgICAgICAgICB9LCBtZXNzYWdlLmZyYW1lLCB7IG1lc3NhZ2U6IG1lc3NhZ2UsIHN1YnNjcmliZXI6IHN1YnNjcmliZXIgfSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ29sZE9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLkNvbGRPYnNlcnZhYmxlID0gQ29sZE9ic2VydmFibGU7XG5hcHBseU1peGluc18xLmFwcGx5TWl4aW5zKENvbGRPYnNlcnZhYmxlLCBbU3Vic2NyaXB0aW9uTG9nZ2FibGVfMS5TdWJzY3JpcHRpb25Mb2dnYWJsZV0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29sZE9ic2VydmFibGUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvdGVzdGluZy9Db2xkT2JzZXJ2YWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMzQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3ViamVjdF8xID0gcmVxdWlyZSgnLi4vU3ViamVjdCcpO1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaXB0aW9uJyk7XG52YXIgU3Vic2NyaXB0aW9uTG9nZ2FibGVfMSA9IHJlcXVpcmUoJy4vU3Vic2NyaXB0aW9uTG9nZ2FibGUnKTtcbnZhciBhcHBseU1peGluc18xID0gcmVxdWlyZSgnLi4vdXRpbC9hcHBseU1peGlucycpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBIb3RPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSG90T2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIb3RPYnNlcnZhYmxlKG1lc3NhZ2VzLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMubWVzc2FnZXMgPSBtZXNzYWdlcztcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gW107XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIH1cbiAgICBIb3RPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIHN1YmplY3QgPSB0aGlzO1xuICAgICAgICB2YXIgaW5kZXggPSBzdWJqZWN0LmxvZ1N1YnNjcmliZWRGcmFtZSgpO1xuICAgICAgICBzdWJzY3JpYmVyLmFkZChuZXcgU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHN1YmplY3QubG9nVW5zdWJzY3JpYmVkRnJhbWUoaW5kZXgpO1xuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLl9zdWJzY3JpYmUuY2FsbCh0aGlzLCBzdWJzY3JpYmVyKTtcbiAgICB9O1xuICAgIEhvdE9ic2VydmFibGUucHJvdG90eXBlLnNldHVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3ViamVjdCA9IHRoaXM7XG4gICAgICAgIHZhciBtZXNzYWdlc0xlbmd0aCA9IHN1YmplY3QubWVzc2FnZXMubGVuZ3RoO1xuICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpuby12YXIta2V5d29yZCAqL1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2VzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBzdWJqZWN0Lm1lc3NhZ2VzW2ldO1xuICAgICAgICAgICAgICAgIC8qIHRzbGludDplbmFibGUgKi9cbiAgICAgICAgICAgICAgICBzdWJqZWN0LnNjaGVkdWxlci5zY2hlZHVsZShmdW5jdGlvbiAoKSB7IG1lc3NhZ2Uubm90aWZpY2F0aW9uLm9ic2VydmUoc3ViamVjdCk7IH0sIG1lc3NhZ2UuZnJhbWUpO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEhvdE9ic2VydmFibGU7XG59KFN1YmplY3RfMS5TdWJqZWN0KSk7XG5leHBvcnRzLkhvdE9ic2VydmFibGUgPSBIb3RPYnNlcnZhYmxlO1xuYXBwbHlNaXhpbnNfMS5hcHBseU1peGlucyhIb3RPYnNlcnZhYmxlLCBbU3Vic2NyaXB0aW9uTG9nZ2FibGVfMS5TdWJzY3JpcHRpb25Mb2dnYWJsZV0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SG90T2JzZXJ2YWJsZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy90ZXN0aW5nL0hvdE9ic2VydmFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDM0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciBOb3RpZmljYXRpb25fMSA9IHJlcXVpcmUoJy4uL05vdGlmaWNhdGlvbicpO1xudmFyIENvbGRPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL0NvbGRPYnNlcnZhYmxlJyk7XG52YXIgSG90T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9Ib3RPYnNlcnZhYmxlJyk7XG52YXIgU3Vic2NyaXB0aW9uTG9nXzEgPSByZXF1aXJlKCcuL1N1YnNjcmlwdGlvbkxvZycpO1xudmFyIFZpcnR1YWxUaW1lU2NoZWR1bGVyXzEgPSByZXF1aXJlKCcuLi9zY2hlZHVsZXIvVmlydHVhbFRpbWVTY2hlZHVsZXInKTtcbnZhciBkZWZhdWx0TWF4RnJhbWUgPSA3NTA7XG52YXIgVGVzdFNjaGVkdWxlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRlc3RTY2hlZHVsZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGVzdFNjaGVkdWxlcihhc3NlcnREZWVwRXF1YWwpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgVmlydHVhbFRpbWVTY2hlZHVsZXJfMS5WaXJ0dWFsQWN0aW9uLCBkZWZhdWx0TWF4RnJhbWUpO1xuICAgICAgICB0aGlzLmFzc2VydERlZXBFcXVhbCA9IGFzc2VydERlZXBFcXVhbDtcbiAgICAgICAgdGhpcy5ob3RPYnNlcnZhYmxlcyA9IFtdO1xuICAgICAgICB0aGlzLmNvbGRPYnNlcnZhYmxlcyA9IFtdO1xuICAgICAgICB0aGlzLmZsdXNoVGVzdHMgPSBbXTtcbiAgICB9XG4gICAgVGVzdFNjaGVkdWxlci5wcm90b3R5cGUuY3JlYXRlVGltZSA9IGZ1bmN0aW9uIChtYXJibGVzKSB7XG4gICAgICAgIHZhciBpbmRleE9mID0gbWFyYmxlcy5pbmRleE9mKCd8Jyk7XG4gICAgICAgIGlmIChpbmRleE9mID09PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXJibGUgZGlhZ3JhbSBmb3IgdGltZSBzaG91bGQgaGF2ZSBhIGNvbXBsZXRpb24gbWFya2VyIFwifFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4T2YgKiBUZXN0U2NoZWR1bGVyLmZyYW1lVGltZUZhY3RvcjtcbiAgICB9O1xuICAgIFRlc3RTY2hlZHVsZXIucHJvdG90eXBlLmNyZWF0ZUNvbGRPYnNlcnZhYmxlID0gZnVuY3Rpb24gKG1hcmJsZXMsIHZhbHVlcywgZXJyb3IpIHtcbiAgICAgICAgaWYgKG1hcmJsZXMuaW5kZXhPZignXicpICE9PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb2xkIG9ic2VydmFibGUgY2Fubm90IGhhdmUgc3Vic2NyaXB0aW9uIG9mZnNldCBcIl5cIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXJibGVzLmluZGV4T2YoJyEnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY29sZCBvYnNlcnZhYmxlIGNhbm5vdCBoYXZlIHVuc3Vic2NyaXB0aW9uIG1hcmtlciBcIiFcIicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtZXNzYWdlcyA9IFRlc3RTY2hlZHVsZXIucGFyc2VNYXJibGVzKG1hcmJsZXMsIHZhbHVlcywgZXJyb3IpO1xuICAgICAgICB2YXIgY29sZCA9IG5ldyBDb2xkT2JzZXJ2YWJsZV8xLkNvbGRPYnNlcnZhYmxlKG1lc3NhZ2VzLCB0aGlzKTtcbiAgICAgICAgdGhpcy5jb2xkT2JzZXJ2YWJsZXMucHVzaChjb2xkKTtcbiAgICAgICAgcmV0dXJuIGNvbGQ7XG4gICAgfTtcbiAgICBUZXN0U2NoZWR1bGVyLnByb3RvdHlwZS5jcmVhdGVIb3RPYnNlcnZhYmxlID0gZnVuY3Rpb24gKG1hcmJsZXMsIHZhbHVlcywgZXJyb3IpIHtcbiAgICAgICAgaWYgKG1hcmJsZXMuaW5kZXhPZignIScpICE9PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdob3Qgb2JzZXJ2YWJsZSBjYW5ub3QgaGF2ZSB1bnN1YnNjcmlwdGlvbiBtYXJrZXIgXCIhXCInKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWVzc2FnZXMgPSBUZXN0U2NoZWR1bGVyLnBhcnNlTWFyYmxlcyhtYXJibGVzLCB2YWx1ZXMsIGVycm9yKTtcbiAgICAgICAgdmFyIHN1YmplY3QgPSBuZXcgSG90T2JzZXJ2YWJsZV8xLkhvdE9ic2VydmFibGUobWVzc2FnZXMsIHRoaXMpO1xuICAgICAgICB0aGlzLmhvdE9ic2VydmFibGVzLnB1c2goc3ViamVjdCk7XG4gICAgICAgIHJldHVybiBzdWJqZWN0O1xuICAgIH07XG4gICAgVGVzdFNjaGVkdWxlci5wcm90b3R5cGUubWF0ZXJpYWxpemVJbm5lck9ic2VydmFibGUgPSBmdW5jdGlvbiAob2JzZXJ2YWJsZSwgb3V0ZXJGcmFtZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbWVzc2FnZXMgPSBbXTtcbiAgICAgICAgb2JzZXJ2YWJsZS5zdWJzY3JpYmUoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBtZXNzYWdlcy5wdXNoKHsgZnJhbWU6IF90aGlzLmZyYW1lIC0gb3V0ZXJGcmFtZSwgbm90aWZpY2F0aW9uOiBOb3RpZmljYXRpb25fMS5Ob3RpZmljYXRpb24uY3JlYXRlTmV4dCh2YWx1ZSkgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2goeyBmcmFtZTogX3RoaXMuZnJhbWUgLSBvdXRlckZyYW1lLCBub3RpZmljYXRpb246IE5vdGlmaWNhdGlvbl8xLk5vdGlmaWNhdGlvbi5jcmVhdGVFcnJvcihlcnIpIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBtZXNzYWdlcy5wdXNoKHsgZnJhbWU6IF90aGlzLmZyYW1lIC0gb3V0ZXJGcmFtZSwgbm90aWZpY2F0aW9uOiBOb3RpZmljYXRpb25fMS5Ob3RpZmljYXRpb24uY3JlYXRlQ29tcGxldGUoKSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlcztcbiAgICB9O1xuICAgIFRlc3RTY2hlZHVsZXIucHJvdG90eXBlLmV4cGVjdE9ic2VydmFibGUgPSBmdW5jdGlvbiAob2JzZXJ2YWJsZSwgdW5zdWJzY3JpcHRpb25NYXJibGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh1bnN1YnNjcmlwdGlvbk1hcmJsZXMgPT09IHZvaWQgMCkgeyB1bnN1YnNjcmlwdGlvbk1hcmJsZXMgPSBudWxsOyB9XG4gICAgICAgIHZhciBhY3R1YWwgPSBbXTtcbiAgICAgICAgdmFyIGZsdXNoVGVzdCA9IHsgYWN0dWFsOiBhY3R1YWwsIHJlYWR5OiBmYWxzZSB9O1xuICAgICAgICB2YXIgdW5zdWJzY3JpcHRpb25GcmFtZSA9IFRlc3RTY2hlZHVsZXJcbiAgICAgICAgICAgIC5wYXJzZU1hcmJsZXNBc1N1YnNjcmlwdGlvbnModW5zdWJzY3JpcHRpb25NYXJibGVzKS51bnN1YnNjcmliZWRGcmFtZTtcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy5zY2hlZHVsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24gPSBvYnNlcnZhYmxlLnN1YnNjcmliZShmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHg7XG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydCBPYnNlcnZhYmxlLW9mLU9ic2VydmFibGVzXG4gICAgICAgICAgICAgICAgaWYgKHggaW5zdGFuY2VvZiBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF90aGlzLm1hdGVyaWFsaXplSW5uZXJPYnNlcnZhYmxlKHZhbHVlLCBfdGhpcy5mcmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFjdHVhbC5wdXNoKHsgZnJhbWU6IF90aGlzLmZyYW1lLCBub3RpZmljYXRpb246IE5vdGlmaWNhdGlvbl8xLk5vdGlmaWNhdGlvbi5jcmVhdGVOZXh0KHZhbHVlKSB9KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBhY3R1YWwucHVzaCh7IGZyYW1lOiBfdGhpcy5mcmFtZSwgbm90aWZpY2F0aW9uOiBOb3RpZmljYXRpb25fMS5Ob3RpZmljYXRpb24uY3JlYXRlRXJyb3IoZXJyKSB9KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBhY3R1YWwucHVzaCh7IGZyYW1lOiBfdGhpcy5mcmFtZSwgbm90aWZpY2F0aW9uOiBOb3RpZmljYXRpb25fMS5Ob3RpZmljYXRpb24uY3JlYXRlQ29tcGxldGUoKSB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgaWYgKHVuc3Vic2NyaXB0aW9uRnJhbWUgIT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkge1xuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZShmdW5jdGlvbiAoKSB7IHJldHVybiBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTsgfSwgdW5zdWJzY3JpcHRpb25GcmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mbHVzaFRlc3RzLnB1c2goZmx1c2hUZXN0KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvQmU6IGZ1bmN0aW9uIChtYXJibGVzLCB2YWx1ZXMsIGVycm9yVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBmbHVzaFRlc3QucmVhZHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZsdXNoVGVzdC5leHBlY3RlZCA9IFRlc3RTY2hlZHVsZXIucGFyc2VNYXJibGVzKG1hcmJsZXMsIHZhbHVlcywgZXJyb3JWYWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBUZXN0U2NoZWR1bGVyLnByb3RvdHlwZS5leHBlY3RTdWJzY3JpcHRpb25zID0gZnVuY3Rpb24gKGFjdHVhbFN1YnNjcmlwdGlvbkxvZ3MpIHtcbiAgICAgICAgdmFyIGZsdXNoVGVzdCA9IHsgYWN0dWFsOiBhY3R1YWxTdWJzY3JpcHRpb25Mb2dzLCByZWFkeTogZmFsc2UgfTtcbiAgICAgICAgdGhpcy5mbHVzaFRlc3RzLnB1c2goZmx1c2hUZXN0KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvQmU6IGZ1bmN0aW9uIChtYXJibGVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hcmJsZXNBcnJheSA9ICh0eXBlb2YgbWFyYmxlcyA9PT0gJ3N0cmluZycpID8gW21hcmJsZXNdIDogbWFyYmxlcztcbiAgICAgICAgICAgICAgICBmbHVzaFRlc3QucmVhZHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZsdXNoVGVzdC5leHBlY3RlZCA9IG1hcmJsZXNBcnJheS5tYXAoZnVuY3Rpb24gKG1hcmJsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFRlc3RTY2hlZHVsZXIucGFyc2VNYXJibGVzQXNTdWJzY3JpcHRpb25zKG1hcmJsZXMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgVGVzdFNjaGVkdWxlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBob3RPYnNlcnZhYmxlcyA9IHRoaXMuaG90T2JzZXJ2YWJsZXM7XG4gICAgICAgIHdoaWxlIChob3RPYnNlcnZhYmxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBob3RPYnNlcnZhYmxlcy5zaGlmdCgpLnNldHVwKCk7XG4gICAgICAgIH1cbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5mbHVzaC5jYWxsKHRoaXMpO1xuICAgICAgICB2YXIgcmVhZHlGbHVzaFRlc3RzID0gdGhpcy5mbHVzaFRlc3RzLmZpbHRlcihmdW5jdGlvbiAodGVzdCkgeyByZXR1cm4gdGVzdC5yZWFkeTsgfSk7XG4gICAgICAgIHdoaWxlIChyZWFkeUZsdXNoVGVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIHRlc3QgPSByZWFkeUZsdXNoVGVzdHMuc2hpZnQoKTtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0RGVlcEVxdWFsKHRlc3QuYWN0dWFsLCB0ZXN0LmV4cGVjdGVkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGVzdFNjaGVkdWxlci5wYXJzZU1hcmJsZXNBc1N1YnNjcmlwdGlvbnMgPSBmdW5jdGlvbiAobWFyYmxlcykge1xuICAgICAgICBpZiAodHlwZW9mIG1hcmJsZXMgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN1YnNjcmlwdGlvbkxvZ18xLlN1YnNjcmlwdGlvbkxvZyhOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZW4gPSBtYXJibGVzLmxlbmd0aDtcbiAgICAgICAgdmFyIGdyb3VwU3RhcnQgPSAtMTtcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbkZyYW1lID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICB2YXIgdW5zdWJzY3JpcHRpb25GcmFtZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGZyYW1lID0gaSAqIHRoaXMuZnJhbWVUaW1lRmFjdG9yO1xuICAgICAgICAgICAgdmFyIGMgPSBtYXJibGVzW2ldO1xuICAgICAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnICc6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJygnOlxuICAgICAgICAgICAgICAgICAgICBncm91cFN0YXJ0ID0gZnJhbWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJyknOlxuICAgICAgICAgICAgICAgICAgICBncm91cFN0YXJ0ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ14nOlxuICAgICAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uRnJhbWUgIT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmb3VuZCBhIHNlY29uZCBzdWJzY3JpcHRpb24gcG9pbnQgXFwnXlxcJyBpbiBhICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzdWJzY3JpcHRpb24gbWFyYmxlIGRpYWdyYW0uIFRoZXJlIGNhbiBvbmx5IGJlIG9uZS4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25GcmFtZSA9IGdyb3VwU3RhcnQgPiAtMSA/IGdyb3VwU3RhcnQgOiBmcmFtZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnISc6XG4gICAgICAgICAgICAgICAgICAgIGlmICh1bnN1YnNjcmlwdGlvbkZyYW1lICE9PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZm91bmQgYSBzZWNvbmQgc3Vic2NyaXB0aW9uIHBvaW50IFxcJ15cXCcgaW4gYSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc3Vic2NyaXB0aW9uIG1hcmJsZSBkaWFncmFtLiBUaGVyZSBjYW4gb25seSBiZSBvbmUuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdW5zdWJzY3JpcHRpb25GcmFtZSA9IGdyb3VwU3RhcnQgPiAtMSA/IGdyb3VwU3RhcnQgOiBmcmFtZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGVyZSBjYW4gb25seSBiZSBcXCdeXFwnIGFuZCBcXCchXFwnIG1hcmtlcnMgaW4gYSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdzdWJzY3JpcHRpb24gbWFyYmxlIGRpYWdyYW0uIEZvdW5kIGluc3RlYWQgXFwnJyArIGMgKyAnXFwnLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh1bnN1YnNjcmlwdGlvbkZyYW1lIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdWJzY3JpcHRpb25Mb2dfMS5TdWJzY3JpcHRpb25Mb2coc3Vic2NyaXB0aW9uRnJhbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdWJzY3JpcHRpb25Mb2dfMS5TdWJzY3JpcHRpb25Mb2coc3Vic2NyaXB0aW9uRnJhbWUsIHVuc3Vic2NyaXB0aW9uRnJhbWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUZXN0U2NoZWR1bGVyLnBhcnNlTWFyYmxlcyA9IGZ1bmN0aW9uIChtYXJibGVzLCB2YWx1ZXMsIGVycm9yVmFsdWUsIG1hdGVyaWFsaXplSW5uZXJPYnNlcnZhYmxlcykge1xuICAgICAgICBpZiAobWF0ZXJpYWxpemVJbm5lck9ic2VydmFibGVzID09PSB2b2lkIDApIHsgbWF0ZXJpYWxpemVJbm5lck9ic2VydmFibGVzID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKG1hcmJsZXMuaW5kZXhPZignIScpICE9PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZW50aW9uYWwgbWFyYmxlIGRpYWdyYW1zIGNhbm5vdCBoYXZlIHRoZSAnICtcbiAgICAgICAgICAgICAgICAndW5zdWJzY3JpcHRpb24gbWFya2VyIFwiIVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbiA9IG1hcmJsZXMubGVuZ3RoO1xuICAgICAgICB2YXIgdGVzdE1lc3NhZ2VzID0gW107XG4gICAgICAgIHZhciBzdWJJbmRleCA9IG1hcmJsZXMuaW5kZXhPZignXicpO1xuICAgICAgICB2YXIgZnJhbWVPZmZzZXQgPSBzdWJJbmRleCA9PT0gLTEgPyAwIDogKHN1YkluZGV4ICogLXRoaXMuZnJhbWVUaW1lRmFjdG9yKTtcbiAgICAgICAgdmFyIGdldFZhbHVlID0gdHlwZW9mIHZhbHVlcyAhPT0gJ29iamVjdCcgP1xuICAgICAgICAgICAgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0gOlxuICAgICAgICAgICAgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0IE9ic2VydmFibGUtb2YtT2JzZXJ2YWJsZXNcbiAgICAgICAgICAgICAgICBpZiAobWF0ZXJpYWxpemVJbm5lck9ic2VydmFibGVzICYmIHZhbHVlc1t4XSBpbnN0YW5jZW9mIENvbGRPYnNlcnZhYmxlXzEuQ29sZE9ic2VydmFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlc1t4XS5tZXNzYWdlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlc1t4XTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIHZhciBncm91cFN0YXJ0ID0gLTE7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBmcmFtZSA9IGkgKiB0aGlzLmZyYW1lVGltZUZhY3RvciArIGZyYW1lT2Zmc2V0O1xuICAgICAgICAgICAgdmFyIG5vdGlmaWNhdGlvbiA9IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBjID0gbWFyYmxlc1tpXTtcbiAgICAgICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgIGNhc2UgJyAnOlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICcoJzpcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBTdGFydCA9IGZyYW1lO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICcpJzpcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBTdGFydCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd8JzpcbiAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uID0gTm90aWZpY2F0aW9uXzEuTm90aWZpY2F0aW9uLmNyZWF0ZUNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ14nOlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uID0gTm90aWZpY2F0aW9uXzEuTm90aWZpY2F0aW9uLmNyZWF0ZUVycm9yKGVycm9yVmFsdWUgfHwgJ2Vycm9yJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbiA9IE5vdGlmaWNhdGlvbl8xLk5vdGlmaWNhdGlvbi5jcmVhdGVOZXh0KGdldFZhbHVlKGMpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90aWZpY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGVzdE1lc3NhZ2VzLnB1c2goeyBmcmFtZTogZ3JvdXBTdGFydCA+IC0xID8gZ3JvdXBTdGFydCA6IGZyYW1lLCBub3RpZmljYXRpb246IG5vdGlmaWNhdGlvbiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVzdE1lc3NhZ2VzO1xuICAgIH07XG4gICAgcmV0dXJuIFRlc3RTY2hlZHVsZXI7XG59KFZpcnR1YWxUaW1lU2NoZWR1bGVyXzEuVmlydHVhbFRpbWVTY2hlZHVsZXIpKTtcbmV4cG9ydHMuVGVzdFNjaGVkdWxlciA9IFRlc3RTY2hlZHVsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UZXN0U2NoZWR1bGVyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL3Rlc3RpbmcvVGVzdFNjaGVkdWxlci5qc1xuLy8gbW9kdWxlIGlkID0gMzQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHJvb3RfMSA9IHJlcXVpcmUoJy4vcm9vdCcpO1xudmFyIFJlcXVlc3RBbmltYXRpb25GcmFtZURlZmluaXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlcXVlc3RBbmltYXRpb25GcmFtZURlZmluaXRpb24ocm9vdCkge1xuICAgICAgICBpZiAocm9vdC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSByb290LmNhbmNlbEFuaW1hdGlvbkZyYW1lLmJpbmQocm9vdCk7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHJvb3QucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQocm9vdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocm9vdC5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSByb290Lm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lLmJpbmQocm9vdCk7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHJvb3QubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQocm9vdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocm9vdC53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSByb290LndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lLmJpbmQocm9vdCk7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHJvb3Qud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQocm9vdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocm9vdC5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgICAgICAgdGhpcy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IHJvb3QubXNDYW5jZWxBbmltYXRpb25GcmFtZS5iaW5kKHJvb3QpO1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSByb290Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQocm9vdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocm9vdC5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgICAgICB0aGlzLmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gcm9vdC5vQ2FuY2VsQW5pbWF0aW9uRnJhbWUuYmluZChyb290KTtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcm9vdC5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQocm9vdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gcm9vdC5jbGVhclRpbWVvdXQuYmluZChyb290KTtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKGNiKSB7IHJldHVybiByb290LnNldFRpbWVvdXQoY2IsIDEwMDAgLyA2MCk7IH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFJlcXVlc3RBbmltYXRpb25GcmFtZURlZmluaXRpb247XG59KCkpO1xuZXhwb3J0cy5SZXF1ZXN0QW5pbWF0aW9uRnJhbWVEZWZpbml0aW9uID0gUmVxdWVzdEFuaW1hdGlvbkZyYW1lRGVmaW5pdGlvbjtcbmV4cG9ydHMuQW5pbWF0aW9uRnJhbWUgPSBuZXcgUmVxdWVzdEFuaW1hdGlvbkZyYW1lRGVmaW5pdGlvbihyb290XzEucm9vdCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BbmltYXRpb25GcmFtZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy91dGlsL0FuaW1hdGlvbkZyYW1lLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgRmFzdE1hcCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRmFzdE1hcCgpIHtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7fTtcbiAgICB9XG4gICAgRmFzdE1hcC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB0aGlzLnZhbHVlc1trZXldID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBGYXN0TWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlc1trZXldID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgRmFzdE1hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXNba2V5XTtcbiAgICB9O1xuICAgIEZhc3RNYXAucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2IsIHRoaXNBcmcpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzLmhhc093blByb3BlcnR5KGtleSkgJiYgdmFsdWVzW2tleV0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjYi5jYWxsKHRoaXNBcmcsIHZhbHVlc1trZXldLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBGYXN0TWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7fTtcbiAgICB9O1xuICAgIHJldHVybiBGYXN0TWFwO1xufSgpKTtcbmV4cG9ydHMuRmFzdE1hcCA9IEZhc3RNYXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GYXN0TWFwLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL3V0aWwvRmFzdE1hcC5qc1xuLy8gbW9kdWxlIGlkID0gMzQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuU29tZSBjcmVkaXQgZm9yIHRoaXMgaGVscGVyIGdvZXMgdG8gaHR0cDovL2dpdGh1Yi5jb20vWXV6dUpTL3NldEltbWVkaWF0ZVxuKi9cblwidXNlIHN0cmljdFwiO1xudmFyIHJvb3RfMSA9IHJlcXVpcmUoJy4vcm9vdCcpO1xudmFyIEltbWVkaWF0ZURlZmluaXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEltbWVkaWF0ZURlZmluaXRpb24ocm9vdCkge1xuICAgICAgICB0aGlzLnJvb3QgPSByb290O1xuICAgICAgICBpZiAocm9vdC5zZXRJbW1lZGlhdGUgJiYgdHlwZW9mIHJvb3Quc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLnNldEltbWVkaWF0ZSA9IHJvb3Quc2V0SW1tZWRpYXRlLmJpbmQocm9vdCk7XG4gICAgICAgICAgICB0aGlzLmNsZWFySW1tZWRpYXRlID0gcm9vdC5jbGVhckltbWVkaWF0ZS5iaW5kKHJvb3QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5uZXh0SGFuZGxlID0gMTtcbiAgICAgICAgICAgIHRoaXMudGFza3NCeUhhbmRsZSA9IHt9O1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICAgICAgICAgIGlmICh0aGlzLmNhblVzZVByb2Nlc3NOZXh0VGljaygpKSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0SW1tZWRpYXRlID0gdGhpcy5jcmVhdGVQcm9jZXNzTmV4dFRpY2tTZXRJbW1lZGlhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAgICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgICAgICAgICB0aGlzLnNldEltbWVkaWF0ZSA9IHRoaXMuY3JlYXRlUG9zdE1lc3NhZ2VTZXRJbW1lZGlhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY2FuVXNlTWVzc2FnZUNoYW5uZWwoKSkge1xuICAgICAgICAgICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRJbW1lZGlhdGUgPSB0aGlzLmNyZWF0ZU1lc3NhZ2VDaGFubmVsU2V0SW1tZWRpYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNhblVzZVJlYWR5U3RhdGVDaGFuZ2UoKSkge1xuICAgICAgICAgICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICAgICAgICAgIHRoaXMuc2V0SW1tZWRpYXRlID0gdGhpcy5jcmVhdGVSZWFkeVN0YXRlQ2hhbmdlU2V0SW1tZWRpYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgICAgICAgICB0aGlzLnNldEltbWVkaWF0ZSA9IHRoaXMuY3JlYXRlU2V0VGltZW91dFNldEltbWVkaWF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNpID0gZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNsZWFySW1tZWRpYXRlLmluc3RhbmNlLnRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjaS5pbnN0YW5jZSA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmNsZWFySW1tZWRpYXRlID0gY2k7XG4gICAgICAgIH1cbiAgICB9XG4gICAgSW1tZWRpYXRlRGVmaW5pdGlvbi5wcm90b3R5cGUuaWRlbnRpZnkgPSBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290Lk9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbiAgICB9O1xuICAgIEltbWVkaWF0ZURlZmluaXRpb24ucHJvdG90eXBlLmNhblVzZVByb2Nlc3NOZXh0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWRlbnRpZnkodGhpcy5yb290LnByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXSc7XG4gICAgfTtcbiAgICBJbW1lZGlhdGVEZWZpbml0aW9uLnByb3RvdHlwZS5jYW5Vc2VNZXNzYWdlQ2hhbm5lbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5yb290Lk1lc3NhZ2VDaGFubmVsKTtcbiAgICB9O1xuICAgIEltbWVkaWF0ZURlZmluaXRpb24ucHJvdG90eXBlLmNhblVzZVJlYWR5U3RhdGVDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkb2N1bWVudCA9IHRoaXMucm9vdC5kb2N1bWVudDtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oZG9jdW1lbnQgJiYgJ29ucmVhZHlzdGF0ZWNoYW5nZScgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JykpO1xuICAgIH07XG4gICAgSW1tZWRpYXRlRGVmaW5pdGlvbi5wcm90b3R5cGUuY2FuVXNlUG9zdE1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByb290ID0gdGhpcy5yb290O1xuICAgICAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgICAgIC8vIHdoZXJlIGByb290LnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKHJvb3QucG9zdE1lc3NhZ2UgJiYgIXJvb3QuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgdmFyIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXNfMSA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gcm9vdC5vbm1lc3NhZ2U7XG4gICAgICAgICAgICByb290Lm9ubWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzXzEgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByb290LnBvc3RNZXNzYWdlKCcnLCAnKicpO1xuICAgICAgICAgICAgcm9vdC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91c18xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyB0aGUgc2FtZSBhcmd1bWVudHMgYXMgc2V0SW1tZWRpYXRlLCBidXRcbiAgICAvLyByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCByZXF1aXJlcyBubyBhcmd1bWVudHMuXG4gICAgSW1tZWRpYXRlRGVmaW5pdGlvbi5wcm90b3R5cGUucGFydGlhbGx5QXBwbGllZCA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmbiA9IGZ1bmN0aW9uIHJlc3VsdCgpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHJlc3VsdCwgaGFuZGxlciA9IF9hLmhhbmRsZXIsIGFyZ3MgPSBfYS5hcmdzO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgKG5ldyBGdW5jdGlvbignJyArIGhhbmRsZXIpKSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmbi5oYW5kbGVyID0gaGFuZGxlcjtcbiAgICAgICAgZm4uYXJncyA9IGFyZ3M7XG4gICAgICAgIHJldHVybiBmbjtcbiAgICB9O1xuICAgIEltbWVkaWF0ZURlZmluaXRpb24ucHJvdG90eXBlLmFkZEZyb21TZXRJbW1lZGlhdGVBcmd1bWVudHMgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICB0aGlzLnRhc2tzQnlIYW5kbGVbdGhpcy5uZXh0SGFuZGxlXSA9IHRoaXMucGFydGlhbGx5QXBwbGllZC5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0SGFuZGxlKys7XG4gICAgfTtcbiAgICBJbW1lZGlhdGVEZWZpbml0aW9uLnByb3RvdHlwZS5jcmVhdGVQcm9jZXNzTmV4dFRpY2tTZXRJbW1lZGlhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmbiA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZSgpIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHNldEltbWVkaWF0ZS5pbnN0YW5jZTtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBpbnN0YW5jZS5hZGRGcm9tU2V0SW1tZWRpYXRlQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpbnN0YW5jZS5yb290LnByb2Nlc3MubmV4dFRpY2soaW5zdGFuY2UucGFydGlhbGx5QXBwbGllZChpbnN0YW5jZS5ydW5JZlByZXNlbnQsIGhhbmRsZSkpO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgICAgfTtcbiAgICAgICAgZm4uaW5zdGFuY2UgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZm47XG4gICAgfTtcbiAgICBJbW1lZGlhdGVEZWZpbml0aW9uLnByb3RvdHlwZS5jcmVhdGVQb3N0TWVzc2FnZVNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG4gICAgICAgIHZhciByb290ID0gdGhpcy5yb290O1xuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9ICdzZXRJbW1lZGlhdGUkJyArIHJvb3QuTWF0aC5yYW5kb20oKSArICckJztcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uIGdsb2JhbE1lc3NhZ2VIYW5kbGVyKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBnbG9iYWxNZXNzYWdlSGFuZGxlci5pbnN0YW5jZTtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IHJvb3QgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5ydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgb25HbG9iYWxNZXNzYWdlLmluc3RhbmNlID0gdGhpcztcbiAgICAgICAgcm9vdC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIHZhciBmbiA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZSgpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHNldEltbWVkaWF0ZSwgbWVzc2FnZVByZWZpeCA9IF9hLm1lc3NhZ2VQcmVmaXgsIGluc3RhbmNlID0gX2EuaW5zdGFuY2U7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gaW5zdGFuY2UuYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICAgICAgICAgICAgaW5zdGFuY2Uucm9vdC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCAnKicpO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgICAgfTtcbiAgICAgICAgZm4uaW5zdGFuY2UgPSB0aGlzO1xuICAgICAgICBmbi5tZXNzYWdlUHJlZml4ID0gbWVzc2FnZVByZWZpeDtcbiAgICAgICAgcmV0dXJuIGZuO1xuICAgIH07XG4gICAgSW1tZWRpYXRlRGVmaW5pdGlvbi5wcm90b3R5cGUucnVuSWZQcmVzZW50ID0gZnVuY3Rpb24gKGhhbmRsZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiAnV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuJ1xuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAodGhpcy5jdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXG4gICAgICAgICAgICAvLyAndG9vIG11Y2ggcmVjdXJzaW9uJyBlcnJvci5cbiAgICAgICAgICAgIHRoaXMucm9vdC5zZXRUaW1lb3V0KHRoaXMucGFydGlhbGx5QXBwbGllZCh0aGlzLnJ1bklmUHJlc2VudCwgaGFuZGxlKSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRoaXMudGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGFzaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgSW1tZWRpYXRlRGVmaW5pdGlvbi5wcm90b3R5cGUuY3JlYXRlTWVzc2FnZUNoYW5uZWxTZXRJbW1lZGlhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IHRoaXMucm9vdC5NZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBfdGhpcy5ydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGZuID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKCkge1xuICAgICAgICAgICAgdmFyIF9hID0gc2V0SW1tZWRpYXRlLCBjaGFubmVsID0gX2EuY2hhbm5lbCwgaW5zdGFuY2UgPSBfYS5pbnN0YW5jZTtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBpbnN0YW5jZS5hZGRGcm9tU2V0SW1tZWRpYXRlQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlO1xuICAgICAgICB9O1xuICAgICAgICBmbi5jaGFubmVsID0gY2hhbm5lbDtcbiAgICAgICAgZm4uaW5zdGFuY2UgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZm47XG4gICAgfTtcbiAgICBJbW1lZGlhdGVEZWZpbml0aW9uLnByb3RvdHlwZS5jcmVhdGVSZWFkeVN0YXRlQ2hhbmdlU2V0SW1tZWRpYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZm4gPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoKSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBzZXRJbW1lZGlhdGUuaW5zdGFuY2U7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IGluc3RhbmNlLnJvb3Q7XG4gICAgICAgICAgICB2YXIgZG9jID0gcm9vdC5kb2N1bWVudDtcbiAgICAgICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBpbnN0YW5jZS5hZGRGcm9tU2V0SW1tZWRpYXRlQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5ydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlO1xuICAgICAgICB9O1xuICAgICAgICBmbi5pbnN0YW5jZSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmbjtcbiAgICB9O1xuICAgIEltbWVkaWF0ZURlZmluaXRpb24ucHJvdG90eXBlLmNyZWF0ZVNldFRpbWVvdXRTZXRJbW1lZGlhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmbiA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZSgpIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHNldEltbWVkaWF0ZS5pbnN0YW5jZTtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBpbnN0YW5jZS5hZGRGcm9tU2V0SW1tZWRpYXRlQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpbnN0YW5jZS5yb290LnNldFRpbWVvdXQoaW5zdGFuY2UucGFydGlhbGx5QXBwbGllZChpbnN0YW5jZS5ydW5JZlByZXNlbnQsIGhhbmRsZSksIDApO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgICAgfTtcbiAgICAgICAgZm4uaW5zdGFuY2UgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZm47XG4gICAgfTtcbiAgICByZXR1cm4gSW1tZWRpYXRlRGVmaW5pdGlvbjtcbn0oKSk7XG5leHBvcnRzLkltbWVkaWF0ZURlZmluaXRpb24gPSBJbW1lZGlhdGVEZWZpbml0aW9uO1xuZXhwb3J0cy5JbW1lZGlhdGUgPSBuZXcgSW1tZWRpYXRlRGVmaW5pdGlvbihyb290XzEucm9vdCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbW1lZGlhdGUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvdXRpbC9JbW1lZGlhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDM0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciByb290XzEgPSByZXF1aXJlKCcuL3Jvb3QnKTtcbnZhciBNYXBQb2x5ZmlsbF8xID0gcmVxdWlyZSgnLi9NYXBQb2x5ZmlsbCcpO1xuZXhwb3J0cy5NYXAgPSByb290XzEucm9vdC5NYXAgfHwgKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1hcFBvbHlmaWxsXzEuTWFwUG9seWZpbGw7IH0pKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXAuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvdXRpbC9NYXAuanNcbi8vIG1vZHVsZSBpZCA9IDM0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBNYXBQb2x5ZmlsbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFwUG9seWZpbGwoKSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IFtdO1xuICAgICAgICB0aGlzLl9rZXlzID0gW107XG4gICAgfVxuICAgIE1hcFBvbHlmaWxsLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5fa2V5cy5pbmRleE9mKGtleSk7XG4gICAgICAgIHJldHVybiBpID09PSAtMSA/IHVuZGVmaW5lZCA6IHRoaXMuX3ZhbHVlc1tpXTtcbiAgICB9O1xuICAgIE1hcFBvbHlmaWxsLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgaSA9IHRoaXMuX2tleXMuaW5kZXhPZihrZXkpO1xuICAgICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX2tleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgdGhpcy5fdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5zaXplKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZXNbaV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIE1hcFBvbHlmaWxsLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5fa2V5cy5pbmRleE9mKGtleSk7XG4gICAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ZhbHVlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHRoaXMuX2tleXMuc3BsaWNlKGksIDEpO1xuICAgICAgICB0aGlzLnNpemUtLTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBNYXBQb2x5ZmlsbC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2tleXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5fdmFsdWVzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfTtcbiAgICBNYXBQb2x5ZmlsbC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYiwgdGhpc0FyZykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICBjYi5jYWxsKHRoaXNBcmcsIHRoaXMuX3ZhbHVlc1tpXSwgdGhpcy5fa2V5c1tpXSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBNYXBQb2x5ZmlsbDtcbn0oKSk7XG5leHBvcnRzLk1hcFBvbHlmaWxsID0gTWFwUG9seWZpbGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXBQb2x5ZmlsbC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy91dGlsL01hcFBvbHlmaWxsLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcm9vdF8xID0gcmVxdWlyZSgnLi9yb290Jyk7XG5mdW5jdGlvbiBtaW5pbWFsU2V0SW1wbCgpIHtcbiAgICAvLyBUSElTIElTIE5PVCBhIGZ1bGwgaW1wbCBvZiBTZXQsIHRoaXMgaXMganVzdCB0aGUgbWluaW11bVxuICAgIC8vIGJpdHMgb2YgZnVuY3Rpb25hbGl0eSB3ZSBuZWVkIGZvciB0aGlzIGxpYnJhcnkuXG4gICAgcmV0dXJuIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE1pbmltYWxTZXQoKSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBNaW5pbWFsU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5oYXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBNaW5pbWFsU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWx1ZXMuaW5kZXhPZih2YWx1ZSkgIT09IC0xO1xuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWluaW1hbFNldC5wcm90b3R5cGUsIFwic2l6ZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWVzLmxlbmd0aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBNaW5pbWFsU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlcy5sZW5ndGggPSAwO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTWluaW1hbFNldDtcbiAgICB9KCkpO1xufVxuZXhwb3J0cy5taW5pbWFsU2V0SW1wbCA9IG1pbmltYWxTZXRJbXBsO1xuZXhwb3J0cy5TZXQgPSByb290XzEucm9vdC5TZXQgfHwgbWluaW1hbFNldEltcGwoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNldC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy91dGlsL1NldC5qc1xuLy8gbW9kdWxlIGlkID0gMzQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHJvb3RfMSA9IHJlcXVpcmUoJy4vcm9vdCcpO1xuZnVuY3Rpb24gYXNzaWduSW1wbCh0YXJnZXQpIHtcbiAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHNvdXJjZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBsZW4gPSBzb3VyY2VzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2ldO1xuICAgICAgICBmb3IgKHZhciBrIGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrXSA9IHNvdXJjZVtrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZXhwb3J0cy5hc3NpZ25JbXBsID0gYXNzaWduSW1wbDtcbjtcbmZ1bmN0aW9uIGdldEFzc2lnbihyb290KSB7XG4gICAgcmV0dXJuIHJvb3QuT2JqZWN0LmFzc2lnbiB8fCBhc3NpZ25JbXBsO1xufVxuZXhwb3J0cy5nZXRBc3NpZ24gPSBnZXRBc3NpZ247XG5leHBvcnRzLmFzc2lnbiA9IGdldEFzc2lnbihyb290XzEucm9vdCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3NpZ24uanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvdXRpbC9hc3NpZ24uanNcbi8vIG1vZHVsZSBpZCA9IDM1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIG5vdChwcmVkLCB0aGlzQXJnKSB7XG4gICAgZnVuY3Rpb24gbm90UHJlZCgpIHtcbiAgICAgICAgcmV0dXJuICEobm90UHJlZC5wcmVkLmFwcGx5KG5vdFByZWQudGhpc0FyZywgYXJndW1lbnRzKSk7XG4gICAgfVxuICAgIG5vdFByZWQucHJlZCA9IHByZWQ7XG4gICAgbm90UHJlZC50aGlzQXJnID0gdGhpc0FyZztcbiAgICByZXR1cm4gbm90UHJlZDtcbn1cbmV4cG9ydHMubm90ID0gbm90O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm90LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL3V0aWwvbm90LmpzXG4vLyBtb2R1bGUgaWQgPSAzNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIHJ4U3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vc3ltYm9sL3J4U3Vic2NyaWJlcicpO1xudmFyIE9ic2VydmVyXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZlcicpO1xuZnVuY3Rpb24gdG9TdWJzY3JpYmVyKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpIHtcbiAgICBpZiAobmV4dE9yT2JzZXJ2ZXIpIHtcbiAgICAgICAgaWYgKG5leHRPck9ic2VydmVyIGluc3RhbmNlb2YgU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0T3JPYnNlcnZlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dE9yT2JzZXJ2ZXJbcnhTdWJzY3JpYmVyXzEuJCRyeFN1YnNjcmliZXJdKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dE9yT2JzZXJ2ZXJbcnhTdWJzY3JpYmVyXzEuJCRyeFN1YnNjcmliZXJdKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFuZXh0T3JPYnNlcnZlciAmJiAhZXJyb3IgJiYgIWNvbXBsZXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIoT2JzZXJ2ZXJfMS5lbXB0eSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSk7XG59XG5leHBvcnRzLnRvU3Vic2NyaWJlciA9IHRvU3Vic2NyaWJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvU3Vic2NyaWJlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy91dGlsL3RvU3Vic2NyaWJlci5qc1xuLy8gbW9kdWxlIGlkID0gMzUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbihcIlwiICsgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XG4gICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gdGFzaztcbiAgICAgIHJlZ2lzdGVySW1tZWRpYXRlKG5leHRIYW5kbGUpO1xuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4odGFzaykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0YXNrLmNhbGxiYWNrO1xuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bih0YXNrKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5JZlByZXNlbnQoaGFuZGxlKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0odHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAzNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbnZhciBzdHlsZXNJbkRvbSA9IHt9LFxuXHRtZW1vaXplID0gZnVuY3Rpb24oZm4pIHtcblx0XHR2YXIgbWVtbztcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdHJldHVybiBtZW1vO1xuXHRcdH07XG5cdH0sXG5cdGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAvbXNpZSBbNi05XVxcYi8udGVzdChzZWxmLm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSk7XG5cdH0pLFxuXHRnZXRIZWFkRWxlbWVudCA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcblx0fSksXG5cdHNpbmdsZXRvbkVsZW1lbnQgPSBudWxsLFxuXHRzaW5nbGV0b25Db3VudGVyID0gMCxcblx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AgPSBbXTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XG5cdGlmKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xuXHRcdGlmKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuXHR9XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cdGlmICh0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gPT09IFwidW5kZWZpbmVkXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiA8aGVhZD4uXG5cdGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ1bmRlZmluZWRcIikgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XG5cblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0KTtcblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcblx0XHR9XG5cdFx0aWYobmV3TGlzdCkge1xuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0KTtcblx0XHRcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XG5cdFx0fVxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTtcblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcblx0XHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKVxuXHRcdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKCk7XG5cdFx0XHRcdGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpIHtcblx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXHRcdGlmKGRvbVN0eWxlKSB7XG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG5cdFx0XHR9XG5cdFx0XHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHBhcnRzID0gW107XG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMobGlzdCkge1xuXHR2YXIgc3R5bGVzID0gW107XG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcblx0Zm9yKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XG5cdFx0dmFyIGlkID0gaXRlbVswXTtcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xuXHRcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcblx0XHRpZighbmV3U3R5bGVzW2lkXSlcblx0XHRcdHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XG5cdFx0ZWxzZVxuXHRcdFx0bmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xuXHR9XG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpIHtcblx0dmFyIGhlYWQgPSBnZXRIZWFkRWxlbWVudCgpO1xuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcFtzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcblx0XHRpZighbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcblx0XHRcdGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgaGVhZC5maXJzdENoaWxkKTtcblx0XHR9IGVsc2UgaWYobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcblx0XHRcdGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XG5cdFx0fVxuXHRcdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGVFbGVtZW50KTtcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XG5cdFx0aGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnLiBNdXN0IGJlICd0b3AnIG9yICdib3R0b20nLlwiKTtcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KSB7XG5cdHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudCk7XG5cdHZhciBpZHggPSBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlRWxlbWVudCk7XG5cdGlmKGlkeCA+PSAwKSB7XG5cdFx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcblx0c3R5bGVFbGVtZW50LnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpO1xuXHRyZXR1cm4gc3R5bGVFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKSB7XG5cdHZhciBsaW5rRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuXHRsaW5rRWxlbWVudC5yZWwgPSBcInN0eWxlc2hlZXRcIjtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIGxpbmtFbGVtZW50KTtcblx0cmV0dXJuIGxpbmtFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlRWxlbWVudCwgdXBkYXRlLCByZW1vdmU7XG5cblx0aWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG5cdFx0c3R5bGVFbGVtZW50ID0gc2luZ2xldG9uRWxlbWVudCB8fCAoc2luZ2xldG9uRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgZmFsc2UpO1xuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpO1xuXHR9IGVsc2UgaWYob2JqLnNvdXJjZU1hcCAmJlxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRzdHlsZUVsZW1lbnQgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xuXHRcdFx0aWYoc3R5bGVFbGVtZW50LmhyZWYpXG5cdFx0XHRcdFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGVFbGVtZW50LmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XG5cdFx0fTtcblx0fVxuXG5cdHVwZGF0ZShvYmopO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcblx0XHRpZihuZXdPYmopIHtcblx0XHRcdGlmKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcClcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0dXBkYXRlKG9iaiA9IG5ld09iaik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlbW92ZSgpO1xuXHRcdH1cblx0fTtcbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcblx0dmFyIHRleHRTdG9yZSA9IFtdO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG5cdFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuXHR9O1xufSkoKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZUVsZW1lbnQsIGluZGV4LCByZW1vdmUsIG9iaikge1xuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XG5cblx0aWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuXHR9IGVsc2Uge1xuXHRcdHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzO1xuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdHN0eWxlRWxlbWVudC5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGVFbGVtZW50LCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcblxuXHRpZihtZWRpYSkge1xuXHRcdHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcblx0fVxuXG5cdGlmKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcblx0fSBlbHNlIHtcblx0XHR3aGlsZShzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuXHRcdFx0c3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKTtcblx0XHR9XG5cdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsobGlua0VsZW1lbnQsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0aWYoc291cmNlTWFwKSB7XG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcblx0XHRjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArIFwiICovXCI7XG5cdH1cblxuXHR2YXIgYmxvYiA9IG5ldyBCbG9iKFtjc3NdLCB7IHR5cGU6IFwidGV4dC9jc3NcIiB9KTtcblxuXHR2YXIgb2xkU3JjID0gbGlua0VsZW1lbnQuaHJlZjtcblxuXHRsaW5rRWxlbWVudC5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpXG5cdFx0VVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcbi8vIG1vZHVsZSBpZCA9IDM1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBETyBOT1QgaW1wb3J0IGJhYmVsIHBvbHlmaWwgd2l0aG91dCBlbnN1cmluZyB0aGF0IGl0IGRvZXMgbm90IGFkZCB0byB0aGUgZ2xvYmFsXG4vLyBzY29wZSBvZiB0aGUgd2luZG93LiBBZGRpbmcgYmFiZWwgcG9seWZpbCB0byB0aGUgY3VzdG9tZXJzIHdpbmRvdyBkb2VzIG5vdCB3b3JrIGlmXG4vLyBpdCBpcyBhbHJlYWR5IHByZXNlbnQgdmlhIHRoZSBjdXN0b21lcidzIGFwcCwgYW5kIHdpbGwgQlJFQUsgb3VyIHBsdWdpbiBjb21wbGV0ZWx5XG4vLyBTZWUgaHR0cHM6Ly9wZW5kby1pby5hdGxhc3NpYW4ubmV0L2Jyb3dzZS9BUFAtMjg3MyBmb3IgbW9yZVxuaW1wb3J0ICcuL3RldGhlcic7XG5pbXBvcnQgJy4vc2VsZWN0aW9uLmNzcyc7XG5pbXBvcnQgJy4vaHRtbDJjYW52YXMnO1xuaW1wb3J0IHtzdGFydEZyYW1lTWVzc2FnZVJvdXRlciwgcmVnaXN0ZXJXaXRoRnJhbWVNZXNzYWdlUm91dGVyfSBmcm9tICcuL2ZyYW1lcyc7XG5cbnN0YXJ0RnJhbWVNZXNzYWdlUm91dGVyKCk7XG5yZWdpc3RlcldpdGhGcmFtZU1lc3NhZ2VSb3V0ZXIoKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BsdWdpbnMvaW5kZXguanMiXSwic291cmNlUm9vdCI6IiJ9